"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/postprocessing";
exports.ids = ["vendor-chunks/postprocessing"];
exports.modules = {

/***/ "(ssr)/./node_modules/postprocessing/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/postprocessing/build/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdaptiveLuminanceMaterial: () => (/* binding */ AdaptiveLuminanceMaterial),\n/* harmony export */   AdaptiveLuminancePass: () => (/* binding */ AdaptiveLuminancePass),\n/* harmony export */   BlendFunction: () => (/* binding */ BlendFunction),\n/* harmony export */   BlendMode: () => (/* binding */ BlendMode),\n/* harmony export */   BloomEffect: () => (/* binding */ BloomEffect),\n/* harmony export */   BlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   BokehEffect: () => (/* binding */ BokehEffect),\n/* harmony export */   BokehMaterial: () => (/* binding */ BokehMaterial),\n/* harmony export */   BoxBlurMaterial: () => (/* binding */ BoxBlurMaterial),\n/* harmony export */   BoxBlurPass: () => (/* binding */ BoxBlurPass),\n/* harmony export */   BrightnessContrastEffect: () => (/* binding */ BrightnessContrastEffect),\n/* harmony export */   ChromaticAberrationEffect: () => (/* binding */ ChromaticAberrationEffect),\n/* harmony export */   CircleOfConfusionMaterial: () => (/* binding */ CircleOfConfusionMaterial),\n/* harmony export */   ClearMaskPass: () => (/* binding */ ClearMaskPass),\n/* harmony export */   ClearPass: () => (/* binding */ ClearPass),\n/* harmony export */   ColorAverageEffect: () => (/* binding */ ColorAverageEffect),\n/* harmony export */   ColorChannel: () => (/* binding */ ColorChannel),\n/* harmony export */   ColorDepthEffect: () => (/* binding */ ColorDepthEffect),\n/* harmony export */   ColorEdgesMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   ConvolutionMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   CopyMaterial: () => (/* binding */ CopyMaterial),\n/* harmony export */   CopyPass: () => (/* binding */ CopyPass),\n/* harmony export */   DepthComparisonMaterial: () => (/* binding */ DepthComparisonMaterial),\n/* harmony export */   DepthCopyMaterial: () => (/* binding */ DepthCopyMaterial),\n/* harmony export */   DepthCopyMode: () => (/* binding */ DepthCopyMode),\n/* harmony export */   DepthCopyPass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthDownsamplingMaterial: () => (/* binding */ DepthDownsamplingMaterial),\n/* harmony export */   DepthDownsamplingPass: () => (/* binding */ DepthDownsamplingPass),\n/* harmony export */   DepthEffect: () => (/* binding */ DepthEffect),\n/* harmony export */   DepthMaskMaterial: () => (/* binding */ DepthMaskMaterial),\n/* harmony export */   DepthOfFieldEffect: () => (/* binding */ DepthOfFieldEffect),\n/* harmony export */   DepthPass: () => (/* binding */ DepthPass),\n/* harmony export */   DepthPickingPass: () => (/* binding */ DepthPickingPass),\n/* harmony export */   DepthSavePass: () => (/* binding */ DepthCopyPass),\n/* harmony export */   DepthTestStrategy: () => (/* binding */ DepthTestStrategy),\n/* harmony export */   DisplayP3ColorSpace: () => (/* binding */ DisplayP3ColorSpace),\n/* harmony export */   Disposable: () => (/* binding */ Disposable),\n/* harmony export */   DotScreenEffect: () => (/* binding */ DotScreenEffect),\n/* harmony export */   DownsamplingMaterial: () => (/* binding */ DownsamplingMaterial),\n/* harmony export */   EdgeDetectionMaterial: () => (/* binding */ EdgeDetectionMaterial),\n/* harmony export */   EdgeDetectionMode: () => (/* binding */ EdgeDetectionMode),\n/* harmony export */   Effect: () => (/* binding */ Effect),\n/* harmony export */   EffectAttribute: () => (/* binding */ EffectAttribute),\n/* harmony export */   EffectComposer: () => (/* binding */ EffectComposer),\n/* harmony export */   EffectMaterial: () => (/* binding */ EffectMaterial),\n/* harmony export */   EffectPass: () => (/* binding */ EffectPass),\n/* harmony export */   EffectShaderData: () => (/* binding */ EffectShaderData),\n/* harmony export */   EffectShaderSection: () => (/* binding */ EffectShaderSection),\n/* harmony export */   FXAAEffect: () => (/* binding */ FXAAEffect),\n/* harmony export */   GammaCorrectionEffect: () => (/* binding */ GammaCorrectionEffect),\n/* harmony export */   GaussKernel: () => (/* binding */ GaussKernel),\n/* harmony export */   GaussianBlurMaterial: () => (/* binding */ GaussianBlurMaterial),\n/* harmony export */   GaussianBlurPass: () => (/* binding */ GaussianBlurPass),\n/* harmony export */   GlitchEffect: () => (/* binding */ GlitchEffect),\n/* harmony export */   GlitchMode: () => (/* binding */ GlitchMode),\n/* harmony export */   GodRaysEffect: () => (/* binding */ GodRaysEffect),\n/* harmony export */   GodRaysMaterial: () => (/* binding */ GodRaysMaterial),\n/* harmony export */   GridEffect: () => (/* binding */ GridEffect),\n/* harmony export */   HueSaturationEffect: () => (/* binding */ HueSaturationEffect),\n/* harmony export */   ImmutableTimer: () => (/* binding */ ImmutableTimer),\n/* harmony export */   Initializable: () => (/* binding */ Initializable),\n/* harmony export */   KawaseBlurMaterial: () => (/* binding */ KawaseBlurMaterial),\n/* harmony export */   KawaseBlurPass: () => (/* binding */ KawaseBlurPass),\n/* harmony export */   KernelSize: () => (/* binding */ KernelSize),\n/* harmony export */   LUT1DEffect: () => (/* binding */ LUT1DEffect),\n/* harmony export */   LUT3DEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUT3dlLoader: () => (/* binding */ LUT3dlLoader),\n/* harmony export */   LUTCubeLoader: () => (/* binding */ LUTCubeLoader),\n/* harmony export */   LUTEffect: () => (/* binding */ LUT3DEffect),\n/* harmony export */   LUTOperation: () => (/* binding */ LUTOperation),\n/* harmony export */   LambdaPass: () => (/* binding */ LambdaPass),\n/* harmony export */   LensDistortionEffect: () => (/* binding */ LensDistortionEffect),\n/* harmony export */   LinearSRGBColorSpace: () => (/* binding */ LinearSRGBColorSpace),\n/* harmony export */   LookupTexture: () => (/* binding */ LookupTexture),\n/* harmony export */   LookupTexture3D: () => (/* binding */ LookupTexture),\n/* harmony export */   LuminanceMaterial: () => (/* binding */ LuminanceMaterial),\n/* harmony export */   LuminancePass: () => (/* binding */ LuminancePass),\n/* harmony export */   MaskFunction: () => (/* binding */ MaskFunction),\n/* harmony export */   MaskMaterial: () => (/* binding */ MaskMaterial),\n/* harmony export */   MaskPass: () => (/* binding */ MaskPass),\n/* harmony export */   MipmapBlurPass: () => (/* binding */ MipmapBlurPass),\n/* harmony export */   NoColorSpace: () => (/* binding */ NoColorSpace),\n/* harmony export */   NoiseEffect: () => (/* binding */ NoiseEffect),\n/* harmony export */   NoiseTexture: () => (/* binding */ NoiseTexture),\n/* harmony export */   NormalPass: () => (/* binding */ NormalPass),\n/* harmony export */   OutlineEdgesMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OutlineEffect: () => (/* binding */ OutlineEffect),\n/* harmony export */   OutlineMaterial: () => (/* binding */ OutlineMaterial),\n/* harmony export */   OverrideMaterialManager: () => (/* binding */ OverrideMaterialManager),\n/* harmony export */   Pass: () => (/* binding */ Pass),\n/* harmony export */   PixelationEffect: () => (/* binding */ PixelationEffect),\n/* harmony export */   PredicationMode: () => (/* binding */ PredicationMode),\n/* harmony export */   RawImageData: () => (/* binding */ RawImageData),\n/* harmony export */   RealisticBokehEffect: () => (/* binding */ RealisticBokehEffect),\n/* harmony export */   RenderPass: () => (/* binding */ RenderPass),\n/* harmony export */   Resizable: () => (/* binding */ Resizable),\n/* harmony export */   Resizer: () => (/* binding */ Resolution),\n/* harmony export */   Resolution: () => (/* binding */ Resolution),\n/* harmony export */   SMAAAreaImageData: () => (/* binding */ SMAAAreaImageData),\n/* harmony export */   SMAAEffect: () => (/* binding */ SMAAEffect),\n/* harmony export */   SMAAImageGenerator: () => (/* binding */ SMAAImageGenerator),\n/* harmony export */   SMAAImageLoader: () => (/* binding */ SMAAImageLoader),\n/* harmony export */   SMAAPreset: () => (/* binding */ SMAAPreset),\n/* harmony export */   SMAASearchImageData: () => (/* binding */ SMAASearchImageData),\n/* harmony export */   SMAAWeightsMaterial: () => (/* binding */ SMAAWeightsMaterial),\n/* harmony export */   SRGBColorSpace: () => (/* binding */ SRGBColorSpace),\n/* harmony export */   SSAOEffect: () => (/* binding */ SSAOEffect),\n/* harmony export */   SSAOMaterial: () => (/* binding */ SSAOMaterial),\n/* harmony export */   SavePass: () => (/* binding */ CopyPass),\n/* harmony export */   ScanlineEffect: () => (/* binding */ ScanlineEffect),\n/* harmony export */   Section: () => (/* binding */ EffectShaderSection),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   SelectiveBloomEffect: () => (/* binding */ SelectiveBloomEffect),\n/* harmony export */   SepiaEffect: () => (/* binding */ SepiaEffect),\n/* harmony export */   ShaderPass: () => (/* binding */ ShaderPass),\n/* harmony export */   ShockWaveEffect: () => (/* binding */ ShockWaveEffect),\n/* harmony export */   TetrahedralUpscaler: () => (/* binding */ TetrahedralUpscaler),\n/* harmony export */   TextureEffect: () => (/* binding */ TextureEffect),\n/* harmony export */   TiltShiftBlurMaterial: () => (/* binding */ TiltShiftBlurMaterial),\n/* harmony export */   TiltShiftBlurPass: () => (/* binding */ TiltShiftBlurPass),\n/* harmony export */   TiltShiftEffect: () => (/* binding */ TiltShiftEffect),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   ToneMappingEffect: () => (/* binding */ ToneMappingEffect),\n/* harmony export */   ToneMappingMode: () => (/* binding */ ToneMappingMode),\n/* harmony export */   UpsamplingMaterial: () => (/* binding */ UpsamplingMaterial),\n/* harmony export */   VignetteEffect: () => (/* binding */ VignetteEffect),\n/* harmony export */   VignetteTechnique: () => (/* binding */ VignetteTechnique),\n/* harmony export */   WebGLExtension: () => (/* binding */ WebGLExtension),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * postprocessing v6.34.3 build Sat Feb 10 2024\n * https://github.com/pmndrs/postprocessing\n * Copyright 2015-2024 Raoul van RÃ¼schen\n * @license Zlib\n */ // package.json\nvar version = \"6.34.3\";\n// src/core/Disposable.js\nvar Disposable = class {\n    /**\n   * Frees internal resources.\n   */ dispose() {}\n};\n// src/core/EffectComposer.js\n\n// src/passes/AdaptiveLuminancePass.js\n\n// src/materials/AdaptiveLuminanceMaterial.js\n\n// src/materials/glsl/adaptive-luminance.frag\nvar adaptive_luminance_default = \"#include <packing>\\n#define packFloatToRGBA(v) packDepthToRGBA(v)\\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\\n#if __VERSION__ < 300\\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\\n#else\\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\\n#endif\\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}\";\n// src/materials/glsl/common.vert\nvar common_default = \"varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/AdaptiveLuminanceMaterial.js\nvar AdaptiveLuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new adaptive luminance material.\n   */ constructor(){\n        super({\n            name: \"AdaptiveLuminanceMaterial\",\n            defines: {\n                MIP_LEVEL_1X1: \"0.0\"\n            },\n            uniforms: {\n                luminanceBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                luminanceBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                minLuminance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n                deltaTime: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                tau: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            extensions: {\n                shaderTextureLOD: true\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: adaptive_luminance_default,\n            vertexShader: common_default\n        });\n    }\n    /**\n   * The primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @type {Texture}\n   */ set luminanceBuffer0(value) {\n        this.uniforms.luminanceBuffer0.value = value;\n    }\n    /**\n   * Sets the primary luminance buffer that contains the downsampled average luminance.\n   *\n   * @deprecated Use luminanceBuffer0 instead.\n   * @param {Texture} value - The buffer.\n   */ setLuminanceBuffer0(value) {\n        this.uniforms.luminanceBuffer0.value = value;\n    }\n    /**\n   * The secondary luminance buffer.\n   *\n   * @type {Texture}\n   */ set luminanceBuffer1(value) {\n        this.uniforms.luminanceBuffer1.value = value;\n    }\n    /**\n   * Sets the secondary luminance buffer.\n   *\n   * @deprecated Use luminanceBuffer1 instead.\n   * @param {Texture} value - The buffer.\n   */ setLuminanceBuffer1(value) {\n        this.uniforms.luminanceBuffer1.value = value;\n    }\n    /**\n   * The 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the primary luminance buffer.\n   *\n   * @type {Number}\n   */ set mipLevel1x1(value) {\n        this.defines.MIP_LEVEL_1X1 = value.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the 1x1 mipmap level.\n   *\n   * @deprecated Use mipLevel1x1 instead.\n   * @param {Number} value - The level.\n   */ setMipLevel1x1(value) {\n        this.mipLevel1x1 = value;\n    }\n    /**\n   * The delta time.\n   *\n   * @type {Number}\n   */ set deltaTime(value) {\n        this.uniforms.deltaTime.value = value;\n    }\n    /**\n   * Sets the delta time.\n   *\n   * @deprecated Use deltaTime instead.\n   * @param {Number} value - The delta time.\n   */ setDeltaTime(value) {\n        this.uniforms.deltaTime.value = value;\n    }\n    /**\n   * The lowest possible luminance value.\n   *\n   * @type {Number}\n   */ get minLuminance() {\n        return this.uniforms.minLuminance.value;\n    }\n    set minLuminance(value) {\n        this.uniforms.minLuminance.value = value;\n    }\n    /**\n   * Returns the lowest possible luminance value.\n   *\n   * @deprecated Use minLuminance instead.\n   * @return {Number} The minimum luminance.\n   */ getMinLuminance() {\n        return this.uniforms.minLuminance.value;\n    }\n    /**\n   * Sets the minimum luminance.\n   *\n   * @deprecated Use minLuminance instead.\n   * @param {Number} value - The minimum luminance.\n   */ setMinLuminance(value) {\n        this.uniforms.minLuminance.value = value;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   */ get adaptationRate() {\n        return this.uniforms.tau.value;\n    }\n    set adaptationRate(value) {\n        this.uniforms.tau.value = value;\n    }\n    /**\n   * Returns the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @return {Number} The adaptation rate.\n   */ getAdaptationRate() {\n        return this.uniforms.tau.value;\n    }\n    /**\n   * Sets the luminance adaptation rate.\n   *\n   * @deprecated Use adaptationRate instead.\n   * @param {Number} value - The adaptation rate.\n   */ setAdaptationRate(value) {\n        this.uniforms.tau.value = value;\n    }\n};\n// src/materials/BokehMaterial.js\n\n// src/materials/glsl/convolution.bokeh.frag\nvar convolution_bokeh_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#if PASS == 1\\nuniform vec4 kernel64[32];\\n#else\\nuniform vec4 kernel16[8];\\n#endif\\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\\n#ifdef FOREGROUND\\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\\n#else\\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\\n#endif\\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\\n#ifdef FOREGROUND\\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\\n#else\\nvec2 step=texelSize*coc;\\n#endif\\n#if PASS == 1\\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\\n#else\\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\\n#endif\\n}}\";\n// src/materials/BokehMaterial.js\nvar BokehMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new bokeh material.\n   *\n   * @param {Boolean} [fill=false] - Enables or disables the bokeh highlight fill mode.\n   * @param {Boolean} [foreground=false] - Determines whether this material will be applied to foreground colors.\n   */ constructor(fill = false, foreground = false){\n        super({\n            name: \"BokehMaterial\",\n            defines: {\n                PASS: fill ? \"2\" : \"1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cocBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                kernel64: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                kernel16: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_bokeh_default,\n            vertexShader: common_default\n        });\n        if (foreground) {\n            this.defines.FOREGROUND = \"1\";\n        }\n        this.generateKernel();\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The circle of confusion buffer.\n   *\n   * @type {Texture}\n   */ set cocBuffer(value) {\n        this.uniforms.cocBuffer.value = value;\n    }\n    /**\n   * Sets the circle of confusion buffer.\n   *\n   * @deprecated Use cocBuffer instead.\n   * @param {Texture} value - The buffer.\n   */ setCoCBuffer(value) {\n        this.uniforms.cocBuffer.value = value;\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale(value) {\n        return this.scale;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * Generates the blur kernel.\n   *\n   * @private\n   */ generateKernel() {\n        const GOLDEN_ANGLE = 2.39996323;\n        const points64 = new Float64Array(128);\n        const points16 = new Float64Array(32);\n        let i64 = 0, i16 = 0;\n        for(let i = 0, sqrt80 = Math.sqrt(80); i < 80; ++i){\n            const theta = i * GOLDEN_ANGLE;\n            const r = Math.sqrt(i) / sqrt80;\n            const u = r * Math.cos(theta), v3 = r * Math.sin(theta);\n            if (i % 5 === 0) {\n                points16[i16++] = u;\n                points16[i16++] = v3;\n            } else {\n                points64[i64++] = u;\n                points64[i64++] = v3;\n            }\n        }\n        this.uniforms.kernel64.value = points64;\n        this.uniforms.kernel16.value = points16;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/BoxBlurMaterial.js\n\n// src/utils/BackCompat.js\n\n// src/enums/BlendFunction.js\nvar BlendFunction = {\n    SKIP: 9,\n    SET: 30,\n    ADD: 0,\n    ALPHA: 1,\n    AVERAGE: 2,\n    COLOR: 3,\n    COLOR_BURN: 4,\n    COLOR_DODGE: 5,\n    DARKEN: 6,\n    DIFFERENCE: 7,\n    DIVIDE: 8,\n    DST: 9,\n    EXCLUSION: 10,\n    HARD_LIGHT: 11,\n    HARD_MIX: 12,\n    HUE: 13,\n    INVERT: 14,\n    INVERT_RGB: 15,\n    LIGHTEN: 16,\n    LINEAR_BURN: 17,\n    LINEAR_DODGE: 18,\n    LINEAR_LIGHT: 19,\n    LUMINOSITY: 20,\n    MULTIPLY: 21,\n    NEGATION: 22,\n    NORMAL: 23,\n    OVERLAY: 24,\n    PIN_LIGHT: 25,\n    REFLECT: 26,\n    SATURATION: 27,\n    SCREEN: 28,\n    SOFT_LIGHT: 29,\n    SRC: 30,\n    SUBTRACT: 31,\n    VIVID_LIGHT: 32\n};\n// src/enums/ColorChannel.js\nvar ColorChannel = {\n    RED: 0,\n    GREEN: 1,\n    BLUE: 2,\n    ALPHA: 3\n};\n// src/enums/ColorSpace.js\nvar NoColorSpace = \"\";\nvar SRGBColorSpace = \"srgb\";\nvar LinearSRGBColorSpace = \"srgb-linear\";\nvar DisplayP3ColorSpace = \"display-p3\";\n// src/enums/DepthCopyMode.js\nvar DepthCopyMode = {\n    FULL: 0,\n    SINGLE: 1\n};\n// src/enums/DepthTestStrategy.js\nvar DepthTestStrategy = {\n    DEFAULT: 0,\n    KEEP_MAX_DEPTH: 1,\n    DISCARD_MAX_DEPTH: 2\n};\n// src/enums/EdgeDetectionMode.js\nvar EdgeDetectionMode = {\n    DEPTH: 0,\n    LUMA: 1,\n    COLOR: 2\n};\n// src/enums/EffectAttribute.js\nvar EffectAttribute = {\n    NONE: 0,\n    DEPTH: 1,\n    CONVOLUTION: 2\n};\n// src/enums/EffectShaderSection.js\nvar EffectShaderSection = {\n    FRAGMENT_HEAD: \"FRAGMENT_HEAD\",\n    FRAGMENT_MAIN_UV: \"FRAGMENT_MAIN_UV\",\n    FRAGMENT_MAIN_IMAGE: \"FRAGMENT_MAIN_IMAGE\",\n    VERTEX_HEAD: \"VERTEX_HEAD\",\n    VERTEX_MAIN_SUPPORT: \"VERTEX_MAIN_SUPPORT\"\n};\n// src/enums/GlitchMode.js\nvar GlitchMode = {\n    DISABLED: 0,\n    SPORADIC: 1,\n    CONSTANT_MILD: 2,\n    CONSTANT_WILD: 3\n};\n// src/enums/KernelSize.js\nvar KernelSize = {\n    VERY_SMALL: 0,\n    SMALL: 1,\n    MEDIUM: 2,\n    LARGE: 3,\n    VERY_LARGE: 4,\n    HUGE: 5\n};\n// src/enums/LUTOperation.js\nvar LUTOperation = {\n    SCALE_UP: \"lut.scaleup\"\n};\n// src/enums/MaskFunction.js\nvar MaskFunction = {\n    DISCARD: 0,\n    MULTIPLY: 1,\n    MULTIPLY_RGB_SET_ALPHA: 2,\n    MULTIPLY_RGB: 3\n};\n// src/enums/PredicationMode.js\nvar PredicationMode = {\n    DISABLED: 0,\n    DEPTH: 1,\n    CUSTOM: 2\n};\n// src/enums/SMAAPreset.js\nvar SMAAPreset = {\n    LOW: 0,\n    MEDIUM: 1,\n    HIGH: 2,\n    ULTRA: 3\n};\n// src/enums/ToneMappingMode.js\nvar ToneMappingMode = {\n    REINHARD: 0,\n    REINHARD2: 1,\n    REINHARD2_ADAPTIVE: 2,\n    UNCHARTED2: 3,\n    OPTIMIZED_CINEON: 4,\n    ACES_FILMIC: 5,\n    AGX: 6\n};\n// src/enums/VignetteTechnique.js\nvar VignetteTechnique = {\n    DEFAULT: 0,\n    ESKIL: 1\n};\n// src/enums/WebGLExtension.js\nvar WebGLExtension = {\n    DERIVATIVES: \"derivatives\",\n    FRAG_DEPTH: \"fragDepth\",\n    DRAW_BUFFERS: \"drawBuffers\",\n    SHADER_TEXTURE_LOD: \"shaderTextureLOD\"\n};\n// src/utils/BackCompat.js\nvar revision = Number(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nvar useColorSpace = revision >= 152;\nvar encodingToColorSpace = /* @__PURE__ */ new Map([\n    [\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding,\n        LinearSRGBColorSpace\n    ],\n    [\n        three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding,\n        SRGBColorSpace\n    ]\n]);\nvar colorSpaceToEncoding = /* @__PURE__ */ new Map([\n    [\n        LinearSRGBColorSpace,\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding\n    ],\n    [\n        SRGBColorSpace,\n        three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding\n    ]\n]);\nfunction getOutputColorSpace(renderer) {\n    return renderer === null ? null : useColorSpace ? renderer.outputColorSpace : encodingToColorSpace.get(renderer.outputEncoding);\n}\nfunction setTextureColorSpace(texture, colorSpace) {\n    if (texture === null) {\n        return;\n    }\n    if (useColorSpace) {\n        texture.colorSpace = colorSpace;\n    } else {\n        texture.encoding = colorSpaceToEncoding.get(colorSpace);\n    }\n}\nfunction copyTextureColorSpace(src, dest) {\n    if (src === null || dest === null) {\n        return;\n    }\n    if (useColorSpace) {\n        dest.colorSpace = src.colorSpace;\n    } else {\n        dest.encoding = src.encoding;\n    }\n}\nfunction updateFragmentShader(fragmentShader) {\n    if (revision < 154) {\n        return fragmentShader.replace(\"colorspace_fragment\", \"encodings_fragment\");\n    }\n    return fragmentShader;\n}\nfunction validateToneMappingMode(mode) {\n    if (revision < 160 && mode === ToneMappingMode.AGX) {\n        console.warn(\"AgX requires three r160 or higher, falling back to ACES filmic\");\n        mode = ToneMappingMode.ACES_FILMIC;\n    }\n    return mode;\n}\n// src/utils/orthographicDepthToViewZ.js\nfunction orthographicDepthToViewZ(depth, near, far) {\n    return depth * (near - far) - near;\n}\n// src/utils/viewZToOrthographicDepth.js\nfunction viewZToOrthographicDepth(viewZ, near, far) {\n    return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);\n}\n// src/materials/glsl/convolution.box.frag\nvar convolution_box_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef BILATERAL\\n#include <packing>\\nuniform vec2 cameraNearFar;\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nfloat getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}\\n#ifdef PERSPECTIVE_CAMERA\\n#define linearDepth(v) viewZToOrthographicDepth(getViewZ(readDepth(v)), cameraNearFar.x, cameraNearFar.y)\\n#else\\n#define linearDepth(v) readDepth(v)\\n#endif\\n#endif\\n#define getTexel(v) texture2D(inputBuffer, v)\\n#if KERNEL_SIZE == 3\\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\\n#else\\nuniform vec2 texelSize;uniform float scale;varying vec2 vUv;\\n#endif\\nvoid main(){\\n#if KERNEL_SIZE == 3\\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08));\\n#ifdef BILATERAL\\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08));\\n#endif\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvec4 c[]=vec4[KERNEL_SIZE_SQ](getTexel(vUv00),getTexel(vUv01),getTexel(vUv02),getTexel(vUv03),getTexel(vUv04),getTexel(vUv05),getTexel(vUv06),getTexel(vUv07),getTexel(vUv08),getTexel(vUv09),getTexel(vUv10),getTexel(vUv11),getTexel(vUv12),getTexel(vUv13),getTexel(vUv14),getTexel(vUv15),getTexel(vUv16),getTexel(vUv17),getTexel(vUv18),getTexel(vUv19),getTexel(vUv20),getTexel(vUv21),getTexel(vUv22),getTexel(vUv23),getTexel(vUv24));\\n#ifdef BILATERAL\\nfloat z[]=float[KERNEL_SIZE_SQ](linearDepth(vUv00),linearDepth(vUv01),linearDepth(vUv02),linearDepth(vUv03),linearDepth(vUv04),linearDepth(vUv05),linearDepth(vUv06),linearDepth(vUv07),linearDepth(vUv08),linearDepth(vUv09),linearDepth(vUv10),linearDepth(vUv11),linearDepth(vUv12),linearDepth(vUv13),linearDepth(vUv14),linearDepth(vUv15),linearDepth(vUv16),linearDepth(vUv17),linearDepth(vUv18),linearDepth(vUv19),linearDepth(vUv20),linearDepth(vUv21),linearDepth(vUv22),linearDepth(vUv23),linearDepth(vUv24));\\n#endif\\n#endif\\nvec4 result=vec4(0.0);\\n#ifdef BILATERAL\\nfloat w=0.0;\\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\\nfloat centerDepth=z[KERNEL_SIZE_SQ_HALF];for(int i=0;i<KERNEL_SIZE_SQ;++i){float d=step(abs(z[i]-centerDepth),DISTANCE_THRESHOLD);result+=c[i]*d;w+=d;}\\n#else\\nfloat centerDepth=linearDepth(vUv);vec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){vec2 coords=vUv+vec2(x,y)*s;vec4 c=getTexel(coords);float z=(x==0&&y==0)?centerDepth:linearDepth(coords);float d=step(abs(z-centerDepth),DISTANCE_THRESHOLD);result+=c*d;w+=d;}}\\n#endif\\ngl_FragColor=result/max(w,1.0);\\n#else\\n#if KERNEL_SIZE == 3 || (KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13)\\nfor(int i=0;i<KERNEL_SIZE_SQ;++i){result+=c[i];}\\n#else\\nvec2 s=texelSize*scale;for(int x=-KERNEL_SIZE_HALF;x<=KERNEL_SIZE_HALF;++x){for(int y=-KERNEL_SIZE_HALF;y<=KERNEL_SIZE_HALF;++y){result+=getTexel(uv+vec2(x,y)*s);}}\\n#endif\\ngl_FragColor=result*INV_KERNEL_SIZE_SQ;\\n#endif\\n}\";\n// src/materials/glsl/convolution.box.vert\nvar convolution_box_default2 = \"uniform vec2 texelSize;uniform float scale;\\n#if KERNEL_SIZE == 3\\nvarying vec2 vUv00,vUv01,vUv02;varying vec2 vUv03,vUv04,vUv05;varying vec2 vUv06,vUv07,vUv08;\\n#elif KERNEL_SIZE == 5 && MAX_VARYING_VECTORS >= 13\\nvarying vec2 vUv00,vUv01,vUv02,vUv03,vUv04;varying vec2 vUv05,vUv06,vUv07,vUv08,vUv09;varying vec2 vUv10,vUv11,vUv12,vUv13,vUv14;varying vec2 vUv15,vUv16,vUv17,vUv18,vUv19;varying vec2 vUv20,vUv21,vUv22,vUv23,vUv24;\\n#else\\nvarying vec2 vUv;\\n#endif\\nvoid main(){vec2 uv=position.xy*0.5+0.5;\\n#if KERNEL_SIZE == 3\\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-1.0,-1.0);vUv01=uv+s*vec2(0.0,-1.0);vUv02=uv+s*vec2(1.0,-1.0);vUv03=uv+s*vec2(-1.0,0.0);vUv04=uv;vUv05=uv+s*vec2(1.0,0.0);vUv06=uv+s*vec2(-1.0,1.0);vUv07=uv+s*vec2(0.0,1.0);vUv08=uv+s*vec2(1.0,1.0);\\n#elif KERNEL_SIZE == 5\\nvec2 s=texelSize*scale;vUv00=uv+s*vec2(-2.0,-2.0);vUv01=uv+s*vec2(-1.0,-2.0);vUv02=uv+s*vec2(0.0,-2.0);vUv03=uv+s*vec2(1.0,-2.0);vUv04=uv+s*vec2(2.0,-2.0);vUv05=uv+s*vec2(-2.0,-1.0);vUv06=uv+s*vec2(-1.0,-1.0);vUv07=uv+s*vec2(0.0,-1.0);vUv08=uv+s*vec2(1.0,-1.0);vUv09=uv+s*vec2(2.0,-1.0);vUv10=uv+s*vec2(-2.0,0.0);vUv11=uv+s*vec2(-1.0,0.0);vUv12=uv;vUv13=uv+s*vec2(1.0,0.0);vUv14=uv+s*vec2(2.0,0.0);vUv15=uv+s*vec2(-2.0,1.0);vUv16=uv+s*vec2(-1.0,1.0);vUv17=uv+s*vec2(0.0,1.0);vUv18=uv+s*vec2(1.0,1.0);vUv19=uv+s*vec2(2.0,1.0);vUv20=uv+s*vec2(-2.0,2.0);vUv21=uv+s*vec2(-1.0,2.0);vUv22=uv+s*vec2(0.0,2.0);vUv23=uv+s*vec2(1.0,2.0);vUv24=uv+s*vec2(2.0,2.0);\\n#else\\nvUv=uv;\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/BoxBlurMaterial.js\nvar BoxBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new box blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.kernelSize=5] - The kernel size.\n   */ constructor({ bilateral = false, kernelSize = 5 } = {}){\n        super({\n            name: \"BoxBlurMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\",\n                DISTANCE_THRESHOLD: \"0.1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_box_default,\n            vertexShader: convolution_box_default2\n        });\n        this.bilateral = bilateral;\n        this.kernelSize = kernelSize;\n        this.maxVaryingVectors = 8;\n    }\n    /**\n   * The maximum amount of varying vectors.\n   *\n   * Should be synced with `renderer.capabilities.maxVaryings`. Default is 8.\n   *\n   * @type {Number}\n   */ set maxVaryingVectors(value) {\n        this.defines.MAX_VARYING_VECTORS = value.toFixed(0);\n    }\n    /**\n   * The kernel size.\n   *\n   * - Must be an odd number\n   * - Kernel size 3 and 5 use optimized code paths\n   * - Default is 5\n   *\n   * @type {Number}\n   */ get kernelSize() {\n        return Number(this.defines.KERNEL_SIZE);\n    }\n    set kernelSize(value) {\n        if (value % 2 === 0) {\n            throw new Error(\"The kernel size must be an odd number\");\n        }\n        this.defines.KERNEL_SIZE = value.toFixed(0);\n        this.defines.KERNEL_SIZE_HALF = Math.floor(value / 2).toFixed(0);\n        this.defines.KERNEL_SIZE_SQ = (value ** 2).toFixed(0);\n        this.defines.KERNEL_SIZE_SQ_HALF = Math.floor(value ** 2 / 2).toFixed(0);\n        this.defines.INV_KERNEL_SIZE_SQ = (1 / value ** 2).toFixed(6);\n        this.needsUpdate = true;\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNearFar.value.x;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraNearFar.value.y;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * A combined normal-depth buffer. Overrides {@link depthBuffer} if set.\n   *\n   * @type {Texture}\n   */ set normalDepthBuffer(value) {\n        this.uniforms.normalDepthBuffer.value = value;\n        if (value !== null) {\n            this.defines.NORMAL_DEPTH = \"1\";\n        } else {\n            delete this.defines.NORMAL_DEPTH;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether bilateral filtering is enabled.\n   *\n   * @type {Boolean}\n   */ get bilateral() {\n        return this.defines.BILATERAL !== void 0;\n    }\n    set bilateral(value) {\n        if (value !== null) {\n            this.defines.BILATERAL = \"1\";\n        } else {\n            delete this.defines.BILATERAL;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * The bilateral filter distance threshold in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceThreshold() {\n        return -orthographicDepthToViewZ(Number(this.defines.DISTANCE_THRESHOLD), this.near, this.far);\n    }\n    set worldDistanceThreshold(value) {\n        const threshold = viewZToOrthographicDepth(-value, this.near, this.far);\n        this.defines.DISTANCE_THRESHOLD = threshold.toFixed(12);\n        this.needsUpdate = true;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/CircleOfConfusionMaterial.js\n\n// src/materials/glsl/circle-of-confusion.frag\nvar circle_of_confusion_default = \"#include <common>\\n#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nfloat depth=texture2D(depthBuffer,uv).r;\\n#endif\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\\n#endif\\nreturn depth;}void main(){float depth=readDepth(vUv);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}\";\n// src/materials/CircleOfConfusionMaterial.js\nvar CircleOfConfusionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new CoC material.\n   *\n   * @param {Camera} camera - A camera.\n   */ constructor(camera){\n        super({\n            name: \"CircleOfConfusionMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                focusDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                focusRange: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: circle_of_confusion_default,\n            vertexShader: common_default\n        });\n        this.uniforms.focalLength = this.uniforms.focusRange;\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNear.value;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraFar.value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The focus distance. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get focusDistance() {\n        return this.uniforms.focusDistance.value;\n    }\n    set focusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * The focus distance in world units.\n   *\n   * @type {Number}\n   */ get worldFocusDistance() {\n        return -orthographicDepthToViewZ(this.focusDistance, this.near, this.far);\n    }\n    set worldFocusDistance(value) {\n        this.focusDistance = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Returns the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @return {Number} The focus distance.\n   */ getFocusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * Sets the focus distance.\n   *\n   * @deprecated Use focusDistance instead.\n   * @param {Number} value - The focus distance.\n   */ setFocusDistance(value) {\n        this.uniforms.focusDistance.value = value;\n    }\n    /**\n   * The focal length.\n   *\n   * @deprecated Renamed to focusRange.\n   * @type {Number}\n   */ get focalLength() {\n        return this.focusRange;\n    }\n    set focalLength(value) {\n        this.focusRange = value;\n    }\n    /**\n   * The focus range. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get focusRange() {\n        return this.uniforms.focusRange.value;\n    }\n    set focusRange(value) {\n        this.uniforms.focusRange.value = value;\n    }\n    /**\n   * The focus range in world units.\n   *\n   * @type {Number}\n   */ get worldFocusRange() {\n        return -orthographicDepthToViewZ(this.focusRange, this.near, this.far);\n    }\n    set worldFocusRange(value) {\n        this.focusRange = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Returns the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @return {Number} The focal length.\n   */ getFocalLength(value) {\n        return this.focusRange;\n    }\n    /**\n   * Sets the focal length.\n   *\n   * @deprecated Use focusRange instead.\n   * @param {Number} value - The focal length.\n   */ setFocalLength(value) {\n        this.focusRange = value;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/KawaseBlurMaterial.js\n\n// src/materials/glsl/convolution.kawase.frag\nvar convolution_kawase_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\\n#include <colorspace_fragment>\\n}\";\n// src/materials/glsl/convolution.kawase.vert\nvar convolution_kawase_default2 = \"uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/KawaseBlurMaterial.js\nvar kernelPresets = [\n    new Float32Array([\n        0,\n        0\n    ]),\n    new Float32Array([\n        0,\n        1,\n        1\n    ]),\n    new Float32Array([\n        0,\n        1,\n        1,\n        2\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        2,\n        3\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        3,\n        4,\n        4,\n        5\n    ]),\n    new Float32Array([\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        8,\n        9,\n        10\n    ])\n];\nvar KawaseBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new convolution material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector4} [texelSize] - Deprecated.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()){\n        super({\n            name: \"KawaseBlurMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4()),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_kawase_default,\n            vertexShader: convolution_kawase_default2\n        });\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n        this.setTexelSize(texelSize.x, texelSize.y);\n        this.kernelSize = KernelSize.MEDIUM;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.inputBuffer = value;\n    }\n    /**\n   * The kernel sequence for the current kernel size.\n   *\n   * @type {Float32Array}\n   */ get kernelSequence() {\n        return kernelPresets[this.kernelSize];\n    }\n    /**\n   * The blur scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.uniforms.scale.value;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} value - The scale.\n   */ setScale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Returns the kernel.\n   *\n   * @return {Float32Array} The kernel.\n   * @deprecated Implementation detail, removed with no replacement.\n   */ getKernel() {\n        return null;\n    }\n    /**\n   * The current kernel.\n   *\n   * @type {Number}\n   */ get kernel() {\n        return this.uniforms.kernel.value;\n    }\n    set kernel(value) {\n        this.uniforms.kernel.value = value;\n    }\n    /**\n   * Sets the current kernel.\n   *\n   * @deprecated Use kernel instead.\n   * @param {Number} value - The kernel.\n   */ setKernel(value) {\n        this.kernel = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const x = 1 / width, y = 1 / height;\n        this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);\n    }\n};\n// src/materials/CopyMaterial.js\n\n// src/materials/glsl/copy.frag\nvar copy_default = \"#include <common>\\n#include <dithering_pars_fragment>\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\\n#include <colorspace_fragment>\\n#include <dithering_fragment>\\n}\";\n// src/materials/CopyMaterial.js\nvar CopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new copy material.\n   */ constructor(){\n        super({\n            name: \"CopyMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                opacity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: copy_default,\n            vertexShader: common_default\n        });\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Returns the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @return {Number} The opacity.\n   */ getOpacity(value) {\n        return this.uniforms.opacity.value;\n    }\n    /**\n   * Sets the opacity.\n   *\n   * @deprecated Use opacity instead.\n   * @param {Number} value - The opacity.\n   */ setOpacity(value) {\n        this.uniforms.opacity.value = value;\n    }\n};\n// src/materials/DepthComparisonMaterial.js\n\n// src/materials/glsl/depth-comparison.frag\nvar depth_comparison_default = \"#include <packing>\\n#include <clipping_planes_pars_fragment>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\\n#include <clipping_planes_fragment>\\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\\n#if DEPTH_PACKING == 3201\\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\\n#else\\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\\n#endif\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\\n#else\\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\\n#endif\\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}\";\n// src/materials/glsl/depth-comparison.vert\nvar depth_comparison_default2 = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\\n#include <skinbase_vertex>\\n#include <begin_vertex>\\n#include <morphtarget_vertex>\\n#include <skinning_vertex>\\n#include <project_vertex>\\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\\n#include <clipping_planes_vertex>\\n}\";\n// src/materials/DepthComparisonMaterial.js\nvar DepthComparisonMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth comparison material.\n   *\n   * @param {Texture} [depthTexture=null] - A depth texture.\n   * @param {PerspectiveCamera} [camera] - A camera.\n   */ constructor(depthTexture = null, camera){\n        super({\n            name: \"DepthComparisonMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_comparison_default,\n            vertexShader: depth_comparison_default2\n        });\n        this.depthBuffer = depthTexture;\n        this.depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/DepthCopyMaterial.js\n\n// src/materials/glsl/depth-copy.frag\nvar depth_copy_default = \"#include <packing>\\nvarying vec2 vUv;\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\n#if INPUT_DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if INPUT_DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nvoid main(){\\n#if INPUT_DEPTH_PACKING == OUTPUT_DEPTH_PACKING\\ngl_FragColor=texture2D(depthBuffer,vUv);\\n#else\\nfloat depth=readDepth(vUv);\\n#if OUTPUT_DEPTH_PACKING == 3201\\ngl_FragColor=(depth==1.0)?vec4(1.0):packDepthToRGBA(depth);\\n#else\\ngl_FragColor=vec4(vec3(depth),1.0);\\n#endif\\n#endif\\n}\";\n// src/materials/glsl/depth-copy.vert\nvar depth_copy_default2 = \"varying vec2 vUv;\\n#if DEPTH_COPY_MODE == 1\\nuniform vec2 texelPosition;\\n#endif\\nvoid main(){\\n#if DEPTH_COPY_MODE == 1\\nvUv=texelPosition;\\n#else\\nvUv=position.xy*0.5+0.5;\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/DepthCopyMaterial.js\nvar DepthCopyMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth copy material.\n   */ constructor(){\n        super({\n            name: \"DepthCopyMaterial\",\n            defines: {\n                INPUT_DEPTH_PACKING: \"0\",\n                OUTPUT_DEPTH_PACKING: \"0\",\n                DEPTH_COPY_MODE: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_copy_default,\n            vertexShader: depth_copy_default2\n        });\n        this.depthCopyMode = DepthCopyMode.FULL;\n    }\n    /**\n   * The input depth buffer.\n   *\n   * @type {Texture}\n   */ get depthBuffer() {\n        return this.uniforms.depthBuffer.value;\n    }\n    set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The input depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set inputDepthPacking(value) {\n        this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * The output depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ get outputDepthPacking() {\n        return Number(this.defines.OUTPUT_DEPTH_PACKING);\n    }\n    set outputDepthPacking(value) {\n        this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the input depth buffer.\n   *\n   * @deprecated Use depthBuffer and inputDepthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.inputDepthPacking = depthPacking;\n    }\n    /**\n   * Returns the current input depth packing strategy.\n   *\n   * @deprecated\n   * @return {DepthPackingStrategies} The input depth packing strategy.\n   */ getInputDepthPacking() {\n        return Number(this.defines.INPUT_DEPTH_PACKING);\n    }\n    /**\n   * Sets the input depth packing strategy.\n   *\n   * @deprecated Use inputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new input depth packing strategy.\n   */ setInputDepthPacking(value) {\n        this.defines.INPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @return {DepthPackingStrategies} The output depth packing strategy.\n   */ getOutputDepthPacking() {\n        return Number(this.defines.OUTPUT_DEPTH_PACKING);\n    }\n    /**\n   * Sets the output depth packing strategy.\n   *\n   * @deprecated Use outputDepthPacking instead.\n   * @param {DepthPackingStrategies} value - The new output depth packing strategy.\n   */ setOutputDepthPacking(value) {\n        this.defines.OUTPUT_DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * The screen space position used for single-texel copy operations.\n   *\n   * @type {Vector2}\n   */ get texelPosition() {\n        return this.uniforms.texelPosition.value;\n    }\n    /**\n   * Returns the screen space position used for single-texel copy operations.\n   *\n   * @deprecated Use texelPosition instead.\n   * @return {Vector2} The position.\n   */ getTexelPosition() {\n        return this.uniforms.texelPosition.value;\n    }\n    /**\n   * Sets the screen space position used for single-texel copy operations.\n   *\n   * @deprecated\n   * @param {Vector2} value - The position.\n   */ setTexelPosition(value) {\n        this.uniforms.texelPosition.value = value;\n    }\n    /**\n   * The depth copy mode.\n   *\n   * @type {DepthCopyMode}\n   */ get mode() {\n        return this.depthCopyMode;\n    }\n    set mode(value) {\n        this.depthCopyMode = value;\n        this.defines.DEPTH_COPY_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {DepthCopyMode} The depth copy mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the depth copy mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {DepthCopyMode} value - The new mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n};\n// src/materials/DepthDownsamplingMaterial.js\n\n// src/materials/glsl/depth-downsampling.frag\nvar depth_downsampling_default = \"#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\n#ifdef DOWNSAMPLE_NORMALS\\nuniform lowp sampler2D normalBuffer;\\n#endif\\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\\n#ifdef DOWNSAMPLE_NORMALS\\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\\n#else\\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\\n#endif\\ngl_FragColor=vec4(n[index],d[index]);}\";\n// src/materials/glsl/depth-downsampling.vert\nvar depth_downsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/DepthDownsamplingMaterial.js\nvar DepthDownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth downsampling material.\n   */ constructor(){\n        super({\n            name: \"DepthDownsamplingMaterial\",\n            defines: {\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_downsampling_default,\n            vertexShader: depth_downsampling_default2\n        });\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */ set normalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n        if (value !== null) {\n            this.defines.DOWNSAMPLE_NORMALS = \"1\";\n        } else {\n            delete this.defines.DOWNSAMPLE_NORMALS;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Texture} value - The normal buffer.\n   */ setNormalBuffer(value) {\n        this.normalBuffer = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/DepthMaskMaterial.js\n\n// src/materials/glsl/depth-mask.frag\nvar depth_mask_default = \"#include <common>\\n#include <packing>\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\\n#else\\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\\n#endif\\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}varying vec2 vUv;void main(){vec2 depth;\\n#if DEPTH_PACKING_0 == 3201\\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\\n#else\\ndepth.x=texture2D(depthBuffer0,vUv).r;\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\\n#endif\\n#endif\\n#if DEPTH_PACKING_1 == 3201\\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\\n#else\\ndepth.y=texture2D(depthBuffer1,vUv).r;\\n#ifdef LOG_DEPTH\\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\\n#endif\\n#endif\\nbool isMaxDepth=(depth.x==1.0);\\n#ifdef PERSPECTIVE_CAMERA\\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\\n#endif\\n#if DEPTH_TEST_STRATEGY == 0\\nbool keep=depthTest(depth.x,depth.y);\\n#elif DEPTH_TEST_STRATEGY == 1\\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\\n#else\\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\\n#endif\\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}\";\n// src/materials/DepthMaskMaterial.js\nvar DepthMaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new depth mask material.\n   */ constructor(){\n        super({\n            name: \"DepthMaskMaterial\",\n            defines: {\n                DEPTH_EPSILON: \"0.0001\",\n                DEPTH_PACKING_0: \"0\",\n                DEPTH_PACKING_1: \"0\",\n                DEPTH_TEST_STRATEGY: DepthTestStrategy.KEEP_MAX_DEPTH\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer0: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer1: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1))\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: depth_mask_default,\n            vertexShader: common_default\n        });\n        this.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.LessDepth;\n    }\n    /**\n   * The primary depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer0(value) {\n        this.uniforms.depthBuffer0.value = value;\n    }\n    /**\n   * The primary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking0(value) {\n        this.defines.DEPTH_PACKING_0 = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the base depth buffer.\n   *\n   * @deprecated Use depthBuffer0 and depthPacking0 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer0(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer0 = buffer;\n        this.depthPacking0 = depthPacking;\n    }\n    /**\n   * The secondary depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer1(value) {\n        this.uniforms.depthBuffer1.value = value;\n    }\n    /**\n   * The secondary depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking1(value) {\n        this.defines.DEPTH_PACKING_1 = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer that will be compared with the base depth buffer.\n   *\n   * @deprecated Use depthBuffer1 and depthPacking1 instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer1(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer1 = buffer;\n        this.depthPacking1 = depthPacking;\n    }\n    /**\n   * The strategy for handling maximum depth.\n   *\n   * @type {DepthTestStrategy}\n   */ get maxDepthStrategy() {\n        return Number(this.defines.DEPTH_TEST_STRATEGY);\n    }\n    set maxDepthStrategy(value) {\n        this.defines.DEPTH_TEST_STRATEGY = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether maximum depth values should be preserved.\n   *\n   * @type {Boolean}\n   * @deprecated Use maxDepthStrategy instead.\n   */ get keepFar() {\n        return this.maxDepthStrategy;\n    }\n    set keepFar(value) {\n        this.maxDepthStrategy = value ? DepthTestStrategy.KEEP_MAX_DEPTH : DepthTestStrategy.DISCARD_MAX_DEPTH;\n    }\n    /**\n   * Returns the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @return {DepthTestStrategy} The strategy.\n   */ getMaxDepthStrategy() {\n        return this.maxDepthStrategy;\n    }\n    /**\n   * Sets the strategy for dealing with maximum depth values.\n   *\n   * @deprecated Use maxDepthStrategy instead.\n   * @param {DepthTestStrategy} value - The strategy.\n   */ setMaxDepthStrategy(value) {\n        this.maxDepthStrategy = value;\n    }\n    /**\n   * A small error threshold that is used for `EqualDepth` and `NotEqualDepth` tests. Default is `1e-4`.\n   *\n   * @type {Number}\n   */ get epsilon() {\n        return Number(this.defines.DEPTH_EPSILON);\n    }\n    set epsilon(value) {\n        this.defines.DEPTH_EPSILON = value.toFixed(16);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current error threshold for depth comparisons.\n   *\n   * @deprecated Use epsilon instead.\n   * @return {Number} The error threshold.\n   */ getEpsilon() {\n        return this.epsilon;\n    }\n    /**\n   * Sets the depth comparison error threshold.\n   *\n   * @deprecated Use epsilon instead.\n   * @param {Number} value - The new error threshold.\n   */ setEpsilon(value) {\n        this.epsilon = value;\n    }\n    /**\n   * The depth mode.\n   *\n   * @see https://threejs.org/docs/#api/en/constants/Materials\n   * @type {DepthModes}\n   */ get depthMode() {\n        return Number(this.defines.DEPTH_MODE);\n    }\n    set depthMode(value) {\n        let depthTest;\n        switch(value){\n            case three__WEBPACK_IMPORTED_MODULE_0__.NeverDepth:\n                depthTest = \"false\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.AlwaysDepth:\n                depthTest = \"true\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth:\n                depthTest = \"abs(d1 - d0) <= DEPTH_EPSILON\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth:\n                depthTest = \"abs(d1 - d0) > DEPTH_EPSILON\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.LessDepth:\n                depthTest = \"d0 > d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.LessEqualDepth:\n                depthTest = \"d0 >= d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.GreaterEqualDepth:\n                depthTest = \"d0 <= d1\";\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.GreaterDepth:\n            default:\n                depthTest = \"d0 < d1\";\n                break;\n        }\n        this.defines.DEPTH_MODE = value.toFixed(0);\n        this.defines[\"depthTest(d0, d1)\"] = depthTest;\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @return {DepthModes} The depth mode. Default is `LessDepth`.\n   */ getDepthMode() {\n        return this.depthMode;\n    }\n    /**\n   * Sets the depth mode.\n   *\n   * @deprecated Use depthMode instead.\n   * @param {DepthModes} mode - The depth mode.\n   */ setDepthMode(mode) {\n        this.depthMode = mode;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n};\n// src/materials/DownsamplingMaterial.js\n\n// src/materials/glsl/convolution.downsampling.frag\nvar convolution_downsampling_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#define WEIGHT_INNER 0.125\\n#define WEIGHT_OUTER 0.0555555\\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\\n#include <colorspace_fragment>\\n}\";\n// src/materials/glsl/convolution.downsampling.vert\nvar convolution_downsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/DownsamplingMaterial.js\nvar DownsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new downsampling material.\n   */ constructor(){\n        super({\n            name: \"DownsamplingMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_downsampling_default,\n            vertexShader: convolution_downsampling_default2\n        });\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/EdgeDetectionMaterial.js\n\n// src/materials/glsl/edge-detection.frag\nvar edge_detection_default = \"varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if EDGE_DETECTION_MODE != 0\\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\\n#endif\\n#if EDGE_DETECTION_MODE == 1\\n#include <common>\\n#endif\\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\\n#elif PREDICATION_MODE == 2\\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\\n#endif\\n#if PREDICATION_MODE != 0\\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\\n#endif\\n#if EDGE_DETECTION_MODE != 0\\nuniform sampler2D inputBuffer;\\n#endif\\nvoid main(){\\n#if EDGE_DETECTION_MODE == 0\\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\\n#elif PREDICATION_MODE != 0\\nvec2 threshold=calculatePredicatedThreshold();\\n#else\\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\\n#endif\\n#if EDGE_DETECTION_MODE == 0\\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\\n#elif EDGE_DETECTION_MODE == 1\\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\\n#elif EDGE_DETECTION_MODE == 2\\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\\n#endif\\n}\";\n// src/materials/glsl/edge-detection.vert\nvar edge_detection_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\\n#if EDGE_DETECTION_MODE != 0\\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\\n#endif\\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\\n#if EDGE_DETECTION_MODE != 0\\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\\n#endif\\ngl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/EdgeDetectionMaterial.js\nvar EdgeDetectionMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new edge detection material.\n   *\n   * TODO Remove parameters.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), mode = EdgeDetectionMode.COLOR){\n        super({\n            name: \"EdgeDetectionMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n                LOCAL_CONTRAST_ADAPTATION_FACTOR: \"2.0\",\n                EDGE_THRESHOLD: \"0.1\",\n                DEPTH_THRESHOLD: \"0.01\",\n                PREDICATION_MODE: \"0\",\n                PREDICATION_THRESHOLD: \"0.01\",\n                PREDICATION_SCALE: \"2.0\",\n                PREDICATION_STRENGTH: \"1.0\",\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                predicationBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: edge_detection_default,\n            vertexShader: edge_detection_default2\n        });\n        this.edgeDetectionMode = mode;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The edge detection mode.\n   *\n   * @type {EdgeDetectionMode}\n   */ get edgeDetectionMode() {\n        return Number(this.defines.EDGE_DETECTION_MODE);\n    }\n    set edgeDetectionMode(value) {\n        this.defines.EDGE_DETECTION_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @return {EdgeDetectionMode} The mode.\n   */ getEdgeDetectionMode() {\n        return this.edgeDetectionMode;\n    }\n    /**\n   * Sets the edge detection mode.\n   *\n   * @deprecated Use edgeDetectionMode instead.\n   * @param {EdgeDetectionMode} value - The edge detection mode.\n   */ setEdgeDetectionMode(value) {\n        this.edgeDetectionMode = value;\n    }\n    /**\n   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.\n   *\n   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.\n   *\n   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a\n   * direction, the perceptual contrast in the other neighbors will be hidden.\n   *\n   * @type {Number}\n   */ get localContrastAdaptationFactor() {\n        return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);\n    }\n    set localContrastAdaptationFactor(value) {\n        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the local contrast adaptation factor.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @return {Number} The factor.\n   */ getLocalContrastAdaptationFactor() {\n        return this.localContrastAdaptationFactor;\n    }\n    /**\n   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.\n   *\n   * @deprecated Use localContrastAdaptationFactor instead.\n   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.\n   */ setLocalContrastAdaptationFactor(value) {\n        this.localContrastAdaptationFactor = value;\n    }\n    /**\n   * The edge detection threshold. Range: [0.0, 0.5].\n   *\n   * A lower value results in more edges being detected at the expense of performance.\n   *\n   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05\n   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.\n   *\n   * If depth-based edge detection is used, the threshold will depend on the scene depth.\n   *\n   * @type {Number}\n   */ get edgeDetectionThreshold() {\n        return Number(this.defines.EDGE_THRESHOLD);\n    }\n    set edgeDetectionThreshold(value) {\n        this.defines.EDGE_THRESHOLD = value.toFixed(\"6\");\n        this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @return {Number} The threshold.\n   */ getEdgeDetectionThreshold() {\n        return this.edgeDetectionThreshold;\n    }\n    /**\n   * Sets the edge detection threshold.\n   *\n   * @deprecated Use edgeDetectionThreshold instead.\n   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].\n   */ setEdgeDetectionThreshold(value) {\n        this.edgeDetectionThreshold = value;\n    }\n    /**\n   * The predication mode.\n   *\n   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional\n   * buffer such as a light accumulation or depth buffer.\n   *\n   * @type {PredicationMode}\n   */ get predicationMode() {\n        return Number(this.defines.PREDICATION_MODE);\n    }\n    set predicationMode(value) {\n        this.defines.PREDICATION_MODE = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @return {PredicationMode} The mode.\n   */ getPredicationMode() {\n        return this.predicationMode;\n    }\n    /**\n   * Sets the predication mode.\n   *\n   * @deprecated Use predicationMode instead.\n   * @param {PredicationMode} value - The predication mode.\n   */ setPredicationMode(value) {\n        this.predicationMode = value;\n    }\n    /**\n   * The predication buffer.\n   *\n   * @type {Texture}\n   */ set predicationBuffer(value) {\n        this.uniforms.predicationBuffer.value = value;\n    }\n    /**\n   * Sets a custom predication buffer.\n   *\n   * @deprecated Use predicationBuffer instead.\n   * @param {Texture} value - The predication buffer.\n   */ setPredicationBuffer(value) {\n        this.uniforms.predicationBuffer.value = value;\n    }\n    /**\n   * The predication threshold.\n   *\n   * @type {Number}\n   */ get predicationThreshold() {\n        return Number(this.defines.PREDICATION_THRESHOLD);\n    }\n    set predicationThreshold(value) {\n        this.defines.PREDICATION_THRESHOLD = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @return {Number} The threshold.\n   */ getPredicationThreshold() {\n        return this.predicationThreshold;\n    }\n    /**\n   * Sets the predication threshold.\n   *\n   * @deprecated Use predicationThreshold instead.\n   * @param {Number} value - The threshold.\n   */ setPredicationThreshold(value) {\n        this.predicationThreshold = value;\n    }\n    /**\n   * The predication scale. Range: [1.0, 5.0].\n   *\n   * Determines how much the edge detection threshold should be scaled when using predication.\n   *\n   * @type {Boolean|Texture|Number}\n   */ get predicationScale() {\n        return Number(this.defines.PREDICATION_SCALE);\n    }\n    set predicationScale(value) {\n        this.defines.PREDICATION_SCALE = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @return {Number} The scale.\n   */ getPredicationScale() {\n        return this.predicationScale;\n    }\n    /**\n   * Sets the predication scale.\n   *\n   * @deprecated Use predicationScale instead.\n   * @param {Number} value - The scale. Range: [1.0, 5.0].\n   */ setPredicationScale(value) {\n        this.predicationScale = value;\n    }\n    /**\n   * The predication strength. Range: [0.0, 1.0].\n   *\n   * Determines how much the edge detection threshold should be decreased locally when using predication.\n   *\n   * @type {Number}\n   */ get predicationStrength() {\n        return Number(this.defines.PREDICATION_STRENGTH);\n    }\n    set predicationStrength(value) {\n        this.defines.PREDICATION_STRENGTH = value.toFixed(\"6\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @return {Number} The strength.\n   */ getPredicationStrength() {\n        return this.predicationStrength;\n    }\n    /**\n   * Sets the predication strength.\n   *\n   * @deprecated Use predicationStrength instead.\n   * @param {Number} value - The strength. Range: [0.0, 1.0].\n   */ setPredicationStrength(value) {\n        this.predicationStrength = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/EffectMaterial.js\n\n// src/materials/glsl/effect.frag\nvar effect_default = \"#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#define packFloatToRGBA(v) packDepthToRGBA(v)\\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if THREE_REVISION >= 137\\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\\n#endif\\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\\n#ifdef ENCODE_OUTPUT\\n#include <colorspace_fragment>\\n#endif\\n#include <dithering_fragment>\\n}\";\n// src/materials/glsl/effect.vert\nvar effect_default2 = \"uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/EffectMaterial.js\nvar EffectMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new effect material.\n   *\n   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.\n   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.\n   * @param {Camera} [camera] - A camera.\n   * @param {Boolean} [dithering=false] - Deprecated.\n   */ constructor(shaderParts, defines, uniforms, camera, dithering = false){\n        super({\n            name: \"EffectMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"),\n                DEPTH_PACKING: \"0\",\n                ENCODE_OUTPUT: \"1\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNear: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.3),\n                cameraFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1e3),\n                aspect: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                time: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            dithering\n        });\n        if (shaderParts) {\n            this.setShaderParts(shaderParts);\n        }\n        if (defines) {\n            this.setDefines(defines);\n        }\n        if (uniforms) {\n            this.setUniforms(uniforms);\n        }\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ get depthBuffer() {\n        return this.uniforms.depthBuffer.value;\n    }\n    set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ get depthPacking() {\n        return Number(this.defines.DEPTH_PACKING);\n    }\n    set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * Sets the shader data.\n   *\n   * @param {EffectShaderData} data - The shader data.\n   * @return {EffectMaterial} This material.\n   */ setShaderData(data) {\n        this.setShaderParts(data.shaderParts);\n        this.setDefines(data.defines);\n        this.setUniforms(data.uniforms);\n        this.setExtensions(data.extensions);\n    }\n    /**\n   * Sets the shader parts.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.\n   * @return {EffectMaterial} This material.\n   */ setShaderParts(shaderParts) {\n        this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_UV, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\");\n        this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\");\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n        this.needsUpdate = true;\n        return this;\n    }\n    /**\n   * Sets the shader macros.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.\n   * @return {EffectMaterial} This material.\n   */ setDefines(defines) {\n        for (const entry of defines.entries()){\n            this.defines[entry[0]] = entry[1];\n        }\n        this.needsUpdate = true;\n        return this;\n    }\n    /**\n   * Sets the shader uniforms.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.\n   * @return {EffectMaterial} This material.\n   */ setUniforms(uniforms) {\n        for (const entry of uniforms.entries()){\n            this.uniforms[entry[0]] = entry[1];\n        }\n        return this;\n    }\n    /**\n   * Sets the required shader extensions.\n   *\n   * @deprecated Use setShaderData instead.\n   * @param {Set<WebGLExtension>} extensions - A collection of extensions.\n   * @return {EffectMaterial} This material.\n   */ setExtensions(extensions) {\n        this.extensions = {};\n        for (const extension of extensions){\n            this.extensions[extension] = true;\n        }\n        return this;\n    }\n    /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @type {Boolean}\n   */ get encodeOutput() {\n        return this.defines.ENCODE_OUTPUT !== void 0;\n    }\n    set encodeOutput(value) {\n        if (this.encodeOutput !== value) {\n            if (value) {\n                this.defines.ENCODE_OUTPUT = \"1\";\n            } else {\n                delete this.defines.ENCODE_OUTPUT;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Indicates whether output encoding is enabled.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @return {Boolean} Whether output encoding is enabled.\n   */ isOutputEncodingEnabled(value) {\n        return this.encodeOutput;\n    }\n    /**\n   * Enables or disables output encoding.\n   *\n   * @deprecated Use encodeOutput instead.\n   * @param {Boolean} value - Whether output encoding should be enabled.\n   */ setOutputEncodingEnabled(value) {\n        this.encodeOutput = value;\n    }\n    /**\n   * The time in seconds.\n   *\n   * @type {Number}\n   */ get time() {\n        return this.uniforms.time.value;\n    }\n    set time(value) {\n        this.uniforms.time.value = value;\n    }\n    /**\n   * Sets the delta time.\n   *\n   * @deprecated Use time instead.\n   * @param {Number} value - The delta time in seconds.\n   */ setDeltaTime(value) {\n        this.uniforms.time.value += value;\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNear.value = camera.near;\n            this.uniforms.cameraFar.value = camera.far;\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the resolution.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        uniforms.resolution.value.set(width, height);\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        uniforms.aspect.value = width / height;\n    }\n    /**\n   * An enumeration of shader code placeholders.\n   *\n   * @deprecated Use EffectShaderSection instead.\n   * @type {Object}\n   */ static get Section() {\n        return EffectShaderSection;\n    }\n};\n// src/materials/GaussianBlurMaterial.js\n\n// src/materials/glsl/convolution.gaussian.frag\nvar convolution_gaussian_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec2 kernel[STEPS];varying vec2 vOffset;varying vec2 vUv;void main(){vec4 result=texture2D(inputBuffer,vUv)*kernel[0].y;for(int i=1;i<STEPS;++i){vec2 offset=kernel[i].x*vOffset;vec4 c0=texture2D(inputBuffer,vUv+offset);vec4 c1=texture2D(inputBuffer,vUv-offset);result+=(c0+c1)*kernel[i].y;}gl_FragColor=result;\\n#include <colorspace_fragment>\\n}\";\n// src/materials/glsl/convolution.gaussian.vert\nvar convolution_gaussian_default2 = \"uniform vec2 texelSize;uniform vec2 direction;uniform float scale;varying vec2 vOffset;varying vec2 vUv;void main(){vOffset=direction*texelSize*scale;vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/GaussianBlurMaterial.js\nvar GaussianBlurMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new convolution material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size.\n   */ constructor({ kernelSize = 35 } = {}){\n        super({\n            name: \"GaussianBlurMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                direction: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                kernel: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_gaussian_default,\n            vertexShader: convolution_gaussian_default2\n        });\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n        this._kernelSize = 0;\n        this.kernelSize = kernelSize;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The kernel size.\n   *\n   * @type {Number}\n   */ get kernelSize() {\n        return this._kernelSize;\n    }\n    set kernelSize(value) {\n        this._kernelSize = value;\n        this.generateKernel(value);\n    }\n    /**\n   * The blur direction.\n   *\n   * @type {Vector2}\n   */ get direction() {\n        return this.uniforms.direction.value;\n    }\n    /**\n   * The blur kernel scale. Values greater than 1.0 may introduce artifacts.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.scale.value;\n    }\n    set scale(value) {\n        this.uniforms.scale.value = value;\n    }\n    /**\n   * Generates the Gauss kernel.\n   *\n   * @param {KernelSize} kernelSize - The kernel size. Should be an odd number.\n   * @private\n   */ generateKernel(kernelSize) {\n        const kernel = new GaussKernel(kernelSize);\n        const steps = kernel.linearSteps;\n        const kernelData = new Float64Array(steps * 2);\n        for(let i = 0, j = 0; i < steps; ++i){\n            kernelData[j++] = kernel.linearOffsets[i];\n            kernelData[j++] = kernel.linearWeights[i];\n        }\n        this.uniforms.kernel.value = kernelData;\n        this.defines.STEPS = steps.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/GodRaysMaterial.js\n\n// src/materials/glsl/convolution.god-rays.frag\nvar convolution_god_rays_default = \"#include <common>\\n#include <dithering_pars_fragment>\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\\n#include <dithering_fragment>\\n}\";\n// src/materials/GodRaysMaterial.js\nvar GodRaysMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new god rays material.\n   *\n   * TODO Remove lightPosition param.\n   * @param {Vector2} lightPosition - Deprecated.\n   */ constructor(lightPosition){\n        super({\n            name: \"GodRaysMaterial\",\n            defines: {\n                SAMPLES_INT: \"60\",\n                SAMPLES_FLOAT: \"60.0\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                lightPosition: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lightPosition),\n                density: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                decay: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                weight: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                exposure: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                clampMax: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_god_rays_default,\n            vertexShader: common_default\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The screen space position of the light source.\n   *\n   * @type {Vector2}\n   */ get lightPosition() {\n        return this.uniforms.lightPosition.value;\n    }\n    /**\n   * Returns the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @return {Vector2} The position.\n   */ getLightPosition() {\n        return this.uniforms.lightPosition.value;\n    }\n    /**\n   * Sets the screen space position of the light source.\n   *\n   * @deprecated Use lightPosition instead.\n   * @param {Vector2} value - The position.\n   */ setLightPosition(value) {\n        this.uniforms.lightPosition.value = value;\n    }\n    /**\n   * The density.\n   *\n   * @type {Number}\n   */ get density() {\n        return this.uniforms.density.value;\n    }\n    set density(value) {\n        this.uniforms.density.value = value;\n    }\n    /**\n   * Returns the density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The density.\n   */ getDensity() {\n        return this.uniforms.density.value;\n    }\n    /**\n   * Sets the density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The density.\n   */ setDensity(value) {\n        this.uniforms.density.value = value;\n    }\n    /**\n   * The decay.\n   *\n   * @type {Number}\n   */ get decay() {\n        return this.uniforms.decay.value;\n    }\n    set decay(value) {\n        this.uniforms.decay.value = value;\n    }\n    /**\n   * Returns the decay.\n   *\n   * @deprecated Use decay instead.\n   * @return {Number} The decay.\n   */ getDecay() {\n        return this.uniforms.decay.value;\n    }\n    /**\n   * Sets the decay.\n   *\n   * @deprecated Use decay instead.\n   * @param {Number} value - The decay.\n   */ setDecay(value) {\n        this.uniforms.decay.value = value;\n    }\n    /**\n   * The weight.\n   *\n   * @type {Number}\n   */ get weight() {\n        return this.uniforms.weight.value;\n    }\n    set weight(value) {\n        this.uniforms.weight.value = value;\n    }\n    /**\n   * Returns the weight.\n   *\n   * @deprecated Use weight instead.\n   * @return {Number} The weight.\n   */ getWeight() {\n        return this.uniforms.weight.value;\n    }\n    /**\n   * Sets the weight.\n   *\n   * @deprecated Use weight instead.\n   * @param {Number} value - The weight.\n   */ setWeight(value) {\n        this.uniforms.weight.value = value;\n    }\n    /**\n   * The exposure.\n   *\n   * @type {Number}\n   */ get exposure() {\n        return this.uniforms.exposure.value;\n    }\n    set exposure(value) {\n        this.uniforms.exposure.value = value;\n    }\n    /**\n   * Returns the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @return {Number} The exposure.\n   */ getExposure() {\n        return this.uniforms.exposure.value;\n    }\n    /**\n   * Sets the exposure.\n   *\n   * @deprecated Use exposure instead.\n   * @param {Number} value - The exposure.\n   */ setExposure(value) {\n        this.uniforms.exposure.value = value;\n    }\n    /**\n   * The maximum light intensity.\n   *\n   * @type {Number}\n   */ get maxIntensity() {\n        return this.uniforms.clampMax.value;\n    }\n    set maxIntensity(value) {\n        this.uniforms.clampMax.value = value;\n    }\n    /**\n   * Returns the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @return {Number} The maximum light intensity.\n   */ getMaxIntensity() {\n        return this.uniforms.clampMax.value;\n    }\n    /**\n   * Sets the maximum light intensity.\n   *\n   * @deprecated Use maxIntensity instead.\n   * @param {Number} value - The maximum light intensity.\n   */ setMaxIntensity(value) {\n        this.uniforms.clampMax.value = value;\n    }\n    /**\n   * The amount of samples per pixel.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.SAMPLES_INT);\n    }\n    set samples(value) {\n        const s = Math.floor(value);\n        this.defines.SAMPLES_INT = s.toFixed(0);\n        this.defines.SAMPLES_FLOAT = s.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */ getSamples() {\n        return this.samples;\n    }\n    /**\n   * Sets the amount of samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */ setSamples(value) {\n        this.samples = value;\n    }\n};\n// src/materials/LuminanceMaterial.js\n\n// src/materials/glsl/luminance.frag\nvar luminance_default = \"#include <common>\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef RANGE\\nuniform vec2 range;\\n#elif defined(THRESHOLD)\\nuniform float threshold;uniform float smoothing;\\n#endif\\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\\n#ifdef RANGE\\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\\n#elif defined(THRESHOLD)\\nl=smoothstep(threshold,threshold+smoothing,l)*l;\\n#endif\\n#ifdef COLOR\\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\\n#else\\ngl_FragColor=vec4(l);\\n#endif\\n}\";\n// src/materials/LuminanceMaterial.js\nvar LuminanceMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new luminance material.\n   *\n   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.\n   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.\n   */ constructor(colorOutput = false, luminanceRange = null){\n        super({\n            name: \"LuminanceMaterial\",\n            defines: {\n                THREE_REVISION: three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                threshold: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),\n                smoothing: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                range: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: luminance_default,\n            vertexShader: common_default\n        });\n        this.colorOutput = colorOutput;\n        this.luminanceRange = luminanceRange;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The luminance threshold.\n   *\n   * @type {Number}\n   */ get threshold() {\n        return this.uniforms.threshold.value;\n    }\n    set threshold(value) {\n        if (this.smoothing > 0 || value > 0) {\n            this.defines.THRESHOLD = \"1\";\n        } else {\n            delete this.defines.THRESHOLD;\n        }\n        this.uniforms.threshold.value = value;\n    }\n    /**\n   * Returns the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @return {Number} The threshold.\n   */ getThreshold() {\n        return this.threshold;\n    }\n    /**\n   * Sets the luminance threshold.\n   *\n   * @deprecated Use threshold instead.\n   * @param {Number} value - The threshold.\n   */ setThreshold(value) {\n        this.threshold = value;\n    }\n    /**\n   * The luminance threshold smoothing.\n   *\n   * @type {Number}\n   */ get smoothing() {\n        return this.uniforms.smoothing.value;\n    }\n    set smoothing(value) {\n        if (this.threshold > 0 || value > 0) {\n            this.defines.THRESHOLD = \"1\";\n        } else {\n            delete this.defines.THRESHOLD;\n        }\n        this.uniforms.smoothing.value = value;\n    }\n    /**\n   * Returns the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @return {Number} The smoothing factor.\n   */ getSmoothingFactor() {\n        return this.smoothing;\n    }\n    /**\n   * Sets the luminance threshold smoothing factor.\n   *\n   * @deprecated Use smoothing instead.\n   * @param {Number} value - The smoothing factor.\n   */ setSmoothingFactor(value) {\n        this.smoothing = value;\n    }\n    /**\n   * Indicates whether the luminance threshold is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Adjust the threshold or smoothing factor instead.\n   */ get useThreshold() {\n        return this.threshold > 0 || this.smoothing > 0;\n    }\n    set useThreshold(value) {}\n    /**\n   * Indicates whether color output is enabled.\n   *\n   * @type {Boolean}\n   */ get colorOutput() {\n        return this.defines.COLOR !== void 0;\n    }\n    set colorOutput(value) {\n        if (value) {\n            this.defines.COLOR = \"1\";\n        } else {\n            delete this.defines.COLOR;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether color output is enabled.\n   *\n   * @deprecated Use colorOutput instead.\n   * @return {Boolean} Whether color output is enabled.\n   */ isColorOutputEnabled(value) {\n        return this.colorOutput;\n    }\n    /**\n   * Enables or disables color output.\n   *\n   * @deprecated Use colorOutput instead.\n   * @param {Boolean} value - Whether color output should be enabled.\n   */ setColorOutputEnabled(value) {\n        this.colorOutput = value;\n    }\n    /**\n   * Indicates whether luminance masking is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get useRange() {\n        return this.luminanceRange !== null;\n    }\n    set useRange(value) {\n        this.luminanceRange = null;\n    }\n    /**\n   * The luminance range. Set to null to disable.\n   *\n   * @type {Boolean}\n   */ get luminanceRange() {\n        return this.uniforms.range.value;\n    }\n    set luminanceRange(value) {\n        if (value !== null) {\n            this.defines.RANGE = \"1\";\n        } else {\n            delete this.defines.RANGE;\n        }\n        this.uniforms.range.value = value;\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the current luminance range.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @return {Vector2} The luminance range.\n   */ getLuminanceRange() {\n        return this.luminanceRange;\n    }\n    /**\n   * Sets a luminance range. Set to null to disable.\n   *\n   * @deprecated Use luminanceRange instead.\n   * @param {Vector2} value - The luminance range.\n   */ setLuminanceRange(value) {\n        this.luminanceRange = value;\n    }\n};\n// src/materials/MaskMaterial.js\n\n// src/materials/glsl/mask.frag\nvar mask_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\n#ifdef MASK_PRECISION_HIGH\\nuniform mediump sampler2D maskTexture;\\n#else\\nuniform lowp sampler2D maskTexture;\\n#endif\\n#if MASK_FUNCTION != 0\\nuniform float strength;\\n#endif\\nvarying vec2 vUv;void main(){\\n#if COLOR_CHANNEL == 0\\nfloat mask=texture2D(maskTexture,vUv).r;\\n#elif COLOR_CHANNEL == 1\\nfloat mask=texture2D(maskTexture,vUv).g;\\n#elif COLOR_CHANNEL == 2\\nfloat mask=texture2D(maskTexture,vUv).b;\\n#else\\nfloat mask=texture2D(maskTexture,vUv).a;\\n#endif\\n#if MASK_FUNCTION == 0\\n#ifdef INVERTED\\nmask=step(mask,0.0);\\n#else\\nmask=1.0-step(mask,0.0);\\n#endif\\n#else\\nmask=clamp(mask*strength,0.0,1.0);\\n#ifdef INVERTED\\nmask=1.0-mask;\\n#endif\\n#endif\\n#if MASK_FUNCTION == 3\\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\\n#elif MASK_FUNCTION == 2\\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\\n#else\\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\\n#endif\\n}\";\n// src/materials/MaskMaterial.js\nvar MaskMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new mask material.\n   *\n   * @param {Texture} [maskTexture] - The mask texture.\n   */ constructor(maskTexture = null){\n        super({\n            name: \"MaskMaterial\",\n            uniforms: {\n                maskTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maskTexture),\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                strength: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: mask_default,\n            vertexShader: common_default\n        });\n        this.colorChannel = ColorChannel.RED;\n        this.maskFunction = MaskFunction.DISCARD;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The mask texture.\n   *\n   * @type {Texture}\n   */ set maskTexture(value) {\n        this.uniforms.maskTexture.value = value;\n        delete this.defines.MASK_PRECISION_HIGH;\n        if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.defines.MASK_PRECISION_HIGH = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the mask texture.\n   *\n   * @deprecated Use maskTexture instead.\n   * @param {Texture} value - The texture.\n   */ setMaskTexture(value) {\n        this.maskTexture = value;\n    }\n    /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @type {ColorChannel}\n   */ set colorChannel(value) {\n        this.defines.COLOR_CHANNEL = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the color channel to use for masking. Default is `ColorChannel.RED`.\n   *\n   * @deprecated Use colorChannel instead.\n   * @param {ColorChannel} value - The channel.\n   */ setColorChannel(value) {\n        this.colorChannel = value;\n    }\n    /**\n   * The masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @type {MaskFunction}\n   */ set maskFunction(value) {\n        this.defines.MASK_FUNCTION = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the masking technique. Default is `MaskFunction.DISCARD`.\n   *\n   * @deprecated Use maskFunction instead.\n   * @param {MaskFunction} value - The function.\n   */ setMaskFunction(value) {\n        this.maskFunction = value;\n    }\n    /**\n   * Indicates whether the masking is inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.defines.INVERTED !== void 0;\n    }\n    set inverted(value) {\n        if (this.inverted && !value) {\n            delete this.defines.INVERTED;\n        } else if (value) {\n            this.defines.INVERTED = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether the masking is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the masking is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Determines whether the masking should be inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the masking should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * The current mask strength.\n   *\n   * Individual mask values will be clamped to [0.0, 1.0]. Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @type {Number}\n   */ get strength() {\n        return this.uniforms.strength.value;\n    }\n    set strength(value) {\n        this.uniforms.strength.value = value;\n    }\n    /**\n   * Returns the current mask strength.\n   *\n   * @deprecated Use strength instead.\n   * @return {Number} The mask strength.\n   */ getStrength() {\n        return this.strength;\n    }\n    /**\n   * Sets the mask strength.\n   *\n   * Has no effect when the mask function is set to `DISCARD`.\n   *\n   * @deprecated Use strength instead.\n   * @param {Number} value - The mask strength.\n   */ setStrength(value) {\n        this.strength = value;\n    }\n};\n// src/materials/OutlineMaterial.js\n\n// src/materials/glsl/outline.frag\nvar outline_default = \"uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}\";\n// src/materials/glsl/outline.vert\nvar outline_default2 = \"uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/OutlineMaterial.js\nvar OutlineMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new outline material.\n   *\n   * TODO Remove texelSize param.\n   * @param {Vector2} [texelSize] - The screen texel size.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()){\n        super({\n            name: \"OutlineMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: outline_default,\n            vertexShader: outline_default2\n        });\n        this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);\n        this.uniforms.maskTexture = this.uniforms.inputBuffer;\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/materials/SMAAWeightsMaterial.js\n\n// src/materials/glsl/smaa-weights.frag\nvar smaa_weights_default = \"#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\\n#if __VERSION__ < 300\\n#define round(v) floor(v + 0.5)\\n#endif\\n#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\\n#if !defined(DISABLE_CORNER_DETECTION)\\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\\n#endif\\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\\n#if !defined(DISABLE_CORNER_DETECTION)\\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\\n#endif\\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\\n#if !defined(DISABLE_DIAG_DETECTION)\\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\\n#endif\\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\\n#if !defined(DISABLE_DIAG_DETECTION)\\n}else{e.r=0.0;}\\n#endif\\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}\";\n// src/materials/glsl/smaa-weights.vert\nvar smaa_weights_default2 = \"uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/SMAAWeightsMaterial.js\nvar SMAAWeightsMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new SMAA weights material.\n   *\n   * @param {Vector2} [texelSize] - The absolute screen texel size.\n   * @param {Vector2} [resolution] - The resolution.\n   */ constructor(texelSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(), resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()){\n        super({\n            name: \"SMAAWeightsMaterial\",\n            defines: {\n                // Configurable settings:\n                MAX_SEARCH_STEPS_INT: \"16\",\n                MAX_SEARCH_STEPS_FLOAT: \"16.0\",\n                MAX_SEARCH_STEPS_DIAG_INT: \"8\",\n                MAX_SEARCH_STEPS_DIAG_FLOAT: \"8.0\",\n                CORNER_ROUNDING: \"25\",\n                CORNER_ROUNDING_NORM: \"0.25\",\n                // Non-configurable settings:\n                AREATEX_MAX_DISTANCE: \"16.0\",\n                AREATEX_MAX_DISTANCE_DIAG: \"20.0\",\n                AREATEX_PIXEL_SIZE: \"(1.0 / vec2(160.0, 560.0))\",\n                AREATEX_SUBTEX_SIZE: \"(1.0 / 7.0)\",\n                SEARCHTEX_SIZE: \"vec2(66.0, 33.0)\",\n                SEARCHTEX_PACKED_SIZE: \"vec2(64.0, 16.0)\"\n            },\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                searchTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                areaTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                resolution: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(resolution),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(texelSize)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: smaa_weights_default,\n            vertexShader: smaa_weights_default2\n        });\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * Sets the input buffer.\n   *\n   * @deprecated Use inputBuffer instead.\n   * @param {Texture} value - The input buffer.\n   */ setInputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * The search lookup texture.\n   *\n   * @type {Texture}\n   */ get searchTexture() {\n        return this.uniforms.searchTexture.value;\n    }\n    set searchTexture(value) {\n        this.uniforms.searchTexture.value = value;\n    }\n    /**\n   * The area lookup texture.\n   *\n   * @type {Texture}\n   */ get areaTexture() {\n        return this.uniforms.areaTexture.value;\n    }\n    set areaTexture(value) {\n        this.uniforms.areaTexture.value = value;\n    }\n    /**\n   * Sets the search and area lookup textures.\n   *\n   * @deprecated Use searchTexture and areaTexture instead.\n   * @param {Texture} search - The search lookup texture.\n   * @param {Texture} area - The area lookup texture.\n   */ setLookupTextures(search, area2) {\n        this.searchTexture = search;\n        this.areaTexture = area2;\n    }\n    /**\n   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   * Range: [0, 112].\n   *\n   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is\n   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).\n   *\n   * @type {Number}\n   */ get orthogonalSearchSteps() {\n        return Number(this.defines.MAX_SEARCH_STEPS_INT);\n    }\n    set orthogonalSearchSteps(value) {\n        const s = Math.min(Math.max(value, 0), 112);\n        this.defines.MAX_SEARCH_STEPS_INT = s.toFixed(\"0\");\n        this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed(\"1\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use orthogonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 112].\n   */ setOrthogonalSearchSteps(value) {\n        this.orthogonalSearchSteps = value;\n    }\n    /**\n   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search\n   * jumps one pixel at a time. Range: [0, 20].\n   *\n   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a\n   * significant impact on older machines.\n   *\n   * @type {Number}\n   */ get diagonalSearchSteps() {\n        return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);\n    }\n    set diagonalSearchSteps(value) {\n        const s = Math.min(Math.max(value, 0), 20);\n        this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed(\"0\");\n        this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed(\"1\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.\n   *\n   * @deprecated Use diagonalSearchSteps instead.\n   * @param {Number} value - The search steps. Range: [0, 20].\n   */ setDiagonalSearchSteps(value) {\n        this.diagonalSearchSteps = value;\n    }\n    /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @type {Boolean}\n   */ get diagonalDetection() {\n        return this.defines.DISABLE_DIAG_DETECTION === void 0;\n    }\n    set diagonalDetection(value) {\n        if (value) {\n            delete this.defines.DISABLE_DIAG_DETECTION;\n        } else {\n            this.defines.DISABLE_DIAG_DETECTION = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether diagonal pattern detection is enabled.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @return {Boolean} Whether diagonal pattern detection is enabled.\n   */ isDiagonalDetectionEnabled() {\n        return this.diagonalDetection;\n    }\n    /**\n   * Enables or disables diagonal pattern detection.\n   *\n   * @deprecated Use diagonalDetection instead.\n   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.\n   */ setDiagonalDetectionEnabled(value) {\n        this.diagonalDetection = value;\n    }\n    /**\n   * Specifies how much sharp corners will be rounded. Range: [0, 100].\n   *\n   * @type {Number}\n   */ get cornerRounding() {\n        return Number(this.defines.CORNER_ROUNDING);\n    }\n    set cornerRounding(value) {\n        const r = Math.min(Math.max(value, 0), 100);\n        this.defines.CORNER_ROUNDING = r.toFixed(\"4\");\n        this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed(\"4\");\n        this.needsUpdate = true;\n    }\n    /**\n   * Specifies how much sharp corners will be rounded.\n   *\n   * @deprecated Use cornerRounding instead.\n   * @param {Number} value - The corner rounding amount. Range: [0, 100].\n   */ setCornerRounding(value) {\n        this.cornerRounding = value;\n    }\n    /**\n   * Indicates whether corner detection is enabled.\n   *\n   * @type {Number}\n   */ get cornerDetection() {\n        return this.defines.DISABLE_CORNER_DETECTION === void 0;\n    }\n    set cornerDetection(value) {\n        if (value) {\n            delete this.defines.DISABLE_CORNER_DETECTION;\n        } else {\n            this.defines.DISABLE_CORNER_DETECTION = \"1\";\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Indicates whether corner rounding is enabled.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @return {Boolean} Whether corner rounding is enabled.\n   */ isCornerRoundingEnabled() {\n        return this.cornerDetection;\n    }\n    /**\n   * Enables or disables corner rounding.\n   *\n   * @deprecated Use cornerDetection instead.\n   * @param {Boolean} value - Whether corner rounding should be enabled.\n   */ setCornerRoundingEnabled(value) {\n        this.cornerDetection = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        uniforms.resolution.value.set(width, height);\n    }\n};\n// src/materials/SSAOMaterial.js\n\n// src/materials/glsl/ssao.frag\nvar ssao_default = \"#include <common>\\n#include <packing>\\n#ifdef NORMAL_DEPTH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\\n#else\\nuniform lowp sampler2D normalBuffer;\\n#if DEPTH_PACKING == 3201\\nuniform lowp sampler2D depthBuffer;\\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\\nuniform highp sampler2D depthBuffer;\\n#else\\nuniform mediump sampler2D depthBuffer;\\n#endif\\nfloat readDepth(const in vec2 uv){\\n#if DEPTH_PACKING == 3201\\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\\n#else\\nreturn texture2D(depthBuffer,uv).r;\\n#endif\\n}\\n#endif\\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\\n#ifdef PERSPECTIVE_CAMERA\\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#else\\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\\n#endif\\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\\n#else\\nfloat linearSampleDepth=sampleDepth;\\n#endif\\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\\n#ifdef NORMAL_DEPTH\\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\\n#else\\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\\n#endif\\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\\n#ifdef LEGACY_INTENSITY\\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\\n#endif\\n}gl_FragColor.r=ao;}\";\n// src/materials/glsl/ssao.vert\nvar ssao_default2 = \"uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/SSAOMaterial.js\nvar SSAOMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new SSAO material.\n   *\n   * @param {Camera} camera - A camera.\n   */ constructor(camera){\n        super({\n            name: \"SSAOMaterial\",\n            defines: {\n                SAMPLES_INT: \"0\",\n                INV_SAMPLES_FLOAT: \"0.0\",\n                SPIRAL_TURNS: \"0.0\",\n                RADIUS: \"1.0\",\n                RADIUS_SQ: \"1.0\",\n                DISTANCE_SCALING: \"1\",\n                DEPTH_PACKING: \"0\"\n            },\n            uniforms: {\n                depthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                normalDepthBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                noiseTexture: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                inverseProjectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n                projectionMatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                cameraNearFar: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                distanceCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                proximityCutoff: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                noiseScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                minRadiusScale: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.33),\n                intensity: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1),\n                fade: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.01),\n                bias: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: ssao_default,\n            vertexShader: ssao_default2\n        });\n        this.copyCameraSettings(camera);\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.r = 1;\n    }\n    /**\n   * The current near plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get near() {\n        return this.uniforms.cameraNearFar.value.x;\n    }\n    /**\n   * The current far plane setting.\n   *\n   * @type {Number}\n   * @private\n   */ get far() {\n        return this.uniforms.cameraNearFar.value.y;\n    }\n    /**\n   * A combined normal-depth buffer.\n   *\n   * @type {Texture}\n   */ set normalDepthBuffer(value) {\n        this.uniforms.normalDepthBuffer.value = value;\n        if (value !== null) {\n            this.defines.NORMAL_DEPTH = \"1\";\n        } else {\n            delete this.defines.NORMAL_DEPTH;\n        }\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the combined normal-depth buffer.\n   *\n   * @deprecated Use normalDepthBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setNormalDepthBuffer(value) {\n        this.normalDepthBuffer = value;\n    }\n    /**\n   * The normal buffer.\n   *\n   * @type {Texture}\n   */ set normalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @deprecated Use normalBuffer instead.\n   * @param {Number} value - The buffer.\n   */ setNormalBuffer(value) {\n        this.uniforms.normalBuffer.value = value;\n    }\n    /**\n   * The depth buffer.\n   *\n   * @type {Texture}\n   */ set depthBuffer(value) {\n        this.uniforms.depthBuffer.value = value;\n    }\n    /**\n   * The depth packing strategy.\n   *\n   * @type {DepthPackingStrategies}\n   */ set depthPacking(value) {\n        this.defines.DEPTH_PACKING = value.toFixed(0);\n        this.needsUpdate = true;\n    }\n    /**\n   * Sets the depth buffer.\n   *\n   * @deprecated Use depthBuffer and depthPacking instead.\n   * @param {Texture} buffer - The depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthBuffer(buffer, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthBuffer = buffer;\n        this.depthPacking = depthPacking;\n    }\n    /**\n   * The noise texture.\n   *\n   * @type {Texture}\n   */ set noiseTexture(value) {\n        this.uniforms.noiseTexture.value = value;\n    }\n    /**\n   * Sets the noise texture.\n   *\n   * @deprecated Use noiseTexture instead.\n   * @param {Number} value - The texture.\n   */ setNoiseTexture(value) {\n        this.uniforms.noiseTexture.value = value;\n    }\n    /**\n   * The sample count.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.SAMPLES_INT);\n    }\n    set samples(value) {\n        this.defines.SAMPLES_INT = value.toFixed(0);\n        this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @return {Number} The sample count.\n   */ getSamples() {\n        return this.samples;\n    }\n    /**\n   * Sets the amount of occlusion samples per pixel.\n   *\n   * @deprecated Use samples instead.\n   * @param {Number} value - The sample count.\n   */ setSamples(value) {\n        this.samples = value;\n    }\n    /**\n   * The sampling spiral ring count.\n   *\n   * @type {Number}\n   */ get rings() {\n        return Number(this.defines.SPIRAL_TURNS);\n    }\n    set rings(value) {\n        this.defines.SPIRAL_TURNS = value.toFixed(1);\n        this.needsUpdate = true;\n    }\n    /**\n   * Returns the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @return {Number} The radius.\n   */ getRings() {\n        return this.rings;\n    }\n    /**\n   * Sets the amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @deprecated Use rings instead.\n   * @param {Number} value - The radius.\n   */ setRings(value) {\n        this.rings = value;\n    }\n    /**\n   * The intensity.\n   *\n   * @type {Number}\n   * @deprecated Use SSAOEffect.intensity instead.\n   */ get intensity() {\n        return this.uniforms.intensity.value;\n    }\n    set intensity(value) {\n        this.uniforms.intensity.value = value;\n        if (this.defines.LEGACY_INTENSITY === void 0) {\n            this.defines.LEGACY_INTENSITY = \"1\";\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Returns the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.uniforms.intensity.value;\n    }\n    /**\n   * Sets the intensity.\n   *\n   * @deprecated Use SSAOEffect.intensity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.uniforms.intensity.value = value;\n    }\n    /**\n   * The depth fade factor.\n   *\n   * @type {Number}\n   */ get fade() {\n        return this.uniforms.fade.value;\n    }\n    set fade(value) {\n        this.uniforms.fade.value = value;\n    }\n    /**\n   * Returns the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @return {Number} The fade factor.\n   */ getFade() {\n        return this.uniforms.fade.value;\n    }\n    /**\n   * Sets the depth fade factor.\n   *\n   * @deprecated Use fade instead.\n   * @param {Number} value - The fade factor.\n   */ setFade(value) {\n        this.uniforms.fade.value = value;\n    }\n    /**\n   * The depth bias. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get bias() {\n        return this.uniforms.bias.value;\n    }\n    set bias(value) {\n        this.uniforms.bias.value = value;\n    }\n    /**\n   * Returns the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @return {Number} The bias.\n   */ getBias() {\n        return this.uniforms.bias.value;\n    }\n    /**\n   * Sets the depth bias.\n   *\n   * @deprecated Use bias instead.\n   * @param {Number} value - The bias.\n   */ setBias(value) {\n        this.uniforms.bias.value = value;\n    }\n    /**\n   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get minRadiusScale() {\n        return this.uniforms.minRadiusScale.value;\n    }\n    set minRadiusScale(value) {\n        this.uniforms.minRadiusScale.value = value;\n    }\n    /**\n   * Returns the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @return {Number} The minimum radius scale.\n   */ getMinRadiusScale() {\n        return this.uniforms.minRadiusScale.value;\n    }\n    /**\n   * Sets the minimum radius scale for distance scaling.\n   *\n   * @deprecated Use minRadiusScale instead.\n   * @param {Number} value - The minimum radius scale.\n   */ setMinRadiusScale(value) {\n        this.uniforms.minRadiusScale.value = value;\n    }\n    /**\n   * Updates the absolute radius.\n   *\n   * @private\n   */ updateRadius() {\n        const radius = this.r * this.resolution.height;\n        this.defines.RADIUS = radius.toFixed(11);\n        this.defines.RADIUS_SQ = (radius * radius).toFixed(11);\n        this.needsUpdate = true;\n    }\n    /**\n   * The occlusion sampling radius. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.r;\n    }\n    set radius(value) {\n        this.r = Math.min(Math.max(value, 1e-6), 1);\n        this.updateRadius();\n    }\n    /**\n   * Returns the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @return {Number} The radius.\n   */ getRadius() {\n        return this.radius;\n    }\n    /**\n   * Sets the occlusion sampling radius.\n   *\n   * @deprecated Use radius instead.\n   * @param {Number} value - The radius. Range [1e-6, 1.0].\n   */ setRadius(value) {\n        this.radius = value;\n    }\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get distanceScaling() {\n        return true;\n    }\n    set distanceScaling(value) {}\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @deprecated\n   * @return {Boolean} Whether distance scaling is enabled.\n   */ isDistanceScalingEnabled() {\n        return this.distanceScaling;\n    }\n    /**\n   * Enables or disables distance-based radius scaling.\n   *\n   * @deprecated\n   * @param {Boolean} value - Whether distance scaling should be enabled.\n   */ setDistanceScalingEnabled(value) {\n        this.distanceScaling = value;\n    }\n    /**\n   * The occlusion distance threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get distanceThreshold() {\n        return this.uniforms.distanceCutoff.value.x;\n    }\n    set distanceThreshold(value) {\n        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(value, 0), 1), Math.min(Math.max(value + this.distanceFalloff, 0), 1));\n    }\n    /**\n   * The occlusion distance threshold in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceThreshold() {\n        return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);\n    }\n    set worldDistanceThreshold(value) {\n        this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * The occlusion distance falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get distanceFalloff() {\n        return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;\n    }\n    set distanceFalloff(value) {\n        this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);\n    }\n    /**\n   * The occlusion distance falloff in world units.\n   *\n   * @type {Number}\n   */ get worldDistanceFalloff() {\n        return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);\n    }\n    set worldDistanceFalloff(value) {\n        this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use distanceThreshold and distanceFalloff instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setDistanceCutoff(threshold, falloff) {\n        this.uniforms.distanceCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n    /**\n   * The occlusion proximity threshold. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get proximityThreshold() {\n        return this.uniforms.proximityCutoff.value.x;\n    }\n    set proximityThreshold(value) {\n        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(value, 0), 1), Math.min(Math.max(value + this.proximityFalloff, 0), 1));\n    }\n    /**\n   * The occlusion proximity threshold in world units.\n   *\n   * @type {Number}\n   */ get worldProximityThreshold() {\n        return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);\n    }\n    set worldProximityThreshold(value) {\n        this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * The occlusion proximity falloff. Range: [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get proximityFalloff() {\n        return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;\n    }\n    set proximityFalloff(value) {\n        this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);\n    }\n    /**\n   * The occlusion proximity falloff in world units.\n   *\n   * @type {Number}\n   */ get worldProximityFalloff() {\n        return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);\n    }\n    set worldProximityFalloff(value) {\n        this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);\n    }\n    /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use proximityThreshold and proximityFalloff instead.\n   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setProximityCutoff(threshold, falloff) {\n        this.uniforms.proximityCutoff.value.set(Math.min(Math.max(threshold, 0), 1), Math.min(Math.max(threshold + falloff, 0), 1));\n    }\n    /**\n   * Sets the texel size.\n   *\n   * @deprecated Use setSize() instead.\n   * @param {Number} x - The texel width.\n   * @param {Number} y - The texel height.\n   */ setTexelSize(x, y) {\n        this.uniforms.texelSize.value.set(x, y);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @deprecated Use copyCameraSettings instead.\n   * @param {Camera} camera - A camera.\n   */ adoptCameraSettings(camera) {\n        this.copyCameraSettings(camera);\n    }\n    /**\n   * Copies the settings of the given camera.\n   *\n   * @param {Camera} camera - A camera.\n   */ copyCameraSettings(camera) {\n        if (camera) {\n            this.uniforms.cameraNearFar.value.set(camera.near, camera.far);\n            this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);\n            this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();\n            if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n                this.defines.PERSPECTIVE_CAMERA = \"1\";\n            } else {\n                delete this.defines.PERSPECTIVE_CAMERA;\n            }\n            this.needsUpdate = true;\n        }\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const uniforms = this.uniforms;\n        const noiseTexture = uniforms.noiseTexture.value;\n        if (noiseTexture !== null) {\n            uniforms.noiseScale.value.set(width / noiseTexture.image.width, height / noiseTexture.image.height);\n        }\n        uniforms.texelSize.value.set(1 / width, 1 / height);\n        this.resolution.set(width, height);\n        this.updateRadius();\n    }\n};\n// src/materials/TiltShiftBlurMaterial.js\n\n// src/materials/glsl/convolution.tilt-shift.frag\nvar convolution_tilt_shift_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;\\n#endif\\nuniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;\\n#include <colorspace_fragment>\\n}\";\n// src/materials/glsl/convolution.tilt-shift.vert\nvar convolution_tilt_shift_default2 = \"uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/TiltShiftBlurMaterial.js\nvar TiltShiftBlurMaterial = class extends KawaseBlurMaterial {\n    /**\n   * Constructs a new tilt shift blur material.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   */ constructor({ kernelSize = KernelSize.MEDIUM, offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3 } = {}){\n        super();\n        this.fragmentShader = convolution_tilt_shift_default;\n        this.vertexShader = convolution_tilt_shift_default2;\n        this.kernelSize = kernelSize;\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n        this.uniforms.aspect = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1);\n        this.uniforms.rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        this.uniforms.maskParams = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4());\n        this._offset = offset;\n        this._focusArea = focusArea;\n        this._feather = feather;\n        this.rotation = rotation;\n        this.updateParams();\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @private\n   */ updateParams() {\n        const params = this.uniforms.maskParams.value;\n        const a = Math.max(this.focusArea, 0);\n        const b = Math.max(a - this.feather, 0);\n        params.set(this.offset - a, this.offset - b, this.offset + a, this.offset + b);\n    }\n    /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */ get rotation() {\n        return Math.acos(this.uniforms.rotation.value.x);\n    }\n    set rotation(value) {\n        this.uniforms.rotation.value.set(Math.cos(value), Math.sin(value));\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this._offset;\n    }\n    set offset(value) {\n        this._offset = value;\n        this.updateParams();\n    }\n    /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */ get focusArea() {\n        return this._focusArea;\n    }\n    set focusArea(value) {\n        this._focusArea = value;\n        this.updateParams();\n    }\n    /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */ get feather() {\n        return this._feather;\n    }\n    set feather(value) {\n        this._feather = value;\n        this.updateParams();\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        super.setSize(width, height);\n        this.uniforms.aspect.value = width / height;\n    }\n};\n// src/materials/UpsamplingMaterial.js\n\n// src/materials/glsl/convolution.upsampling.frag\nvar convolution_upsampling_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\\n#else\\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\\n#endif\\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\\n#include <colorspace_fragment>\\n}\";\n// src/materials/glsl/convolution.upsampling.vert\nvar convolution_upsampling_default2 = \"uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}\";\n// src/materials/UpsamplingMaterial.js\nvar UpsamplingMaterial = class extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n   * Constructs a new upsampling material.\n   */ constructor(){\n        super({\n            name: \"UpsamplingMaterial\",\n            uniforms: {\n                inputBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                supportBuffer: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null),\n                texelSize: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()),\n                radius: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0.85)\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            toneMapped: false,\n            depthWrite: false,\n            depthTest: false,\n            fragmentShader: convolution_upsampling_default,\n            vertexShader: convolution_upsampling_default2\n        });\n        this.fragmentShader = updateFragmentShader(this.fragmentShader);\n    }\n    /**\n   * The input buffer.\n   *\n   * @type {Texture}\n   */ set inputBuffer(value) {\n        this.uniforms.inputBuffer.value = value;\n    }\n    /**\n   * A support buffer.\n   *\n   * @type {Texture}\n   */ set supportBuffer(value) {\n        this.uniforms.supportBuffer.value = value;\n    }\n    /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.uniforms.radius.value;\n    }\n    set radius(value) {\n        this.uniforms.radius.value = value;\n    }\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.uniforms.texelSize.value.set(1 / width, 1 / height);\n    }\n};\n// src/passes/CopyPass.js\n\n// src/passes/Pass.js\n\nvar dummyCamera = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Camera();\nvar geometry = null;\nfunction getFullscreenTriangle() {\n    if (geometry === null) {\n        const vertices = new Float32Array([\n            -1,\n            -1,\n            0,\n            3,\n            -1,\n            0,\n            -1,\n            3,\n            0\n        ]);\n        const uvs = new Float32Array([\n            0,\n            0,\n            2,\n            0,\n            0,\n            2\n        ]);\n        geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometry.setAttribute !== void 0) {\n            geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n            geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n        } else {\n            geometry.addAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(vertices, 3));\n            geometry.addAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(uvs, 2));\n        }\n    }\n    return geometry;\n}\nvar Pass = class _Pass {\n    /**\n   * Constructs a new pass.\n   *\n   * @param {String} [name] - The name of this pass. Does not have to be unique.\n   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.\n   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.\n   */ constructor(name = \"Pass\", scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), camera = dummyCamera){\n        this.name = name;\n        this.renderer = null;\n        this.scene = scene;\n        this.camera = camera;\n        this.screen = null;\n        this.rtt = true;\n        this.needsSwap = true;\n        this.needsDepthTexture = false;\n        this.enabled = true;\n    }\n    /**\n   * Sets the render to screen flag.\n   *\n   * If this flag is changed, the fullscreen material will be updated as well.\n   *\n   * @type {Boolean}\n   */ get renderToScreen() {\n        return !this.rtt;\n    }\n    set renderToScreen(value) {\n        if (this.rtt === value) {\n            const material = this.fullscreenMaterial;\n            if (material !== null) {\n                material.needsUpdate = true;\n            }\n            this.rtt = !value;\n        }\n    }\n    /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */ set mainScene(value) {}\n    /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */ set mainCamera(value) {}\n    /**\n   * Sets the renderer\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n    }\n    /**\n   * Indicates whether this pass is enabled.\n   *\n   * @deprecated Use enabled instead.\n   * @return {Boolean} Whether this pass is enabled.\n   */ isEnabled() {\n        return this.enabled;\n    }\n    /**\n   * Enables or disables this pass.\n   *\n   * @deprecated Use enabled instead.\n   * @param {Boolean} value - Whether the pass should be enabled.\n   */ setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n   * The fullscreen material.\n   *\n   * @type {Material}\n   */ get fullscreenMaterial() {\n        return this.screen !== null ? this.screen.material : null;\n    }\n    set fullscreenMaterial(value) {\n        let screen = this.screen;\n        if (screen !== null) {\n            screen.material = value;\n        } else {\n            screen = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(getFullscreenTriangle(), value);\n            screen.frustumCulled = false;\n            if (this.scene === null) {\n                this.scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n            }\n            this.scene.add(screen);\n            this.screen = screen;\n        }\n    }\n    /**\n   * Returns the current fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @return {Material} The current fullscreen material, or null if there is none.\n   */ getFullscreenMaterial() {\n        return this.fullscreenMaterial;\n    }\n    /**\n   * Sets the fullscreen material.\n   *\n   * @deprecated Use fullscreenMaterial instead.\n   * @protected\n   * @param {Material} value - A fullscreen material.\n   */ setFullscreenMaterial(value) {\n        this.fullscreenMaterial = value;\n    }\n    /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */ getDepthTexture() {\n        return null;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * This method will be called automatically by the {@link EffectComposer}.\n   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {}\n    /**\n   * Renders this pass.\n   *\n   * This is an abstract method that must be overridden.\n   *\n   * @abstract\n   * @throws {Error} An error is thrown if the method is not overridden.\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        throw new Error(\"Render method not implemented!\");\n    }\n    /**\n   * Sets the size.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n    /**\n   * Performs initialization tasks.\n   *\n   * This method is called when this pass is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {}\n    /**\n   * Performs a shallow search for disposable properties and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free\n   * memory when you're certain that you don't need this pass anymore.\n   */ dispose() {\n        for (const key of Object.keys(this)){\n            const property = this[key];\n            const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof _Pass;\n            if (isDisposable) {\n                this[key].dispose();\n            }\n        }\n    }\n};\n// src/passes/CopyPass.js\nvar CopyPass = class extends Pass {\n    /**\n   * Constructs a new save pass.\n   *\n   * @param {WebGLRenderTarget} [renderTarget] - A render target.\n   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.\n   */ constructor(renderTarget, autoResize = true){\n        super(\"CopyPass\");\n        this.fullscreenMaterial = new CopyMaterial();\n        this.needsSwap = false;\n        this.renderTarget = renderTarget;\n        if (renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n                stencilBuffer: false,\n                depthBuffer: false\n            });\n            this.renderTarget.texture.name = \"CopyPass.Target\";\n        }\n        this.autoResize = autoResize;\n    }\n    /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @type {Boolean}\n   */ get resize() {\n        return this.autoResize;\n    }\n    set resize(value) {\n        this.autoResize = value;\n    }\n    /**\n   * The output texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the output texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Enables or disables auto resizing of the render target.\n   *\n   * @deprecated Use autoResize instead.\n   * @param {Boolean} value - Whether the render target size should be updated automatically.\n   */ setAutoResizeEnabled(value) {\n        this.autoResize = value;\n    }\n    /**\n   * Saves the input buffer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.fullscreenMaterial.inputBuffer = inputBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        if (this.autoResize) {\n            this.renderTarget.setSize(width, height);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/passes/AdaptiveLuminancePass.js\nvar AdaptiveLuminancePass = class extends Pass {\n    /**\n   * Constructs a new adaptive luminance pass.\n   *\n   * @param {Texture} luminanceBuffer - A buffer that contains the current scene luminance.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */ constructor(luminanceBuffer, { minLuminance = 0.01, adaptationRate = 1 } = {}){\n        super(\"AdaptiveLuminancePass\");\n        this.fullscreenMaterial = new AdaptiveLuminanceMaterial();\n        this.needsSwap = false;\n        this.renderTargetPrevious = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false\n        });\n        this.renderTargetPrevious.texture.name = \"Luminance.Previous\";\n        const material = this.fullscreenMaterial;\n        material.luminanceBuffer0 = this.renderTargetPrevious.texture;\n        material.luminanceBuffer1 = luminanceBuffer;\n        material.minLuminance = minLuminance;\n        material.adaptationRate = adaptationRate;\n        this.renderTargetAdapted = this.renderTargetPrevious.clone();\n        this.renderTargetAdapted.texture.name = \"Luminance.Adapted\";\n        this.copyPass = new CopyPass(this.renderTargetPrevious, false);\n    }\n    /**\n   * The adaptive luminance texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTargetAdapted.texture;\n    }\n    /**\n   * Returns the adaptive 1x1 luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTargetAdapted.texture;\n    }\n    /**\n   * Sets the 1x1 mipmap level.\n   *\n   * This level is used to identify the smallest mipmap of the main luminance texture which contains the downsampled\n   * average scene luminance.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.mipLevel1x1 instead.\n   */ set mipLevel1x1(value) {\n        this.fullscreenMaterial.mipLevel1x1 = value;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */ get adaptationRate() {\n        return this.fullscreenMaterial.adaptationRate;\n    }\n    /**\n   * @type {Number}\n   * @deprecated Use fullscreenMaterial.adaptationRate instead.\n   */ set adaptationRate(value) {\n        this.fullscreenMaterial.adaptationRate = value;\n    }\n    /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.fullscreenMaterial.deltaTime = deltaTime;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted);\n        renderer.render(this.scene, this.camera);\n        this.copyPass.render(renderer, this.renderTargetAdapted);\n    }\n};\n// src/passes/BoxBlurPass.js\n\nvar BoxBlurPass = class extends Pass {\n    /**\n   * Constructs a new box blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=5] - Must be an odd number. The sizes 3 and 5 use optimized code paths.\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.bilateral=false] - Enables or disables bilateral blurring.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ kernelSize = 5, iterations = 1, bilateral = false, resolutionScale = 1, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"BoxBlurPass\");\n        this.needsDepthTexture = bilateral;\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        this.blurMaterial = new BoxBlurMaterial({\n            bilateral,\n            kernelSize\n        });\n        this.copyMaterial = new CopyMaterial();\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.iterations = iterations;\n    }\n    set mainCamera(value) {\n        this.blurMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.blurMaterial.depthBuffer = depthTexture;\n        this.blurMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const blurMaterial = this.blurMaterial;\n        this.fullscreenMaterial = blurMaterial;\n        let previousBuffer = inputBuffer;\n        for(let i = 0, l = Math.max(this.iterations, 1); i < l; ++i){\n            const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n            blurMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(buffer);\n            renderer.render(scene, camera);\n            previousBuffer = buffer;\n        }\n        this.copyMaterial.inputBuffer = previousBuffer.texture;\n        this.fullscreenMaterial = this.copyMaterial;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurMaterial.maxVaryingVectors = renderer.capabilities.maxVaryings;\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/passes/ClearMaskPass.js\nvar ClearMaskPass = class extends Pass {\n    /**\n   * Constructs a new clear mask pass.\n   */ constructor(){\n        super(\"ClearMaskPass\", null, null);\n        this.needsSwap = false;\n    }\n    /**\n   * Disables the global stencil test.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const stencil = renderer.state.buffers.stencil;\n        stencil.setLocked(false);\n        stencil.setTest(false);\n    }\n};\n// src/passes/ClearPass.js\n\nvar color = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar ClearPass = class extends Pass {\n    /**\n   * Constructs a new clear pass.\n   *\n   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.\n   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.\n   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.\n   */ constructor(color2 = true, depth = true, stencil = false){\n        super(\"ClearPass\", null, null);\n        this.needsSwap = false;\n        this.color = color2;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.overrideClearColor = null;\n        this.overrideClearAlpha = -1;\n    }\n    /**\n   * Sets the clear flags.\n   *\n   * @param {Boolean} color - Whether the color buffer should be cleared.\n   * @param {Boolean} depth - Whether the depth buffer should be cleared.\n   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.\n   */ setClearFlags(color2, depth, stencil) {\n        this.color = color2;\n        this.depth = depth;\n        this.stencil = stencil;\n    }\n    /**\n   * Returns the override clear color. Default is null.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @return {Color} The clear color.\n   */ getOverrideClearColor() {\n        return this.overrideClearColor;\n    }\n    /**\n   * Sets the override clear color.\n   *\n   * @deprecated Use overrideClearColor instead.\n   * @param {Color} value - The clear color.\n   */ setOverrideClearColor(value) {\n        this.overrideClearColor = value;\n    }\n    /**\n   * Returns the override clear alpha. Default is -1.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @return {Number} The clear alpha.\n   */ getOverrideClearAlpha() {\n        return this.overrideClearAlpha;\n    }\n    /**\n   * Sets the override clear alpha.\n   *\n   * @deprecated Use overrideClearAlpha instead.\n   * @param {Number} value - The clear alpha.\n   */ setOverrideClearAlpha(value) {\n        this.overrideClearAlpha = value;\n    }\n    /**\n   * Clears the input buffer or the screen.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const overrideClearColor = this.overrideClearColor;\n        const overrideClearAlpha = this.overrideClearAlpha;\n        const clearAlpha = renderer.getClearAlpha();\n        const hasOverrideClearColor = overrideClearColor !== null;\n        const hasOverrideClearAlpha = overrideClearAlpha >= 0;\n        if (hasOverrideClearColor) {\n            renderer.getClearColor(color);\n            renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);\n        } else if (hasOverrideClearAlpha) {\n            renderer.setClearAlpha(overrideClearAlpha);\n        }\n        renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);\n        renderer.clear(this.color, this.depth, this.stencil);\n        if (hasOverrideClearColor) {\n            renderer.setClearColor(color, clearAlpha);\n        } else if (hasOverrideClearAlpha) {\n            renderer.setClearAlpha(clearAlpha);\n        }\n    }\n};\n// src/passes/DepthPass.js\n\n// src/passes/RenderPass.js\nvar RenderPass = class extends Pass {\n    /**\n   * Constructs a new render pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Material} [overrideMaterial=null] - An override material.\n   */ constructor(scene, camera, overrideMaterial = null){\n        super(\"RenderPass\", scene, camera);\n        this.needsSwap = false;\n        this.clearPass = new ClearPass();\n        this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);\n        this.ignoreBackground = false;\n        this.skipShadowMapUpdate = false;\n        this.selection = null;\n    }\n    set mainScene(value) {\n        this.scene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    get renderToScreen() {\n        return super.renderToScreen;\n    }\n    set renderToScreen(value) {\n        super.renderToScreen = value;\n        this.clearPass.renderToScreen = value;\n    }\n    /**\n   * The current override material.\n   *\n   * @type {Material}\n   */ get overrideMaterial() {\n        const manager = this.overrideMaterialManager;\n        return manager !== null ? manager.material : null;\n    }\n    set overrideMaterial(value) {\n        const manager = this.overrideMaterialManager;\n        if (value !== null) {\n            if (manager !== null) {\n                manager.setMaterial(value);\n            } else {\n                this.overrideMaterialManager = new OverrideMaterialManager(value);\n            }\n        } else if (manager !== null) {\n            manager.dispose();\n            this.overrideMaterialManager = null;\n        }\n    }\n    /**\n   * Returns the current override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} The material.\n   */ getOverrideMaterial() {\n        return this.overrideMaterial;\n    }\n    /**\n   * Sets the override material.\n   *\n   * @deprecated Use overrideMaterial instead.\n   * @return {Material} value - The material.\n   */ setOverrideMaterial(value) {\n        this.overrideMaterial = value;\n    }\n    /**\n   * Indicates whether the target buffer should be cleared before rendering.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */ get clear() {\n        return this.clearPass.enabled;\n    }\n    set clear(value) {\n        this.clearPass.enabled = value;\n    }\n    /**\n   * Returns the selection. Default is `null` (no restriction).\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * Sets the selection. Set to `null` to disable.\n   *\n   * @deprecated Use selection instead.\n   * @param {Selection} value - The selection.\n   */ setSelection(value) {\n        this.selection = value;\n    }\n    /**\n   * Indicates whether the scene background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the scene background is disabled.\n   */ isBackgroundDisabled() {\n        return this.ignoreBackground;\n    }\n    /**\n   * Enables or disables the scene background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the scene background should be disabled.\n   */ setBackgroundDisabled(value) {\n        this.ignoreBackground = value;\n    }\n    /**\n   * Indicates whether the shadow map auto update is disabled.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @return {Boolean} Whether the shadow map update is disabled.\n   */ isShadowMapDisabled() {\n        return this.skipShadowMapUpdate;\n    }\n    /**\n   * Enables or disables the shadow map auto update.\n   *\n   * @deprecated Use skipShadowMapUpdate instead.\n   * @param {Boolean} value - Whether the shadow map auto update should be disabled.\n   */ setShadowMapDisabled(value) {\n        this.skipShadowMapUpdate = value;\n    }\n    /**\n   * Returns the clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */ getClearPass() {\n        return this.clearPass;\n    }\n    /**\n   * Renders the scene.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const selection = this.selection;\n        const mask = camera.layers.mask;\n        const background = scene.background;\n        const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;\n        const renderTarget = this.renderToScreen ? null : inputBuffer;\n        if (selection !== null) {\n            camera.layers.set(selection.getLayer());\n        }\n        if (this.skipShadowMapUpdate) {\n            renderer.shadowMap.autoUpdate = false;\n        }\n        if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {\n            scene.background = null;\n        }\n        if (this.clearPass.enabled) {\n            this.clearPass.render(renderer, inputBuffer);\n        }\n        renderer.setRenderTarget(renderTarget);\n        if (this.overrideMaterialManager !== null) {\n            this.overrideMaterialManager.render(renderer, scene, camera);\n        } else {\n            renderer.render(scene, camera);\n        }\n        camera.layers.mask = mask;\n        scene.background = background;\n        renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;\n    }\n};\n// src/passes/DepthPass.js\nvar DepthPass = class extends Pass {\n    /**\n   * Constructs a new depth pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { renderTarget, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthPass\");\n        this.needsSwap = false;\n        this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({\n            depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking\n        }));\n        const renderPass = this.renderPass;\n        renderPass.skipShadowMapUpdate = true;\n        renderPass.ignoreBackground = true;\n        const clearPass = renderPass.clearPass;\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        clearPass.overrideClearAlpha = 1;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n            });\n            this.renderTarget.texture.name = \"DepthPass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainScene(value) {\n        this.renderPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.renderPass.mainCamera = value;\n    }\n    /**\n   * The depth texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the scene depth.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const renderTarget = this.renderToScreen ? null : this.renderTarget;\n        this.renderPass.render(renderer, renderTarget);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n};\n// src/passes/DepthDownsamplingPass.js\n\nvar DepthDownsamplingPass = class extends Pass {\n    /**\n   * Constructs a new depth downsampling pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ normalBuffer = null, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthDownsamplingPass\");\n        const material = new DepthDownsamplingMaterial();\n        material.normalBuffer = normalBuffer;\n        this.fullscreenMaterial = material;\n        this.needsDepthTexture = true;\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.FloatType\n        });\n        this.renderTarget.texture.name = \"DepthDownsamplingPass.Target\";\n        this.renderTarget.texture.generateMipmaps = false;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * The normal(RGB) + depth(A) texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the normal(RGB) + depth(A) texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Downsamples depth and scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.fullscreenMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        const gl = renderer.getContext();\n        const renderable = gl.getExtension(\"EXT_color_buffer_float\") || gl.getExtension(\"EXT_color_buffer_half_float\");\n        if (!renderable) {\n            throw new Error(\"Rendering to float texture is not supported.\");\n        }\n    }\n};\n// src/passes/DepthPickingPass.js\n\n// src/passes/DepthCopyPass.js\n\nvar DepthCopyPass = class extends Pass {\n    /**\n   * Constructs a new depth save pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The output depth packing.\n   */ constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking } = {}){\n        super(\"DepthCopyPass\");\n        const material = new DepthCopyMaterial();\n        material.outputDepthPacking = depthPacking;\n        this.fullscreenMaterial = material;\n        this.needsDepthTexture = true;\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            type: depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType : three__WEBPACK_IMPORTED_MODULE_0__.FloatType,\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"DepthCopyPass.Target\";\n    }\n    /**\n   * The output depth texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the output depth texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The output depth packing.\n   *\n   * @type {DepthPackingStrategies}\n   */ get depthPacking() {\n        return this.fullscreenMaterial.outputDepthPacking;\n    }\n    /**\n   * Returns the output depth packing.\n   *\n   * @deprecated Use depthPacking instead.\n   * @return {DepthPackingStrategies} The depth packing.\n   */ getDepthPacking() {\n        return this.fullscreenMaterial.outputDepthPacking;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.inputDepthPacking = depthPacking;\n    }\n    /**\n   * Copies depth from a depth texture.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.renderTarget.setSize(width, height);\n    }\n};\n// src/passes/DepthPickingPass.js\nvar unpackFactors = new Float32Array([\n    255 / 256 / 256 ** 3,\n    255 / 256 / 256 ** 2,\n    255 / 256 / 256,\n    255 / 256\n]);\nfunction unpackRGBAToDepth(packedDepth) {\n    return (packedDepth[0] * unpackFactors[0] + packedDepth[1] * unpackFactors[1] + packedDepth[2] * unpackFactors[2] + packedDepth[3] * unpackFactors[3]) / 255;\n}\nvar DepthPickingPass = class extends DepthCopyPass {\n    /**\n   * Constructs a new depth picking pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {DepthPackingStrategies} [options.depthPacking=RGBADepthPacking] - The depth packing.\n   * @param {Number} [options.mode=DepthCopyMode.SINGLE] - The depth copy mode.\n   */ constructor({ depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking, mode = DepthCopyMode.SINGLE } = {}){\n        super({\n            depthPacking\n        });\n        this.name = \"DepthPickingPass\";\n        this.fullscreenMaterial.mode = mode;\n        this.pixelBuffer = depthPacking === three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking ? new Uint8Array(4) : new Float32Array(4);\n        this.callback = null;\n    }\n    /**\n   * Reads depth at a specific screen position.\n   *\n   * Only one depth value can be picked per frame. Calling this method multiple times per frame will overwrite the\n   * picking coordinates. Unresolved promises will be abandoned.\n   *\n   * @example\n   * const ndc = new Vector3();\n   * const clientRect = myViewport.getBoundingClientRect();\n   * const clientX = pointerEvent.clientX - clientRect.left;\n   * const clientY = pointerEvent.clientY - clientRect.top;\n   * ndc.x = (clientX / myViewport.clientWidth) * 2.0 - 1.0;\n   * ndc.y = -(clientY / myViewport.clientHeight) * 2.0 + 1.0;\n   * const depth = await depthPickingPass.readDepth(ndc);\n   * ndc.z = depth * 2.0 - 1.0;\n   *\n   * const worldPosition = ndc.unproject(camera);\n   *\n   * @param {Vector2|Vector3} ndc - Normalized device coordinates. Only X and Y are relevant.\n   * @return {Promise<Number>} A promise that returns the depth on the next frame.\n   */ readDepth(ndc) {\n        this.fullscreenMaterial.texelPosition.set(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);\n        return new Promise((resolve)=>{\n            this.callback = resolve;\n        });\n    }\n    /**\n   * Copies depth and resolves depth picking promises.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const material = this.fullscreenMaterial;\n        const mode = material.mode;\n        if (mode === DepthCopyMode.FULL) {\n            super.render(renderer);\n        }\n        if (this.callback !== null) {\n            const renderTarget = this.renderTarget;\n            const pixelBuffer = this.pixelBuffer;\n            const packed = renderTarget.texture.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            let x = 0, y = 0;\n            if (mode === DepthCopyMode.SINGLE) {\n                super.render(renderer);\n            } else {\n                const texelPosition = material.texelPosition;\n                x = Math.round(texelPosition.x * renderTarget.width);\n                y = Math.round(texelPosition.y * renderTarget.height);\n            }\n            renderer.readRenderTargetPixels(renderTarget, x, y, 1, 1, pixelBuffer);\n            this.callback(packed ? unpackRGBAToDepth(pixelBuffer) : pixelBuffer[0]);\n            this.callback = null;\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        if (this.fullscreenMaterial.mode === DepthCopyMode.FULL) {\n            super.setSize(width, height);\n        }\n    }\n};\n// src/passes/EffectPass.js\n\nfunction prefixSubstrings(prefix, substrings, strings) {\n    for (const substring of substrings){\n        const prefixed = \"$1\" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);\n        const regExp = new RegExp(\"([^\\\\.])(\\\\b\" + substring + \"\\\\b)\", \"g\");\n        for (const entry of strings.entries()){\n            if (entry[1] !== null) {\n                strings.set(entry[0], entry[1].replace(regExp, prefixed));\n            }\n        }\n    }\n}\nfunction integrateEffect(prefix, effect, data) {\n    let fragmentShader = effect.getFragmentShader();\n    let vertexShader = effect.getVertexShader();\n    const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);\n    const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);\n    data.attributes |= effect.getAttributes();\n    if (fragmentShader === void 0) {\n        throw new Error(`Missing fragment shader (${effect.name})`);\n    } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {\n        throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);\n    } else if (!mainImageExists && !mainUvExists) {\n        throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);\n    } else {\n        const functionRegExp = /\\w+\\s+(\\w+)\\([\\w\\s,]*\\)\\s*{/g;\n        const shaderParts = data.shaderParts;\n        let fragmentHead = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD) || \"\";\n        let fragmentMainUv = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV) || \"\";\n        let fragmentMainImage = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE) || \"\";\n        let vertexHead = shaderParts.get(EffectShaderSection.VERTEX_HEAD) || \"\";\n        let vertexMainSupport = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT) || \"\";\n        const varyings = /* @__PURE__ */ new Set();\n        const names = /* @__PURE__ */ new Set();\n        if (mainUvExists) {\n            fragmentMainUv += `\t${prefix}MainUv(UV);\n`;\n            data.uvTransformation = true;\n        }\n        if (vertexShader !== null && /mainSupport/.test(vertexShader)) {\n            const needsUv = /mainSupport *\\([\\w\\s]*?uv\\s*?\\)/.test(vertexShader);\n            vertexMainSupport += `\t${prefix}MainSupport(`;\n            vertexMainSupport += needsUv ? \"vUv);\\n\" : \");\\n\";\n            for (const m2 of vertexShader.matchAll(/(?:varying\\s+\\w+\\s+([\\S\\s]*?);)/g)){\n                for (const n of m2[1].split(/\\s*,\\s*/)){\n                    data.varyings.add(n);\n                    varyings.add(n);\n                    names.add(n);\n                }\n            }\n            for (const m2 of vertexShader.matchAll(functionRegExp)){\n                names.add(m2[1]);\n            }\n        }\n        for (const m2 of fragmentShader.matchAll(functionRegExp)){\n            names.add(m2[1]);\n        }\n        for (const d of effect.defines.keys()){\n            names.add(d.replace(/\\([\\w\\s,]*\\)/g, \"\"));\n        }\n        for (const u of effect.uniforms.keys()){\n            names.add(u);\n        }\n        names.delete(\"while\");\n        names.delete(\"for\");\n        names.delete(\"if\");\n        effect.uniforms.forEach((val, key)=>data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n        effect.defines.forEach((val, key)=>data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));\n        const shaders = /* @__PURE__ */ new Map([\n            [\n                \"fragment\",\n                fragmentShader\n            ],\n            [\n                \"vertex\",\n                vertexShader\n            ]\n        ]);\n        prefixSubstrings(prefix, names, data.defines);\n        prefixSubstrings(prefix, names, shaders);\n        fragmentShader = shaders.get(\"fragment\");\n        vertexShader = shaders.get(\"vertex\");\n        const blendMode = effect.blendMode;\n        data.blendModes.set(blendMode.blendFunction, blendMode);\n        if (mainImageExists) {\n            if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {\n                fragmentMainImage += effect.inputColorSpace === SRGBColorSpace ? \"color0 = LinearTosRGB(color0);\\n\t\" : \"color0 = sRGBToLinear(color0);\\n\t\";\n            }\n            if (effect.outputColorSpace !== NoColorSpace) {\n                data.colorSpace = effect.outputColorSpace;\n            } else if (effect.inputColorSpace !== null) {\n                data.colorSpace = effect.inputColorSpace;\n            }\n            const depthParamRegExp = /MainImage *\\([\\w\\s,]*?depth[\\w\\s,]*?\\)/;\n            fragmentMainImage += `${prefix}MainImage(color0, UV, `;\n            if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {\n                fragmentMainImage += \"depth, \";\n                data.readDepth = true;\n            }\n            fragmentMainImage += \"color1);\\n\t\";\n            const blendOpacity = prefix + \"BlendOpacity\";\n            data.uniforms.set(blendOpacity, blendMode.opacity);\n            fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});\n\n\t`;\n            fragmentHead += `uniform float ${blendOpacity};\n\n`;\n        }\n        fragmentHead += fragmentShader + \"\\n\";\n        if (vertexShader !== null) {\n            vertexHead += vertexShader + \"\\n\";\n        }\n        shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n        shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n        shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n        shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);\n        shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);\n        if (effect.extensions !== null) {\n            for (const extension of effect.extensions){\n                data.extensions.add(extension);\n            }\n        }\n    }\n}\nvar EffectPass = class extends Pass {\n    /**\n   * Constructs a new effect pass.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {...Effect} effects - The effects that will be rendered by this pass.\n   */ constructor(camera, ...effects){\n        super(\"EffectPass\");\n        this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);\n        this.listener = (event)=>this.handleEvent(event);\n        this.effects = [];\n        this.setEffects(effects);\n        this.skipRendering = false;\n        this.minTime = 1;\n        this.maxTime = Number.POSITIVE_INFINITY;\n        this.timeScale = 1;\n    }\n    set mainScene(value) {\n        for (const effect of this.effects){\n            effect.mainScene = value;\n        }\n    }\n    set mainCamera(value) {\n        this.fullscreenMaterial.copyCameraSettings(value);\n        for (const effect of this.effects){\n            effect.mainCamera = value;\n        }\n    }\n    /**\n   * Indicates whether this pass encodes its output when rendering to screen.\n   *\n   * @type {Boolean}\n   * @deprecated Use fullscreenMaterial.encodeOutput instead.\n   */ get encodeOutput() {\n        return this.fullscreenMaterial.encodeOutput;\n    }\n    set encodeOutput(value) {\n        this.fullscreenMaterial.encodeOutput = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   */ get dithering() {\n        return this.fullscreenMaterial.dithering;\n    }\n    set dithering(value) {\n        const material = this.fullscreenMaterial;\n        material.dithering = value;\n        material.needsUpdate = true;\n    }\n    /**\n   * Sets the effects.\n   *\n   * @param {Effect[]} effects - The effects.\n   * @protected\n   */ setEffects(effects) {\n        for (const effect of this.effects){\n            effect.removeEventListener(\"change\", this.listener);\n        }\n        this.effects = effects.sort((a, b)=>b.attributes - a.attributes);\n        for (const effect of this.effects){\n            effect.addEventListener(\"change\", this.listener);\n        }\n    }\n    /**\n   * Updates the compound shader material.\n   *\n   * @protected\n   */ updateMaterial() {\n        const data = new EffectShaderData();\n        let id = 0;\n        for (const effect of this.effects){\n            if (effect.blendMode.blendFunction === BlendFunction.DST) {\n                data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;\n            } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {\n                throw new Error(`Convolution effects cannot be merged (${effect.name})`);\n            } else {\n                integrateEffect(\"e\" + id++, effect, data);\n            }\n        }\n        let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);\n        let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);\n        let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);\n        const blendRegExp = /\\bblend\\b/g;\n        for (const blendMode of data.blendModes.values()){\n            fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + \"\\n\";\n        }\n        if ((data.attributes & EffectAttribute.DEPTH) !== 0) {\n            if (data.readDepth) {\n                fragmentMainImage = \"float depth = readDepth(UV);\\n\\n\t\" + fragmentMainImage;\n            }\n            this.needsDepthTexture = this.getDepthTexture() === null;\n        } else {\n            this.needsDepthTexture = false;\n        }\n        if (data.colorSpace === SRGBColorSpace) {\n            fragmentMainImage += \"color0 = sRGBToLinear(color0);\\n\t\";\n        }\n        if (data.uvTransformation) {\n            fragmentMainUv = \"vec2 transformedUv = vUv;\\n\" + fragmentMainUv;\n            data.defines.set(\"UV\", \"transformedUv\");\n        } else {\n            data.defines.set(\"UV\", \"vUv\");\n        }\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);\n        data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);\n        for (const [key, value] of data.shaderParts){\n            if (value !== null) {\n                data.shaderParts.set(key, value.trim().replace(/^#/, \"\\n#\"));\n            }\n        }\n        this.skipRendering = id === 0;\n        this.needsSwap = !this.skipRendering;\n        this.fullscreenMaterial.setShaderData(data);\n    }\n    /**\n   * Rebuilds the shader material.\n   */ recompile() {\n        this.updateMaterial();\n    }\n    /**\n   * Returns the current depth texture.\n   *\n   * @return {Texture} The current depth texture, or null if there is none.\n   */ getDepthTexture() {\n        return this.fullscreenMaterial.depthBuffer;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.fullscreenMaterial.depthBuffer = depthTexture;\n        this.fullscreenMaterial.depthPacking = depthPacking;\n        for (const effect of this.effects){\n            effect.setDepthTexture(depthTexture, depthPacking);\n        }\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        for (const effect of this.effects){\n            effect.update(renderer, inputBuffer, deltaTime);\n        }\n        if (!this.skipRendering || this.renderToScreen) {\n            const material = this.fullscreenMaterial;\n            material.inputBuffer = inputBuffer.texture;\n            material.time += deltaTime * this.timeScale;\n            renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n            renderer.render(this.scene, this.camera);\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.fullscreenMaterial.setSize(width, height);\n        for (const effect of this.effects){\n            effect.setSize(width, height);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.renderer = renderer;\n        for (const effect of this.effects){\n            effect.initialize(renderer, alpha, frameBufferType);\n        }\n        this.updateMaterial();\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n    /**\n   * Deletes disposable objects.\n   */ dispose() {\n        super.dispose();\n        for (const effect of this.effects){\n            effect.removeEventListener(\"change\", this.listener);\n            effect.dispose();\n        }\n    }\n    /**\n   * Handles events.\n   *\n   * @param {Event} event - An event.\n   */ handleEvent(event) {\n        switch(event.type){\n            case \"change\":\n                this.recompile();\n                break;\n        }\n    }\n};\n// src/passes/GaussianBlurPass.js\n\nvar GaussianBlurPass = class extends Pass {\n    /**\n   * Constructs a new Gaussian blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.kernelSize=35] - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [options.iterations=1] - The amount of times the blur should be applied.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ kernelSize = 35, iterations = 1, resolutionScale = 1, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"GaussianBlurPass\");\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        this.blurMaterial = new GaussianBlurMaterial({\n            kernelSize\n        });\n        this.copyMaterial = new CopyMaterial();\n        this.copyMaterial.inputBuffer = this.renderTargetB.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.iterations = iterations;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const blurMaterial = this.blurMaterial;\n        this.fullscreenMaterial = blurMaterial;\n        let previousBuffer = inputBuffer;\n        for(let i = 0, l = Math.max(this.iterations, 1); i < l; ++i){\n            blurMaterial.direction.set(1, 0);\n            blurMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(renderTargetA);\n            renderer.render(scene, camera);\n            blurMaterial.direction.set(0, 1);\n            blurMaterial.inputBuffer = renderTargetA.texture;\n            renderer.setRenderTarget(renderTargetB);\n            renderer.render(scene, camera);\n            if (i === 0 && l > 1) {\n                previousBuffer = renderTargetB;\n            }\n        }\n        this.fullscreenMaterial = this.copyMaterial;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/passes/KawaseBlurPass.js\n\nvar KawaseBlurPass = class extends Pass {\n    /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"KawaseBlurPass\");\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"Blur.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"Blur.Target.B\";\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this._blurMaterial = new KawaseBlurMaterial();\n        this._blurMaterial.kernelSize = kernelSize;\n        this.copyMaterial = new CopyMaterial();\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   */ get blurMaterial() {\n        return this._blurMaterial;\n    }\n    /**\n   * The blur material.\n   *\n   * @type {KawaseBlurMaterial}\n   * @protected\n   */ set blurMaterial(value) {\n        this._blurMaterial = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use copyMaterial.dithering instead.\n   */ get dithering() {\n        return this.copyMaterial.dithering;\n    }\n    set dithering(value) {\n        this.copyMaterial.dithering = value;\n    }\n    /**\n   * The kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurMaterial.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurMaterial.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurMaterial.kernelSize = value;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    /**\n   * Sets the render width.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredWidth instead.\n   */ set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    /**\n   * Sets the render height.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.preferredHeight instead.\n   */ set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * The current blur scale.\n   *\n   * @type {Number}\n   * @deprecated Use blurMaterial.scale instead.\n   */ get scale() {\n        return this.blurMaterial.scale;\n    }\n    set scale(value) {\n        this.blurMaterial.scale = value;\n    }\n    /**\n   * Returns the current blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.blurMaterial.scale;\n    }\n    /**\n   * Sets the blur scale.\n   *\n   * @deprecated Use blurMaterial.scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.blurMaterial.scale = value;\n    }\n    /**\n   * Returns the kernel size.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @return {KernelSize} The kernel size.\n   */ getKernelSize() {\n        return this.kernelSize;\n    }\n    /**\n   * Sets the kernel size.\n   *\n   * Larger kernels require more processing power but scale well with larger render resolutions.\n   *\n   * @deprecated Use blurMaterial.kernelSize instead.\n   * @param {KernelSize} value - The kernel size.\n   */ setKernelSize(value) {\n        this.kernelSize = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetB = this.renderTargetB;\n        const material = this.blurMaterial;\n        const kernelSequence = material.kernelSequence;\n        let previousBuffer = inputBuffer;\n        this.fullscreenMaterial = material;\n        for(let i = 0, l = kernelSequence.length; i < l; ++i){\n            const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;\n            material.kernel = kernelSequence[i];\n            material.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(buffer);\n            renderer.render(scene, camera);\n            previousBuffer = buffer;\n        }\n        this.fullscreenMaterial = this.copyMaterial;\n        this.copyMaterial.inputBuffer = previousBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(scene, camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.blurMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n            }\n        }\n    }\n    /**\n   * An auto sizing flag.\n   *\n   * @type {Number}\n   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.\n   */ static get AUTO_SIZE() {\n        return Resolution.AUTO_SIZE;\n    }\n};\n// src/passes/LambdaPass.js\nvar LambdaPass = class extends Pass {\n    /**\n   * Constructs a new lambda pass.\n   *\n   * @param {Function} f - A function.\n   */ constructor(f){\n        super(\"LambdaPass\", null, null);\n        this.needsSwap = false;\n        this.f = f;\n    }\n    /**\n   * Executes the function.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        this.f();\n    }\n};\n// src/passes/LuminancePass.js\n\nvar LuminancePass = class extends Pass {\n    /**\n   * Constructs a new luminance pass.\n   *\n   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor({ renderTarget, luminanceRange, colorOutput, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"LuminancePass\");\n        this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);\n        this.needsSwap = false;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                depthBuffer: false\n            });\n            this.renderTarget.texture.name = \"LuminancePass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * The luminance texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the luminance texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Renders the luminance.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const material = this.fullscreenMaterial;\n        material.inputBuffer = inputBuffer.texture;\n        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.renderTarget.texture.type = frameBufferType;\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n};\n// src/passes/MaskPass.js\nvar MaskPass = class extends Pass {\n    /**\n   * Constructs a new mask pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use.\n   */ constructor(scene, camera){\n        super(\"MaskPass\", scene, camera);\n        this.needsSwap = false;\n        this.clearPass = new ClearPass(false, false, true);\n        this.inverse = false;\n    }\n    set mainScene(value) {\n        this.scene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    /**\n   * Indicates whether the mask should be inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.inverse;\n    }\n    set inverted(value) {\n        this.inverse = value;\n    }\n    /**\n   * Indicates whether this pass should clear the stencil buffer.\n   *\n   * @type {Boolean}\n   * @deprecated Use clearPass.enabled instead.\n   */ get clear() {\n        return this.clearPass.enabled;\n    }\n    set clear(value) {\n        this.clearPass.enabled = value;\n    }\n    /**\n   * Returns the internal clear pass.\n   *\n   * @deprecated Use clearPass.enabled instead.\n   * @return {ClearPass} The clear pass.\n   */ getClearPass() {\n        return this.clearPass;\n    }\n    /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const context = renderer.getContext();\n        const buffers = renderer.state.buffers;\n        const scene = this.scene;\n        const camera = this.camera;\n        const clearPass = this.clearPass;\n        const writeValue = this.inverted ? 0 : 1;\n        const clearValue = 1 - writeValue;\n        buffers.color.setMask(false);\n        buffers.depth.setMask(false);\n        buffers.color.setLocked(true);\n        buffers.depth.setLocked(true);\n        buffers.stencil.setTest(true);\n        buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n        buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);\n        buffers.stencil.setClear(clearValue);\n        buffers.stencil.setLocked(true);\n        if (this.clearPass.enabled) {\n            if (this.renderToScreen) {\n                clearPass.render(renderer, null);\n            } else {\n                clearPass.render(renderer, inputBuffer);\n                clearPass.render(renderer, outputBuffer);\n            }\n        }\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(scene, camera);\n        } else {\n            renderer.setRenderTarget(inputBuffer);\n            renderer.render(scene, camera);\n            renderer.setRenderTarget(outputBuffer);\n            renderer.render(scene, camera);\n        }\n        buffers.color.setLocked(false);\n        buffers.depth.setLocked(false);\n        buffers.stencil.setLocked(false);\n        buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);\n        buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n        buffers.stencil.setLocked(true);\n    }\n};\n// src/passes/MipmapBlurPass.js\n\nvar MipmapBlurPass = class extends Pass {\n    /**\n   * Constructs a new mipmap blur pass.\n   *\n   * @param {Object} [options] - The options.\n   */ constructor(){\n        super(\"MipmapBlurPass\");\n        this.needsSwap = false;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"Upsampling.Mipmap0\";\n        this.downsamplingMipmaps = [];\n        this.upsamplingMipmaps = [];\n        this.downsamplingMaterial = new DownsamplingMaterial();\n        this.upsamplingMaterial = new UpsamplingMaterial();\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    }\n    /**\n   * A texture that contains the blurred result.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The MIP levels. Default is 8.\n   *\n   * @type {Number}\n   */ get levels() {\n        return this.downsamplingMipmaps.length;\n    }\n    set levels(value) {\n        if (this.levels !== value) {\n            const renderTarget = this.renderTarget;\n            this.dispose();\n            this.downsamplingMipmaps = [];\n            this.upsamplingMipmaps = [];\n            for(let i = 0; i < value; ++i){\n                const mipmap = renderTarget.clone();\n                mipmap.texture.name = \"Downsampling.Mipmap\" + i;\n                this.downsamplingMipmaps.push(mipmap);\n            }\n            this.upsamplingMipmaps.push(renderTarget);\n            for(let i = 1, l = value - 1; i < l; ++i){\n                const mipmap = renderTarget.clone();\n                mipmap.texture.name = \"Upsampling.Mipmap\" + i;\n                this.upsamplingMipmaps.push(mipmap);\n            }\n            this.setSize(this.resolution.x, this.resolution.y);\n        }\n    }\n    /**\n   * The blur radius.\n   *\n   * @type {Number}\n   */ get radius() {\n        return this.upsamplingMaterial.radius;\n    }\n    set radius(value) {\n        this.upsamplingMaterial.radius = value;\n    }\n    /**\n   * Renders the blur.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const { scene, camera } = this;\n        const { downsamplingMaterial, upsamplingMaterial } = this;\n        const { downsamplingMipmaps, upsamplingMipmaps } = this;\n        let previousBuffer = inputBuffer;\n        this.fullscreenMaterial = downsamplingMaterial;\n        for(let i = 0, l = downsamplingMipmaps.length; i < l; ++i){\n            const mipmap = downsamplingMipmaps[i];\n            downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n            downsamplingMaterial.inputBuffer = previousBuffer.texture;\n            renderer.setRenderTarget(mipmap);\n            renderer.render(scene, camera);\n            previousBuffer = mipmap;\n        }\n        this.fullscreenMaterial = upsamplingMaterial;\n        for(let i = upsamplingMipmaps.length - 1; i >= 0; --i){\n            const mipmap = upsamplingMipmaps[i];\n            upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);\n            upsamplingMaterial.inputBuffer = previousBuffer.texture;\n            upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;\n            renderer.setRenderTarget(mipmap);\n            renderer.render(scene, camera);\n            previousBuffer = mipmap;\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.set(width, height);\n        let w = resolution.width, h = resolution.height;\n        for(let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i){\n            w = Math.round(w * 0.5);\n            h = Math.round(h * 0.5);\n            this.downsamplingMipmaps[i].setSize(w, h);\n            if (i < this.upsamplingMipmaps.length) {\n                this.upsamplingMipmaps[i].setSize(w, h);\n            }\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0) {\n            const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);\n            for (const mipmap of mipmaps){\n                mipmap.texture.type = frameBufferType;\n            }\n            if (frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n                this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n            } else if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                for (const mipmap of mipmaps){\n                    setTextureColorSpace(mipmap.texture, SRGBColorSpace);\n                }\n            }\n        }\n    }\n    /**\n   * Deletes internal render targets and textures.\n   */ dispose() {\n        super.dispose();\n        for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)){\n            mipmap.dispose();\n        }\n    }\n};\n// src/passes/NormalPass.js\n\nvar NormalPass = class extends Pass {\n    /**\n   * Constructs a new normal pass.\n   *\n   * @param {Scene} scene - The scene to render.\n   * @param {Camera} camera - The camera to use to render the scene.\n   * @param {Object} [options] - The options.\n   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { renderTarget, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"NormalPass\");\n        this.needsSwap = false;\n        this.renderPass = new RenderPass(scene, camera, new three__WEBPACK_IMPORTED_MODULE_0__.MeshNormalMaterial());\n        const renderPass = this.renderPass;\n        renderPass.ignoreBackground = true;\n        renderPass.skipShadowMapUpdate = true;\n        const clearPass = renderPass.getClearPass();\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(7829503);\n        clearPass.overrideClearAlpha = 1;\n        this.renderTarget = renderTarget;\n        if (this.renderTarget === void 0) {\n            this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n                minFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n                magFilter: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter\n            });\n            this.renderTarget.texture.name = \"NormalPass.Target\";\n        }\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainScene(value) {\n        this.renderPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.renderPass.mainCamera = value;\n    }\n    /**\n   * The normal texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * The normal texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.renderTarget.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Renders the scene normals.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const renderTarget = this.renderToScreen ? null : this.renderTarget;\n        this.renderPass.render(renderer, renderTarget, renderTarget);\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n    }\n};\n// src/passes/ShaderPass.js\n\nvar ShaderPass = class extends Pass {\n    /**\n   * Constructs a new shader pass.\n   *\n   * @param {ShaderMaterial} material - A shader material.\n   * @param {String} [input=\"inputBuffer\"] - The name of the input buffer uniform.\n   */ constructor(material, input = \"inputBuffer\"){\n        super(\"ShaderPass\");\n        this.fullscreenMaterial = material;\n        this.input = input;\n    }\n    /**\n   * Sets the name of the input buffer uniform.\n   *\n   * @param {String} input - The name of the input buffer uniform.\n   * @deprecated Use input instead.\n   */ setInput(input) {\n        this.input = input;\n    }\n    /**\n   * Renders the effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.\n   */ render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {\n        const uniforms = this.fullscreenMaterial.uniforms;\n        if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {\n            uniforms[this.input].value = inputBuffer.texture;\n        }\n        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n        renderer.render(this.scene, this.camera);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        if (frameBufferType !== void 0 && frameBufferType !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = \"1\";\n        }\n    }\n};\n// src/passes/TiltShiftBlurPass.js\nvar TiltShiftBlurPass = class extends KawaseBlurPass {\n    /**\n   * Constructs a new Kawase blur pass.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3, kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super({\n            kernelSize,\n            resolutionScale,\n            resolutionX,\n            resolutionY\n        });\n        this.blurMaterial = new TiltShiftBlurMaterial({\n            kernelSize,\n            offset,\n            rotation,\n            focusArea,\n            feather\n        });\n    }\n};\n// src/core/Timer.js\nvar MILLISECONDS_TO_SECONDS = 1 / 1e3;\nvar SECONDS_TO_MILLISECONDS = 1e3;\nvar Timer = class {\n    /**\n   * Constructs a new timer.\n   */ constructor(){\n        this.startTime = performance.now();\n        this.previousTime = 0;\n        this.currentTime = 0;\n        this._delta = 0;\n        this._elapsed = 0;\n        this._fixedDelta = 1e3 / 60;\n        this.timescale = 1;\n        this.useFixedDelta = false;\n        this._autoReset = false;\n    }\n    /**\n   * Enables or disables auto reset based on page visibility.\n   *\n   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page\n   * is hidden. Has no effect if the API is not supported.\n   *\n   * @type {Boolean}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n   */ get autoReset() {\n        return this._autoReset;\n    }\n    set autoReset(value) {\n        if (typeof document !== \"undefined\" && document.hidden !== void 0) {\n            if (value) {\n                document.addEventListener(\"visibilitychange\", this);\n            } else {\n                document.removeEventListener(\"visibilitychange\", this);\n            }\n            this._autoReset = value;\n        }\n    }\n    get delta() {\n        return this._delta * MILLISECONDS_TO_SECONDS;\n    }\n    get fixedDelta() {\n        return this._fixedDelta * MILLISECONDS_TO_SECONDS;\n    }\n    set fixedDelta(value) {\n        this._fixedDelta = value * SECONDS_TO_MILLISECONDS;\n    }\n    get elapsed() {\n        return this._elapsed * MILLISECONDS_TO_SECONDS;\n    }\n    /**\n   * Updates this timer.\n   *\n   * @param {Boolean} [timestamp] - The current time in milliseconds.\n   */ update(timestamp) {\n        if (this.useFixedDelta) {\n            this._delta = this.fixedDelta;\n        } else {\n            this.previousTime = this.currentTime;\n            this.currentTime = (timestamp !== void 0 ? timestamp : performance.now()) - this.startTime;\n            this._delta = this.currentTime - this.previousTime;\n        }\n        this._delta *= this.timescale;\n        this._elapsed += this._delta;\n    }\n    /**\n   * Resets this timer.\n   */ reset() {\n        this._delta = 0;\n        this._elapsed = 0;\n        this.currentTime = performance.now() - this.startTime;\n    }\n    handleEvent(e) {\n        if (!document.hidden) {\n            this.currentTime = performance.now() - this.startTime;\n        }\n    }\n    dispose() {\n        this.autoReset = false;\n    }\n};\n// src/core/EffectComposer.js\nvar EffectComposer = class {\n    /**\n   * Constructs a new effect composer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer that should be used.\n   * @param {Object} [options] - The options.\n   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.\n   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.\n   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.\n   */ constructor(renderer = null, { depthBuffer = true, stencilBuffer = false, multisampling = 0, frameBufferType } = {}){\n        this.renderer = null;\n        this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);\n        this.outputBuffer = this.inputBuffer.clone();\n        this.copyPass = new CopyPass();\n        this.depthTexture = null;\n        this.passes = [];\n        this.timer = new Timer();\n        this.autoRenderToScreen = true;\n        this.setRenderer(renderer);\n    }\n    /**\n   * The current amount of samples used for multisample anti-aliasing.\n   *\n   * @type {Number}\n   */ get multisampling() {\n        return this.inputBuffer.samples || 0;\n    }\n    /**\n   * Sets the amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @type {Number}\n   */ set multisampling(value) {\n        const buffer = this.inputBuffer;\n        const multisampling = this.multisampling;\n        if (multisampling > 0 && value > 0) {\n            this.inputBuffer.samples = value;\n            this.outputBuffer.samples = value;\n            this.inputBuffer.dispose();\n            this.outputBuffer.dispose();\n        } else if (multisampling !== value) {\n            this.inputBuffer.dispose();\n            this.outputBuffer.dispose();\n            this.inputBuffer = this.createBuffer(buffer.depthBuffer, buffer.stencilBuffer, buffer.texture.type, value);\n            this.inputBuffer.depthTexture = this.depthTexture;\n            this.outputBuffer = this.inputBuffer.clone();\n        }\n    }\n    /**\n   * Returns the internal timer.\n   *\n   * @return {Timer} The timer.\n   */ getTimer() {\n        return this.timer;\n    }\n    /**\n   * Returns the renderer.\n   *\n   * @return {WebGLRenderer} The renderer.\n   */ getRenderer() {\n        return this.renderer;\n    }\n    /**\n   * Sets the renderer.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n        if (renderer !== null) {\n            const size = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n            const alpha = renderer.getContext().getContextAttributes().alpha;\n            const frameBufferType = this.inputBuffer.texture.type;\n            if (frameBufferType === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.inputBuffer.texture, SRGBColorSpace);\n                setTextureColorSpace(this.outputBuffer.texture, SRGBColorSpace);\n                this.inputBuffer.dispose();\n                this.outputBuffer.dispose();\n            }\n            renderer.autoClear = false;\n            this.setSize(size.width, size.height);\n            for (const pass of this.passes){\n                pass.initialize(renderer, alpha, frameBufferType);\n            }\n        }\n    }\n    /**\n   * Replaces the current renderer with the given one.\n   *\n   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the\n   * previous one, all passes will be updated.\n   *\n   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM\n   * element of the new renderer will take its place.\n   *\n   * @deprecated Use setRenderer instead.\n   * @param {WebGLRenderer} renderer - The new renderer.\n   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.\n   * @return {WebGLRenderer} The old renderer.\n   */ replaceRenderer(renderer, updateDOM = true) {\n        const oldRenderer = this.renderer;\n        const parent = oldRenderer.domElement.parentNode;\n        this.setRenderer(renderer);\n        if (updateDOM && parent !== null) {\n            parent.removeChild(oldRenderer.domElement);\n            parent.appendChild(renderer.domElement);\n        }\n        return oldRenderer;\n    }\n    /**\n   * Creates a depth texture attachment that will be provided to all passes.\n   *\n   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture\n   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.\n   *\n   * @private\n   * @return {DepthTexture} The depth texture.\n   */ createDepthTexture() {\n        const depthTexture = this.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n        this.inputBuffer.depthTexture = depthTexture;\n        this.inputBuffer.dispose();\n        if (this.inputBuffer.stencilBuffer) {\n            depthTexture.format = three__WEBPACK_IMPORTED_MODULE_0__.DepthStencilFormat;\n            depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedInt248Type;\n        } else {\n            depthTexture.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType;\n        }\n        return depthTexture;\n    }\n    /**\n   * Deletes the current depth texture.\n   *\n   * @private\n   */ deleteDepthTexture() {\n        if (this.depthTexture !== null) {\n            this.depthTexture.dispose();\n            this.depthTexture = null;\n            this.inputBuffer.depthTexture = null;\n            this.inputBuffer.dispose();\n            for (const pass of this.passes){\n                pass.setDepthTexture(null);\n            }\n        }\n    }\n    /**\n   * Creates a new render target.\n   *\n   * @deprecated Create buffers manually via WebGLRenderTarget instead.\n   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.\n   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.\n   * @param {Number} type - The frame buffer type.\n   * @param {Number} multisampling - The number of samples to use for antialiasing.\n   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.\n   */ createBuffer(depthBuffer, stencilBuffer, type, multisampling) {\n        const renderer = this.renderer;\n        const size = renderer === null ? new three__WEBPACK_IMPORTED_MODULE_0__.Vector2() : renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        const options = {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            stencilBuffer,\n            depthBuffer,\n            type\n        };\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(size.width, size.height, options);\n        if (multisampling > 0) {\n            renderTarget.ignoreDepthForMultisampleCopy = false;\n            renderTarget.samples = multisampling;\n        }\n        if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType && getOutputColorSpace(renderer) === SRGBColorSpace) {\n            setTextureColorSpace(renderTarget.texture, SRGBColorSpace);\n        }\n        renderTarget.texture.name = \"EffectComposer.Buffer\";\n        renderTarget.texture.generateMipmaps = false;\n        return renderTarget;\n    }\n    /**\n   * Can be used to change the main scene for all registered passes and effects.\n   *\n   * @param {Scene} scene - The scene.\n   */ setMainScene(scene) {\n        for (const pass of this.passes){\n            pass.mainScene = scene;\n        }\n    }\n    /**\n   * Can be used to change the main camera for all registered passes and effects.\n   *\n   * @param {Camera} camera - The camera.\n   */ setMainCamera(camera) {\n        for (const pass of this.passes){\n            pass.mainCamera = camera;\n        }\n    }\n    /**\n   * Adds a pass, optionally at a specific index.\n   *\n   * @param {Pass} pass - A new pass.\n   * @param {Number} [index] - An index at which the pass should be inserted.\n   */ addPass(pass, index) {\n        const passes = this.passes;\n        const renderer = this.renderer;\n        const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        const alpha = renderer.getContext().getContextAttributes().alpha;\n        const frameBufferType = this.inputBuffer.texture.type;\n        pass.setRenderer(renderer);\n        pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        pass.initialize(renderer, alpha, frameBufferType);\n        if (this.autoRenderToScreen) {\n            if (passes.length > 0) {\n                passes[passes.length - 1].renderToScreen = false;\n            }\n            if (pass.renderToScreen) {\n                this.autoRenderToScreen = false;\n            }\n        }\n        if (index !== void 0) {\n            passes.splice(index, 0, pass);\n        } else {\n            passes.push(pass);\n        }\n        if (this.autoRenderToScreen) {\n            passes[passes.length - 1].renderToScreen = true;\n        }\n        if (pass.needsDepthTexture || this.depthTexture !== null) {\n            if (this.depthTexture === null) {\n                const depthTexture = this.createDepthTexture();\n                for (pass of passes){\n                    pass.setDepthTexture(depthTexture);\n                }\n            } else {\n                pass.setDepthTexture(this.depthTexture);\n            }\n        }\n    }\n    /**\n   * Removes a pass.\n   *\n   * @param {Pass} pass - The pass.\n   */ removePass(pass) {\n        const passes = this.passes;\n        const index = passes.indexOf(pass);\n        const exists = index !== -1;\n        const removed = exists && passes.splice(index, 1).length > 0;\n        if (removed) {\n            if (this.depthTexture !== null) {\n                const reducer = (a, b)=>a || b.needsDepthTexture;\n                const depthTextureRequired = passes.reduce(reducer, false);\n                if (!depthTextureRequired) {\n                    if (pass.getDepthTexture() === this.depthTexture) {\n                        pass.setDepthTexture(null);\n                    }\n                    this.deleteDepthTexture();\n                }\n            }\n            if (this.autoRenderToScreen) {\n                if (index === passes.length) {\n                    pass.renderToScreen = false;\n                    if (passes.length > 0) {\n                        passes[passes.length - 1].renderToScreen = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Removes all passes.\n   */ removeAllPasses() {\n        const passes = this.passes;\n        this.deleteDepthTexture();\n        if (passes.length > 0) {\n            if (this.autoRenderToScreen) {\n                passes[passes.length - 1].renderToScreen = false;\n            }\n            this.passes = [];\n        }\n    }\n    /**\n   * Renders all enabled passes in the order in which they were added.\n   *\n   * @param {Number} [deltaTime] - The time since the last frame in seconds.\n   */ render(deltaTime) {\n        const renderer = this.renderer;\n        const copyPass = this.copyPass;\n        let inputBuffer = this.inputBuffer;\n        let outputBuffer = this.outputBuffer;\n        let stencilTest = false;\n        let context, stencil, buffer;\n        if (deltaTime === void 0) {\n            this.timer.update();\n            deltaTime = this.timer.delta;\n        }\n        for (const pass of this.passes){\n            if (pass.enabled) {\n                pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n                if (pass.needsSwap) {\n                    if (stencilTest) {\n                        copyPass.renderToScreen = pass.renderToScreen;\n                        context = renderer.getContext();\n                        stencil = renderer.state.buffers.stencil;\n                        stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n                        copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);\n                        stencil.setFunc(context.EQUAL, 1, 4294967295);\n                    }\n                    buffer = inputBuffer;\n                    inputBuffer = outputBuffer;\n                    outputBuffer = buffer;\n                }\n                if (pass instanceof MaskPass) {\n                    stencilTest = true;\n                } else if (pass instanceof ClearMaskPass) {\n                    stencilTest = false;\n                }\n            }\n        }\n    }\n    /**\n   * Sets the size of the buffers, passes and the renderer.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.\n   */ setSize(width, height, updateStyle) {\n        const renderer = this.renderer;\n        const currentSize = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        if (width === void 0 || height === void 0) {\n            width = currentSize.width;\n            height = currentSize.height;\n        }\n        if (currentSize.width !== width || currentSize.height !== height) {\n            renderer.setSize(width, height, updateStyle);\n        }\n        const drawingBufferSize = renderer.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        for (const pass of this.passes){\n            pass.setSize(drawingBufferSize.width, drawingBufferSize.height);\n        }\n    }\n    /**\n   * Resets this composer by deleting all passes and creating new buffers.\n   */ reset() {\n        const autoReset = this.timer.autoReset;\n        this.dispose();\n        this.autoRenderToScreen = true;\n        this.timer.autoReset = autoReset;\n    }\n    /**\n   * Disposes this composer and all passes.\n   */ dispose() {\n        for (const pass of this.passes){\n            pass.dispose();\n        }\n        this.passes = [];\n        if (this.inputBuffer !== null) {\n            this.inputBuffer.dispose();\n        }\n        if (this.outputBuffer !== null) {\n            this.outputBuffer.dispose();\n        }\n        this.deleteDepthTexture();\n        this.copyPass.dispose();\n        this.timer.dispose();\n    }\n};\n// src/core/EffectShaderData.js\nvar EffectShaderData = class {\n    /**\n   * Constructs new shader data.\n   */ constructor(){\n        this.shaderParts = /* @__PURE__ */ new Map([\n            [\n                EffectShaderSection.FRAGMENT_HEAD,\n                null\n            ],\n            [\n                EffectShaderSection.FRAGMENT_MAIN_UV,\n                null\n            ],\n            [\n                EffectShaderSection.FRAGMENT_MAIN_IMAGE,\n                null\n            ],\n            [\n                EffectShaderSection.VERTEX_HEAD,\n                null\n            ],\n            [\n                EffectShaderSection.VERTEX_MAIN_SUPPORT,\n                null\n            ]\n        ]);\n        this.defines = /* @__PURE__ */ new Map();\n        this.uniforms = /* @__PURE__ */ new Map();\n        this.blendModes = /* @__PURE__ */ new Map();\n        this.extensions = /* @__PURE__ */ new Set();\n        this.attributes = EffectAttribute.NONE;\n        this.varyings = /* @__PURE__ */ new Set();\n        this.uvTransformation = false;\n        this.readDepth = false;\n        this.colorSpace = LinearSRGBColorSpace;\n    }\n};\n// src/core/GaussKernel.js\nfunction getCoefficients(n) {\n    let result;\n    if (n === 0) {\n        result = new Float64Array(0);\n    } else if (n === 1) {\n        result = new Float64Array([\n            1\n        ]);\n    } else if (n > 1) {\n        let row0 = new Float64Array(n);\n        let row1 = new Float64Array(n);\n        for(let y = 1; y <= n; ++y){\n            for(let x = 0; x < y; ++x){\n                row1[x] = x === 0 || x === y - 1 ? 1 : row0[x - 1] + row0[x];\n            }\n            result = row1;\n            row1 = row0;\n            row0 = result;\n        }\n    }\n    return result;\n}\nvar GaussKernel = class {\n    /**\n   * Constructs a new Gauss kernel.\n   *\n   * @param {Number} kernelSize - The kernel size. Should be an odd number in the range [3, 1020].\n   * @param {Number} [edgeBias=2] - Determines how many edge coefficients should be cut off for increased accuracy.\n   */ constructor(kernelSize, edgeBias = 2){\n        this.weights = null;\n        this.offsets = null;\n        this.linearWeights = null;\n        this.linearOffsets = null;\n        this.generate(kernelSize, edgeBias);\n    }\n    /**\n   * The number of steps for discrete sampling.\n   *\n   * @type {Number}\n   */ get steps() {\n        return this.offsets === null ? 0 : this.offsets.length;\n    }\n    /**\n   * The number of steps for linear sampling.\n   *\n   * @type {Number}\n   */ get linearSteps() {\n        return this.linearOffsets === null ? 0 : this.linearOffsets.length;\n    }\n    /**\n   * Generates the kernel.\n   *\n   * @private\n   * @param {Number} kernelSize - The kernel size.\n   * @param {Number} edgeBias - The amount of edge coefficients to ignore.\n   */ generate(kernelSize, edgeBias) {\n        if (kernelSize < 3 || kernelSize > 1020) {\n            throw new Error(\"The kernel size must be in the range [3, 1020]\");\n        }\n        const n = kernelSize + edgeBias * 2;\n        const coefficients = edgeBias > 0 ? getCoefficients(n).slice(edgeBias, -edgeBias) : getCoefficients(n);\n        const mid = Math.floor((coefficients.length - 1) / 2);\n        const sum = coefficients.reduce((a, b)=>a + b, 0);\n        const weights = coefficients.slice(mid);\n        const offsets = [\n            ...Array(mid + 1).keys()\n        ];\n        const linearWeights = new Float64Array(Math.floor(offsets.length / 2));\n        const linearOffsets = new Float64Array(linearWeights.length);\n        linearWeights[0] = weights[0] / sum;\n        for(let i = 1, j = 1, l = offsets.length - 1; i < l; i += 2, ++j){\n            const offset0 = offsets[i], offset1 = offsets[i + 1];\n            const weight0 = weights[i], weight1 = weights[i + 1];\n            const w = weight0 + weight1;\n            const o = (offset0 * weight0 + offset1 * weight1) / w;\n            linearWeights[j] = w / sum;\n            linearOffsets[j] = o;\n        }\n        for(let i = 0, l = weights.length, s = 1 / sum; i < l; ++i){\n            weights[i] *= s;\n        }\n        const linearWeightSum = (linearWeights.reduce((a, b)=>a + b, 0) - linearWeights[0] * 0.5) * 2;\n        if (linearWeightSum !== 0) {\n            for(let i = 0, l = linearWeights.length, s = 1 / linearWeightSum; i < l; ++i){\n                linearWeights[i] *= s;\n            }\n        }\n        this.offsets = offsets;\n        this.weights = weights;\n        this.linearOffsets = linearOffsets;\n        this.linearWeights = linearWeights;\n    }\n};\n// src/core/ImmutableTimer.js\nvar ImmutableTimer = class {\n    /**\n   * The current delta time in seconds.\n   *\n   * @type {Number}\n   */ get delta() {\n        return NaN;\n    }\n    /**\n   * The fixed delta time in seconds.\n   *\n   * @type {Number}\n   */ get fixedDelta() {\n        return NaN;\n    }\n    /**\n   * The elapsed time in seconds.\n   *\n   * @type {Number}\n   */ get elapsed() {\n        return NaN;\n    }\n};\n// src/core/Initializable.js\nvar Initializable = class {\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - A renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {}\n};\n// src/core/OverrideMaterialManager.js\n\nvar workaroundEnabled = false;\nvar OverrideMaterialManager = class {\n    /**\n   * Constructs a new override material manager.\n   *\n   * @param {Material} [material=null] - An override material.\n   */ constructor(material = null){\n        this.originalMaterials = /* @__PURE__ */ new Map();\n        this.material = null;\n        this.materials = null;\n        this.materialsBackSide = null;\n        this.materialsDoubleSide = null;\n        this.materialsFlatShaded = null;\n        this.materialsFlatShadedBackSide = null;\n        this.materialsFlatShadedDoubleSide = null;\n        this.setMaterial(material);\n        this.meshCount = 0;\n        this.replaceMaterial = (node)=>{\n            if (node.isMesh) {\n                let materials;\n                if (node.material.flatShading) {\n                    switch(node.material.side){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n                            materials = this.materialsFlatShadedDoubleSide;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n                            materials = this.materialsFlatShadedBackSide;\n                            break;\n                        default:\n                            materials = this.materialsFlatShaded;\n                            break;\n                    }\n                } else {\n                    switch(node.material.side){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide:\n                            materials = this.materialsDoubleSide;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.BackSide:\n                            materials = this.materialsBackSide;\n                            break;\n                        default:\n                            materials = this.materials;\n                            break;\n                    }\n                }\n                this.originalMaterials.set(node, node.material);\n                if (node.isSkinnedMesh) {\n                    node.material = materials[2];\n                } else if (node.isInstancedMesh) {\n                    node.material = materials[1];\n                } else {\n                    node.material = materials[0];\n                }\n                ++this.meshCount;\n            }\n        };\n    }\n    /**\n   * Clones the given material.\n   *\n   * @private\n   * @param {Material} material - The material.\n   * @return {Material} The cloned material.\n   */ cloneMaterial(material) {\n        if (!(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial)) {\n            return material.clone();\n        }\n        const uniforms = material.uniforms;\n        const textureUniforms = /* @__PURE__ */ new Map();\n        for(const key in uniforms){\n            const value = uniforms[key].value;\n            if (value.isRenderTargetTexture) {\n                uniforms[key].value = null;\n                textureUniforms.set(key, value);\n            }\n        }\n        const clone = material.clone();\n        for (const entry of textureUniforms){\n            uniforms[entry[0]].value = entry[1];\n            clone.uniforms[entry[0]].value = entry[1];\n        }\n        return clone;\n    }\n    /**\n   * Sets the override material.\n   *\n   * @param {Material} material - The material.\n   */ setMaterial(material) {\n        this.disposeMaterials();\n        this.material = material;\n        if (material !== null) {\n            const materials = this.materials = [\n                this.cloneMaterial(material),\n                this.cloneMaterial(material),\n                this.cloneMaterial(material)\n            ];\n            for (const m2 of materials){\n                m2.uniforms = Object.assign({}, material.uniforms);\n                m2.side = three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n            }\n            materials[2].skinning = true;\n            this.materialsBackSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n                return c2;\n            });\n            this.materialsDoubleSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n                return c2;\n            });\n            this.materialsFlatShaded = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                return c2;\n            });\n            this.materialsFlatShadedBackSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.BackSide;\n                return c2;\n            });\n            this.materialsFlatShadedDoubleSide = materials.map((m2)=>{\n                const c2 = this.cloneMaterial(m2);\n                c2.uniforms = Object.assign({}, material.uniforms);\n                c2.flatShading = true;\n                c2.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n                return c2;\n            });\n        }\n    }\n    /**\n   * Renders the scene with the override material.\n   *\n   * @private\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Scene} scene - A scene.\n   * @param {Camera} camera - A camera.\n   */ render(renderer, scene, camera) {\n        const shadowMapEnabled = renderer.shadowMap.enabled;\n        renderer.shadowMap.enabled = false;\n        if (workaroundEnabled) {\n            const originalMaterials = this.originalMaterials;\n            this.meshCount = 0;\n            scene.traverse(this.replaceMaterial);\n            renderer.render(scene, camera);\n            for (const entry of originalMaterials){\n                entry[0].material = entry[1];\n            }\n            if (this.meshCount !== originalMaterials.size) {\n                originalMaterials.clear();\n            }\n        } else {\n            const overrideMaterial = scene.overrideMaterial;\n            scene.overrideMaterial = this.material;\n            renderer.render(scene, camera);\n            scene.overrideMaterial = overrideMaterial;\n        }\n        renderer.shadowMap.enabled = shadowMapEnabled;\n    }\n    /**\n   * Deletes cloned override materials.\n   *\n   * @private\n   */ disposeMaterials() {\n        if (this.material !== null) {\n            const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);\n            for (const m2 of materials){\n                m2.dispose();\n            }\n        }\n    }\n    /**\n   * Performs cleanup tasks.\n   */ dispose() {\n        this.originalMaterials.clear();\n        this.disposeMaterials();\n    }\n    /**\n   * Indicates whether the override material workaround is enabled.\n   *\n   * @type {Boolean}\n   */ static get workaroundEnabled() {\n        return workaroundEnabled;\n    }\n    /**\n   * Enables or disables the override material workaround globally.\n   *\n   * This only affects post processing passes and effects.\n   *\n   * @type {Boolean}\n   */ static set workaroundEnabled(value) {\n        workaroundEnabled = value;\n    }\n};\n// src/core/Resizable.js\nvar Resizable = class {\n    /**\n   * Sets the size of this object.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n};\n// src/core/Resolution.js\n\nvar AUTO_SIZE = -1;\nvar Resolution = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new resolution.\n   *\n   * TODO Remove resizable param.\n   * @param {Resizable} resizable - A resizable object.\n   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.\n   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.\n   * @param {Number} [scale=1.0] - A resolution scale.\n   */ constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1){\n        super();\n        this.resizable = resizable;\n        this.baseSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n        this.preferredSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(width, height);\n        this.target = this.preferredSize;\n        this.s = scale;\n        this.effectiveSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.addEventListener(\"change\", ()=>this.updateEffectiveSize());\n        this.updateEffectiveSize();\n    }\n    /**\n   * Calculates the effective size.\n   *\n   * @private\n   */ updateEffectiveSize() {\n        const base = this.baseSize;\n        const preferred = this.preferredSize;\n        const effective = this.effectiveSize;\n        const scale = this.scale;\n        if (preferred.width !== AUTO_SIZE) {\n            effective.width = preferred.width;\n        } else if (preferred.height !== AUTO_SIZE) {\n            effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));\n        } else {\n            effective.width = Math.round(base.width * scale);\n        }\n        if (preferred.height !== AUTO_SIZE) {\n            effective.height = preferred.height;\n        } else if (preferred.width !== AUTO_SIZE) {\n            effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));\n        } else {\n            effective.height = Math.round(base.height * scale);\n        }\n    }\n    /**\n   * The effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @type {Number}\n   */ get width() {\n        return this.effectiveSize.width;\n    }\n    set width(value) {\n        this.preferredWidth = value;\n    }\n    /**\n   * The effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @type {Number}\n   */ get height() {\n        return this.effectiveSize.height;\n    }\n    set height(value) {\n        this.preferredHeight = value;\n    }\n    /**\n   * Returns the effective width.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.\n   *\n   * @deprecated Use width instead.\n   * @return {Number} The effective width.\n   */ getWidth() {\n        return this.width;\n    }\n    /**\n   * Returns the effective height.\n   *\n   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.\n   *\n   * @deprecated Use height instead.\n   * @return {Number} The effective height.\n   */ getHeight() {\n        return this.height;\n    }\n    /**\n   * The resolution scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.s;\n    }\n    set scale(value) {\n        if (this.s !== value) {\n            this.s = value;\n            this.preferredSize.setScalar(AUTO_SIZE);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The scale.\n   */ getScale() {\n        return this.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * The base width.\n   *\n   * @type {Number}\n   */ get baseWidth() {\n        return this.baseSize.width;\n    }\n    set baseWidth(value) {\n        if (this.baseSize.width !== value) {\n            this.baseSize.width = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @return {Number} The base width.\n   */ getBaseWidth() {\n        return this.baseWidth;\n    }\n    /**\n   * Sets the base width.\n   *\n   * @deprecated Use baseWidth instead.\n   * @param {Number} value - The width.\n   */ setBaseWidth(value) {\n        this.baseWidth = value;\n    }\n    /**\n   * The base height.\n   *\n   * @type {Number}\n   */ get baseHeight() {\n        return this.baseSize.height;\n    }\n    set baseHeight(value) {\n        if (this.baseSize.height !== value) {\n            this.baseSize.height = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @return {Number} The base height.\n   */ getBaseHeight() {\n        return this.baseHeight;\n    }\n    /**\n   * Sets the base height.\n   *\n   * @deprecated Use baseHeight instead.\n   * @param {Number} value - The height.\n   */ setBaseHeight(value) {\n        this.baseHeight = value;\n    }\n    /**\n   * Sets the base size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setBaseSize(width, height) {\n        if (this.baseSize.width !== width || this.baseSize.height !== height) {\n            this.baseSize.set(width, height);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * The preferred width.\n   *\n   * @type {Number}\n   */ get preferredWidth() {\n        return this.preferredSize.width;\n    }\n    set preferredWidth(value) {\n        if (this.preferredSize.width !== value) {\n            this.preferredSize.width = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the preferred width.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @return {Number} The preferred width.\n   */ getPreferredWidth() {\n        return this.preferredWidth;\n    }\n    /**\n   * Sets the preferred width.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.\n   *\n   * @deprecated Use preferredWidth instead.\n   * @param {Number} value - The width.\n   */ setPreferredWidth(value) {\n        this.preferredWidth = value;\n    }\n    /**\n   * The preferred height.\n   *\n   * @type {Number}\n   */ get preferredHeight() {\n        return this.preferredSize.height;\n    }\n    set preferredHeight(value) {\n        if (this.preferredSize.height !== value) {\n            this.preferredSize.height = value;\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Returns the preferred height.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @return {Number} The preferred height.\n   */ getPreferredHeight() {\n        return this.preferredHeight;\n    }\n    /**\n   * Sets the preferred height.\n   *\n   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.\n   *\n   * @deprecated Use preferredHeight instead.\n   * @param {Number} value - The height.\n   */ setPreferredHeight(value) {\n        this.preferredHeight = value;\n    }\n    /**\n   * Sets the preferred size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setPreferredSize(width, height) {\n        if (this.preferredSize.width !== width || this.preferredSize.height !== height) {\n            this.preferredSize.set(width, height);\n            this.dispatchEvent({\n                type: \"change\"\n            });\n            this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n        }\n    }\n    /**\n   * Copies the given resolution.\n   *\n   * @param {Resolution} resolution - The resolution.\n   */ copy(resolution) {\n        this.s = resolution.scale;\n        this.baseSize.set(resolution.baseWidth, resolution.baseHeight);\n        this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);\n        this.dispatchEvent({\n            type: \"change\"\n        });\n        this.resizable.setSize(this.baseSize.width, this.baseSize.height);\n    }\n    /**\n   * An auto sizing constant.\n   *\n   * Can be used to automatically calculate the width or height based on the original aspect ratio.\n   *\n   * @type {Number}\n   */ static get AUTO_SIZE() {\n        return AUTO_SIZE;\n    }\n};\n// src/core/Selection.js\nvar Selection = class extends Set {\n    /**\n   * Constructs a new selection.\n   *\n   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.\n   * @param {Number} [layer=10] - A dedicated render layer for selected objects.\n   */ constructor(iterable, layer = 10){\n        super();\n        this.l = layer;\n        this.exclusive = false;\n        if (iterable !== void 0) {\n            this.set(iterable);\n        }\n    }\n    /**\n   * The render layer for selected objects.\n   *\n   * @type {Number}\n   */ get layer() {\n        return this.l;\n    }\n    set layer(value) {\n        const currentLayer = this.l;\n        for (const object of this){\n            object.layers.disable(currentLayer);\n            object.layers.enable(value);\n        }\n        this.l = value;\n    }\n    /**\n   * Returns the current render layer for selected objects.\n   *\n   * The default layer is 10. If this collides with your own custom layers, please change it before rendering!\n   *\n   * @deprecated Use layer instead.\n   * @return {Number} The layer.\n   */ getLayer() {\n        return this.layer;\n    }\n    /**\n   * Sets the render layer for selected objects.\n   *\n   * The current selection will be updated accordingly.\n   *\n   * @deprecated Use layer instead.\n   * @param {Number} value - The layer. Range is [0, 31].\n   */ setLayer(value) {\n        this.layer = value;\n    }\n    /**\n   * Indicates whether objects that are added to this selection will be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @return {Number} Whether this selection is exclusive. Default is false.\n   */ isExclusive() {\n        return this.exclusive;\n    }\n    /**\n   * Controls whether objects that are added to this selection should be removed from all other layers.\n   *\n   * @deprecated Use exclusive instead.\n   * @param {Number} value - Whether this selection should be exclusive.\n   */ setExclusive(value) {\n        this.exclusive = value;\n    }\n    /**\n   * Clears this selection.\n   *\n   * @return {Selection} This selection.\n   */ clear() {\n        const layer = this.layer;\n        for (const object of this){\n            object.layers.disable(layer);\n        }\n        return super.clear();\n    }\n    /**\n   * Clears this selection and adds the given objects.\n   *\n   * @param {Iterable<Object3D>} objects - The objects that should be selected.\n   * @return {Selection} This selection.\n   */ set(objects) {\n        this.clear();\n        for (const object of objects){\n            this.add(object);\n        }\n        return this;\n    }\n    /**\n   * An alias for {@link has}.\n   *\n   * @param {Object3D} object - An object.\n   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.\n   * @deprecated Added for backward-compatibility.\n   */ indexOf(object) {\n        return this.has(object) ? 0 : -1;\n    }\n    /**\n   * Adds an object to this selection.\n   *\n   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.\n   *\n   * @param {Object3D} object - The object that should be selected.\n   * @return {Selection} This selection.\n   */ add(object) {\n        if (this.exclusive) {\n            object.layers.set(this.layer);\n        } else {\n            object.layers.enable(this.layer);\n        }\n        return super.add(object);\n    }\n    /**\n   * Removes an object from this selection.\n   *\n   * @param {Object3D} object - The object that should be deselected.\n   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.\n   */ delete(object) {\n        if (this.has(object)) {\n            object.layers.disable(this.layer);\n        }\n        return super.delete(object);\n    }\n    /**\n   * Removes an existing object from the selection. If the object doesn't exist it's added instead.\n   *\n   * @param {Object3D} object - The object.\n   * @return {Boolean} Returns true if the object is added, false otherwise.\n   */ toggle(object) {\n        let result;\n        if (this.has(object)) {\n            this.delete(object);\n            result = false;\n        } else {\n            this.add(object);\n            result = true;\n        }\n        return result;\n    }\n    /**\n   * Sets the visibility of all selected objects.\n   *\n   * This method enables or disables render layer 0 of all selected objects.\n   *\n   * @param {Boolean} visible - Whether the selected objects should be visible.\n   * @return {Selection} This selection.\n   */ setVisible(visible) {\n        for (const object of this){\n            if (visible) {\n                object.layers.enable(0);\n            } else {\n                object.layers.disable(0);\n            }\n        }\n        return this;\n    }\n};\n// src/effects/blending/BlendMode.js\n\n// src/effects/blending/glsl/add.frag\nvar add_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}\";\n// src/effects/blending/glsl/alpha.frag\nvar alpha_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}\";\n// src/effects/blending/glsl/average.frag\nvar average_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}\";\n// src/effects/blending/glsl/color.frag\nvar color_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n// src/effects/blending/glsl/color-burn.frag\nvar color_burn_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/color-dodge.frag\nvar color_dodge_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/darken.frag\nvar darken_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}\";\n// src/effects/blending/glsl/difference.frag\nvar difference_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}\";\n// src/effects/blending/glsl/divide.frag\nvar divide_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}\";\n// src/effects/blending/glsl/exclusion.frag\nvar exclusion_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}\";\n// src/effects/blending/glsl/hard-light.frag\nvar hard_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/hard-mix.frag\nvar hard_mix_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}\";\n// src/effects/blending/glsl/hue.frag\nvar hue_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n// src/effects/blending/glsl/invert.frag\nvar invert_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}\";\n// src/effects/blending/glsl/invert-rgb.frag\nvar invert_rgb_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}\";\n// src/effects/blending/glsl/lighten.frag\nvar lighten_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}\";\n// src/effects/blending/glsl/linear-burn.frag\nvar linear_burn_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}\";\n// src/effects/blending/glsl/linear-dodge.frag\nvar linear_dodge_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}\";\n// src/effects/blending/glsl/linear-light.frag\nvar linear_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}\";\n// src/effects/blending/glsl/luminosity.frag\nvar luminosity_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n// src/effects/blending/glsl/multiply.frag\nvar multiply_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}\";\n// src/effects/blending/glsl/negation.frag\nvar negation_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}\";\n// src/effects/blending/glsl/normal.frag\nvar normal_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}\";\n// src/effects/blending/glsl/overlay.frag\nvar overlay_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/pin-light.frag\nvar pin_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/reflect.frag\nvar reflect_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/saturation.frag\nvar saturation_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}\";\n// src/effects/blending/glsl/screen.frag\nvar screen_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}\";\n// src/effects/blending/glsl/soft-light.frag\nvar soft_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}\";\n// src/effects/blending/glsl/src.frag\nvar src_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}\";\n// src/effects/blending/glsl/subtract.frag\nvar subtract_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}\";\n// src/effects/blending/glsl/vivid-light.frag\nvar vivid_light_default = \"vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}\";\n// src/effects/blending/BlendMode.js\nvar blendFunctions = /* @__PURE__ */ new Map([\n    [\n        BlendFunction.ADD,\n        add_default\n    ],\n    [\n        BlendFunction.ALPHA,\n        alpha_default\n    ],\n    [\n        BlendFunction.AVERAGE,\n        average_default\n    ],\n    [\n        BlendFunction.COLOR,\n        color_default\n    ],\n    [\n        BlendFunction.COLOR_BURN,\n        color_burn_default\n    ],\n    [\n        BlendFunction.COLOR_DODGE,\n        color_dodge_default\n    ],\n    [\n        BlendFunction.DARKEN,\n        darken_default\n    ],\n    [\n        BlendFunction.DIFFERENCE,\n        difference_default\n    ],\n    [\n        BlendFunction.DIVIDE,\n        divide_default\n    ],\n    [\n        BlendFunction.DST,\n        null\n    ],\n    [\n        BlendFunction.EXCLUSION,\n        exclusion_default\n    ],\n    [\n        BlendFunction.HARD_LIGHT,\n        hard_light_default\n    ],\n    [\n        BlendFunction.HARD_MIX,\n        hard_mix_default\n    ],\n    [\n        BlendFunction.HUE,\n        hue_default\n    ],\n    [\n        BlendFunction.INVERT,\n        invert_default\n    ],\n    [\n        BlendFunction.INVERT_RGB,\n        invert_rgb_default\n    ],\n    [\n        BlendFunction.LIGHTEN,\n        lighten_default\n    ],\n    [\n        BlendFunction.LINEAR_BURN,\n        linear_burn_default\n    ],\n    [\n        BlendFunction.LINEAR_DODGE,\n        linear_dodge_default\n    ],\n    [\n        BlendFunction.LINEAR_LIGHT,\n        linear_light_default\n    ],\n    [\n        BlendFunction.LUMINOSITY,\n        luminosity_default\n    ],\n    [\n        BlendFunction.MULTIPLY,\n        multiply_default\n    ],\n    [\n        BlendFunction.NEGATION,\n        negation_default\n    ],\n    [\n        BlendFunction.NORMAL,\n        normal_default\n    ],\n    [\n        BlendFunction.OVERLAY,\n        overlay_default\n    ],\n    [\n        BlendFunction.PIN_LIGHT,\n        pin_light_default\n    ],\n    [\n        BlendFunction.REFLECT,\n        reflect_default\n    ],\n    [\n        BlendFunction.SATURATION,\n        saturation_default\n    ],\n    [\n        BlendFunction.SCREEN,\n        screen_default\n    ],\n    [\n        BlendFunction.SOFT_LIGHT,\n        soft_light_default\n    ],\n    [\n        BlendFunction.SRC,\n        src_default\n    ],\n    [\n        BlendFunction.SUBTRACT,\n        subtract_default\n    ],\n    [\n        BlendFunction.VIVID_LIGHT,\n        vivid_light_default\n    ]\n]);\nvar BlendMode = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new blend mode.\n   *\n   * @param {BlendFunction} blendFunction - The blend function.\n   * @param {Number} opacity - The opacity of the color that will be blended with the base color.\n   */ constructor(blendFunction, opacity = 1){\n        super();\n        this._blendFunction = blendFunction;\n        this.opacity = new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(opacity);\n    }\n    /**\n   * Returns the opacity.\n   *\n   * @return {Number} The opacity.\n   */ getOpacity() {\n        return this.opacity.value;\n    }\n    /**\n   * Sets the opacity.\n   *\n   * @param {Number} value - The opacity.\n   */ setOpacity(value) {\n        this.opacity.value = value;\n    }\n    /**\n   * The blend function.\n   *\n   * @type {BlendFunction}\n   */ get blendFunction() {\n        return this._blendFunction;\n    }\n    set blendFunction(value) {\n        this._blendFunction = value;\n        this.dispatchEvent({\n            type: \"change\"\n        });\n    }\n    /**\n   * Returns the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @return {BlendFunction} The blend function.\n   */ getBlendFunction() {\n        return this.blendFunction;\n    }\n    /**\n   * Sets the blend function.\n   *\n   * @deprecated Use blendFunction instead.\n   * @param {BlendFunction} value - The blend function.\n   */ setBlendFunction(value) {\n        this.blendFunction = value;\n    }\n    /**\n   * Returns the blend function shader code.\n   *\n   * @return {String} The blend function shader code.\n   */ getShaderCode() {\n        return blendFunctions.get(this.blendFunction);\n    }\n};\n// src/effects/BloomEffect.js\n\n// src/effects/Effect.js\n\nvar Effect = class extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    /**\n   * Constructs a new effect.\n   *\n   * @param {String} name - The name of this effect. Doesn't have to be unique.\n   * @param {String} fragmentShader - The fragment shader. This shader is required.\n   * @param {Object} [options] - Additional options.\n   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.\n   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.\n   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.\n   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.\n   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.\n   */ constructor(name, fragmentShader, { attributes = EffectAttribute.NONE, blendFunction = BlendFunction.NORMAL, defines = /* @__PURE__ */ new Map(), uniforms = /* @__PURE__ */ new Map(), extensions = null, vertexShader = null } = {}){\n        super();\n        this.name = name;\n        this.renderer = null;\n        this.attributes = attributes;\n        this.fragmentShader = fragmentShader;\n        this.vertexShader = vertexShader;\n        this.defines = defines;\n        this.uniforms = uniforms;\n        this.extensions = extensions;\n        this.blendMode = new BlendMode(blendFunction);\n        this.blendMode.addEventListener(\"change\", (event)=>this.setChanged());\n        this._inputColorSpace = LinearSRGBColorSpace;\n        this._outputColorSpace = NoColorSpace;\n    }\n    /**\n   * The input color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */ get inputColorSpace() {\n        return this._inputColorSpace;\n    }\n    /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */ set inputColorSpace(value) {\n        this._inputColorSpace = value;\n        this.setChanged();\n    }\n    /**\n   * The output color space.\n   *\n   * Should only be changed if this effect converts the input colors to a different color space.\n   *\n   * @type {ColorSpace}\n   * @experimental\n   */ get outputColorSpace() {\n        return this._outputColorSpace;\n    }\n    /**\n   * @type {ColorSpace}\n   * @protected\n   * @experimental\n   */ set outputColorSpace(value) {\n        this._outputColorSpace = value;\n        this.setChanged();\n    }\n    /**\n   * Sets the main scene.\n   *\n   * @type {Scene}\n   */ set mainScene(value) {}\n    /**\n   * Sets the main camera.\n   *\n   * @type {Camera}\n   */ set mainCamera(value) {}\n    /**\n   * Returns the name of this effect.\n   *\n   * @deprecated Use name instead.\n   * @return {String} The name.\n   */ getName() {\n        return this.name;\n    }\n    /**\n   * Sets the renderer.\n   *\n   * @deprecated\n   * @param {WebGLRenderer} renderer - The renderer.\n   */ setRenderer(renderer) {\n        this.renderer = renderer;\n    }\n    /**\n   * Returns the preprocessor macro definitions.\n   *\n   * @deprecated Use defines instead.\n   * @return {Map<String, String>} The extensions.\n   */ getDefines() {\n        return this.defines;\n    }\n    /**\n   * Returns the uniforms of this effect.\n   *\n   * @deprecated Use uniforms instead.\n   * @return {Map<String, Uniform>} The extensions.\n   */ getUniforms() {\n        return this.uniforms;\n    }\n    /**\n   * Returns the WebGL extensions that are required by this effect.\n   *\n   * @deprecated Use extensions instead.\n   * @return {Set<WebGLExtension>} The extensions.\n   */ getExtensions() {\n        return this.extensions;\n    }\n    /**\n   * Returns the blend mode.\n   *\n   * The result of this effect will be blended with the result of the previous effect using this blend mode.\n   *\n   * @deprecated Use blendMode instead.\n   * @return {BlendMode} The blend mode.\n   */ getBlendMode() {\n        return this.blendMode;\n    }\n    /**\n   * Returns the effect attributes.\n   *\n   * @return {EffectAttribute} The attributes.\n   */ getAttributes() {\n        return this.attributes;\n    }\n    /**\n   * Sets the effect attributes.\n   *\n   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes\n   * imply a higher priority.\n   *\n   * @protected\n   * @param {EffectAttribute} attributes - The attributes.\n   */ setAttributes(attributes) {\n        this.attributes = attributes;\n        this.setChanged();\n    }\n    /**\n   * Returns the fragment shader.\n   *\n   * @return {String} The fragment shader.\n   */ getFragmentShader() {\n        return this.fragmentShader;\n    }\n    /**\n   * Sets the fragment shader.\n   *\n   * @protected\n   * @param {String} fragmentShader - The fragment shader.\n   */ setFragmentShader(fragmentShader) {\n        this.fragmentShader = fragmentShader;\n        this.setChanged();\n    }\n    /**\n   * Returns the vertex shader.\n   *\n   * @return {String} The vertex shader.\n   */ getVertexShader() {\n        return this.vertexShader;\n    }\n    /**\n   * Sets the vertex shader.\n   *\n   * @protected\n   * @param {String} vertexShader - The vertex shader.\n   */ setVertexShader(vertexShader) {\n        this.vertexShader = vertexShader;\n        this.setChanged();\n    }\n    /**\n   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.\n   *\n   * Should be called after changing macros or extensions and after adding/removing uniforms.\n   *\n   * @protected\n   */ setChanged() {\n        this.dispatchEvent({\n            type: \"change\"\n        });\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * You may override this method if your effect requires direct access to the depth texture that is bound to the\n   * associated {@link EffectPass}.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {}\n    /**\n   * Updates this effect by performing supporting operations.\n   *\n   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the\n   * blend function is set to `SKIP`.\n   *\n   * You may override this method if you need to update custom uniforms or render additional off-screen textures.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {}\n    /**\n   * Updates the size of this effect.\n   *\n   * You may override this method if you want to be informed about the size of the backbuffer/canvas.\n   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {}\n    /**\n   * Performs initialization tasks.\n   *\n   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }\n   */ initialize(renderer, alpha, frameBufferType) {}\n    /**\n   * Performs a shallow search for properties that define a dispose method and deletes them.\n   *\n   * The {@link EffectComposer} calls this method when it is being destroyed.\n   */ dispose() {\n        for (const key of Object.keys(this)){\n            const property = this[key];\n            const isDisposable = property instanceof three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || property instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture || property instanceof Pass;\n            if (isDisposable) {\n                this[key].dispose();\n            }\n        }\n    }\n};\n// src/effects/glsl/bloom.frag\nvar bloom_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}\";\n// src/effects/BloomEffect.js\nvar BloomEffect = class extends Effect {\n    /**\n   * Constructs a new bloom effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.\n   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.\n   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.\n   * @param {Number} [options.intensity=1.0] - The bloom intensity.\n   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.\n   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.\n   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.\n   */ constructor({ blendFunction = BlendFunction.SCREEN, luminanceThreshold = 0.9, luminanceSmoothing = 0.025, mipmapBlur = false, intensity = 1, radius = 0.85, levels = 8, kernelSize = KernelSize.LARGE, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"BloomEffect\", bloom_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"intensity\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)\n                ]\n            ])\n        });\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"Bloom.Target\";\n        this.blurPass = new KawaseBlurPass({\n            kernelSize\n        });\n        this.luminancePass = new LuminancePass({\n            colorOutput: true\n        });\n        this.luminanceMaterial.threshold = luminanceThreshold;\n        this.luminanceMaterial.smoothing = luminanceSmoothing;\n        this.mipmapBlurPass = new MipmapBlurPass();\n        this.mipmapBlurPass.enabled = mipmapBlur;\n        this.mipmapBlurPass.radius = radius;\n        this.mipmapBlurPass.levels = levels;\n        this.uniforms.get(\"map\").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;\n    }\n    /**\n   * Returns the generated bloom texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Returns the blur pass.\n   *\n   * @deprecated\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the luminance pass.\n   *\n   * @deprecated Use luminancePass instead.\n   * @return {LuminancePass} The luminance pass.\n   */ getLuminancePass() {\n        return this.luminancePass;\n    }\n    /**\n   * The luminance material.\n   *\n   * @type {LuminanceMaterial}\n   */ get luminanceMaterial() {\n        return this.luminancePass.fullscreenMaterial;\n    }\n    /**\n   * Returns the luminance material.\n   *\n   * @deprecated Use luminanceMaterial instead.\n   * @return {LuminanceMaterial} The material.\n   */ getLuminanceMaterial() {\n        return this.luminancePass.fullscreenMaterial;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use EffectPass.dithering instead.\n   */ get dithering() {\n        return this.blurPass.dithering;\n    }\n    set dithering(value) {\n        this.blurPass.dithering = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * @type {Number}\n   * @deprecated\n   */ get distinction() {\n        console.warn(this.name, \"distinction was removed\");\n        return 1;\n    }\n    set distinction(value) {\n        console.warn(this.name, \"distinction was removed\");\n    }\n    /**\n   * The bloom intensity.\n   *\n   * @type {Number}\n   */ get intensity() {\n        return this.uniforms.get(\"intensity\").value;\n    }\n    set intensity(value) {\n        this.uniforms.get(\"intensity\").value = value;\n    }\n    /**\n   * The bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.intensity;\n    }\n    /**\n   * Sets the bloom intensity.\n   *\n   * @deprecated Use intensity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.intensity = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        const luminancePass = this.luminancePass;\n        if (luminancePass.enabled) {\n            luminancePass.render(renderer, inputBuffer);\n            if (this.mipmapBlurPass.enabled) {\n                this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);\n            } else {\n                this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);\n            }\n        } else {\n            if (this.mipmapBlurPass.enabled) {\n                this.mipmapBlurPass.render(renderer, inputBuffer);\n            } else {\n                this.blurPass.render(renderer, inputBuffer, renderTarget);\n            }\n        }\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.blurPass.resolution.copy(resolution);\n        this.luminancePass.setSize(width, height);\n        this.mipmapBlurPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        this.luminancePass.initialize(renderer, alpha, frameBufferType);\n        this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/effects/BokehEffect.js\n\n// src/effects/glsl/bokeh.frag\nvar bokeh_default = \"uniform float focus;uniform float dof;uniform float aperture;uniform float maxBlur;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec2 aspectCorrection=vec2(1.0,aspect);\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\nfloat focusNear=clamp(focus-dof,0.0,1.0);float focusFar=clamp(focus+dof,0.0,1.0);float low=step(linearDepth,focusNear);float high=step(focusFar,linearDepth);float factor=(linearDepth-focusNear)*low+(linearDepth-focusFar)*high;vec2 dofBlur=vec2(clamp(factor*aperture,-maxBlur,maxBlur));vec2 dofblur9=dofBlur*0.9;vec2 dofblur7=dofBlur*0.7;vec2 dofblur4=dofBlur*0.4;vec4 color=inputColor;color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofBlur);color+=texture2D(inputBuffer,uv+(vec2(0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.15,0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.37,0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(-0.37,-0.15)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.15,-0.37)*aspectCorrection)*dofblur9);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.40,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur7);color+=texture2D(inputBuffer,uv+(vec2(0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,-0.4)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.4,0.0)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(-0.29,-0.29)*aspectCorrection)*dofblur4);color+=texture2D(inputBuffer,uv+(vec2(0.0,0.4)*aspectCorrection)*dofblur4);outputColor=color/41.0;}\";\n// src/effects/BokehEffect.js\nvar BokehEffect = class extends Effect {\n    /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=0.5] - The focus distance ratio, ranging from 0.0 to 1.0.\n   * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focal point that still appears sharp.\n   * @param {Number} [options.aperture=0.015] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   */ constructor({ blendFunction, focus = 0.5, dof = 0.02, aperture = 0.015, maxBlur = 1 } = {}){\n        super(\"BokehEffect\", bokeh_default, {\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"focus\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)\n                ],\n                [\n                    \"dof\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(dof)\n                ],\n                [\n                    \"aperture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(aperture)\n                ],\n                [\n                    \"maxBlur\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)\n                ]\n            ])\n        });\n    }\n};\n// src/effects/BrightnessContrastEffect.js\n\n// src/effects/glsl/brightness-contrast.frag\nvar brightness_contrast_default = \"uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}\";\n// src/effects/BrightnessContrastEffect.js\nvar BrightnessContrastEffect = class extends Effect {\n    /**\n   * Constructs a new brightness/contrast effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.brightness=0.0] - The brightness factor, ranging from -1 to 1, where 0 means no change.\n   * @param {Number} [options.contrast=0.0] - The contrast factor, ranging from -1 to 1, where 0 means no change.\n   */ constructor({ blendFunction = BlendFunction.SRC, brightness = 0, contrast = 0 } = {}){\n        super(\"BrightnessContrastEffect\", brightness_contrast_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"brightness\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(brightness)\n                ],\n                [\n                    \"contrast\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(contrast)\n                ]\n            ])\n        });\n        this.inputColorSpace = SRGBColorSpace;\n    }\n    /**\n   * The brightness.\n   *\n   * @type {Number}\n   */ get brightness() {\n        return this.uniforms.get(\"brightness\").value;\n    }\n    set brightness(value) {\n        this.uniforms.get(\"brightness\").value = value;\n    }\n    /**\n   * Returns the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @return {Number} The brightness.\n   */ getBrightness() {\n        return this.brightness;\n    }\n    /**\n   * Sets the brightness.\n   *\n   * @deprecated Use brightness instead.\n   * @param {Number} value - The brightness.\n   */ setBrightness(value) {\n        this.brightness = value;\n    }\n    /**\n   * The contrast.\n   *\n   * @type {Number}\n   */ get contrast() {\n        return this.uniforms.get(\"contrast\").value;\n    }\n    set contrast(value) {\n        this.uniforms.get(\"contrast\").value = value;\n    }\n    /**\n   * Returns the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @return {Number} The contrast.\n   */ getContrast() {\n        return this.contrast;\n    }\n    /**\n   * Sets the contrast.\n   *\n   * @deprecated Use contrast instead.\n   * @param {Number} value - The contrast.\n   */ setContrast(value) {\n        this.contrast = value;\n    }\n};\n// src/effects/glsl/color-average.frag\nvar color_average_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}\";\n// src/effects/ColorAverageEffect.js\nvar ColorAverageEffect = class extends Effect {\n    /**\n   * Constructs a new color average effect.\n   *\n   * @param {BlendFunction} [blendFunction] - The blend function of this effect.\n   */ constructor(blendFunction){\n        super(\"ColorAverageEffect\", color_average_default, {\n            blendFunction\n        });\n    }\n};\n// src/effects/ColorDepthEffect.js\n\n// src/effects/glsl/color-depth.frag\nvar color_depth_default = \"uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}\";\n// src/effects/ColorDepthEffect.js\nvar ColorDepthEffect = class extends Effect {\n    /**\n   * Constructs a new color depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.bits=16] - The color bit depth.\n   */ constructor({ blendFunction, bits = 16 } = {}){\n        super(\"ColorDepthEffect\", color_depth_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"factor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ]\n            ])\n        });\n        this.bits = 0;\n        this.bitDepth = bits;\n    }\n    /**\n   * The virtual amount of color bits.\n   *\n   * Each color channel effectively uses a fourth of the total amount of bits. Alpha remains unaffected.\n   *\n   * @type {Number}\n   */ get bitDepth() {\n        return this.bits;\n    }\n    set bitDepth(value) {\n        this.bits = value;\n        this.uniforms.get(\"factor\").value = Math.pow(2, value / 3);\n    }\n    /**\n   * Returns the current color bit depth.\n   *\n   * @return {Number} The bit depth.\n   */ getBitDepth() {\n        return this.bitDepth;\n    }\n    /**\n   * Sets the virtual amount of color bits.\n   *\n   * @param {Number} value - The bit depth.\n   */ setBitDepth(value) {\n        this.bitDepth = value;\n    }\n};\n// src/effects/ChromaticAberrationEffect.js\n\n// src/effects/glsl/chromatic-aberration.frag\nvar chromatic_aberration_default = \"#ifdef RADIAL_MODULATION\\nuniform float modulationOffset;\\n#endif\\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\\n#ifdef RADIAL_MODULATION\\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\\n#else\\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\\n#endif\\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}\";\n// src/effects/glsl/chromatic-aberration.vert\nvar chromatic_aberration_default2 = \"uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}\";\n// src/effects/ChromaticAberrationEffect.js\nvar ChromaticAberrationEffect = class extends Effect {\n    /**\n   * Constructs a new chromatic aberration effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.offset] - The color offset.\n   * @param {Boolean} [options.radialModulation=false] - Whether the effect should be modulated with a radial gradient.\n   * @param {Number} [options.modulationOffset=0.15] - The modulation offset. Only applies if `radialModulation` is enabled.\n   */ constructor({ offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1e-3, 5e-4), radialModulation = false, modulationOffset = 0.15 } = {}){\n        super(\"ChromaticAberrationEffect\", chromatic_aberration_default, {\n            vertexShader: chromatic_aberration_default2,\n            attributes: EffectAttribute.CONVOLUTION,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)\n                ],\n                [\n                    \"modulationOffset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(modulationOffset)\n                ]\n            ])\n        });\n        this.radialModulation = radialModulation;\n    }\n    /**\n   * The color offset.\n   *\n   * @type {Vector2}\n   */ get offset() {\n        return this.uniforms.get(\"offset\").value;\n    }\n    set offset(value) {\n        this.uniforms.get(\"offset\").value = value;\n    }\n    /**\n   * Indicates whether radial modulation is enabled.\n   *\n   * When enabled, the effect will be weaker in the middle and stronger towards the screen edges.\n   *\n   * @type {Boolean}\n   */ get radialModulation() {\n        return this.defines.has(\"RADIAL_MODULATION\");\n    }\n    set radialModulation(value) {\n        if (value) {\n            this.defines.set(\"RADIAL_MODULATION\", \"1\");\n        } else {\n            this.defines.delete(\"RADIAL_MODULATION\");\n        }\n        this.setChanged();\n    }\n    /**\n   * The modulation offset.\n   *\n   * @type {Number}\n   */ get modulationOffset() {\n        return this.uniforms.get(\"modulationOffset\").value;\n    }\n    set modulationOffset(value) {\n        this.uniforms.get(\"modulationOffset\").value = value;\n    }\n    /**\n   * Returns the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @return {Vector2} The offset.\n   */ getOffset() {\n        return this.offset;\n    }\n    /**\n   * Sets the color offset vector.\n   *\n   * @deprecated Use offset instead.\n   * @param {Vector2} value - The offset.\n   */ setOffset(value) {\n        this.offset = value;\n    }\n};\n// src/effects/glsl/depth.frag\nvar depth_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\\n#ifdef INVERTED\\nvec3 color=vec3(1.0-depth);\\n#else\\nvec3 color=vec3(depth);\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n// src/effects/DepthEffect.js\nvar DepthEffect = class extends Effect {\n    /**\n   * Constructs a new depth effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.inverted=false] - Whether the depth should be inverted.\n   */ constructor({ blendFunction = BlendFunction.SRC, inverted = false } = {}){\n        super(\"DepthEffect\", depth_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH\n        });\n        this.inverted = inverted;\n    }\n    /**\n   * Indicates whether depth should be inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this.defines.has(\"INVERTED\");\n    }\n    set inverted(value) {\n        if (this.inverted !== value) {\n            if (value) {\n                this.defines.set(\"INVERTED\", \"1\");\n            } else {\n                this.defines.delete(\"INVERTED\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the rendered depth is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the rendered depth is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disables depth inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether depth should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n};\n// src/effects/DepthOfFieldEffect.js\n\n// src/effects/glsl/depth-of-field.frag\nvar depth_of_field_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\\n#else\\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\\n#endif\\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\\n#if MASK_FUNCTION == 1\\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\\n#else\\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\\n#endif\\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}\";\n// src/effects/DepthOfFieldEffect.js\nvar DepthOfFieldEffect = class extends Effect {\n    /**\n   * Constructs a new depth of field effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.worldFocusDistance] - The focus distance in world units.\n   * @param {Number} [options.worldFocusRange] - The focus distance in world units.\n   * @param {Number} [options.focusDistance=0.0] - The normalized focus distance. Range is [0.0, 1.0].\n   * @param {Number} [options.focusRange=0.1] - The focus range. Range is [0.0, 1.0].\n   * @param {Number} [options.focalLength=0.1] - Deprecated.\n   * @param {Number} [options.bokehScale=1.0] - The scale of the bokeh blur.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(camera, { blendFunction, worldFocusDistance, worldFocusRange, focusDistance = 0, focalLength = 0.1, focusRange = focalLength, bokehScale = 1, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"DepthOfFieldEffect\", depth_of_field_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"nearColorBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"farColorBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"nearCoCBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"farCoCBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ]\n            ])\n        });\n        this.camera = camera;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"DoF.Intermediate\";\n        this.renderTargetMasked = this.renderTarget.clone();\n        this.renderTargetMasked.texture.name = \"DoF.Masked.Far\";\n        this.renderTargetNear = this.renderTarget.clone();\n        this.renderTargetNear.texture.name = \"DoF.Bokeh.Near\";\n        this.uniforms.get(\"nearColorBuffer\").value = this.renderTargetNear.texture;\n        this.renderTargetFar = this.renderTarget.clone();\n        this.renderTargetFar.texture.name = \"DoF.Bokeh.Far\";\n        this.uniforms.get(\"farColorBuffer\").value = this.renderTargetFar.texture;\n        this.renderTargetCoC = this.renderTarget.clone();\n        this.renderTargetCoC.texture.name = \"DoF.CoC\";\n        this.uniforms.get(\"farCoCBuffer\").value = this.renderTargetCoC.texture;\n        this.renderTargetCoCBlurred = this.renderTargetCoC.clone();\n        this.renderTargetCoCBlurred.texture.name = \"DoF.CoC.Blurred\";\n        this.uniforms.get(\"nearCoCBuffer\").value = this.renderTargetCoCBlurred.texture;\n        this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));\n        const cocMaterial = this.cocMaterial;\n        cocMaterial.focusDistance = focusDistance;\n        cocMaterial.focusRange = focusRange;\n        if (worldFocusDistance !== void 0) {\n            cocMaterial.worldFocusDistance = worldFocusDistance;\n        }\n        if (worldFocusRange !== void 0) {\n            cocMaterial.worldFocusRange = worldFocusRange;\n        }\n        this.blurPass = new KawaseBlurPass({\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            kernelSize: KernelSize.MEDIUM\n        });\n        this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture));\n        const maskMaterial = this.maskPass.fullscreenMaterial;\n        maskMaterial.colorChannel = ColorChannel.GREEN;\n        this.maskFunction = MaskFunction.MULTIPLY_RGB;\n        this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true));\n        this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n        this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true));\n        this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture;\n        this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false));\n        this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n        this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false));\n        this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture;\n        this.target = null;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.bokehScale = bokehScale;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.cocMaterial.copyCameraSettings(value);\n    }\n    /**\n   * The circle of confusion texture.\n   *\n   * @type {Texture}\n   */ get cocTexture() {\n        return this.renderTargetCoC.texture;\n    }\n    /**\n   * The mask function. Default is `MULTIPLY_RGB`.\n   *\n   * @type {MaskFunction}\n   */ get maskFunction() {\n        return this.maskPass.fullscreenMaterial.maskFunction;\n    }\n    set maskFunction(value) {\n        if (this.maskFunction !== value) {\n            this.defines.set(\"MASK_FUNCTION\", value.toFixed(0));\n            this.maskPass.fullscreenMaterial.maskFunction = value;\n            this.setChanged();\n        }\n    }\n    /**\n   * The circle of confusion material.\n   *\n   * @type {CircleOfConfusionMaterial}\n   */ get cocMaterial() {\n        return this.cocPass.fullscreenMaterial;\n    }\n    /**\n   * The circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @type {CircleOfConfusionMaterial}\n   */ get circleOfConfusionMaterial() {\n        return this.cocMaterial;\n    }\n    /**\n   * Returns the circle of confusion material.\n   *\n   * @deprecated Use cocMaterial instead.\n   * @return {CircleOfConfusionMaterial} The material.\n   */ getCircleOfConfusionMaterial() {\n        return this.cocMaterial;\n    }\n    /**\n   * Returns the pass that blurs the foreground CoC buffer to soften edges.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The current bokeh scale.\n   *\n   * @type {Number}\n   */ get bokehScale() {\n        return this.uniforms.get(\"scale\").value;\n    }\n    set bokehScale(value) {\n        this.bokehNearBasePass.fullscreenMaterial.scale = value;\n        this.bokehNearFillPass.fullscreenMaterial.scale = value;\n        this.bokehFarBasePass.fullscreenMaterial.scale = value;\n        this.bokehFarFillPass.fullscreenMaterial.scale = value;\n        this.maskPass.fullscreenMaterial.strength = value;\n        this.uniforms.get(\"scale\").value = value;\n    }\n    /**\n   * Returns the current bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @return {Number} The scale.\n   */ getBokehScale() {\n        return this.bokehScale;\n    }\n    /**\n   * Sets the bokeh scale.\n   *\n   * @deprecated Use bokehScale instead.\n   * @param {Number} value - The scale.\n   */ setBokehScale(value) {\n        this.bokehScale = value;\n    }\n    /**\n   * Returns the current auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @return {Vector3} The target.\n   */ getTarget() {\n        return this.target;\n    }\n    /**\n   * Sets the auto focus target.\n   *\n   * @deprecated Use target instead.\n   * @param {Vector3} value - The target.\n   */ setTarget(value) {\n        this.target = value;\n    }\n    /**\n   * Calculates the focus distance from the camera to the given position.\n   *\n   * @param {Vector3} target - The target.\n   * @return {Number} The normalized focus distance.\n   */ calculateFocusDistance(target) {\n        const camera = this.camera;\n        const distance = camera.position.distanceTo(target);\n        return viewZToOrthographicDepth(-distance, camera.near, camera.far);\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.cocMaterial.depthBuffer = depthTexture;\n        this.cocMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        const renderTargetCoC = this.renderTargetCoC;\n        const renderTargetCoCBlurred = this.renderTargetCoCBlurred;\n        const renderTargetMasked = this.renderTargetMasked;\n        if (this.target !== null) {\n            const distance = this.calculateFocusDistance(this.target);\n            this.cocMaterial.focusDistance = distance;\n        }\n        this.cocPass.render(renderer, null, renderTargetCoC);\n        this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCBlurred);\n        this.maskPass.render(renderer, inputBuffer, renderTargetMasked);\n        this.bokehFarBasePass.render(renderer, renderTargetMasked, renderTarget);\n        this.bokehFarFillPass.render(renderer, renderTarget, this.renderTargetFar);\n        this.bokehNearBasePass.render(renderer, inputBuffer, renderTarget);\n        this.bokehNearFillPass.render(renderer, renderTarget, this.renderTargetNear);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.cocPass.setSize(width, height);\n        this.blurPass.setSize(width, height);\n        this.maskPass.setSize(width, height);\n        this.renderTargetFar.setSize(width, height);\n        this.renderTargetCoC.setSize(width, height);\n        this.renderTargetMasked.setSize(width, height);\n        this.renderTarget.setSize(w, h);\n        this.renderTargetNear.setSize(w, h);\n        this.renderTargetCoCBlurred.setSize(w, h);\n        this.bokehNearBasePass.fullscreenMaterial.setSize(width, height);\n        this.bokehNearFillPass.fullscreenMaterial.setSize(width, height);\n        this.bokehFarBasePass.fullscreenMaterial.setSize(width, height);\n        this.bokehFarFillPass.fullscreenMaterial.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.cocPass.initialize(renderer, alpha, frameBufferType);\n        this.maskPass.initialize(renderer, alpha, frameBufferType);\n        this.bokehNearBasePass.initialize(renderer, alpha, frameBufferType);\n        this.bokehNearFillPass.initialize(renderer, alpha, frameBufferType);\n        this.bokehFarBasePass.initialize(renderer, alpha, frameBufferType);\n        this.bokehFarFillPass.initialize(renderer, alpha, frameBufferType);\n        this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n        if (renderer.capabilities.logarithmicDepthBuffer) {\n            this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n        }\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            this.renderTargetNear.texture.type = frameBufferType;\n            this.renderTargetFar.texture.type = frameBufferType;\n            this.renderTargetMasked.texture.type = frameBufferType;\n            if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetNear.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetFar.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetMasked.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/effects/DotScreenEffect.js\n\n// src/effects/glsl/dot-screen.frag\nvar dot_screen_default = \"uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}\";\n// src/effects/DotScreenEffect.js\nvar DotScreenEffect = class extends Effect {\n    /**\n   * Constructs a new dot screen effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.angle=1.57] - The angle of the dot pattern.\n   * @param {Number} [options.scale=1.0] - The scale of the dot pattern.\n   */ constructor({ blendFunction, angle = Math.PI * 0.5, scale = 1 } = {}){\n        super(\"DotScreenEffect\", dot_screen_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"angle\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(scale)\n                ]\n            ])\n        });\n        this.angle = angle;\n    }\n    /**\n   * The angle.\n   *\n   * @type {Number}\n   */ get angle() {\n        return Math.acos(this.uniforms.get(\"angle\").value.y);\n    }\n    set angle(value) {\n        this.uniforms.get(\"angle\").value.set(Math.sin(value), Math.cos(value));\n    }\n    /**\n   * Returns the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @return {Number} The angle in radians.\n   */ getAngle() {\n        return this.angle;\n    }\n    /**\n   * Sets the pattern angle.\n   *\n   * @deprecated Use angle instead.\n   * @param {Number} value - The angle in radians.\n   */ setAngle(value) {\n        this.angle = value;\n    }\n    /**\n   * The scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.uniforms.get(\"scale\").value;\n    }\n    set scale(value) {\n        this.uniforms.get(\"scale\").value = value;\n    }\n};\n// src/effects/glsl/fxaa.frag\nvar fxaa_default = \"#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\\n#define ONE_OVER_TWELVE 0.08333333333333333\\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}\";\n// src/effects/glsl/fxaa.vert\nvar fxaa_default2 = \"varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}\";\n// src/effects/FXAAEffect.js\nvar FXAAEffect = class extends Effect {\n    /**\n   * Constructs a new FXAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */ constructor({ blendFunction = BlendFunction.SRC } = {}){\n        super(\"FXAAEffect\", fxaa_default, {\n            vertexShader: fxaa_default2,\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"EDGE_THRESHOLD_MIN\",\n                    \"0.0312\"\n                ],\n                [\n                    \"EDGE_THRESHOLD_MAX\",\n                    \"0.125\"\n                ],\n                [\n                    \"SUBPIXEL_QUALITY\",\n                    \"0.75\"\n                ],\n                [\n                    \"SAMPLES\",\n                    \"12\"\n                ]\n            ])\n        });\n    }\n    /**\n   * The minimum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get minEdgeThreshold() {\n        return Number(this.defines.get(\"EDGE_THRESHOLD_MIN\"));\n    }\n    set minEdgeThreshold(value) {\n        this.defines.set(\"EDGE_THRESHOLD_MIN\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The maximum edge detection threshold. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get maxEdgeThreshold() {\n        return Number(this.defines.get(\"EDGE_THRESHOLD_MAX\"));\n    }\n    set maxEdgeThreshold(value) {\n        this.defines.set(\"EDGE_THRESHOLD_MAX\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The subpixel blend quality. Range is [0.0, 1.0].\n   *\n   * @type {Number}\n   */ get subpixelQuality() {\n        return Number(this.defines.get(\"SUBPIXEL_QUALITY\"));\n    }\n    set subpixelQuality(value) {\n        this.defines.set(\"SUBPIXEL_QUALITY\", value.toFixed(12));\n        this.setChanged();\n    }\n    /**\n   * The maximum amount of edge detection samples.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number(this.defines.get(\"SAMPLES\"));\n    }\n    set samples(value) {\n        this.defines.set(\"SAMPLES\", value.toFixed(0));\n        this.setChanged();\n    }\n};\n// src/effects/GammaCorrectionEffect.js\n\n// src/effects/glsl/gamma-correction.frag\nvar gamma_correction_default = \"uniform float gamma;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=LinearToGamma(max(inputColor,0.0),gamma);}\";\n// src/effects/GammaCorrectionEffect.js\nvar GammaCorrectionEffect = class extends Effect {\n    /**\n   * Constructs a new gamma correction effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.gamma=2.0] - The gamma factor.\n   */ constructor({ blendFunction = BlendFunction.SRC, gamma = 2 } = {}){\n        super(\"GammaCorrectionEffect\", gamma_correction_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"gamma\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(gamma)\n                ]\n            ])\n        });\n    }\n};\n// src/effects/GlitchEffect.js\n\n// src/textures/lut/LookupTexture.js\n\n// src/textures/RawImageData.js\nfunction createCanvas(width, height, data) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    canvas.width = width;\n    canvas.height = height;\n    if (data instanceof Image) {\n        context.drawImage(data, 0, 0);\n    } else {\n        const imageData = context.createImageData(width, height);\n        imageData.data.set(data);\n        context.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n}\nvar RawImageData = class _RawImageData {\n    /**\n   * Constructs a new image data container.\n   *\n   * @param {Number} [width=0] - The width of the image.\n   * @param {Number} [height=0] - The height of the image.\n   * @param {Uint8ClampedArray} [data=null] - The image data.\n   */ constructor(width = 0, height = 0, data = null){\n        this.width = width;\n        this.height = height;\n        this.data = data;\n    }\n    /**\n   * Creates a canvas from this image data.\n   *\n   * @return {Canvas} The canvas, or null if it couldn't be created.\n   */ toCanvas() {\n        return typeof document === \"undefined\" ? null : createCanvas(this.width, this.height, this.data);\n    }\n    /**\n   * Creates a new image data container.\n   *\n   * @param {ImageData|Image} image - An image or plain image data.\n   * @return {RawImageData} The image data.\n   */ static from(image) {\n        const { width, height } = image;\n        let data;\n        if (image instanceof Image) {\n            const canvas = createCanvas(width, height, image);\n            if (canvas !== null) {\n                const context = canvas.getContext(\"2d\");\n                data = context.getImageData(0, 0, width, height).data;\n            }\n        } else {\n            data = image.data;\n        }\n        return new _RawImageData(width, height, data);\n    }\n};\n// tmp/lut/worker.txt\nvar worker_default = '\"use strict\";(()=>{var O={SCALE_UP:\"lut.scaleup\"};var _=[new Float32Array(3),new Float32Array(3)],n=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],Z=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function d(a,t,r,m){let i=r[0]-t[0],e=r[1]-t[1],y=r[2]-t[2],h=a[0]-t[0],A=a[1]-t[1],w=a[2]-t[2],c=e*w-y*A,l=y*h-i*w,x=i*A-e*h,u=Math.sqrt(c*c+l*l+x*x),b=u*.5,s=c/u,F=l/u,f=x/u,p=-(a[0]*s+a[1]*F+a[2]*f),M=m[0]*s+m[1]*F+m[2]*f;return Math.abs(M+p)*b/3}function V(a,t,r,m,i,e){let y=(r+m*t+i*t*t)*4;e[0]=a[y+0],e[1]=a[y+1],e[2]=a[y+2]}function k(a,t,r,m,i,e){let y=r*(t-1),h=m*(t-1),A=i*(t-1),w=Math.floor(y),c=Math.floor(h),l=Math.floor(A),x=Math.ceil(y),u=Math.ceil(h),b=Math.ceil(A),s=y-w,F=h-c,f=A-l;if(w===y&&c===h&&l===A)V(a,t,y,h,A,e);else{let p;s>=F&&F>=f?p=Z[0]:s>=f&&f>=F?p=Z[1]:f>=s&&s>=F?p=Z[2]:F>=s&&s>=f?p=Z[3]:F>=f&&f>=s?p=Z[4]:f>=F&&F>=s&&(p=Z[5]);let[M,g,X,Y]=p,P=_[0];P[0]=s,P[1]=F,P[2]=f;let o=_[1],L=x-w,S=u-c,U=b-l;o[0]=L*M[0]+w,o[1]=S*M[1]+c,o[2]=U*M[2]+l,V(a,t,o[0],o[1],o[2],n[0]),o[0]=L*g[0]+w,o[1]=S*g[1]+c,o[2]=U*g[2]+l,V(a,t,o[0],o[1],o[2],n[1]),o[0]=L*X[0]+w,o[1]=S*X[1]+c,o[2]=U*X[2]+l,V(a,t,o[0],o[1],o[2],n[2]),o[0]=L*Y[0]+w,o[1]=S*Y[1]+c,o[2]=U*Y[2]+l,V(a,t,o[0],o[1],o[2],n[3]);let T=d(g,X,Y,P)*6,q=d(M,X,Y,P)*6,C=d(M,g,Y,P)*6,E=d(M,g,X,P)*6;n[0][0]*=T,n[0][1]*=T,n[0][2]*=T,n[1][0]*=q,n[1][1]*=q,n[1][2]*=q,n[2][0]*=C,n[2][1]*=C,n[2][2]*=C,n[3][0]*=E,n[3][1]*=E,n[3][2]*=E,e[0]=n[0][0]+n[1][0]+n[2][0]+n[3][0],e[1]=n[0][1]+n[1][1]+n[2][1]+n[3][1],e[2]=n[0][2]+n[1][2]+n[2][2]+n[3][2]}}var v=class{static expand(t,r){let m=Math.cbrt(t.length/4),i=new Float32Array(3),e=new t.constructor(r**3*4),y=t instanceof Uint8Array?255:1,h=r**2,A=1/(r-1);for(let w=0;w<r;++w)for(let c=0;c<r;++c)for(let l=0;l<r;++l){let x=l*A,u=c*A,b=w*A,s=Math.round(l+c*r+w*h)*4;k(t,m,x,u,b,i),e[s+0]=i[0],e[s+1]=i[1],e[s+2]=i[2],e[s+3]=y}return e}};self.addEventListener(\"message\",a=>{let t=a.data,r=t.data;switch(t.operation){case O.SCALE_UP:r=v.expand(r,t.size);break}postMessage(r,[r.buffer]),close()});})();\\n';\n// src/textures/lut/LookupTexture.js\nvar c = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Color();\nvar LookupTexture = class _LookupTexture extends three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture {\n    /**\n   * Constructs a cubic 3D lookup texture.\n   *\n   * @param {TypedArray} data - The pixel data. The default format is RGBA.\n   * @param {Number} size - The sidelength.\n   */ constructor(data, size){\n        super(data, size, size, size);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n        this.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n        this.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        this.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        this.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.wrapR = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.unpackAlignment = 1;\n        this.needsUpdate = true;\n        setTextureColorSpace(this, LinearSRGBColorSpace);\n        this.domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    }\n    /**\n   * Indicates that this is an instance of LookupTexture3D.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get isLookupTexture3D() {\n        return true;\n    }\n    /**\n   * Scales this LUT up to a given target size using tetrahedral interpolation.\n   *\n   * @param {Number} size - The target sidelength.\n   * @param {Boolean} [transferData=true] - Extra fast mode. Set to false to keep the original data intact.\n   * @return {Promise<LookupTexture>} A promise that resolves with a new LUT upon completion.\n   */ scaleUp(size, transferData = true) {\n        const image = this.image;\n        let promise;\n        if (size <= image.width) {\n            promise = Promise.reject(new Error(\"The target size must be greater than the current size\"));\n        } else {\n            promise = new Promise((resolve, reject)=>{\n                const workerURL = URL.createObjectURL(new Blob([\n                    worker_default\n                ], {\n                    type: \"text/javascript\"\n                }));\n                const worker = new Worker(workerURL);\n                worker.addEventListener(\"error\", (event)=>reject(event.error));\n                worker.addEventListener(\"message\", (event)=>{\n                    const lut = new _LookupTexture(event.data, size);\n                    copyTextureColorSpace(this, lut);\n                    lut.type = this.type;\n                    lut.name = this.name;\n                    URL.revokeObjectURL(workerURL);\n                    resolve(lut);\n                });\n                const transferList = transferData ? [\n                    image.data.buffer\n                ] : [];\n                worker.postMessage({\n                    operation: LUTOperation.SCALE_UP,\n                    data: image.data,\n                    size\n                }, transferList);\n            });\n        }\n        return promise;\n    }\n    /**\n   * Applies the given LUT to this one.\n   *\n   * @param {LookupTexture} lut - A LUT. Must have the same dimensions, type and format as this LUT.\n   * @return {LookupTexture} This texture.\n   */ applyLUT(lut) {\n        const img0 = this.image;\n        const img1 = lut.image;\n        const size0 = Math.min(img0.width, img0.height, img0.depth);\n        const size1 = Math.min(img1.width, img1.height, img1.depth);\n        if (size0 !== size1) {\n            console.error(\"Size mismatch\");\n        } else if (lut.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType || this.type !== three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            console.error(\"Both LUTs must be FloatType textures\");\n        } else if (lut.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat || this.format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat) {\n            console.error(\"Both LUTs must be RGBA textures\");\n        } else {\n            const data0 = img0.data;\n            const data1 = img1.data;\n            const size = size0;\n            const sizeSq = size ** 2;\n            const s = size - 1;\n            for(let i = 0, l = size ** 3; i < l; ++i){\n                const i4 = i * 4;\n                const r = data0[i4 + 0] * s;\n                const g = data0[i4 + 1] * s;\n                const b = data0[i4 + 2] * s;\n                const iRGB = Math.round(r + g * size + b * sizeSq) * 4;\n                data0[i4 + 0] = data1[iRGB + 0];\n                data0[i4 + 1] = data1[iRGB + 1];\n                data0[i4 + 2] = data1[iRGB + 2];\n            }\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts the LUT data into unsigned byte data.\n   *\n   * This is a lossy operation which should only be performed after all other transformations have been applied.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertToUint8() {\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            const floatData = this.image.data;\n            const uint8Data = new Uint8Array(floatData.length);\n            for(let i = 0, l = floatData.length; i < l; ++i){\n                uint8Data[i] = floatData[i] * 255 + 0.5;\n            }\n            this.image.data = uint8Data;\n            this.type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts the LUT data into float data.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertToFloat() {\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n            const uint8Data = this.image.data;\n            const floatData = new Float32Array(uint8Data.length);\n            for(let i = 0, l = uint8Data.length; i < l; ++i){\n                floatData[i] = uint8Data[i] / 255;\n            }\n            this.image.data = floatData;\n            this.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            this.needsUpdate = true;\n        }\n        return this;\n    }\n    /**\n   * Converts this LUT into RGBA data.\n   *\n   * @deprecated LUTs are RGBA by default since three r137.\n   * @return {LookupTexture} This texture.\n   */ convertToRGBA() {\n        console.warn(\"LookupTexture\", \"convertToRGBA() is deprecated, LUTs are now RGBA by default\");\n        return this;\n    }\n    /**\n   * Converts the output of this LUT into sRGB color space.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertLinearToSRGB() {\n        const data = this.image.data;\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            for(let i = 0, l = data.length; i < l; i += 4){\n                c.fromArray(data, i).convertLinearToSRGB().toArray(data, i);\n            }\n            setTextureColorSpace(this, SRGBColorSpace);\n            this.needsUpdate = true;\n        } else {\n            console.error(\"Color space conversion requires FloatType data\");\n        }\n        return this;\n    }\n    /**\n   * Converts the output of this LUT into linear color space.\n   *\n   * @return {LookupTexture} This texture.\n   */ convertSRGBToLinear() {\n        const data = this.image.data;\n        if (this.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType) {\n            for(let i = 0, l = data.length; i < l; i += 4){\n                c.fromArray(data, i).convertSRGBToLinear().toArray(data, i);\n            }\n            setTextureColorSpace(this, LinearSRGBColorSpace);\n            this.needsUpdate = true;\n        } else {\n            console.error(\"Color space conversion requires FloatType data\");\n        }\n        return this;\n    }\n    /**\n   * Converts this LUT into a 2D data texture.\n   *\n   * Please note that custom input domains are not carried over to 2D textures.\n   *\n   * @return {DataTexture} The texture.\n   */ toDataTexture() {\n        const width = this.image.width;\n        const height = this.image.height * this.image.depth;\n        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(this.image.data, width, height);\n        texture.name = this.name;\n        texture.type = this.type;\n        texture.format = this.format;\n        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n        texture.wrapS = this.wrapS;\n        texture.wrapT = this.wrapT;\n        texture.generateMipmaps = false;\n        texture.needsUpdate = true;\n        copyTextureColorSpace(this, texture);\n        return texture;\n    }\n    /**\n   * Creates a new 3D LUT by copying a given LUT.\n   *\n   * Common image-based textures will be converted into 3D data textures.\n   *\n   * @param {Texture} texture - The LUT. Assumed to be cubic.\n   * @return {LookupTexture} A new 3D LUT.\n   */ static from(texture) {\n        const image = texture.image;\n        const { width, height } = image;\n        const size = Math.min(width, height);\n        let data;\n        if (image instanceof Image) {\n            const rawImageData = RawImageData.from(image);\n            const src = rawImageData.data;\n            if (width > height) {\n                data = new Uint8Array(src.length);\n                for(let z = 0; z < size; ++z){\n                    for(let y = 0; y < size; ++y){\n                        for(let x = 0; x < size; ++x){\n                            const i4 = (x + z * size + y * size * size) * 4;\n                            const j4 = (x + y * size + z * size * size) * 4;\n                            data[j4 + 0] = src[i4 + 0];\n                            data[j4 + 1] = src[i4 + 1];\n                            data[j4 + 2] = src[i4 + 2];\n                            data[j4 + 3] = src[i4 + 3];\n                        }\n                    }\n                }\n            } else {\n                data = new Uint8Array(src.buffer);\n            }\n        } else {\n            data = image.data.slice();\n        }\n        const lut = new _LookupTexture(data, size);\n        lut.type = texture.type;\n        lut.name = texture.name;\n        copyTextureColorSpace(texture, lut);\n        return lut;\n    }\n    /**\n   * Creates a neutral 3D LUT.\n   *\n   * @param {Number} size - The sidelength.\n   * @return {LookupTexture} A neutral 3D LUT.\n   */ static createNeutral(size) {\n        const data = new Float32Array(size ** 3 * 4);\n        const sizeSq = size ** 2;\n        const s = 1 / (size - 1);\n        for(let r = 0; r < size; ++r){\n            for(let g = 0; g < size; ++g){\n                for(let b = 0; b < size; ++b){\n                    const i4 = (r + g * size + b * sizeSq) * 4;\n                    data[i4 + 0] = r * s;\n                    data[i4 + 1] = g * s;\n                    data[i4 + 2] = b * s;\n                    data[i4 + 3] = 1;\n                }\n            }\n        }\n        const lut = new _LookupTexture(data, size);\n        lut.name = \"neutral\";\n        return lut;\n    }\n};\n// src/textures/lut/TetrahedralUpscaler.js\nvar P = [\n    new Float32Array(3),\n    new Float32Array(3)\n];\nvar C = [\n    new Float32Array(3),\n    new Float32Array(3),\n    new Float32Array(3),\n    new Float32Array(3)\n];\nvar T = [\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            0\n        ]),\n        new Float32Array([\n            1,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            0,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            0\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            0\n        ]),\n        new Float32Array([\n            0,\n            1,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        new Float32Array([\n            0,\n            0,\n            0\n        ]),\n        new Float32Array([\n            0,\n            0,\n            1\n        ]),\n        new Float32Array([\n            0,\n            1,\n            1\n        ]),\n        new Float32Array([\n            1,\n            1,\n            1\n        ])\n    ]\n];\nfunction calculateTetrahedronVolume(a, b, c2, d) {\n    const bcX = c2[0] - b[0];\n    const bcY = c2[1] - b[1];\n    const bcZ = c2[2] - b[2];\n    const baX = a[0] - b[0];\n    const baY = a[1] - b[1];\n    const baZ = a[2] - b[2];\n    const crossX = bcY * baZ - bcZ * baY;\n    const crossY = bcZ * baX - bcX * baZ;\n    const crossZ = bcX * baY - bcY * baX;\n    const length = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n    const triangleArea = length * 0.5;\n    const normalX = crossX / length;\n    const normalY = crossY / length;\n    const normalZ = crossZ / length;\n    const constant = -(a[0] * normalX + a[1] * normalY + a[2] * normalZ);\n    const dot = d[0] * normalX + d[1] * normalY + d[2] * normalZ;\n    const height = Math.abs(dot + constant);\n    return height * triangleArea / 3;\n}\nfunction sample(data, size, x, y, z, color2) {\n    const i4 = (x + y * size + z * size * size) * 4;\n    color2[0] = data[i4 + 0];\n    color2[1] = data[i4 + 1];\n    color2[2] = data[i4 + 2];\n}\nfunction tetrahedralSample(data, size, u, v3, w, color2) {\n    const px = u * (size - 1);\n    const py = v3 * (size - 1);\n    const pz = w * (size - 1);\n    const minX = Math.floor(px);\n    const minY = Math.floor(py);\n    const minZ = Math.floor(pz);\n    const maxX = Math.ceil(px);\n    const maxY = Math.ceil(py);\n    const maxZ = Math.ceil(pz);\n    const su = px - minX;\n    const sv = py - minY;\n    const sw = pz - minZ;\n    if (minX === px && minY === py && minZ === pz) {\n        sample(data, size, px, py, pz, color2);\n    } else {\n        let vertices;\n        if (su >= sv && sv >= sw) {\n            vertices = T[0];\n        } else if (su >= sw && sw >= sv) {\n            vertices = T[1];\n        } else if (sw >= su && su >= sv) {\n            vertices = T[2];\n        } else if (sv >= su && su >= sw) {\n            vertices = T[3];\n        } else if (sv >= sw && sw >= su) {\n            vertices = T[4];\n        } else if (sw >= sv && sv >= su) {\n            vertices = T[5];\n        }\n        const [P0, P1, P2, P3] = vertices;\n        const coords = P[0];\n        coords[0] = su;\n        coords[1] = sv;\n        coords[2] = sw;\n        const tmp = P[1];\n        const diffX = maxX - minX;\n        const diffY = maxY - minY;\n        const diffZ = maxZ - minZ;\n        tmp[0] = diffX * P0[0] + minX;\n        tmp[1] = diffY * P0[1] + minY;\n        tmp[2] = diffZ * P0[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[0]);\n        tmp[0] = diffX * P1[0] + minX;\n        tmp[1] = diffY * P1[1] + minY;\n        tmp[2] = diffZ * P1[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[1]);\n        tmp[0] = diffX * P2[0] + minX;\n        tmp[1] = diffY * P2[1] + minY;\n        tmp[2] = diffZ * P2[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[2]);\n        tmp[0] = diffX * P3[0] + minX;\n        tmp[1] = diffY * P3[1] + minY;\n        tmp[2] = diffZ * P3[2] + minZ;\n        sample(data, size, tmp[0], tmp[1], tmp[2], C[3]);\n        const V0 = calculateTetrahedronVolume(P1, P2, P3, coords) * 6;\n        const V1 = calculateTetrahedronVolume(P0, P2, P3, coords) * 6;\n        const V2 = calculateTetrahedronVolume(P0, P1, P3, coords) * 6;\n        const V3 = calculateTetrahedronVolume(P0, P1, P2, coords) * 6;\n        C[0][0] *= V0;\n        C[0][1] *= V0;\n        C[0][2] *= V0;\n        C[1][0] *= V1;\n        C[1][1] *= V1;\n        C[1][2] *= V1;\n        C[2][0] *= V2;\n        C[2][1] *= V2;\n        C[2][2] *= V2;\n        C[3][0] *= V3;\n        C[3][1] *= V3;\n        C[3][2] *= V3;\n        color2[0] = C[0][0] + C[1][0] + C[2][0] + C[3][0];\n        color2[1] = C[0][1] + C[1][1] + C[2][1] + C[3][1];\n        color2[2] = C[0][2] + C[1][2] + C[2][2] + C[3][2];\n    }\n}\nvar TetrahedralUpscaler = class {\n    /**\n   * Expands the given data to the target size.\n   *\n   * @param {TypedArray} data - The input RGBA data. Assumed to be cubic.\n   * @param {Number} size - The target size.\n   * @return {TypedArray} The new data.\n   */ static expand(data, size) {\n        const originalSize = Math.cbrt(data.length / 4);\n        const rgb = new Float32Array(3);\n        const array = new data.constructor(size ** 3 * 4);\n        const maxValue = data instanceof Uint8Array ? 255 : 1;\n        const sizeSq = size ** 2;\n        const s = 1 / (size - 1);\n        for(let z = 0; z < size; ++z){\n            for(let y = 0; y < size; ++y){\n                for(let x = 0; x < size; ++x){\n                    const u = x * s;\n                    const v3 = y * s;\n                    const w = z * s;\n                    const i4 = Math.round(x + y * size + z * sizeSq) * 4;\n                    tetrahedralSample(data, originalSize, u, v3, w, rgb);\n                    array[i4 + 0] = rgb[0];\n                    array[i4 + 1] = rgb[1];\n                    array[i4 + 2] = rgb[2];\n                    array[i4 + 3] = maxValue;\n                }\n            }\n        }\n        return array;\n    }\n};\n// src/textures/smaa/SMAAAreaImageData.js\nvar area = [\n    new Float32Array(2),\n    new Float32Array(2)\n];\nvar ORTHOGONAL_SIZE = 16;\nvar DIAGONAL_SIZE = 20;\nvar DIAGONAL_SAMPLES = 30;\nvar SMOOTH_MAX_DISTANCE = 32;\nvar orthogonalSubsamplingOffsets = new Float32Array([\n    0,\n    -0.25,\n    0.25,\n    -0.125,\n    0.125,\n    -0.375,\n    0.375\n]);\nvar diagonalSubsamplingOffsets = [\n    new Float32Array([\n        0,\n        0\n    ]),\n    new Float32Array([\n        0.25,\n        -0.25\n    ]),\n    new Float32Array([\n        -0.25,\n        0.25\n    ]),\n    new Float32Array([\n        0.125,\n        -0.125\n    ]),\n    new Float32Array([\n        -0.125,\n        0.125\n    ])\n];\nvar orthogonalEdges = [\n    new Uint8Array([\n        0,\n        0\n    ]),\n    new Uint8Array([\n        3,\n        0\n    ]),\n    new Uint8Array([\n        0,\n        3\n    ]),\n    new Uint8Array([\n        3,\n        3\n    ]),\n    new Uint8Array([\n        1,\n        0\n    ]),\n    new Uint8Array([\n        4,\n        0\n    ]),\n    new Uint8Array([\n        1,\n        3\n    ]),\n    new Uint8Array([\n        4,\n        3\n    ]),\n    new Uint8Array([\n        0,\n        1\n    ]),\n    new Uint8Array([\n        3,\n        1\n    ]),\n    new Uint8Array([\n        0,\n        4\n    ]),\n    new Uint8Array([\n        3,\n        4\n    ]),\n    new Uint8Array([\n        1,\n        1\n    ]),\n    new Uint8Array([\n        4,\n        1\n    ]),\n    new Uint8Array([\n        1,\n        4\n    ]),\n    new Uint8Array([\n        4,\n        4\n    ])\n];\nvar diagonalEdges = [\n    new Uint8Array([\n        0,\n        0\n    ]),\n    new Uint8Array([\n        1,\n        0\n    ]),\n    new Uint8Array([\n        0,\n        2\n    ]),\n    new Uint8Array([\n        1,\n        2\n    ]),\n    new Uint8Array([\n        2,\n        0\n    ]),\n    new Uint8Array([\n        3,\n        0\n    ]),\n    new Uint8Array([\n        2,\n        2\n    ]),\n    new Uint8Array([\n        3,\n        2\n    ]),\n    new Uint8Array([\n        0,\n        1\n    ]),\n    new Uint8Array([\n        1,\n        1\n    ]),\n    new Uint8Array([\n        0,\n        3\n    ]),\n    new Uint8Array([\n        1,\n        3\n    ]),\n    new Uint8Array([\n        2,\n        1\n    ]),\n    new Uint8Array([\n        3,\n        1\n    ]),\n    new Uint8Array([\n        2,\n        3\n    ]),\n    new Uint8Array([\n        3,\n        3\n    ])\n];\nfunction lerp(a, b, p) {\n    return a + (b - a) * p;\n}\nfunction saturate(a) {\n    return Math.min(Math.max(a, 0), 1);\n}\nfunction smoothArea(d) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const b1X = Math.sqrt(a1[0] * 2) * 0.5;\n    const b1Y = Math.sqrt(a1[1] * 2) * 0.5;\n    const b2X = Math.sqrt(a2[0] * 2) * 0.5;\n    const b2Y = Math.sqrt(a2[1] * 2) * 0.5;\n    const p = saturate(d / SMOOTH_MAX_DISTANCE);\n    a1[0] = lerp(b1X, a1[0], p);\n    a1[1] = lerp(b1Y, a1[1], p);\n    a2[0] = lerp(b2X, a2[0], p);\n    a2[1] = lerp(b2Y, a2[1], p);\n}\nfunction getOrthArea(p1X, p1Y, p2X, p2Y, x, result) {\n    const dX = p2X - p1X;\n    const dY = p2Y - p1Y;\n    const x1 = x;\n    const x2 = x + 1;\n    const y1 = p1Y + dY * (x1 - p1X) / dX;\n    const y2 = p1Y + dY * (x2 - p1X) / dX;\n    if (x1 >= p1X && x1 < p2X || x2 > p1X && x2 <= p2X) {\n        if (Math.sign(y1) === Math.sign(y2) || Math.abs(y1) < 1e-4 || Math.abs(y2) < 1e-4) {\n            const a = (y1 + y2) / 2;\n            if (a < 0) {\n                result[0] = Math.abs(a);\n                result[1] = 0;\n            } else {\n                result[0] = 0;\n                result[1] = Math.abs(a);\n            }\n        } else {\n            const t = -p1Y * dX / dY + p1X;\n            const tInt = Math.trunc(t);\n            const a1 = t > p1X ? y1 * (t - tInt) / 2 : 0;\n            const a2 = t < p2X ? y2 * (1 - (t - tInt)) / 2 : 0;\n            const a = Math.abs(a1) > Math.abs(a2) ? a1 : -a2;\n            if (a < 0) {\n                result[0] = Math.abs(a1);\n                result[1] = Math.abs(a2);\n            } else {\n                result[0] = Math.abs(a2);\n                result[1] = Math.abs(a1);\n            }\n        }\n    } else {\n        result[0] = 0;\n        result[1] = 0;\n    }\n    return result;\n}\nfunction getOrthAreaForPattern(pattern, left, right, offset, result) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const o1 = 0.5 + offset;\n    const o2 = 0.5 + offset - 1;\n    const d = left + right + 1;\n    switch(pattern){\n        case 0:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 1:\n            {\n                if (left <= right) {\n                    getOrthArea(0, o2, d / 2, 0, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 2:\n            {\n                if (left >= right) {\n                    getOrthArea(d / 2, 0, d, o2, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 3:\n            {\n                getOrthArea(0, o2, d / 2, 0, left, a1);\n                getOrthArea(d / 2, 0, d, o2, left, a2);\n                smoothArea(d, area);\n                result[0] = a1[0] + a2[0];\n                result[1] = a1[1] + a2[1];\n                break;\n            }\n        case 4:\n            {\n                if (left <= right) {\n                    getOrthArea(0, o1, d / 2, 0, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 5:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 6:\n            {\n                if (Math.abs(offset) > 0) {\n                    getOrthArea(0, o1, d, o2, left, a1);\n                    getOrthArea(0, o1, d / 2, 0, left, a2);\n                    getOrthArea(d / 2, 0, d, o2, left, result);\n                    a2[0] = a2[0] + result[0];\n                    a2[1] = a2[1] + result[1];\n                    result[0] = (a1[0] + a2[0]) / 2;\n                    result[1] = (a1[1] + a2[1]) / 2;\n                } else {\n                    getOrthArea(0, o1, d, o2, left, result);\n                }\n                break;\n            }\n        case 7:\n            {\n                getOrthArea(0, o1, d, o2, left, result);\n                break;\n            }\n        case 8:\n            {\n                if (left >= right) {\n                    getOrthArea(d / 2, 0, d, o1, left, result);\n                } else {\n                    result[0] = 0;\n                    result[1] = 0;\n                }\n                break;\n            }\n        case 9:\n            {\n                if (Math.abs(offset) > 0) {\n                    getOrthArea(0, o2, d, o1, left, a1);\n                    getOrthArea(0, o2, d / 2, 0, left, a2);\n                    getOrthArea(d / 2, 0, d, o1, left, result);\n                    a2[0] = a2[0] + result[0];\n                    a2[1] = a2[1] + result[1];\n                    result[0] = (a1[0] + a2[0]) / 2;\n                    result[1] = (a1[1] + a2[1]) / 2;\n                } else {\n                    getOrthArea(0, o2, d, o1, left, result);\n                }\n                break;\n            }\n        case 10:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n        case 11:\n            {\n                getOrthArea(0, o2, d, o1, left, result);\n                break;\n            }\n        case 12:\n            {\n                getOrthArea(0, o1, d / 2, 0, left, a1);\n                getOrthArea(d / 2, 0, d, o1, left, a2);\n                smoothArea(d, area);\n                result[0] = a1[0] + a2[0];\n                result[1] = a1[1] + a2[1];\n                break;\n            }\n        case 13:\n            {\n                getOrthArea(0, o2, d, o1, left, result);\n                break;\n            }\n        case 14:\n            {\n                getOrthArea(0, o1, d, o2, left, result);\n                break;\n            }\n        case 15:\n            {\n                result[0] = 0;\n                result[1] = 0;\n                break;\n            }\n    }\n    return result;\n}\nfunction isInsideArea(a1X, a1Y, a2X, a2Y, x, y) {\n    let result = a1X === a2X && a1Y === a2Y;\n    if (!result) {\n        const xm = (a1X + a2X) / 2;\n        const ym = (a1Y + a2Y) / 2;\n        const a = a2Y - a1Y;\n        const b = a1X - a2X;\n        const c2 = a * (x - xm) + b * (y - ym);\n        result = c2 > 0;\n    }\n    return result;\n}\nfunction getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, pX, pY) {\n    let n = 0;\n    for(let y = 0; y < DIAGONAL_SAMPLES; ++y){\n        for(let x = 0; x < DIAGONAL_SAMPLES; ++x){\n            const offsetX = x / (DIAGONAL_SAMPLES - 1);\n            const offsetY = y / (DIAGONAL_SAMPLES - 1);\n            if (isInsideArea(a1X, a1Y, a2X, a2Y, pX + offsetX, pY + offsetY)) {\n                ++n;\n            }\n        }\n    }\n    return n / (DIAGONAL_SAMPLES * DIAGONAL_SAMPLES);\n}\nfunction getDiagArea(pattern, a1X, a1Y, a2X, a2Y, left, offset, result) {\n    const e = diagonalEdges[pattern];\n    const e1 = e[0];\n    const e2 = e[1];\n    if (e1 > 0) {\n        a1X += offset[0];\n        a1Y += offset[1];\n    }\n    if (e2 > 0) {\n        a2X += offset[0];\n        a2Y += offset[1];\n    }\n    result[0] = 1 - getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 0 + left);\n    result[1] = getDiagAreaForPixel(a1X, a1Y, a2X, a2Y, 1 + left, 1 + left);\n    return result;\n}\nfunction getDiagAreaForPattern(pattern, left, right, offset, result) {\n    const a1 = area[0];\n    const a2 = area[1];\n    const d = left + right + 1;\n    switch(pattern){\n        case 0:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 1:\n            {\n                getDiagArea(pattern, 1, 0, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 2:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 3:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, result);\n                break;\n            }\n        case 4:\n            {\n                getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 5:\n            {\n                getDiagArea(pattern, 1, 1, 0 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 6:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, result);\n                break;\n            }\n        case 7:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 8:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 9:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, result);\n                break;\n            }\n        case 10:\n            {\n                getDiagArea(pattern, 0, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 11:\n            {\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 12:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, result);\n                break;\n            }\n        case 13:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 1 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 14:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 1, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n        case 15:\n            {\n                getDiagArea(pattern, 1, 1, 1 + d, 1 + d, left, offset, a1);\n                getDiagArea(pattern, 1, 0, 1 + d, 0 + d, left, offset, a2);\n                result[0] = (a1[0] + a2[0]) / 2;\n                result[1] = (a1[1] + a2[1]) / 2;\n                break;\n            }\n    }\n    return result;\n}\nfunction generatePatterns(patterns, offset, orthogonal) {\n    const result = new Float32Array(2);\n    for(let i = 0, l = patterns.length; i < l; ++i){\n        const pattern = patterns[i];\n        const data = pattern.data;\n        const size = pattern.width;\n        for(let y = 0; y < size; ++y){\n            for(let x = 0; x < size; ++x){\n                if (orthogonal) {\n                    getOrthAreaForPattern(i, x, y, offset, result);\n                } else {\n                    getDiagAreaForPattern(i, x, y, offset, result);\n                }\n                const c2 = (y * size + x) * 2;\n                data[c2] = result[0] * 255;\n                data[c2 + 1] = result[1] * 255;\n            }\n        }\n    }\n}\nfunction assemble(baseX, baseY, patterns, edges2, size, orthogonal, target) {\n    const dstData = target.data;\n    const dstWidth = target.width;\n    for(let i = 0, l = patterns.length; i < l; ++i){\n        const edge = edges2[i];\n        const pattern = patterns[i];\n        const srcData = pattern.data;\n        const srcWidth = pattern.width;\n        for(let y = 0; y < size; ++y){\n            for(let x = 0; x < size; ++x){\n                const pX = edge[0] * size + baseX + x;\n                const pY = edge[1] * size + baseY + y;\n                const c2 = (pY * dstWidth + pX) * 4;\n                const d = orthogonal ? (y * y * srcWidth + x * x) * 2 : (y * srcWidth + x) * 2;\n                dstData[c2] = srcData[d];\n                dstData[c2 + 1] = srcData[d + 1];\n                dstData[c2 + 2] = 0;\n                dstData[c2 + 3] = 255;\n            }\n        }\n    }\n}\nvar SMAAAreaImageData = class {\n    /**\n   * Creates a new area image.\n   *\n   * @return {RawImageData} The generated image data.\n   */ static generate() {\n        const width = 2 * 5 * ORTHOGONAL_SIZE;\n        const height = orthogonalSubsamplingOffsets.length * 5 * ORTHOGONAL_SIZE;\n        const data = new Uint8ClampedArray(width * height * 4);\n        const result = new RawImageData(width, height, data);\n        const orthPatternSize = Math.pow(ORTHOGONAL_SIZE - 1, 2) + 1;\n        const diagPatternSize = DIAGONAL_SIZE;\n        const orthogonalPatterns = [];\n        const diagonalPatterns = [];\n        for(let i = 3, l = data.length; i < l; i += 4){\n            data[i] = 255;\n        }\n        for(let i = 0; i < 16; ++i){\n            orthogonalPatterns.push(new RawImageData(orthPatternSize, orthPatternSize, new Uint8ClampedArray(orthPatternSize * orthPatternSize * 2), 2));\n            diagonalPatterns.push(new RawImageData(diagPatternSize, diagPatternSize, new Uint8ClampedArray(diagPatternSize * diagPatternSize * 2), 2));\n        }\n        for(let i = 0, l = orthogonalSubsamplingOffsets.length; i < l; ++i){\n            generatePatterns(orthogonalPatterns, orthogonalSubsamplingOffsets[i], true);\n            assemble(0, 5 * ORTHOGONAL_SIZE * i, orthogonalPatterns, orthogonalEdges, ORTHOGONAL_SIZE, true, result);\n        }\n        for(let i = 0, l = diagonalSubsamplingOffsets.length; i < l; ++i){\n            generatePatterns(diagonalPatterns, diagonalSubsamplingOffsets[i], false);\n            assemble(5 * ORTHOGONAL_SIZE, 4 * DIAGONAL_SIZE * i, diagonalPatterns, diagonalEdges, DIAGONAL_SIZE, false, result);\n        }\n        return result;\n    }\n};\n// src/textures/smaa/SMAAImageGenerator.js\n\n// tmp/smaa/worker.txt\nvar worker_default2 = '\"use strict\";(()=>{function q(t,a,s){let e=document.createElement(\"canvas\"),n=e.getContext(\"2d\");if(e.width=t,e.height=a,s instanceof Image)n.drawImage(s,0,0);else{let r=n.createImageData(t,a);r.data.set(s),n.putImageData(r,0,0)}return e}var F=class t{constructor(a=0,s=0,e=null){this.width=a,this.height=s,this.data=e}toCanvas(){return typeof document==\"undefined\"?null:q(this.width,this.height,this.data)}static from(a){let{width:s,height:e}=a,n;if(a instanceof Image){let r=q(s,e,a);r!==null&&(n=r.getContext(\"2d\").getImageData(0,0,s,e).data)}else n=a.data;return new t(s,e,n)}};var M=[new Float32Array(2),new Float32Array(2)],D=16,W=20,I=30,j=32,v=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),N=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],z=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],p=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function C(t,a,s){return t+(a-t)*s}function B(t){return Math.min(Math.max(t,0),1)}function _(t){let a=M[0],s=M[1],e=Math.sqrt(a[0]*2)*.5,n=Math.sqrt(a[1]*2)*.5,r=Math.sqrt(s[0]*2)*.5,o=Math.sqrt(s[1]*2)*.5,c=B(t/j);a[0]=C(e,a[0],c),a[1]=C(n,a[1],c),s[0]=C(r,s[0],c),s[1]=C(o,s[1],c)}function d(t,a,s,e,n,r){let o=s-t,c=e-a,h=n,i=n+1,w=a+c*(h-t)/o,b=a+c*(i-t)/o;if(h>=t&&h<s||i>t&&i<=s)if(Math.sign(w)===Math.sign(b)||Math.abs(w)<1e-4||Math.abs(b)<1e-4){let g=(w+b)/2;g<0?(r[0]=Math.abs(g),r[1]=0):(r[0]=0,r[1]=Math.abs(g))}else{let g=-a*o/c+t,k=Math.trunc(g),m=g>t?w*(g-k)/2:0,U=g<s?b*(1-(g-k))/2:0;(Math.abs(m)>Math.abs(U)?m:-U)<0?(r[0]=Math.abs(m),r[1]=Math.abs(U)):(r[0]=Math.abs(U),r[1]=Math.abs(m))}else r[0]=0,r[1]=0;return r}function J(t,a,s,e,n){let r=M[0],o=M[1],c=.5+e,h=.5+e-1,i=a+s+1;switch(t){case 0:{n[0]=0,n[1]=0;break}case 1:{a<=s?d(0,h,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 2:{a>=s?d(i/2,0,i,h,a,n):(n[0]=0,n[1]=0);break}case 3:{d(0,h,i/2,0,a,r),d(i/2,0,i,h,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 4:{a<=s?d(0,c,i/2,0,a,n):(n[0]=0,n[1]=0);break}case 5:{n[0]=0,n[1]=0;break}case 6:{Math.abs(e)>0?(d(0,c,i,h,a,r),d(0,c,i/2,0,a,o),d(i/2,0,i,h,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,c,i,h,a,n);break}case 7:{d(0,c,i,h,a,n);break}case 8:{a>=s?d(i/2,0,i,c,a,n):(n[0]=0,n[1]=0);break}case 9:{Math.abs(e)>0?(d(0,h,i,c,a,r),d(0,h,i/2,0,a,o),d(i/2,0,i,c,a,n),o[0]=o[0]+n[0],o[1]=o[1]+n[1],n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2):d(0,h,i,c,a,n);break}case 10:{n[0]=0,n[1]=0;break}case 11:{d(0,h,i,c,a,n);break}case 12:{d(0,c,i/2,0,a,r),d(i/2,0,i,c,a,o),_(i,M),n[0]=r[0]+o[0],n[1]=r[1]+o[1];break}case 13:{d(0,h,i,c,a,n);break}case 14:{d(0,c,i,h,a,n);break}case 15:{n[0]=0,n[1]=0;break}}return n}function K(t,a,s,e,n,r){let o=t===s&&a===e;if(!o){let c=(t+s)/2,h=(a+e)/2,i=e-a,w=t-s;o=i*(n-c)+w*(r-h)>0}return o}function G(t,a,s,e,n,r){let o=0;for(let c=0;c<I;++c)for(let h=0;h<I;++h){let i=h/(I-1),w=c/(I-1);K(t,a,s,e,n+i,r+w)&&++o}return o/(I*I)}function A(t,a,s,e,n,r,o,c){let h=p[t],i=h[0],w=h[1];return i>0&&(a+=o[0],s+=o[1]),w>0&&(e+=o[0],n+=o[1]),c[0]=1-G(a,s,e,n,1+r,0+r),c[1]=G(a,s,e,n,1+r,1+r),c}function Q(t,a,s,e,n){let r=M[0],o=M[1],c=a+s+1;switch(t){case 0:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 1:{A(t,1,0,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 2:{A(t,0,0,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 3:{A(t,1,0,1+c,0+c,a,e,n);break}case 4:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 5:{A(t,1,1,0+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 6:{A(t,1,1,1+c,0+c,a,e,n);break}case 7:{A(t,1,1,1+c,0+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 8:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 9:{A(t,1,0,1+c,1+c,a,e,n),A(t,1,0,1+c,1+c,a,e,n);break}case 10:{A(t,0,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 11:{A(t,1,0,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 12:{A(t,1,1,1+c,1+c,a,e,n);break}case 13:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,1+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 14:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,1,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}case 15:{A(t,1,1,1+c,1+c,a,e,r),A(t,1,0,1+c,0+c,a,e,o),n[0]=(r[0]+o[0])/2,n[1]=(r[1]+o[1])/2;break}}return n}function R(t,a,s){let e=new Float32Array(2);for(let n=0,r=t.length;n<r;++n){let o=t[n],c=o.data,h=o.width;for(let i=0;i<h;++i)for(let w=0;w<h;++w){s?J(n,w,i,a,e):Q(n,w,i,a,e);let b=(i*h+w)*2;c[b]=e[0]*255,c[b+1]=e[1]*255}}}function T(t,a,s,e,n,r,o){let c=o.data,h=o.width;for(let i=0,w=s.length;i<w;++i){let b=e[i],g=s[i],k=g.data,m=g.width;for(let U=0;U<n;++U)for(let x=0;x<n;++x){let Z=b[0]*n+t+x,O=((b[1]*n+a+U)*h+Z)*4,L=r?(U*U*m+x*x)*2:(U*m+x)*2;c[O]=k[L],c[O+1]=k[L+1],c[O+2]=0,c[O+3]=255}}}var S=class{static generate(){let a=10*D,s=v.length*5*D,e=new Uint8ClampedArray(a*s*4),n=new F(a,s,e),r=Math.pow(D-1,2)+1,o=W,c=[],h=[];for(let i=3,w=e.length;i<w;i+=4)e[i]=255;for(let i=0;i<16;++i)c.push(new F(r,r,new Uint8ClampedArray(r*r*2),2)),h.push(new F(o,o,new Uint8ClampedArray(o*o*2),2));for(let i=0,w=v.length;i<w;++i)R(c,v[i],!0),T(0,5*D*i,c,z,D,!0,n);for(let i=0,w=N.length;i<w;++i)R(h,N[i],!1),T(5*D,4*W*i,h,p,W,!1,n);return n}};var P=new Map([[y(0,0,0,0),new Float32Array([0,0,0,0])],[y(0,0,0,1),new Float32Array([0,0,0,1])],[y(0,0,1,0),new Float32Array([0,0,1,0])],[y(0,0,1,1),new Float32Array([0,0,1,1])],[y(0,1,0,0),new Float32Array([0,1,0,0])],[y(0,1,0,1),new Float32Array([0,1,0,1])],[y(0,1,1,0),new Float32Array([0,1,1,0])],[y(0,1,1,1),new Float32Array([0,1,1,1])],[y(1,0,0,0),new Float32Array([1,0,0,0])],[y(1,0,0,1),new Float32Array([1,0,0,1])],[y(1,0,1,0),new Float32Array([1,0,1,0])],[y(1,0,1,1),new Float32Array([1,0,1,1])],[y(1,1,0,0),new Float32Array([1,1,0,0])],[y(1,1,0,1),new Float32Array([1,1,0,1])],[y(1,1,1,0),new Float32Array([1,1,1,0])],[y(1,1,1,1),new Float32Array([1,1,1,1])]]);function H(t,a,s){return t+(a-t)*s}function y(t,a,s,e){let n=H(t,a,.75),r=H(s,e,1-.25);return H(n,r,1-.125)}function V(t,a){let s=0;return a[3]===1&&(s+=1),s===1&&a[2]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s}function $(t,a){let s=0;return a[3]===1&&t[1]!==1&&t[3]!==1&&(s+=1),s===1&&a[2]===1&&t[0]!==1&&t[2]!==1&&(s+=1),s}var E=class{static generate(){let o=new Uint8ClampedArray(2178),c=new Uint8ClampedArray(64*16*4);for(let h=0;h<33;++h)for(let i=0;i<66;++i){let w=.03125*i,b=.03125*h;if(P.has(w)&&P.has(b)){let g=P.get(w),k=P.get(b),m=h*66+i;o[m]=127*V(g,k),o[m+33]=127*$(g,k)}}for(let h=0,i=17;i<33;++i)for(let w=0;w<64;++w,h+=4)c[h]=o[i*66+w],c[h+3]=255;return new F(64,16,c)}};self.addEventListener(\"message\",t=>{let a=S.generate(),s=E.generate();postMessage({areaImageData:a,searchImageData:s},[a.data.buffer,s.data.buffer]),close()});})();\\n';\n// src/textures/smaa/SMAAImageGenerator.js\nfunction generate(useCache = true) {\n    const workerURL = URL.createObjectURL(new Blob([\n        worker_default2\n    ], {\n        type: \"text/javascript\"\n    }));\n    const worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    return new Promise((resolve, reject)=>{\n        worker.addEventListener(\"error\", (event)=>reject(event.error));\n        worker.addEventListener(\"message\", (event)=>{\n            const searchImageData = RawImageData.from(event.data.searchImageData);\n            const areaImageData = RawImageData.from(event.data.areaImageData);\n            const urls = [\n                searchImageData.toCanvas().toDataURL(\"image/png\", 1),\n                areaImageData.toCanvas().toDataURL(\"image/png\", 1)\n            ];\n            if (useCache) {\n                localStorage.setItem(\"smaa-search\", urls[0]);\n                localStorage.setItem(\"smaa-area\", urls[1]);\n            }\n            resolve(urls);\n        });\n        worker.postMessage(null);\n    });\n}\nvar SMAAImageGenerator = class {\n    /**\n   * Constructs a new SMAA image generator.\n   */ constructor(){\n        this.disableCache = false;\n    }\n    /**\n   * Enables or disables caching via localStorage.\n   *\n   * @param {Boolean} value - Whether the cache should be enabled.\n   */ setCacheEnabled(value) {\n        this.disableCache = !value;\n    }\n    /**\n   * Generates the SMAA data images.\n   *\n   * @example\n   * SMAAImageGenerator.generate().then(([search, area]) => {\n   *   const smaaEffect = new SMAAEffect(search, area);\n   * });\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */ generate() {\n        const useCache = !this.disableCache && window.localStorage !== void 0;\n        const cachedURLs = useCache ? [\n            localStorage.getItem(\"smaa-search\"),\n            localStorage.getItem(\"smaa-area\")\n        ] : [\n            null,\n            null\n        ];\n        const promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(useCache);\n        return promise.then((urls)=>{\n            return new Promise((resolve, reject)=>{\n                const searchImage = new Image();\n                const areaImage = new Image();\n                const manager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n                manager.onLoad = ()=>resolve([\n                        searchImage,\n                        areaImage\n                    ]);\n                manager.onError = reject;\n                searchImage.addEventListener(\"error\", (e)=>manager.itemError(\"smaa-search\"));\n                areaImage.addEventListener(\"error\", (e)=>manager.itemError(\"smaa-area\"));\n                searchImage.addEventListener(\"load\", ()=>manager.itemEnd(\"smaa-search\"));\n                areaImage.addEventListener(\"load\", ()=>manager.itemEnd(\"smaa-area\"));\n                manager.itemStart(\"smaa-search\");\n                manager.itemStart(\"smaa-area\");\n                searchImage.src = urls[0];\n                areaImage.src = urls[1];\n            });\n        });\n    }\n};\n// src/textures/smaa/SMAASearchImageData.js\nvar edges = /* @__PURE__ */ new Map([\n    [\n        bilinear(0, 0, 0, 0),\n        new Float32Array([\n            0,\n            0,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 0, 0, 1),\n        new Float32Array([\n            0,\n            0,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 0, 1, 0),\n        new Float32Array([\n            0,\n            0,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 0, 1, 1),\n        new Float32Array([\n            0,\n            0,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 1, 0, 0),\n        new Float32Array([\n            0,\n            1,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 1, 0, 1),\n        new Float32Array([\n            0,\n            1,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(0, 1, 1, 0),\n        new Float32Array([\n            0,\n            1,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(0, 1, 1, 1),\n        new Float32Array([\n            0,\n            1,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 0, 0, 0),\n        new Float32Array([\n            1,\n            0,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 0, 0, 1),\n        new Float32Array([\n            1,\n            0,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 0, 1, 0),\n        new Float32Array([\n            1,\n            0,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 0, 1, 1),\n        new Float32Array([\n            1,\n            0,\n            1,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 1, 0, 0),\n        new Float32Array([\n            1,\n            1,\n            0,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 1, 0, 1),\n        new Float32Array([\n            1,\n            1,\n            0,\n            1\n        ])\n    ],\n    [\n        bilinear(1, 1, 1, 0),\n        new Float32Array([\n            1,\n            1,\n            1,\n            0\n        ])\n    ],\n    [\n        bilinear(1, 1, 1, 1),\n        new Float32Array([\n            1,\n            1,\n            1,\n            1\n        ])\n    ]\n]);\nfunction lerp2(a, b, p) {\n    return a + (b - a) * p;\n}\nfunction bilinear(e0, e1, e2, e3) {\n    const a = lerp2(e0, e1, 1 - 0.25);\n    const b = lerp2(e2, e3, 1 - 0.25);\n    return lerp2(a, b, 1 - 0.125);\n}\nfunction deltaLeft(left, top) {\n    let d = 0;\n    if (top[3] === 1) {\n        d += 1;\n    }\n    if (d === 1 && top[2] === 1 && left[1] !== 1 && left[3] !== 1) {\n        d += 1;\n    }\n    return d;\n}\nfunction deltaRight(left, top) {\n    let d = 0;\n    if (top[3] === 1 && left[1] !== 1 && left[3] !== 1) {\n        d += 1;\n    }\n    if (d === 1 && top[2] === 1 && left[0] !== 1 && left[2] !== 1) {\n        d += 1;\n    }\n    return d;\n}\nvar SMAASearchImageData = class {\n    /**\n   * Creates a new search image.\n   *\n   * @return {RawImageData} The generated image data.\n   */ static generate() {\n        const width = 66;\n        const height = 33;\n        const halfWidth = width / 2;\n        const croppedWidth = 64;\n        const croppedHeight = 16;\n        const data = new Uint8ClampedArray(width * height);\n        const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);\n        for(let y = 0; y < height; ++y){\n            for(let x = 0; x < width; ++x){\n                const s = 0.03125 * x;\n                const t = 0.03125 * y;\n                if (edges.has(s) && edges.has(t)) {\n                    const e1 = edges.get(s);\n                    const e2 = edges.get(t);\n                    const i = y * width + x;\n                    data[i] = 127 * deltaLeft(e1, e2);\n                    data[i + halfWidth] = 127 * deltaRight(e1, e2);\n                }\n            }\n        }\n        for(let i = 0, y = height - croppedHeight; y < height; ++y){\n            for(let x = 0; x < croppedWidth; ++x, i += 4){\n                croppedData[i] = data[y * width + x];\n                croppedData[i + 3] = 255;\n            }\n        }\n        return new RawImageData(croppedWidth, croppedHeight, croppedData);\n    }\n};\n// src/textures/NoiseTexture.js\n\nfunction getNoise(size, format, type) {\n    const channels = /* @__PURE__ */ new Map([\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat,\n            1\n        ],\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,\n            1\n        ],\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,\n            2\n        ],\n        [\n            three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            4\n        ]\n    ]);\n    let data;\n    if (!channels.has(format)) {\n        console.error(\"Invalid noise texture format\");\n    }\n    if (type === three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n        data = new Uint8Array(size * channels.get(format));\n        for(let i = 0, l = data.length; i < l; ++i){\n            data[i] = Math.random() * 255 + 0.5;\n        }\n    } else {\n        data = new Float32Array(size * channels.get(format));\n        for(let i = 0, l = data.length; i < l; ++i){\n            data[i] = Math.random();\n        }\n    }\n    return data;\n}\nvar NoiseTexture = class extends three__WEBPACK_IMPORTED_MODULE_0__.DataTexture {\n    /**\n   * Constructs a new noise texture.\n   *\n   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and\n   * `RGFormat` can be used in a WebGL 2 context.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   * @param {Number} [format=LuminanceFormat] - The texture format.\n   * @param {Number} [type=UnsignedByteType] - The texture type.\n   */ constructor(width, height, format = three__WEBPACK_IMPORTED_MODULE_0__.LuminanceFormat, type = three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType){\n        super(getNoise(width * height, format, type), width, height, format, type);\n        this.needsUpdate = true;\n    }\n};\n// src/effects/glsl/glitch.frag\nvar glitch_default = \"uniform lowp sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seeds;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seeds.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seeds.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seeds*(random*0.2);}}\";\n// src/effects/GlitchEffect.js\nvar textureTag = \"Glitch.Generated\";\nfunction randomFloat(low, high) {\n    return low + Math.random() * (high - low);\n}\nvar GlitchEffect = class extends Effect {\n    /**\n   * Constructs a new glitch effect.\n   *\n   * TODO Change ratio to 0.15.\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.chromaticAberrationOffset] - A chromatic aberration offset. If provided, the glitch effect will influence this offset.\n   * @param {Vector2} [options.delay] - The minimum and maximum delay between glitch activations in seconds.\n   * @param {Vector2} [options.duration] - The minimum and maximum duration of a glitch in seconds.\n   * @param {Vector2} [options.strength] - The strength of weak and strong glitches.\n   * @param {Texture} [options.perturbationMap] - A perturbation map. If none is provided, a noise texture will be created.\n   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.\n   * @param {Number} [options.columns=0.05] - The scale of the blocky glitch columns.\n   * @param {Number} [options.ratio=0.85] - The threshold for strong glitches.\n   */ constructor({ chromaticAberrationOffset = null, delay = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1.5, 3.5), duration = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.6, 1), strength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.3, 1), columns = 0.05, ratio = 0.85, perturbationMap = null, dtSize = 64 } = {}){\n        super(\"GlitchEffect\", glitch_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"perturbationMap\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"columns\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(columns)\n                ],\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"random\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"seeds\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"distortion\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ]\n            ])\n        });\n        if (perturbationMap === null) {\n            const map = new NoiseTexture(dtSize, dtSize, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n            map.name = textureTag;\n            this.perturbationMap = map;\n        } else {\n            this.perturbationMap = perturbationMap;\n        }\n        this.time = 0;\n        this.distortion = this.uniforms.get(\"distortion\").value;\n        this.delay = delay;\n        this.duration = duration;\n        this.breakPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));\n        this.strength = strength;\n        this.mode = GlitchMode.SPORADIC;\n        this.ratio = ratio;\n        this.chromaticAberrationOffset = chromaticAberrationOffset;\n    }\n    /**\n   * Random number seeds.\n   *\n   * @type {Vector2}\n   * @private\n   */ get seeds() {\n        return this.uniforms.get(\"seeds\").value;\n    }\n    /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @type {Boolean}\n   */ get active() {\n        return this.uniforms.get(\"active\").value;\n    }\n    /**\n   * Indicates whether the glitch effect is currently active.\n   *\n   * @deprecated Use active instead.\n   * @return {Boolean} Whether the glitch effect is active.\n   */ isActive() {\n        return this.active;\n    }\n    /**\n   * The minimum delay between glitch activations.\n   *\n   * @type {Number}\n   */ get minDelay() {\n        return this.delay.x;\n    }\n    set minDelay(value) {\n        this.delay.x = value;\n    }\n    /**\n   * Returns the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @return {Number} The minimum delay in seconds.\n   */ getMinDelay() {\n        return this.delay.x;\n    }\n    /**\n   * Sets the minimum delay between glitch activations.\n   *\n   * @deprecated Use minDelay instead.\n   * @param {Number} value - The minimum delay in seconds.\n   */ setMinDelay(value) {\n        this.delay.x = value;\n    }\n    /**\n   * The maximum delay between glitch activations.\n   *\n   * @type {Number}\n   */ get maxDelay() {\n        return this.delay.y;\n    }\n    set maxDelay(value) {\n        this.delay.y = value;\n    }\n    /**\n   * Returns the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @return {Number} The maximum delay in seconds.\n   */ getMaxDelay() {\n        return this.delay.y;\n    }\n    /**\n   * Sets the maximum delay between glitch activations.\n   *\n   * @deprecated Use maxDelay instead.\n   * @param {Number} value - The maximum delay in seconds.\n   */ setMaxDelay(value) {\n        this.delay.y = value;\n    }\n    /**\n   * The minimum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */ get minDuration() {\n        return this.duration.x;\n    }\n    set minDuration(value) {\n        this.duration.x = value;\n    }\n    /**\n   * Returns the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @return {Number} The minimum duration in seconds.\n   */ getMinDuration() {\n        return this.duration.x;\n    }\n    /**\n   * Sets the minimum duration of sporadic glitches.\n   *\n   * @deprecated Use minDuration instead.\n   * @param {Number} value - The minimum duration in seconds.\n   */ setMinDuration(value) {\n        this.duration.x = value;\n    }\n    /**\n   * The maximum duration of sporadic glitches.\n   *\n   * @type {Number}\n   */ get maxDuration() {\n        return this.duration.y;\n    }\n    set maxDuration(value) {\n        this.duration.y = value;\n    }\n    /**\n   * Returns the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @return {Number} The maximum duration in seconds.\n   */ getMaxDuration() {\n        return this.duration.y;\n    }\n    /**\n   * Sets the maximum duration of sporadic glitches.\n   *\n   * @deprecated Use maxDuration instead.\n   * @param {Number} value - The maximum duration in seconds.\n   */ setMaxDuration(value) {\n        this.duration.y = value;\n    }\n    /**\n   * The strength of weak glitches.\n   *\n   * @type {Number}\n   */ get minStrength() {\n        return this.strength.x;\n    }\n    set minStrength(value) {\n        this.strength.x = value;\n    }\n    /**\n   * Returns the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @return {Number} The strength.\n   */ getMinStrength() {\n        return this.strength.x;\n    }\n    /**\n   * Sets the strength of weak glitches.\n   *\n   * @deprecated Use minStrength instead.\n   * @param {Number} value - The strength.\n   */ setMinStrength(value) {\n        this.strength.x = value;\n    }\n    /**\n   * The strength of strong glitches.\n   *\n   * @type {Number}\n   */ get maxStrength() {\n        return this.strength.y;\n    }\n    set maxStrength(value) {\n        this.strength.y = value;\n    }\n    /**\n   * Returns the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @return {Number} The strength.\n   */ getMaxStrength() {\n        return this.strength.y;\n    }\n    /**\n   * Sets the strength of strong glitches.\n   *\n   * @deprecated Use maxStrength instead.\n   * @param {Number} value - The strength.\n   */ setMaxStrength(value) {\n        this.strength.y = value;\n    }\n    /**\n   * Returns the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {GlitchMode} The mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the current glitch mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {GlitchMode} value - The mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n    /**\n   * Returns the glitch ratio.\n   *\n   * @deprecated Use ratio instead.\n   * @return {Number} The ratio.\n   */ getGlitchRatio() {\n        return 1 - this.ratio;\n    }\n    /**\n   * Sets the ratio of weak (0.0) and strong (1.0) glitches.\n   *\n   * @deprecated Use ratio instead.\n   * @param {Number} value - The ratio. Range is [0.0, 1.0].\n   */ setGlitchRatio(value) {\n        this.ratio = Math.min(Math.max(1 - value, 0), 1);\n    }\n    /**\n   * The glitch column size.\n   *\n   * @type {Number}\n   */ get columns() {\n        return this.uniforms.get(\"columns\").value;\n    }\n    set columns(value) {\n        this.uniforms.get(\"columns\").value = value;\n    }\n    /**\n   * Returns the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @return {Number} The glitch column size.\n   */ getGlitchColumns() {\n        return this.columns;\n    }\n    /**\n   * Sets the glitch column size.\n   *\n   * @deprecated Use columns instead.\n   * @param {Number} value - The glitch column size.\n   */ setGlitchColumns(value) {\n        this.columns = value;\n    }\n    /**\n   * Returns the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @return {Vector2} The offset.\n   */ getChromaticAberrationOffset() {\n        return this.chromaticAberrationOffset;\n    }\n    /**\n   * Sets the chromatic aberration offset.\n   *\n   * @deprecated Use chromaticAberrationOffset instead.\n   * @param {Vector2} value - The offset.\n   */ setChromaticAberrationOffset(value) {\n        this.chromaticAberrationOffset = value;\n    }\n    /**\n   * The perturbation map.\n   *\n   * @type {Texture}\n   */ get perturbationMap() {\n        return this.uniforms.get(\"perturbationMap\").value;\n    }\n    set perturbationMap(value) {\n        const currentMap = this.perturbationMap;\n        if (currentMap !== null && currentMap.name === textureTag) {\n            currentMap.dispose();\n        }\n        value.minFilter = value.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        value.generateMipmaps = false;\n        this.uniforms.get(\"perturbationMap\").value = value;\n    }\n    /**\n   * Returns the current perturbation map.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @return {Texture} The current perturbation map.\n   */ getPerturbationMap() {\n        return this.perturbationMap;\n    }\n    /**\n   * Replaces the current perturbation map with the given one.\n   *\n   * The current map will be disposed if it was generated by this effect.\n   *\n   * @deprecated Use perturbationMap instead.\n   * @param {Texture} value - The new perturbation map.\n   */ setPerturbationMap(value) {\n        this.perturbationMap = value;\n    }\n    /**\n   * Generates a perturbation map.\n   *\n   * @deprecated Use NoiseTexture instead.\n   * @param {Number} [value=64] - The texture size.\n   * @return {DataTexture} The perturbation map.\n   */ generatePerturbationMap(value = 64) {\n        const map = new NoiseTexture(value, value, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n        map.name = textureTag;\n        return map;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const mode = this.mode;\n        const breakPoint = this.breakPoint;\n        const offset = this.chromaticAberrationOffset;\n        const s = this.strength;\n        let time = this.time;\n        let active = false;\n        let r = 0, a = 0;\n        let trigger;\n        if (mode !== GlitchMode.DISABLED) {\n            if (mode === GlitchMode.SPORADIC) {\n                time += deltaTime;\n                trigger = time > breakPoint.x;\n                if (time >= breakPoint.x + breakPoint.y) {\n                    breakPoint.set(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));\n                    time = 0;\n                }\n            }\n            r = Math.random();\n            this.uniforms.get(\"random\").value = r;\n            if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {\n                active = true;\n                r *= s.y * 0.03;\n                a = randomFloat(-Math.PI, Math.PI);\n                this.seeds.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));\n                this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n            } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {\n                active = true;\n                r *= s.x * 0.03;\n                a = randomFloat(-Math.PI, Math.PI);\n                this.seeds.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));\n                this.distortion.set(randomFloat(0, 1), randomFloat(0, 1));\n            }\n            this.time = time;\n        }\n        if (offset !== null) {\n            if (active) {\n                offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);\n            } else {\n                offset.set(0, 0);\n            }\n        }\n        this.uniforms.get(\"active\").value = active;\n    }\n    /**\n   * Deletes generated resources.\n   */ dispose() {\n        const map = this.perturbationMap;\n        if (map !== null && map.name === textureTag) {\n            map.dispose();\n        }\n    }\n};\n// src/effects/GodRaysEffect.js\n\n// src/effects/glsl/god-rays.frag\nvar god_rays_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}\";\n// src/effects/GodRaysEffect.js\nvar v = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar m = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nvar GodRaysEffect = class extends Effect {\n    /**\n   * Constructs a new god rays effect.\n   *\n   * @param {Camera} [camera] - The main camera.\n   * @param {Mesh|Points} [lightSource] - The light source. Must not write depth and has to be flagged as transparent.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Number} [options.samples=60.0] - The number of samples per pixel.\n   * @param {Number} [options.density=0.96] - The density of the light rays.\n   * @param {Number} [options.decay=0.9] - An illumination decay factor.\n   * @param {Number} [options.weight=0.4] - A light ray weight factor.\n   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.\n   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   * @param {KernelSize} [options.kernelSize=KernelSize.SMALL] - The blur kernel size. Has no effect if blur is disabled.\n   * @param {Boolean} [options.blur=true] - Whether the god rays should be blurred to reduce artifacts.\n   */ constructor(camera, lightSource, { blendFunction = BlendFunction.SCREEN, samples = 60, density = 0.96, decay = 0.9, weight = 0.4, exposure = 0.6, clampMax = 1, blur = true, kernelSize = KernelSize.SMALL, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"GodRaysEffect\", god_rays_default, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.camera = camera;\n        this._lightSource = lightSource;\n        this.lightSource = lightSource;\n        this.lightScene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this.screenPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.renderTargetA = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetA.texture.name = \"GodRays.Target.A\";\n        this.renderTargetB = this.renderTargetA.clone();\n        this.renderTargetB.texture.name = \"GodRays.Target.B\";\n        this.uniforms.get(\"map\").value = this.renderTargetB.texture;\n        this.renderTargetLight = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n        this.renderTargetLight.texture.name = \"GodRays.Light\";\n        this.renderTargetLight.depthTexture = new three__WEBPACK_IMPORTED_MODULE_0__.DepthTexture();\n        this.renderPassLight = new RenderPass(this.lightScene, camera);\n        this.renderPassLight.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.blurPass = new KawaseBlurPass({\n            kernelSize\n        });\n        this.blurPass.enabled = blur;\n        this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n        const depthMaskMaterial = this.depthMaskMaterial;\n        depthMaskMaterial.depthBuffer1 = this.renderTargetLight.depthTexture;\n        depthMaskMaterial.copyCameraSettings(camera);\n        this.godRaysPass = new ShaderPass(new GodRaysMaterial(this.screenPosition));\n        const godRaysMaterial = this.godRaysMaterial;\n        godRaysMaterial.density = density;\n        godRaysMaterial.decay = decay;\n        godRaysMaterial.weight = weight;\n        godRaysMaterial.exposure = exposure;\n        godRaysMaterial.maxIntensity = clampMax;\n        godRaysMaterial.samples = samples;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.renderPassLight.mainCamera = value;\n        this.depthMaskMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the light source.\n   *\n   * @type {Mesh|Points}\n   */ get lightSource() {\n        return this._lightSource;\n    }\n    set lightSource(value) {\n        this._lightSource = value;\n        if (value !== null) {\n            value.material.depthWrite = false;\n            value.material.transparent = true;\n        }\n    }\n    /**\n   * Returns the blur pass that reduces aliasing artifacts and makes the light softer.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * A texture that contains the intermediate result of this effect.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.renderTargetB.texture;\n    }\n    /**\n   * Returns the god rays texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */ get depthMaskMaterial() {\n        return this.depthMaskPass.fullscreenMaterial;\n    }\n    /**\n   * The internal god rays material.\n   *\n   * @type {GodRaysMaterial}\n   */ get godRaysMaterial() {\n        return this.godRaysPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the god rays material.\n   *\n   * @deprecated Use godRaysMaterial instead.\n   * @return {GodRaysMaterial} The material.\n   */ getGodRaysMaterial() {\n        return this.godRaysMaterial;\n    }\n    /**\n   * Returns the resolution of this effect.\n   *\n   * @deprecated Use resolution instead.\n   * @return {GodRaysMaterial} The material.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get dithering() {\n        return this.godRaysMaterial.dithering;\n    }\n    set dithering(value) {\n        const material = this.godRaysMaterial;\n        material.dithering = value;\n        material.needsUpdate = true;\n    }\n    /**\n   * Indicates whether the god rays should be blurred to reduce artifacts.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */ get blur() {\n        return this.blurPass.enabled;\n    }\n    set blur(value) {\n        this.blurPass.enabled = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * The number of samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */ get samples() {\n        return this.godRaysMaterial.samples;\n    }\n    /**\n   * A higher sample count improves quality at the cost of performance.\n   *\n   * @type {Number}\n   * @deprecated Use godRaysMaterial.samples instead.\n   */ set samples(value) {\n        this.godRaysMaterial.samples = value;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {Number} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthMaskPass.fullscreenMaterial.depthBuffer0 = depthTexture;\n        this.depthMaskPass.fullscreenMaterial.depthPacking0 = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const lightSource = this.lightSource;\n        const parent = lightSource.parent;\n        const matrixAutoUpdate = lightSource.matrixAutoUpdate;\n        const renderTargetA = this.renderTargetA;\n        const renderTargetLight = this.renderTargetLight;\n        lightSource.material.depthWrite = true;\n        lightSource.matrixAutoUpdate = false;\n        lightSource.updateWorldMatrix(true, false);\n        if (parent !== null) {\n            if (!matrixAutoUpdate) {\n                m.copy(lightSource.matrix);\n            }\n            lightSource.matrix.copy(lightSource.matrixWorld);\n        }\n        this.lightScene.add(lightSource);\n        this.renderPassLight.render(renderer, renderTargetLight);\n        this.clearPass.render(renderer, renderTargetA);\n        this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);\n        lightSource.material.depthWrite = false;\n        lightSource.matrixAutoUpdate = matrixAutoUpdate;\n        if (parent !== null) {\n            if (!matrixAutoUpdate) {\n                lightSource.matrix.copy(m);\n            }\n            parent.add(lightSource);\n        }\n        v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);\n        this.screenPosition.set(Math.min(Math.max((v.x + 1) * 0.5, -1), 2), Math.min(Math.max((v.y + 1) * 0.5, -1), 2));\n        if (this.blurPass.enabled) {\n            this.blurPass.render(renderer, renderTargetA, renderTargetA);\n        }\n        this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.renderTargetA.setSize(w, h);\n        this.renderTargetB.setSize(w, h);\n        this.renderTargetLight.setSize(w, h);\n        this.blurPass.resolution.copy(resolution);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        this.renderPassLight.initialize(renderer, alpha, frameBufferType);\n        this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n        this.godRaysPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTargetA.texture.type = frameBufferType;\n            this.renderTargetB.texture.type = frameBufferType;\n            this.renderTargetLight.texture.type = frameBufferType;\n            if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTargetA.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetB.texture, SRGBColorSpace);\n                setTextureColorSpace(this.renderTargetLight.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/effects/GridEffect.js\n\n// src/effects/glsl/grid.frag\nvar grid_default = \"uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}\";\n// src/effects/GridEffect.js\nvar GridEffect = class extends Effect {\n    /**\n   * Constructs a new grid effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.scale=1.0] - The scale of the grid pattern.\n   * @param {Number} [options.lineWidth=0.0] - The line width of the grid pattern.\n   */ constructor({ blendFunction = BlendFunction.OVERLAY, scale = 1, lineWidth = 0 } = {}){\n        super(\"GridEffect\", grid_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"lineWidth\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(lineWidth)\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.s = 0;\n        this.scale = scale;\n        this.l = 0;\n        this.lineWidth = lineWidth;\n    }\n    /**\n   * The scale.\n   *\n   * @type {Number}\n   */ get scale() {\n        return this.s;\n    }\n    set scale(value) {\n        this.s = Math.max(value, 1e-6);\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @return {Number} The grid scale.\n   */ getScale() {\n        return this.scale;\n    }\n    /**\n   * Sets the grid scale.\n   *\n   * @deprecated Use scale instead.\n   * @param {Number} value - The new grid scale.\n   */ setScale(value) {\n        this.scale = value;\n    }\n    /**\n   * The line width.\n   *\n   * @type {Number}\n   */ get lineWidth() {\n        return this.l;\n    }\n    set lineWidth(value) {\n        this.l = value;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @return {Number} The grid line width.\n   */ getLineWidth() {\n        return this.lineWidth;\n    }\n    /**\n   * Sets the grid line width.\n   *\n   * @deprecated Use lineWidth instead.\n   * @param {Number} value - The new grid line width.\n   */ setLineWidth(value) {\n        this.lineWidth = value;\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.resolution.set(width, height);\n        const aspect = width / height;\n        const scale = this.scale * (height * 0.125);\n        this.uniforms.get(\"scale\").value.set(aspect * scale, scale);\n        this.uniforms.get(\"lineWidth\").value = scale / height + this.lineWidth;\n    }\n};\n// src/effects/HueSaturationEffect.js\n\n// src/effects/glsl/hue-saturation.frag\nvar hue_saturation_default = \"uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}\";\n// src/effects/HueSaturationEffect.js\nvar HueSaturationEffect = class extends Effect {\n    /**\n   * Constructs a new hue/saturation effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Number} [options.hue=0.0] - The hue in radians.\n   * @param {Number} [options.saturation=0.0] - The saturation factor, ranging from -1 to 1, where 0 means no change.\n   */ constructor({ blendFunction = BlendFunction.SRC, hue = 0, saturation = 0 } = {}){\n        super(\"HueSaturationEffect\", hue_saturation_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"hue\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"saturation\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(saturation)\n                ]\n            ])\n        });\n        this.hue = hue;\n    }\n    /**\n   * The saturation.\n   *\n   * @type {Number}\n   */ get saturation() {\n        return this.uniforms.get(\"saturation\").value;\n    }\n    set saturation(value) {\n        this.uniforms.get(\"saturation\").value = value;\n    }\n    /**\n   * Returns the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @return {Number} The saturation.\n   */ getSaturation() {\n        return this.saturation;\n    }\n    /**\n   * Sets the saturation.\n   *\n   * @deprecated Use saturation instead.\n   * @param {Number} value - The saturation.\n   */ setSaturation(value) {\n        this.saturation = value;\n    }\n    /**\n   * The hue.\n   *\n   * @type {Number}\n   */ get hue() {\n        const hue = this.uniforms.get(\"hue\").value;\n        return Math.acos((hue.x * 3 - 1) / 2);\n    }\n    set hue(value) {\n        const s = Math.sin(value), c2 = Math.cos(value);\n        this.uniforms.get(\"hue\").value.set((2 * c2 + 1) / 3, (-Math.sqrt(3) * s - c2 + 1) / 3, (Math.sqrt(3) * s - c2 + 1) / 3);\n    }\n    /**\n   * Returns the hue.\n   *\n   * @deprecated Use hue instead.\n   * @return {Number} The hue in radians.\n   */ getHue() {\n        return this.hue;\n    }\n    /**\n   * Sets the hue.\n   *\n   * @deprecated Use hue instead.\n   * @param {Number} value - The hue in radians.\n   */ setHue(value) {\n        this.hue = value;\n    }\n};\n// src/effects/LensDistortionEffect.js\n\n// src/effects/glsl/lens-distortion.frag\nvar lens_distortion_default = \"uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}\";\n// src/effects/LensDistortionEffect.js\nvar LensDistortionEffect = class extends Effect {\n    /**\n   * Constructs a new lens distortion effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {Vector2} [options.distortion] - The distortion value.\n   * @param {Vector2} [options.principalPoint] - The center point.\n   * @param {Vector2} [options.focalLength] - The focal length.\n   * @param {Number} [options.skew=0] - The skew value.\n   */ constructor({ distortion = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0), principalPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0), focalLength = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1), skew = 0 } = {}){\n        super(\"LensDistortionEffect\", lens_distortion_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"distortion\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(distortion)\n                ],\n                [\n                    \"principalPoint\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(principalPoint)\n                ],\n                [\n                    \"focalLength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)\n                ],\n                [\n                    \"skew\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(skew)\n                ]\n            ])\n        });\n    }\n    /**\n   * The radial distortion coefficients. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */ get distortion() {\n        return this.uniforms.get(\"distortion\").value;\n    }\n    set distortion(value) {\n        this.uniforms.get(\"distortion\").value = value;\n    }\n    /**\n   * The principal point. Default is (0, 0).\n   *\n   * @type {Vector2}\n   */ get principalPoint() {\n        return this.uniforms.get(\"principalPoint\").value;\n    }\n    set principalPoint(value) {\n        this.uniforms.get(\"principalPoint\").value = value;\n    }\n    /**\n   * The focal length. Default is (1, 1).\n   *\n   * @type {Vector2}\n   */ get focalLength() {\n        return this.uniforms.get(\"focalLength\").value;\n    }\n    set focalLength(value) {\n        this.uniforms.get(\"focalLength\").value = value;\n    }\n    /**\n   * The skew factor in radians.\n   *\n   * @type {Number}\n   */ get skew() {\n        return this.uniforms.get(\"skew\").value;\n    }\n    set skew(value) {\n        this.uniforms.get(\"skew\").value = value;\n    }\n};\n// src/effects/LUT1DEffect.js\n\n// src/effects/glsl/lut-1d.frag\nvar lut_1d_default = \"#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D lut;\\n#else\\nuniform mediump sampler2D lut;\\n#endif\\n#else\\nuniform lowp sampler2D lut;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(texture2D(lut,vec2(inputColor.r,0.5)).r,texture2D(lut,vec2(inputColor.g,0.5)).r,texture2D(lut,vec2(inputColor.b,0.5)).r,inputColor.a);}\";\n// src/effects/LUT1DEffect.js\nvar LUT1DEffect = class extends Effect {\n    /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   */ constructor(lut, { blendFunction = BlendFunction.SRC } = {}){\n        super(\"LUT1DEffect\", lut_1d_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"lut\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.lut = lut;\n    }\n    /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */ get lut() {\n        return this.uniforms.get(\"lut\").value;\n    }\n    set lut(value) {\n        this.uniforms.get(\"lut\").value = value;\n        if (value !== null && (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType)) {\n            this.defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n        }\n    }\n};\n// src/effects/LUT3DEffect.js\n\n// src/effects/glsl/lut-3d.frag\nvar lut_3d_default = \"uniform vec3 scale;uniform vec3 offset;\\n#ifdef CUSTOM_INPUT_DOMAIN\\nuniform vec3 domainMin;uniform vec3 domainMax;\\n#endif\\n#ifdef LUT_3D\\n#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler3D lut;\\n#else\\nuniform mediump sampler3D lut;\\n#endif\\n#else\\nuniform lowp sampler3D lut;\\n#endif\\nvec4 applyLUT(const in vec3 rgb){\\n#ifdef TETRAHEDRAL_INTERPOLATION\\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\\n#else\\nreturn texture(lut,rgb);\\n#endif\\n}\\n#else\\n#ifdef LUT_PRECISION_HIGH\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D lut;\\n#else\\nuniform mediump sampler2D lut;\\n#endif\\n#else\\nuniform lowp sampler2D lut;\\n#endif\\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\\n#ifdef LUT_STRIP_HORIZONTAL\\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\\n#else\\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\\n#endif\\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=inputColor.rgb;\\n#ifdef CUSTOM_INPUT_DOMAIN\\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=applyLUT(scale*c+offset).rgb;}else{c=inputColor.rgb;}\\n#else\\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\\nc=clamp(c,0.0,1.0);\\n#endif\\nc=applyLUT(scale*c+offset).rgb;\\n#endif\\noutputColor=vec4(c,inputColor.a);}\";\n// src/effects/LUT3DEffect.js\nvar LUT3DEffect = class extends Effect {\n    /**\n   * Constructs a new color grading effect.\n   *\n   * @param {Texture} lut - The lookup texture.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.tetrahedralInterpolation=false] - Enables or disables tetrahedral interpolation.\n   * @param {TextureEncoding} [options.inputEncoding=sRGBEncoding] - Deprecated.\n   * @param {ColorSpace} [options.inputColorSpace=SRGBColorSpace] - The input color space.\n   */ constructor(lut, { blendFunction = BlendFunction.SRC, tetrahedralInterpolation = false, inputEncoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding, inputColorSpace } = {}){\n        super(\"LUT3DEffect\", lut_3d_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"lut\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n                ],\n                [\n                    \"domainMin\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"domainMax\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.tetrahedralInterpolation = tetrahedralInterpolation;\n        this.inputColorSpace = inputColorSpace || encodingToColorSpace.get(inputEncoding);\n        this.lut = lut;\n    }\n    /**\n   * The input encoding. Default is `sRGBEncoding`.\n   *\n   * Set this to `LinearEncoding` if your LUT expects linear color input.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @type {TextureEncoding}\n   */ get inputEncoding() {\n        return this.inputColorSpace;\n    }\n    set inputEncoding(value) {\n        this.inputColorSpace = value;\n    }\n    /**\n   * Returns the input encoding.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @return {TextureEncoding} The encoding.\n   */ getInputEncoding() {\n        return this.inputColorSpace;\n    }\n    /**\n   * Sets the input encoding.\n   *\n   * @deprecated Use inputColorSpace instead.\n   * @param {TextureEncoding} value - The encoding.\n   */ setInputEncoding(value) {\n        this.inputColorSpace = value;\n    }\n    /**\n   * Returns the output encoding.\n   *\n   * @deprecated Use outputColorSpace instead.\n   * @return {TextureEncoding} The encoding.\n   */ getOutputEncoding() {\n        return this.outputColorSpace;\n    }\n    /**\n   * The LUT.\n   *\n   * @type {Texture}\n   */ get lut() {\n        return this.uniforms.get(\"lut\").value;\n    }\n    set lut(value) {\n        const defines = this.defines;\n        const uniforms = this.uniforms;\n        if (this.lut !== value) {\n            uniforms.get(\"lut\").value = value;\n            if (value !== null) {\n                const image = value.image;\n                const tetrahedralInterpolation = this.tetrahedralInterpolation;\n                defines.clear();\n                defines.set(\"LUT_SIZE\", Math.min(image.width, image.height).toFixed(16));\n                defines.set(\"LUT_TEXEL_WIDTH\", (1 / image.width).toFixed(16));\n                defines.set(\"LUT_TEXEL_HEIGHT\", (1 / image.height).toFixed(16));\n                uniforms.get(\"domainMin\").value = null;\n                uniforms.get(\"domainMax\").value = null;\n                if (value.type === three__WEBPACK_IMPORTED_MODULE_0__.FloatType || value.type === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType) {\n                    defines.set(\"LUT_PRECISION_HIGH\", \"1\");\n                }\n                if (image.width > image.height) {\n                    defines.set(\"LUT_STRIP_HORIZONTAL\", \"1\");\n                } else if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                    defines.set(\"LUT_3D\", \"1\");\n                }\n                if (value instanceof LookupTexture) {\n                    const min = value.domainMin;\n                    const max = value.domainMax;\n                    if (min.x !== 0 || min.y !== 0 || min.z !== 0 || max.x !== 1 || max.y !== 1 || max.z !== 1) {\n                        defines.set(\"CUSTOM_INPUT_DOMAIN\", \"1\");\n                        uniforms.get(\"domainMin\").value = min.clone();\n                        uniforms.get(\"domainMax\").value = max.clone();\n                    }\n                }\n                this.tetrahedralInterpolation = tetrahedralInterpolation;\n            }\n        }\n    }\n    /**\n   * Returns the current LUT.\n   *\n   * @deprecated Use lut instead.\n   * @return {Texture} The LUT.\n   */ getLUT() {\n        return this.lut;\n    }\n    /**\n   * Sets the LUT.\n   *\n   * @deprecated Use lut instead.\n   * @param {Texture} value - The LUT.\n   */ setLUT(value) {\n        this.lut = value;\n    }\n    /**\n   * Updates the scale and offset for the LUT sampling coordinates.\n   *\n   * @private\n   */ updateScaleOffset() {\n        const lut = this.lut;\n        if (lut !== null) {\n            const size = Math.min(lut.image.width, lut.image.height);\n            const scale = this.uniforms.get(\"scale\").value;\n            const offset = this.uniforms.get(\"offset\").value;\n            if (this.tetrahedralInterpolation && lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n                    const domainScale = lut.domainMax.clone().sub(lut.domainMin);\n                    scale.setScalar(size - 1).divide(domainScale);\n                    offset.copy(lut.domainMin).negate().multiply(scale);\n                } else {\n                    scale.setScalar(size - 1);\n                    offset.setScalar(0);\n                }\n            } else {\n                if (this.defines.has(\"CUSTOM_INPUT_DOMAIN\")) {\n                    const domainScale = lut.domainMax.clone().sub(lut.domainMin).multiplyScalar(size);\n                    scale.setScalar(size - 1).divide(domainScale);\n                    offset.copy(lut.domainMin).negate().multiply(scale).addScalar(1 / (2 * size));\n                } else {\n                    scale.setScalar((size - 1) / size);\n                    offset.setScalar(1 / (2 * size));\n                }\n            }\n        }\n    }\n    /**\n   * Configures parameters for tetrahedral interpolation.\n   *\n   * @private\n   */ configureTetrahedralInterpolation() {\n        const lut = this.lut;\n        if (lut !== null) {\n            lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            if (this.tetrahedralInterpolation) {\n                if (lut instanceof three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture) {\n                    lut.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n                    lut.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n                } else {\n                    console.warn(\"Tetrahedral interpolation requires a 3D texture\");\n                }\n            }\n            if (lut.source === void 0) {\n                lut.needsUpdate = true;\n            }\n        }\n    }\n    /**\n   * Indicates whether tetrahedral interpolation is enabled. Requires a 3D LUT, disabled by default.\n   *\n   * Tetrahedral interpolation produces highly accurate results but is slower than hardware interpolation.\n   *\n   * @type {Boolean}\n   */ get tetrahedralInterpolation() {\n        return this.defines.has(\"TETRAHEDRAL_INTERPOLATION\");\n    }\n    set tetrahedralInterpolation(value) {\n        if (value) {\n            this.defines.set(\"TETRAHEDRAL_INTERPOLATION\", \"1\");\n        } else {\n            this.defines.delete(\"TETRAHEDRAL_INTERPOLATION\");\n        }\n        this.configureTetrahedralInterpolation();\n        this.updateScaleOffset();\n        this.setChanged();\n    }\n    /**\n   * Enables or disables tetrahedral interpolation.\n   *\n   * @deprecated Use tetrahedralInterpolation instead.\n   * @param {Boolean} value - Whether tetrahedral interpolation should be enabled.\n   */ setTetrahedralInterpolationEnabled(value) {\n        this.tetrahedralInterpolation = value;\n    }\n};\n// src/effects/glsl/noise.frag\nvar noise_default = \"void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\\n#ifdef PREMULTIPLY\\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\\n#else\\noutputColor=vec4(noise,inputColor.a);\\n#endif\\n}\";\n// src/effects/NoiseEffect.js\nvar NoiseEffect = class extends Effect {\n    /**\n   * Constructs a new noise effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.\n   * @param {Boolean} [options.premultiply=false] - Whether the noise should be multiplied with the input colors prior to blending.\n   */ constructor({ blendFunction = BlendFunction.SCREEN, premultiply = false } = {}){\n        super(\"NoiseEffect\", noise_default, {\n            blendFunction\n        });\n        this.premultiply = premultiply;\n    }\n    /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @type {Boolean}\n   */ get premultiply() {\n        return this.defines.has(\"PREMULTIPLY\");\n    }\n    set premultiply(value) {\n        if (this.premultiply !== value) {\n            if (value) {\n                this.defines.set(\"PREMULTIPLY\", \"1\");\n            } else {\n                this.defines.delete(\"PREMULTIPLY\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether noise will be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @return {Boolean} Whether noise is premultiplied.\n   */ isPremultiplied() {\n        return this.premultiply;\n    }\n    /**\n   * Controls whether noise should be multiplied with the input colors prior to blending.\n   *\n   * @deprecated Use premultiply instead.\n   * @param {Boolean} value - Whether noise should be premultiplied.\n   */ setPremultiplied(value) {\n        this.premultiply = value;\n    }\n};\n// src/effects/OutlineEffect.js\n\n// src/effects/glsl/outline.frag\nvar outline_default3 = \"uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\\n#ifdef USE_PATTERN\\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\\n#ifndef X_RAY\\nedge.y=0.0;\\n#endif\\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\\n#ifdef USE_PATTERN\\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\\n#ifdef X_RAY\\nfloat hiddenFactor=0.5;\\n#else\\nfloat hiddenFactor=0.0;\\n#endif\\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\\n#endif\\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\\n#ifdef ALPHA\\noutputColor=vec4(color,alpha);\\n#else\\noutputColor=vec4(color,max(alpha,inputColor.a));\\n#endif\\n}\";\n// src/effects/glsl/outline.vert\nvar outline_default4 = \"uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}\";\n// src/effects/OutlineEffect.js\nvar OutlineEffect = class extends Effect {\n    /**\n   * Constructs a new outline effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.\n   * @param {Texture} [options.patternTexture=null] - A pattern texture.\n   * @param {Number} [options.patternScale=1.0] - The pattern scale.\n   * @param {Number} [options.edgeStrength=1.0] - The edge strength.\n   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.\n   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.\n   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.\n   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.\n   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.\n   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.\n   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(scene, camera, { blendFunction = BlendFunction.SCREEN, patternTexture = null, patternScale = 1, edgeStrength = 1, pulseSpeed = 0, visibleEdgeColor = 16777215, hiddenEdgeColor = 2230538, kernelSize = KernelSize.VERY_SMALL, blur = false, xRay = true, multisampling = 0, resolutionScale = 0.5, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"OutlineEffect\", outline_default3, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"maskTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"edgeTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"edgeStrength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(edgeStrength)\n                ],\n                [\n                    \"visibleEdgeColor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(visibleEdgeColor))\n                ],\n                [\n                    \"hiddenEdgeColor\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Color(hiddenEdgeColor))\n                ],\n                [\n                    \"pulse\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"patternScale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(patternScale)\n                ],\n                [\n                    \"patternTexture\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.blendMode.addEventListener(\"change\", (event)=>{\n            if (this.blendMode.blendFunction === BlendFunction.ALPHA) {\n                this.defines.set(\"ALPHA\", \"1\");\n            } else {\n                this.defines.delete(\"ALPHA\");\n            }\n            this.setChanged();\n        });\n        this.blendMode.blendFunction = blendFunction;\n        this.patternTexture = patternTexture;\n        this.xRay = xRay;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderTargetMask = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1);\n        this.renderTargetMask.samples = multisampling;\n        this.renderTargetMask.texture.name = \"Outline.Mask\";\n        this.uniforms.get(\"maskTexture\").value = this.renderTargetMask.texture;\n        this.renderTargetOutline = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetOutline.texture.name = \"Outline.Edges\";\n        this.uniforms.get(\"edgeTexture\").value = this.renderTargetOutline.texture;\n        this.clearPass = new ClearPass();\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass.overrideClearAlpha = 1;\n        this.depthPass = new DepthPass(scene, camera);\n        this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));\n        const clearPass = this.maskPass.clearPass;\n        clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        clearPass.overrideClearAlpha = 1;\n        this.blurPass = new KawaseBlurPass({\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            kernelSize\n        });\n        this.blurPass.enabled = blur;\n        const resolution = this.blurPass.resolution;\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.outlinePass = new ShaderPass(new OutlineMaterial());\n        const outlineMaterial = this.outlinePass.fullscreenMaterial;\n        outlineMaterial.inputBuffer = this.renderTargetMask.texture;\n        this.time = 0;\n        this.forceUpdate = true;\n        this.selection = new Selection();\n        this.selection.layer = 10;\n        this.pulseSpeed = pulseSpeed;\n    }\n    set mainScene(value) {\n        this.scene = value;\n        this.depthPass.mainScene = value;\n        this.maskPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.depthPass.mainCamera = value;\n        this.maskPass.mainCamera = value;\n        this.maskPass.overrideMaterial.copyCameraSettings(value);\n    }\n    /**\n   * The resolution of this effect.\n   *\n   * @type {Resolution}\n   */ get resolution() {\n        return this.blurPass.resolution;\n    }\n    /**\n   * Returns the resolution.\n   *\n   * @return {Resizer} The resolution.\n   */ getResolution() {\n        return this.blurPass.getResolution();\n    }\n    /**\n   * The amount of MSAA samples.\n   *\n   * Requires WebGL 2. Set to zero to disable multisampling.\n   *\n   * @experimental Requires three >= r138.\n   * @type {Number}\n   */ get multisampling() {\n        return this.renderTargetMask.samples;\n    }\n    set multisampling(value) {\n        this.renderTargetMask.samples = value;\n        this.renderTargetMask.dispose();\n    }\n    /**\n   * The pattern scale.\n   *\n   * @type {Number}\n   */ get patternScale() {\n        return this.uniforms.get(\"patternScale\").value;\n    }\n    set patternScale(value) {\n        this.uniforms.get(\"patternScale\").value = value;\n    }\n    /**\n   * The edge strength.\n   *\n   * @type {Number}\n   */ get edgeStrength() {\n        return this.uniforms.get(\"edgeStrength\").value;\n    }\n    set edgeStrength(value) {\n        this.uniforms.get(\"edgeStrength\").value = value;\n    }\n    /**\n   * The visible edge color.\n   *\n   * @type {Color}\n   */ get visibleEdgeColor() {\n        return this.uniforms.get(\"visibleEdgeColor\").value;\n    }\n    set visibleEdgeColor(value) {\n        this.uniforms.get(\"visibleEdgeColor\").value = value;\n    }\n    /**\n   * The hidden edge color.\n   *\n   * @type {Color}\n   */ get hiddenEdgeColor() {\n        return this.uniforms.get(\"hiddenEdgeColor\").value;\n    }\n    set hiddenEdgeColor(value) {\n        this.uniforms.get(\"hiddenEdgeColor\").value = value;\n    }\n    /**\n   * Returns the blur pass.\n   *\n   * @deprecated Use blurPass instead.\n   * @return {KawaseBlurPass} The blur pass.\n   */ getBlurPass() {\n        return this.blurPass;\n    }\n    /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * Returns the pulse speed.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @return {Number} The speed.\n   */ getPulseSpeed() {\n        return this.pulseSpeed;\n    }\n    /**\n   * Sets the pulse speed. Set to zero to disable.\n   *\n   * @deprecated Use pulseSpeed instead.\n   * @param {Number} value - The speed.\n   */ setPulseSpeed(value) {\n        this.pulseSpeed = value;\n    }\n    /**\n   * The current width of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.width instead.\n   */ get width() {\n        return this.resolution.width;\n    }\n    set width(value) {\n        this.resolution.preferredWidth = value;\n    }\n    /**\n   * The current height of the internal render targets.\n   *\n   * @type {Number}\n   * @deprecated Use resolution.height instead.\n   */ get height() {\n        return this.resolution.height;\n    }\n    set height(value) {\n        this.resolution.preferredHeight = value;\n    }\n    /**\n   * The selection layer.\n   *\n   * @type {Number}\n   * @deprecated Use selection.layer instead.\n   */ get selectionLayer() {\n        return this.selection.layer;\n    }\n    set selectionLayer(value) {\n        this.selection.layer = value;\n    }\n    /**\n   * Indicates whether dithering is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get dithering() {\n        return this.blurPass.dithering;\n    }\n    set dithering(value) {\n        this.blurPass.dithering = value;\n    }\n    /**\n   * The blur kernel size.\n   *\n   * @type {KernelSize}\n   * @deprecated Use blurPass.kernelSize instead.\n   */ get kernelSize() {\n        return this.blurPass.kernelSize;\n    }\n    set kernelSize(value) {\n        this.blurPass.kernelSize = value;\n    }\n    /**\n   * Indicates whether the outlines should be blurred.\n   *\n   * @type {Boolean}\n   * @deprecated Use blurPass.enabled instead.\n   */ get blur() {\n        return this.blurPass.enabled;\n    }\n    set blur(value) {\n        this.blurPass.enabled = value;\n    }\n    /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @type {Boolean}\n   */ get xRay() {\n        return this.defines.has(\"X_RAY\");\n    }\n    set xRay(value) {\n        if (this.xRay !== value) {\n            if (value) {\n                this.defines.set(\"X_RAY\", \"1\");\n            } else {\n                this.defines.delete(\"X_RAY\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether X-ray mode is enabled.\n   *\n   * @deprecated Use xRay instead.\n   * @return {Boolean} Whether X-ray mode is enabled.\n   */ isXRayEnabled() {\n        return this.xRay;\n    }\n    /**\n   * Enables or disables X-ray outlines.\n   *\n   * @deprecated Use xRay instead.\n   * @param {Boolean} value - Whether X-ray should be enabled.\n   */ setXRayEnabled(value) {\n        this.xRay = value;\n    }\n    /**\n   * The pattern texture. Set to `null` to disable.\n   *\n   * @type {Texture}\n   */ get patternTexture() {\n        return this.uniforms.get(\"patternTexture\").value;\n    }\n    set patternTexture(value) {\n        if (value !== null) {\n            value.wrapS = value.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            this.defines.set(\"USE_PATTERN\", \"1\");\n            this.setVertexShader(outline_default4);\n        } else {\n            this.defines.delete(\"USE_PATTERN\");\n            this.setVertexShader(null);\n        }\n        this.uniforms.get(\"patternTexture\").value = value;\n        this.setChanged();\n    }\n    /**\n   * Sets the pattern texture.\n   *\n   * @deprecated Use patternTexture instead.\n   * @param {Texture} value - The new texture.\n   */ setPatternTexture(value) {\n        this.patternTexture = value;\n    }\n    /**\n   * Returns the current resolution scale.\n   *\n   * @return {Number} The resolution scale.\n   * @deprecated Use resolution instead.\n   */ getResolutionScale() {\n        return this.resolution.scale;\n    }\n    /**\n   * Sets the resolution scale.\n   *\n   * @param {Number} scale - The new resolution scale.\n   * @deprecated Use resolution instead.\n   */ setResolutionScale(scale) {\n        this.resolution.scale = scale;\n    }\n    /**\n   * Clears the current selection and selects a list of objects.\n   *\n   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.set() instead.\n   */ setSelection(objects) {\n        this.selection.set(objects);\n        return this;\n    }\n    /**\n   * Clears the list of selected objects.\n   *\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.clear() instead.\n   */ clearSelection() {\n        this.selection.clear();\n        return this;\n    }\n    /**\n   * Selects an object.\n   *\n   * @param {Object3D} object - The object that should be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.add() instead.\n   */ selectObject(object) {\n        this.selection.add(object);\n        return this;\n    }\n    /**\n   * Deselects an object.\n   *\n   * @param {Object3D} object - The object that should no longer be outlined.\n   * @return {OutlinePass} This pass.\n   * @deprecated Use selection.delete() instead.\n   */ deselectObject(object) {\n        this.selection.delete(object);\n        return this;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const scene = this.scene;\n        const camera = this.camera;\n        const selection = this.selection;\n        const uniforms = this.uniforms;\n        const pulse = uniforms.get(\"pulse\");\n        const background = scene.background;\n        const mask = camera.layers.mask;\n        if (this.forceUpdate || selection.size > 0) {\n            scene.background = null;\n            pulse.value = 1;\n            if (this.pulseSpeed > 0) {\n                pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;\n            }\n            this.time += deltaTime;\n            selection.setVisible(false);\n            this.depthPass.render(renderer);\n            selection.setVisible(true);\n            camera.layers.set(selection.layer);\n            this.maskPass.render(renderer, this.renderTargetMask);\n            camera.layers.mask = mask;\n            scene.background = background;\n            this.outlinePass.render(renderer, null, this.renderTargetOutline);\n            if (this.blurPass.enabled) {\n                this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);\n            }\n        }\n        this.forceUpdate = selection.size > 0;\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.blurPass.setSize(width, height);\n        this.renderTargetMask.setSize(width, height);\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.depthPass.setSize(w, h);\n        this.renderTargetOutline.setSize(w, h);\n        this.outlinePass.fullscreenMaterial.setSize(w, h);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);\n        if (frameBufferType !== void 0) {\n            this.depthPass.initialize(renderer, alpha, frameBufferType);\n            this.maskPass.initialize(renderer, alpha, frameBufferType);\n            this.outlinePass.initialize(renderer, alpha, frameBufferType);\n        }\n    }\n};\n// src/effects/PixelationEffect.js\n\n// src/effects/glsl/pixelation.frag\nvar pixelation_default = \"uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}\";\n// src/effects/PixelationEffect.js\nvar PixelationEffect = class extends Effect {\n    /**\n   * Constructs a new pixelation effect.\n   *\n   * @param {Object} [granularity=30.0] - The pixel granularity.\n   */ constructor(granularity = 30){\n        super(\"PixelationEffect\", pixelation_default, {\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"d\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector4())\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this._granularity = 0;\n        this.granularity = granularity;\n    }\n    /**\n   * The pixel granularity.\n   *\n   * A higher value yields coarser visuals.\n   *\n   * @type {Number}\n   */ get granularity() {\n        return this._granularity;\n    }\n    set granularity(value) {\n        let d = Math.floor(value);\n        if (d % 2 > 0) {\n            d += 1;\n        }\n        this._granularity = d;\n        this.uniforms.get(\"active\").value = d > 0;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @return {Number} The granularity.\n   */ getGranularity() {\n        return this.granularity;\n    }\n    /**\n   * Sets the pixel granularity.\n   *\n   * @deprecated Use granularity instead.\n   * @param {Number} value - The new granularity.\n   */ setGranularity(value) {\n        this.granularity = value;\n    }\n    /**\n   * Updates the granularity.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.set(width, height);\n        const d = this.granularity;\n        const x = d / resolution.x;\n        const y = d / resolution.y;\n        this.uniforms.get(\"d\").value.set(x, y, 1 / x, 1 / y);\n    }\n};\n// src/effects/RealisticBokehEffect.js\n\n// src/effects/glsl/realistic-bokeh.frag\nvar realistic_bokeh_default = \"uniform float focus;uniform float focalLength;uniform float fStop;uniform float maxBlur;uniform float luminanceThreshold;uniform float luminanceGain;uniform float bias;uniform float fringe;\\n#ifdef MANUAL_DOF\\nuniform vec4 dof;\\n#endif\\n#ifdef PENTAGON\\nfloat pentagon(const in vec2 coords){const vec4 HS0=vec4(1.0,0.0,0.0,1.0);const vec4 HS1=vec4(0.309016994,0.951056516,0.0,1.0);const vec4 HS2=vec4(-0.809016994,0.587785252,0.0,1.0);const vec4 HS3=vec4(-0.809016994,-0.587785252,0.0,1.0);const vec4 HS4=vec4(0.309016994,-0.951056516,0.0,1.0);const vec4 HS5=vec4(0.0,0.0,1.0,1.0);const vec4 ONE=vec4(1.0);const float P_FEATHER=0.4;const float N_FEATHER=-P_FEATHER;float inOrOut=-4.0;vec4 P=vec4(coords,vec2(RINGS_FLOAT-1.3));vec4 dist=vec4(dot(P,HS0),dot(P,HS1),dot(P,HS2),dot(P,HS3));dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dot(dist,ONE);dist.x=dot(P,HS4);dist.y=HS5.w-abs(P.z);dist=smoothstep(N_FEATHER,P_FEATHER,dist);inOrOut+=dist.x;return clamp(inOrOut,0.0,1.0);}\\n#endif\\nvec3 processTexel(const in vec2 coords,const in float blur){vec2 scale=texelSize*fringe*blur;vec3 c=vec3(texture2D(inputBuffer,coords+vec2(0.0,1.0)*scale).r,texture2D(inputBuffer,coords+vec2(-0.866,-0.5)*scale).g,texture2D(inputBuffer,coords+vec2(0.866,-0.5)*scale).b);float luminance=linearToRelativeLuminance(c);float threshold=max((luminance-luminanceThreshold)*luminanceGain,0.0);return c+mix(vec3(0.0),c,threshold*blur);}float gather(const in float i,const in float j,const in float ringSamples,const in vec2 uv,const in vec2 blurFactor,const in float blur,inout vec3 color){float step=PI2/ringSamples;vec2 wh=vec2(cos(j*step)*i,sin(j*step)*i);\\n#ifdef PENTAGON\\nfloat p=pentagon(wh);\\n#else\\nfloat p=1.0;\\n#endif\\ncolor+=processTexel(wh*blurFactor+uv,blur)*mix(1.0,i/RINGS_FLOAT,bias)*p;return mix(1.0,i/RINGS_FLOAT,bias)*p;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\\n#ifdef PERSPECTIVE_CAMERA\\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\\n#else\\nfloat linearDepth=depth;\\n#endif\\n#ifdef MANUAL_DOF\\nfloat focalPlane=linearDepth-focus;float farDoF=(focalPlane-dof.z)/dof.w;float nearDoF=(-focalPlane-dof.x)/dof.y;float blur=(focalPlane>0.0)?farDoF:nearDoF;\\n#else\\nconst float CIRCLE_OF_CONFUSION=0.03;float focalPlaneMM=focus*1000.0;float depthMM=linearDepth*1000.0;float focalPlane=(depthMM*focalLength)/(depthMM-focalLength);float farDoF=(focalPlaneMM*focalLength)/(focalPlaneMM-focalLength);float nearDoF=(focalPlaneMM-focalLength)/(focalPlaneMM*fStop*CIRCLE_OF_CONFUSION);float blur=abs(focalPlane-farDoF)*nearDoF;\\n#endif\\nconst int MAX_RING_SAMPLES=RINGS_INT*SAMPLES_INT;blur=clamp(blur,0.0,1.0);vec3 color=inputColor.rgb;if(blur>=0.05){vec2 blurFactor=blur*maxBlur*texelSize;float s=1.0;int ringSamples;for(int i=1;i<=RINGS_INT;i++){ringSamples=i*SAMPLES_INT;for(int j=0;j<MAX_RING_SAMPLES;j++){if(j>=ringSamples){break;}s+=gather(float(i),float(j),float(ringSamples),uv,blurFactor,blur,color);}}color/=s;}\\n#ifdef SHOW_FOCUS\\nfloat edge=0.002*linearDepth;float m=clamp(smoothstep(0.0,edge,blur),0.0,1.0);float e=clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);color=mix(color,vec3(1.0,0.5,0.0),(1.0-m)*0.6);color=mix(color,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n// src/effects/RealisticBokehEffect.js\nvar RealisticBokehEffect = class extends Effect {\n    /**\n   * Constructs a new bokeh effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.focus=1.0] - The focus distance in world units.\n   * @param {Number} [options.focalLength=24.0] - The focal length of the main camera.\n   * @param {Number} [options.fStop=0.9] - The ratio of the lens focal length to the diameter of the entrance pupil (aperture).\n   * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.\n   * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.\n   * @param {Number} [options.bias=0.5] - A blur bias.\n   * @param {Number} [options.fringe=0.7] - A blur offset.\n   * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.\n   * @param {Boolean} [options.rings=3] - The number of blur iterations.\n   * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.\n   * @param {Boolean} [options.showFocus=false] - Whether the focal point should be highlighted. Useful for debugging.\n   * @param {Boolean} [options.manualDoF=false] - Enables manual control over the depth of field.\n   * @param {Boolean} [options.pentagon=false] - Enables pentagonal blur shapes. Requires a high number of rings and samples.\n   */ constructor({ blendFunction, focus = 1, focalLength = 24, fStop = 0.9, luminanceThreshold = 0.5, luminanceGain = 2, bias = 0.5, fringe = 0.7, maxBlur = 1, rings = 3, samples = 2, showFocus = false, manualDoF = false, pentagon = false } = {}){\n        super(\"RealisticBokehEffect\", realistic_bokeh_default, {\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"focus\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focus)\n                ],\n                [\n                    \"focalLength\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(focalLength)\n                ],\n                [\n                    \"fStop\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fStop)\n                ],\n                [\n                    \"luminanceThreshold\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceThreshold)\n                ],\n                [\n                    \"luminanceGain\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceGain)\n                ],\n                [\n                    \"bias\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(bias)\n                ],\n                [\n                    \"fringe\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(fringe)\n                ],\n                [\n                    \"maxBlur\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxBlur)\n                ],\n                [\n                    \"dof\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.rings = rings;\n        this.samples = samples;\n        this.showFocus = showFocus;\n        this.manualDoF = manualDoF;\n        this.pentagon = pentagon;\n    }\n    /**\n   * The amount of blur iterations.\n   *\n   * @type {Number}\n   */ get rings() {\n        return Number.parseInt(this.defines.get(\"RINGS_INT\"));\n    }\n    set rings(value) {\n        const r = Math.floor(value);\n        this.defines.set(\"RINGS_INT\", r.toFixed(0));\n        this.defines.set(\"RINGS_FLOAT\", r.toFixed(1));\n        this.setChanged();\n    }\n    /**\n   * The amount of blur samples per ring.\n   *\n   * @type {Number}\n   */ get samples() {\n        return Number.parseInt(this.defines.get(\"SAMPLES_INT\"));\n    }\n    set samples(value) {\n        const s = Math.floor(value);\n        this.defines.set(\"SAMPLES_INT\", s.toFixed(0));\n        this.defines.set(\"SAMPLES_FLOAT\", s.toFixed(1));\n        this.setChanged();\n    }\n    /**\n   * Indicates whether the focal point will be highlighted.\n   *\n   * @type {Boolean}\n   */ get showFocus() {\n        return this.defines.has(\"SHOW_FOCUS\");\n    }\n    set showFocus(value) {\n        if (this.showFocus !== value) {\n            if (value) {\n                this.defines.set(\"SHOW_FOCUS\", \"1\");\n            } else {\n                this.defines.delete(\"SHOW_FOCUS\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the Depth of Field should be calculated manually.\n   *\n   * If enabled, the Depth of Field can be adjusted via the `dof` uniform.\n   *\n   * @type {Boolean}\n   */ get manualDoF() {\n        return this.defines.has(\"MANUAL_DOF\");\n    }\n    set manualDoF(value) {\n        if (this.manualDoF !== value) {\n            if (value) {\n                this.defines.set(\"MANUAL_DOF\", \"1\");\n                this.uniforms.get(\"dof\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4(0.2, 1, 0.2, 2);\n            } else {\n                this.defines.delete(\"MANUAL_DOF\");\n                this.uniforms.get(\"dof\").value = null;\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the blur shape should be pentagonal.\n   *\n   * @type {Boolean}\n   */ get pentagon() {\n        return this.defines.has(\"PENTAGON\");\n    }\n    set pentagon(value) {\n        if (this.pentagon !== value) {\n            if (value) {\n                this.defines.set(\"PENTAGON\", \"1\");\n            } else {\n                this.defines.delete(\"PENTAGON\");\n            }\n            this.setChanged();\n        }\n    }\n};\n// src/effects/ScanlineEffect.js\n\n// src/effects/glsl/scanlines.frag\nvar scanlines_default = \"uniform float count;\\n#ifdef SCROLL\\nuniform float scrollSpeed;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\\n#ifdef SCROLL\\ny+=time*scrollSpeed;\\n#endif\\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}\";\n// src/effects/ScanlineEffect.js\nvar ScanlineEffect = class extends Effect {\n    /**\n   * Constructs a new scanline effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.OVERLAY] - The blend function of this effect.\n   * @param {Number} [options.density=1.25] - The scanline density.\n   * @param {Number} [options.scrollSpeed=0.0] - The scanline scroll speed.\n   */ constructor({ blendFunction = BlendFunction.OVERLAY, density = 1.25, scrollSpeed = 0 } = {}){\n        super(\"ScanlineEffect\", scanlines_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"count\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ],\n                [\n                    \"scrollSpeed\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ]\n            ])\n        });\n        this.resolution = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.d = density;\n        this.scrollSpeed = scrollSpeed;\n    }\n    /**\n   * The scanline density.\n   *\n   * @type {Number}\n   */ get density() {\n        return this.d;\n    }\n    set density(value) {\n        this.d = value;\n        this.setSize(this.resolution.width, this.resolution.height);\n    }\n    /**\n   * Returns the current scanline density.\n   *\n   * @deprecated Use density instead.\n   * @return {Number} The scanline density.\n   */ getDensity() {\n        return this.density;\n    }\n    /**\n   * Sets the scanline density.\n   *\n   * @deprecated Use density instead.\n   * @param {Number} value - The new scanline density.\n   */ setDensity(value) {\n        this.density = value;\n    }\n    /**\n   * The scanline scroll speed. Default is 0 (disabled).\n   *\n   * @type {Number}\n   */ get scrollSpeed() {\n        return this.uniforms.get(\"scrollSpeed\").value;\n    }\n    set scrollSpeed(value) {\n        this.uniforms.get(\"scrollSpeed\").value = value;\n        if (value === 0) {\n            if (this.defines.delete(\"SCROLL\")) {\n                this.setChanged();\n            }\n        } else if (!this.defines.has(\"SCROLL\")) {\n            this.defines.set(\"SCROLL\", \"1\");\n            this.setChanged();\n        }\n    }\n    /**\n   * Updates the size of this pass.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.resolution.set(width, height);\n        this.uniforms.get(\"count\").value = Math.round(height * this.density);\n    }\n};\n// src/effects/ShockWaveEffect.js\n\n// src/effects/glsl/shock-wave.frag\nvar shock_wave_default = \"uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}\";\n// src/effects/glsl/shock-wave.vert\nvar shock_wave_default2 = \"uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}\";\n// src/effects/ShockWaveEffect.js\nvar HALF_PI = Math.PI * 0.5;\nvar v2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ab = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar ShockWaveEffect = class extends Effect {\n    /**\n   * Constructs a new shock wave effect.\n   *\n   * @param {Camera} camera - The main camera.\n   * @param {Vector3} [position] - The world position of the shock wave.\n   * @param {Object} [options] - The options.\n   * @param {Number} [options.speed=2.0] - The animation speed.\n   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.\n   * @param {Number} [options.waveSize=0.2] - The wave size.\n   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.\n   */ constructor(camera, position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), { speed = 2, maxRadius = 1, waveSize = 0.2, amplitude = 0.05 } = {}){\n        super(\"ShockWaveEffect\", shock_wave_default, {\n            vertexShader: shock_wave_default2,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"active\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(false)\n                ],\n                [\n                    \"center\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5))\n                ],\n                [\n                    \"cameraDistance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"size\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"radius\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(-waveSize)\n                ],\n                [\n                    \"maxRadius\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxRadius)\n                ],\n                [\n                    \"waveSize\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(waveSize)\n                ],\n                [\n                    \"amplitude\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(amplitude)\n                ]\n            ])\n        });\n        this.position = position;\n        this.speed = speed;\n        this.camera = camera;\n        this.screenPosition = this.uniforms.get(\"center\").value;\n        this.time = 0;\n        this.active = false;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n    }\n    /**\n   * The amplitude.\n   *\n   * @type {Number}\n   */ get amplitude() {\n        return this.uniforms.get(\"amplitude\").value;\n    }\n    set amplitude(value) {\n        this.uniforms.get(\"amplitude\").value = value;\n    }\n    /**\n   * The wave size.\n   *\n   * @type {Number}\n   */ get waveSize() {\n        return this.uniforms.get(\"waveSize\").value;\n    }\n    set waveSize(value) {\n        this.uniforms.get(\"waveSize\").value = value;\n    }\n    /**\n   * The maximum radius.\n   *\n   * @type {Number}\n   */ get maxRadius() {\n        return this.uniforms.get(\"maxRadius\").value;\n    }\n    set maxRadius(value) {\n        this.uniforms.get(\"maxRadius\").value = value;\n    }\n    /**\n   * The position of the shock wave.\n   *\n   * @type {Vector3}\n   * @deprecated Use position instead.\n   */ get epicenter() {\n        return this.position;\n    }\n    set epicenter(value) {\n        this.position = value;\n    }\n    /**\n   * Returns the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @return {Vector3} The position.\n   */ getPosition() {\n        return this.position;\n    }\n    /**\n   * Sets the position of the shock wave.\n   *\n   * @deprecated Use position instead.\n   * @param {Vector3} value - The position.\n   */ setPosition(value) {\n        this.position = value;\n    }\n    /**\n   * Returns the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @return {Number} The speed.\n   */ getSpeed() {\n        return this.speed;\n    }\n    /**\n   * Sets the speed of the shock wave.\n   *\n   * @deprecated Use speed instead.\n   * @param {Number} value - The speed.\n   */ setSpeed(value) {\n        this.speed = value;\n    }\n    /**\n   * Emits the shock wave.\n   */ explode() {\n        this.time = 0;\n        this.active = true;\n        this.uniforms.get(\"active\").value = true;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [delta] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, delta) {\n        const position = this.position;\n        const camera = this.camera;\n        const uniforms = this.uniforms;\n        const uActive = uniforms.get(\"active\");\n        if (this.active) {\n            const waveSize = uniforms.get(\"waveSize\").value;\n            camera.getWorldDirection(v2);\n            ab.copy(camera.position).sub(position);\n            uActive.value = v2.angleTo(ab) > HALF_PI;\n            if (uActive.value) {\n                uniforms.get(\"cameraDistance\").value = camera.position.distanceTo(position);\n                v2.copy(position).project(camera);\n                this.screenPosition.set((v2.x + 1) * 0.5, (v2.y + 1) * 0.5);\n            }\n            this.time += delta * this.speed;\n            const radius = this.time - waveSize;\n            uniforms.get(\"radius\").value = radius;\n            if (radius >= (uniforms.get(\"maxRadius\").value + waveSize) * 2) {\n                this.active = false;\n                uActive.value = false;\n            }\n        }\n    }\n};\n// src/effects/SelectiveBloomEffect.js\n\nvar SelectiveBloomEffect = class extends BloomEffect {\n    /**\n   * Constructs a new selective bloom effect.\n   *\n   * @param {Scene} scene - The main scene.\n   * @param {Camera} camera - The main camera.\n   * @param {Object} [options] - The options. See {@link BloomEffect} for details.\n   */ constructor(scene, camera, options){\n        super(options);\n        this.setAttributes(this.getAttributes() | EffectAttribute.DEPTH);\n        this.camera = camera;\n        this.depthPass = new DepthPass(scene, camera);\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.depthMaskPass = new ShaderPass(new DepthMaskMaterial());\n        const depthMaskMaterial = this.depthMaskMaterial;\n        depthMaskMaterial.copyCameraSettings(camera);\n        depthMaskMaterial.depthBuffer1 = this.depthPass.texture;\n        depthMaskMaterial.depthPacking1 = three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking;\n        depthMaskMaterial.depthMode = three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n        this.renderTargetMasked = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetMasked.texture.name = \"Bloom.Masked\";\n        this.selection = new Selection();\n        this.selection.layer = 11;\n        this._inverted = false;\n        this._ignoreBackground = false;\n    }\n    set mainScene(value) {\n        this.depthPass.mainScene = value;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.depthPass.mainCamera = value;\n        this.depthMaskMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Returns the selection.\n   *\n   * @deprecated Use selection instead.\n   * @return {Selection} The selection.\n   */ getSelection() {\n        return this.selection;\n    }\n    /**\n   * The depth mask material.\n   *\n   * @type {DepthMaskMaterial}\n   * @private\n   */ get depthMaskMaterial() {\n        return this.depthMaskPass.fullscreenMaterial;\n    }\n    /**\n   * Indicates whether the selection should be considered inverted.\n   *\n   * @type {Boolean}\n   */ get inverted() {\n        return this._inverted;\n    }\n    set inverted(value) {\n        this._inverted = value;\n        this.depthMaskMaterial.depthMode = value ? three__WEBPACK_IMPORTED_MODULE_0__.NotEqualDepth : three__WEBPACK_IMPORTED_MODULE_0__.EqualDepth;\n    }\n    /**\n   * Indicates whether the mask is inverted.\n   *\n   * @deprecated Use inverted instead.\n   * @return {Boolean} Whether the mask is inverted.\n   */ isInverted() {\n        return this.inverted;\n    }\n    /**\n   * Enables or disable mask inversion.\n   *\n   * @deprecated Use inverted instead.\n   * @param {Boolean} value - Whether the mask should be inverted.\n   */ setInverted(value) {\n        this.inverted = value;\n    }\n    /**\n   * Indicates whether the background colors will be ignored.\n   *\n   * @type {Boolean}\n   */ get ignoreBackground() {\n        return this._ignoreBackground;\n    }\n    set ignoreBackground(value) {\n        this._ignoreBackground = value;\n        this.depthMaskMaterial.maxDepthStrategy = value ? DepthTestStrategy.DISCARD_MAX_DEPTH : DepthTestStrategy.KEEP_MAX_DEPTH;\n    }\n    /**\n   * Indicates whether the background is disabled.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @return {Boolean} Whether the background is disabled.\n   */ isBackgroundDisabled() {\n        return this.ignoreBackground;\n    }\n    /**\n   * Enables or disables the background.\n   *\n   * @deprecated Use ignoreBackground instead.\n   * @param {Boolean} value - Whether the background should be disabled.\n   */ setBackgroundDisabled(value) {\n        this.ignoreBackground = value;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthMaskMaterial.depthBuffer0 = depthTexture;\n        this.depthMaskMaterial.depthPacking0 = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const camera = this.camera;\n        const selection = this.selection;\n        const inverted = this.inverted;\n        let renderTarget = inputBuffer;\n        if (this.ignoreBackground || !inverted || selection.size > 0) {\n            const mask = camera.layers.mask;\n            camera.layers.set(selection.layer);\n            this.depthPass.render(renderer);\n            camera.layers.mask = mask;\n            renderTarget = this.renderTargetMasked;\n            this.clearPass.render(renderer, renderTarget);\n            this.depthMaskPass.render(renderer, inputBuffer, renderTarget);\n        }\n        super.update(renderer, renderTarget, deltaTime);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        super.setSize(width, height);\n        this.renderTargetMasked.setSize(width, height);\n        this.depthPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        super.initialize(renderer, alpha, frameBufferType);\n        this.clearPass.initialize(renderer, alpha, frameBufferType);\n        this.depthPass.initialize(renderer, alpha, frameBufferType);\n        this.depthMaskPass.initialize(renderer, alpha, frameBufferType);\n        if (renderer.capabilities.logarithmicDepthBuffer) {\n            this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = \"1\";\n        }\n        if (frameBufferType !== void 0) {\n            this.renderTargetMasked.texture.type = frameBufferType;\n            if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTargetMasked.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/effects/SepiaEffect.js\n\n// src/effects/glsl/sepia.frag\nvar sepia_default = \"uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}\";\n// src/effects/SepiaEffect.js\nvar SepiaEffect = class extends Effect {\n    /**\n   * Constructs a new sepia effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.intensity=1.0] - The intensity of the effect.\n   */ constructor({ blendFunction, intensity = 1 } = {}){\n        super(\"SepiaEffect\", sepia_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"weightsR\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.393, 0.769, 0.189))\n                ],\n                [\n                    \"weightsG\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.349, 0.686, 0.168))\n                ],\n                [\n                    \"weightsB\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.272, 0.534, 0.131))\n                ]\n            ])\n        });\n    }\n    /**\n   * The intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @type {Number}\n   */ get intensity() {\n        return this.blendMode.opacity.value;\n    }\n    set intensity(value) {\n        this.blendMode.opacity.value = value;\n    }\n    /**\n   * Returns the current sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @return {Number} The intensity.\n   */ getIntensity() {\n        return this.intensity;\n    }\n    /**\n   * Sets the sepia intensity.\n   *\n   * @deprecated Use blendMode.opacity instead.\n   * @param {Number} value - The intensity.\n   */ setIntensity(value) {\n        this.intensity = value;\n    }\n    /**\n   * The weights for the red channel. Default is `(0.393, 0.769, 0.189)`.\n   *\n   * @type {Vector3}\n   */ get weightsR() {\n        return this.uniforms.get(\"weightsR\").value;\n    }\n    /**\n   * The weights for the green channel. Default is `(0.349, 0.686, 0.168)`.\n   *\n   * @type {Vector3}\n   */ get weightsG() {\n        return this.uniforms.get(\"weightsG\").value;\n    }\n    /**\n   * The weights for the blue channel. Default is `(0.272, 0.534, 0.131)`.\n   *\n   * @type {Vector3}\n   */ get weightsB() {\n        return this.uniforms.get(\"weightsB\").value;\n    }\n};\n// src/effects/SMAAEffect.js\n\n// src/textures/smaa/searchImageDataURL.js\nvar searchImageDataURL_default = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC\";\n// src/textures/smaa/areaImageDataURL.js\nvar areaImageDataURL_default = \"data:image/png;base64,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\";\n// src/effects/glsl/smaa.frag\nvar smaa_default = \"uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}\";\n// src/effects/glsl/smaa.vert\nvar smaa_default2 = \"varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}\";\n// src/effects/SMAAEffect.js\nvar SMAAEffect = class extends Effect {\n    /**\n   * Constructs a new SMAA effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.\n   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.\n   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.\n   */ constructor({ blendFunction = BlendFunction.SRC, preset = SMAAPreset.MEDIUM, edgeDetectionMode = EdgeDetectionMode.COLOR, predicationMode = PredicationMode.DISABLED } = {}){\n        super(\"SMAAEffect\", smaa_default, {\n            vertexShader: smaa_default2,\n            blendFunction,\n            attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"weightMap\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        let searchImage, areaImage;\n        if (arguments.length > 1) {\n            searchImage = arguments[0];\n            areaImage = arguments[1];\n            if (arguments.length > 2) {\n                preset = arguments[2];\n            }\n            if (arguments.length > 3) {\n                edgeDetectionMode = arguments[3];\n            }\n        }\n        this.renderTargetEdges = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTargetEdges.texture.name = \"SMAA.Edges\";\n        this.renderTargetWeights = this.renderTargetEdges.clone();\n        this.renderTargetWeights.texture.name = \"SMAA.Weights\";\n        this.uniforms.get(\"weightMap\").value = this.renderTargetWeights.texture;\n        this.clearPass = new ClearPass(true, false, false);\n        this.clearPass.overrideClearColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0);\n        this.clearPass.overrideClearAlpha = 1;\n        this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());\n        this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;\n        this.edgeDetectionMaterial.predicationMode = predicationMode;\n        this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());\n        const loadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        loadingManager.onLoad = ()=>{\n            const searchTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(searchImage);\n            searchTexture.name = \"SMAA.Search\";\n            searchTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            searchTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            searchTexture.generateMipmaps = false;\n            searchTexture.needsUpdate = true;\n            searchTexture.flipY = true;\n            this.weightsMaterial.searchTexture = searchTexture;\n            const areaTexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(areaImage);\n            areaTexture.name = \"SMAA.Area\";\n            areaTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            areaTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            areaTexture.generateMipmaps = false;\n            areaTexture.needsUpdate = true;\n            areaTexture.flipY = false;\n            this.weightsMaterial.areaTexture = areaTexture;\n            this.dispatchEvent({\n                type: \"load\"\n            });\n        };\n        loadingManager.itemStart(\"search\");\n        loadingManager.itemStart(\"area\");\n        if (searchImage !== void 0 && areaImage !== void 0) {\n            loadingManager.itemEnd(\"search\");\n            loadingManager.itemEnd(\"area\");\n        } else if (typeof Image !== \"undefined\") {\n            searchImage = new Image();\n            areaImage = new Image();\n            searchImage.addEventListener(\"load\", ()=>loadingManager.itemEnd(\"search\"));\n            areaImage.addEventListener(\"load\", ()=>loadingManager.itemEnd(\"area\"));\n            searchImage.src = searchImageDataURL_default;\n            areaImage.src = areaImageDataURL_default;\n        }\n        this.applyPreset(preset);\n    }\n    /**\n   * The edges texture.\n   *\n   * @type {Texture}\n   */ get edgesTexture() {\n        return this.renderTargetEdges.texture;\n    }\n    /**\n   * Returns the edges texture.\n   *\n   * @deprecated Use edgesTexture instead.\n   * @return {Texture} The texture.\n   */ getEdgesTexture() {\n        return this.edgesTexture;\n    }\n    /**\n   * The edge weights texture.\n   *\n   * @type {Texture}\n   */ get weightsTexture() {\n        return this.renderTargetWeights.texture;\n    }\n    /**\n   * Returns the edge weights texture.\n   *\n   * @deprecated Use weightsTexture instead.\n   * @return {Texture} The texture.\n   */ getWeightsTexture() {\n        return this.weightsTexture;\n    }\n    /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   */ get edgeDetectionMaterial() {\n        return this.edgeDetectionPass.fullscreenMaterial;\n    }\n    /**\n   * The edge detection material.\n   *\n   * @type {EdgeDetectionMaterial}\n   * @deprecated Use edgeDetectionMaterial instead.\n   */ get colorEdgesMaterial() {\n        return this.edgeDetectionMaterial;\n    }\n    /**\n   * Returns the edge detection material.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @return {EdgeDetectionMaterial} The material.\n   */ getEdgeDetectionMaterial() {\n        return this.edgeDetectionMaterial;\n    }\n    /**\n   * The edge weights material.\n   *\n   * @type {SMAAWeightsMaterial}\n   */ get weightsMaterial() {\n        return this.weightsPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the edge weights material.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @return {SMAAWeightsMaterial} The material.\n   */ getWeightsMaterial() {\n        return this.weightsMaterial;\n    }\n    /**\n   * Sets the edge detection sensitivity.\n   *\n   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.\n   *\n   * @deprecated Use edgeDetectionMaterial instead.\n   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].\n   */ setEdgeDetectionThreshold(threshold) {\n        this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;\n    }\n    /**\n   * Sets the maximum amount of horizontal/vertical search steps.\n   *\n   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.\n   *\n   * @deprecated Use weightsMaterial instead.\n   * @param {Number} steps - The search steps. Range: [0, 112].\n   */ setOrthogonalSearchSteps(steps) {\n        this.weightsMaterial.orthogonalSearchSteps = steps;\n    }\n    /**\n   * Applies the given quality preset.\n   *\n   * @param {SMAAPreset} preset - The preset.\n   */ applyPreset(preset) {\n        const edgeDetectionMaterial = this.edgeDetectionMaterial;\n        const weightsMaterial = this.weightsMaterial;\n        switch(preset){\n            case SMAAPreset.LOW:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.15;\n                weightsMaterial.orthogonalSearchSteps = 4;\n                weightsMaterial.diagonalDetection = false;\n                weightsMaterial.cornerDetection = false;\n                break;\n            case SMAAPreset.MEDIUM:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n                weightsMaterial.orthogonalSearchSteps = 8;\n                weightsMaterial.diagonalDetection = false;\n                weightsMaterial.cornerDetection = false;\n                break;\n            case SMAAPreset.HIGH:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.1;\n                weightsMaterial.orthogonalSearchSteps = 16;\n                weightsMaterial.diagonalSearchSteps = 8;\n                weightsMaterial.cornerRounding = 25;\n                weightsMaterial.diagonalDetection = true;\n                weightsMaterial.cornerDetection = true;\n                break;\n            case SMAAPreset.ULTRA:\n                edgeDetectionMaterial.edgeDetectionThreshold = 0.05;\n                weightsMaterial.orthogonalSearchSteps = 32;\n                weightsMaterial.diagonalSearchSteps = 16;\n                weightsMaterial.cornerRounding = 25;\n                weightsMaterial.diagonalDetection = true;\n                weightsMaterial.cornerDetection = true;\n                break;\n        }\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.edgeDetectionMaterial.depthBuffer = depthTexture;\n        this.edgeDetectionMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        this.clearPass.render(renderer, this.renderTargetEdges);\n        this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);\n        this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        this.edgeDetectionMaterial.setSize(width, height);\n        this.weightsMaterial.setSize(width, height);\n        this.renderTargetEdges.setSize(width, height);\n        this.renderTargetWeights.setSize(width, height);\n    }\n    /**\n   * Deletes internal render targets and textures.\n   */ dispose() {\n        const { searchTexture, areaTexture } = this.weightsMaterial;\n        if (searchTexture !== null && areaTexture !== null) {\n            searchTexture.dispose();\n            areaTexture.dispose();\n        }\n        super.dispose();\n    }\n    /**\n   * The SMAA search image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */ static get searchImageDataURL() {\n        return searchImageDataURL_default;\n    }\n    /**\n   * The SMAA area image, encoded as a base64 data URL.\n   *\n   * @type {String}\n   * @deprecated\n   */ static get areaImageDataURL() {\n        return areaImageDataURL_default;\n    }\n};\n// src/effects/SSAOEffect.js\n\n// src/effects/glsl/ssao.frag\nvar ssao_default3 = \"uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nuniform highp sampler2D normalDepthBuffer;\\n#else\\nuniform mediump sampler2D normalDepthBuffer;\\n#endif\\n#endif\\n#ifdef COLORIZE\\nuniform vec3 color;\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\\n#else\\nfloat ao=aoLinear;\\n#endif\\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\\n#ifdef COLORIZE\\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\\n#else\\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\\n#endif\\n}\";\n// src/effects/SSAOEffect.js\nvar NOISE_TEXTURE_SIZE = 64;\nvar SSAOEffect = class extends Effect {\n    /**\n   * Constructs a new SSAO effect.\n   *\n   * @todo Move normalBuffer to options.\n   * @param {Camera} [camera] - The main camera.\n   * @param {Texture} [normalBuffer] - A texture that contains the scene normals.\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.\n   * @param {Boolean} [options.distanceScaling=true] - Deprecated.\n   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.\n   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.\n   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.\n   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.\n   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.\n   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.\n   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.\n   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.\n   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.\n   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.\n   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.\n   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.\n   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.\n   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.\n   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].\n   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.\n   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.\n   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.\n   * @param {Color} [options.color=null] - The color of the ambient occlusion.\n   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.\n   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.\n   */ constructor(camera, normalBuffer, { blendFunction = BlendFunction.MULTIPLY, samples = 9, rings = 7, normalDepthBuffer = null, depthAwareUpsampling = true, worldDistanceThreshold, worldDistanceFalloff, worldProximityThreshold, worldProximityFalloff, distanceThreshold = 0.97, distanceFalloff = 0.03, rangeThreshold = 5e-4, rangeFalloff = 1e-3, minRadiusScale = 0.1, luminanceInfluence = 0.7, radius = 0.1825, intensity = 1, bias = 0.025, fade = 0.01, color: color2 = null, resolutionScale = 1, width = Resolution.AUTO_SIZE, height = Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height } = {}){\n        super(\"SSAOEffect\", ssao_default3, {\n            blendFunction,\n            attributes: EffectAttribute.DEPTH,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"THRESHOLD\",\n                    \"0.997\"\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"aoBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"normalDepthBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(normalDepthBuffer)\n                ],\n                [\n                    \"luminanceInfluence\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(luminanceInfluence)\n                ],\n                [\n                    \"color\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"intensity\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(intensity)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)\n                ]\n            ])\n        });\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"AO.Target\";\n        this.uniforms.get(\"aoBuffer\").value = this.renderTarget.texture;\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.camera = camera;\n        this.depthDownsamplingPass = new DepthDownsamplingPass({\n            normalBuffer,\n            resolutionScale\n        });\n        this.depthDownsamplingPass.enabled = normalDepthBuffer === null;\n        this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));\n        const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat);\n        noiseTexture.wrapS = noiseTexture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n        const ssaoMaterial = this.ssaoMaterial;\n        ssaoMaterial.normalBuffer = normalBuffer;\n        ssaoMaterial.noiseTexture = noiseTexture;\n        ssaoMaterial.minRadiusScale = minRadiusScale;\n        ssaoMaterial.samples = samples;\n        ssaoMaterial.radius = radius;\n        ssaoMaterial.rings = rings;\n        ssaoMaterial.fade = fade;\n        ssaoMaterial.bias = bias;\n        ssaoMaterial.distanceThreshold = distanceThreshold;\n        ssaoMaterial.distanceFalloff = distanceFalloff;\n        ssaoMaterial.proximityThreshold = rangeThreshold;\n        ssaoMaterial.proximityFalloff = rangeFalloff;\n        if (worldDistanceThreshold !== void 0) {\n            ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;\n        }\n        if (worldDistanceFalloff !== void 0) {\n            ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;\n        }\n        if (worldProximityThreshold !== void 0) {\n            ssaoMaterial.worldProximityThreshold = worldProximityThreshold;\n        }\n        if (worldProximityFalloff !== void 0) {\n            ssaoMaterial.worldProximityFalloff = worldProximityFalloff;\n        }\n        if (normalDepthBuffer !== null) {\n            this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n            this.defines.set(\"NORMAL_DEPTH\", \"1\");\n        }\n        this.depthAwareUpsampling = depthAwareUpsampling;\n        this.color = color2;\n    }\n    set mainCamera(value) {\n        this.camera = value;\n        this.ssaoMaterial.copyCameraSettings(value);\n    }\n    /**\n   * Sets the normal buffer.\n   *\n   * @type {Texture}\n   */ get normalBuffer() {\n        return this.ssaoMaterial.normalBuffer;\n    }\n    set normalBuffer(value) {\n        this.ssaoMaterial.normalBuffer = value;\n        this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = value;\n    }\n    /**\n   * Returns the resolution settings.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Resolution} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * The SSAO material.\n   *\n   * @type {SSAOMaterial}\n   */ get ssaoMaterial() {\n        return this.ssaoPass.fullscreenMaterial;\n    }\n    /**\n   * Returns the SSAO material.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @return {SSAOMaterial} The material.\n   */ getSSAOMaterial() {\n        return this.ssaoMaterial;\n    }\n    /**\n   * The amount of occlusion samples per pixel.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.samples instead.\n   */ get samples() {\n        return this.ssaoMaterial.samples;\n    }\n    set samples(value) {\n        this.ssaoMaterial.samples = value;\n    }\n    /**\n   * The amount of spiral turns in the occlusion sampling pattern.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.rings instead.\n   */ get rings() {\n        return this.ssaoMaterial.rings;\n    }\n    set rings(value) {\n        this.ssaoMaterial.rings = value;\n    }\n    /**\n   * The occlusion sampling radius.\n   *\n   * @type {Number}\n   * @deprecated Use ssaoMaterial.radius instead.\n   */ get radius() {\n        return this.ssaoMaterial.radius;\n    }\n    set radius(value) {\n        this.ssaoMaterial.radius = value;\n    }\n    /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @type {Boolean}\n   */ get depthAwareUpsampling() {\n        return this.defines.has(\"DEPTH_AWARE_UPSAMPLING\");\n    }\n    set depthAwareUpsampling(value) {\n        if (this.depthAwareUpsampling !== value) {\n            if (value) {\n                this.defines.set(\"DEPTH_AWARE_UPSAMPLING\", \"1\");\n            } else {\n                this.defines.delete(\"DEPTH_AWARE_UPSAMPLING\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether depth-aware upsampling is enabled.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @return {Boolean} Whether depth-aware upsampling is enabled.\n   */ isDepthAwareUpsamplingEnabled() {\n        return this.depthAwareUpsampling;\n    }\n    /**\n   * Enables or disables depth-aware upsampling.\n   *\n   * @deprecated Use depthAwareUpsampling instead.\n   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.\n   */ setDepthAwareUpsamplingEnabled(value) {\n        this.depthAwareUpsampling = value;\n    }\n    /**\n   * Indicates whether distance-based radius scaling is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated\n   */ get distanceScaling() {\n        return true;\n    }\n    set distanceScaling(value) {}\n    /**\n   * The color of the ambient occlusion. Set to `null` to disable.\n   *\n   * @type {Color}\n   */ get color() {\n        return this.uniforms.get(\"color\").value;\n    }\n    set color(value) {\n        const uniforms = this.uniforms;\n        const defines = this.defines;\n        if (value !== null) {\n            if (defines.has(\"COLORIZE\")) {\n                uniforms.get(\"color\").value.set(value);\n            } else {\n                defines.set(\"COLORIZE\", \"1\");\n                uniforms.get(\"color\").value = new three__WEBPACK_IMPORTED_MODULE_0__.Color(value);\n                this.setChanged();\n            }\n        } else if (defines.has(\"COLORIZE\")) {\n            defines.delete(\"COLORIZE\");\n            uniforms.get(\"color\").value = null;\n            this.setChanged();\n        }\n    }\n    /**\n   * The luminance influence factor. Range: [0.0, 1.0].\n   *\n   * @type {Boolean}\n   */ get luminanceInfluence() {\n        return this.uniforms.get(\"luminanceInfluence\").value;\n    }\n    set luminanceInfluence(value) {\n        this.uniforms.get(\"luminanceInfluence\").value = value;\n    }\n    /**\n   * The intensity.\n   *\n   * @type {Number}\n   */ get intensity() {\n        return this.uniforms.get(\"intensity\").value;\n    }\n    set intensity(value) {\n        this.uniforms.get(\"intensity\").value = value;\n    }\n    /**\n   * Returns the color of the ambient occlusion.\n   *\n   * @deprecated Use color instead.\n   * @return {Color} The color.\n   */ getColor() {\n        return this.color;\n    }\n    /**\n   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.\n   *\n   * @deprecated Use color instead.\n   * @param {Color} value - The color.\n   */ setColor(value) {\n        this.color = value;\n    }\n    /**\n   * Sets the occlusion distance cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setDistanceCutoff(threshold, falloff) {\n        this.ssaoMaterial.distanceThreshold = threshold;\n        this.ssaoMaterial.distanceFalloff = falloff;\n    }\n    /**\n   * Sets the occlusion proximity cutoff.\n   *\n   * @deprecated Use ssaoMaterial instead.\n   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].\n   * @param {Number} falloff - The falloff. Range [0.0, 1.0].\n   */ setProximityCutoff(threshold, falloff) {\n        this.ssaoMaterial.proximityThreshold = threshold;\n        this.ssaoMaterial.proximityFalloff = falloff;\n    }\n    /**\n   * Sets the depth texture.\n   *\n   * @param {Texture} depthTexture - A depth texture.\n   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.\n   */ setDepthTexture(depthTexture, depthPacking = three__WEBPACK_IMPORTED_MODULE_0__.BasicDepthPacking) {\n        this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);\n        this.ssaoMaterial.depthBuffer = depthTexture;\n        this.ssaoMaterial.depthPacking = depthPacking;\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        const renderTarget = this.renderTarget;\n        if (this.depthDownsamplingPass.enabled) {\n            this.depthDownsamplingPass.render(renderer);\n        }\n        this.ssaoPass.render(renderer, null, renderTarget);\n    }\n    /**\n   * Sets the size.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        const w = resolution.width, h = resolution.height;\n        this.ssaoMaterial.copyCameraSettings(this.camera);\n        this.ssaoMaterial.setSize(w, h);\n        this.renderTarget.setSize(w, h);\n        this.depthDownsamplingPass.resolution.scale = resolution.scale;\n        this.depthDownsamplingPass.setSize(width, height);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        try {\n            let normalDepthBuffer = this.uniforms.get(\"normalDepthBuffer\").value;\n            if (normalDepthBuffer === null) {\n                this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);\n                normalDepthBuffer = this.depthDownsamplingPass.texture;\n                this.uniforms.get(\"normalDepthBuffer\").value = normalDepthBuffer;\n                this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;\n                this.defines.set(\"NORMAL_DEPTH\", \"1\");\n            }\n        } catch (e) {\n            this.depthDownsamplingPass.enabled = false;\n        }\n    }\n};\n// src/effects/TextureEffect.js\n\n// src/effects/glsl/texture.frag\nvar texture_default = \"#ifdef TEXTURE_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\\n#ifdef UV_TRANSFORM\\nvec4 texel=texture2D(map,vUv2);\\n#else\\nvec4 texel=texture2D(map,uv);\\n#endif\\noutputColor=TEXEL;}\";\n// src/effects/glsl/texture.vert\nvar texture_default2 = \"#ifdef ASPECT_CORRECTION\\nuniform float scale;\\n#else\\nuniform mat3 uvTransform;\\n#endif\\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\\n#ifdef ASPECT_CORRECTION\\nvUv2=uv*vec2(aspect,1.0)*scale;\\n#else\\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\\n#endif\\n}\";\n// src/effects/TextureEffect.js\nvar TextureEffect = class extends Effect {\n    /**\n   * Constructs a new texture effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Texture} [options.texture] - A texture.\n   * @param {Boolean} [options.aspectCorrection=false] - Deprecated. Adjust the texture's offset, repeat and center instead.\n   */ constructor({ blendFunction, texture = null, aspectCorrection = false } = {}){\n        super(\"TextureEffect\", texture_default, {\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"TEXEL\",\n                    \"texel\"\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"scale\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(1)\n                ],\n                [\n                    \"uvTransform\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this.texture = texture;\n        this.aspectCorrection = aspectCorrection;\n    }\n    /**\n   * The texture.\n   *\n   * @type {Texture}\n   */ get texture() {\n        return this.uniforms.get(\"map\").value;\n    }\n    set texture(value) {\n        const prevTexture = this.texture;\n        const uniforms = this.uniforms;\n        const defines = this.defines;\n        if (prevTexture !== value) {\n            uniforms.get(\"map\").value = value;\n            uniforms.get(\"uvTransform\").value = value.matrix;\n            defines.delete(\"TEXTURE_PRECISION_HIGH\");\n            if (value !== null) {\n                if (value.matrixAutoUpdate) {\n                    defines.set(\"UV_TRANSFORM\", \"1\");\n                    this.setVertexShader(texture_default2);\n                } else {\n                    defines.delete(\"UV_TRANSFORM\");\n                    this.setVertexShader(null);\n                }\n                if (value.type !== three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) {\n                    defines.set(\"TEXTURE_PRECISION_HIGH\", \"1\");\n                }\n                if (prevTexture === null || prevTexture.type !== value.type || prevTexture.encoding !== value.encoding) {\n                    this.setChanged();\n                }\n            }\n        }\n    }\n    /**\n   * Returns the texture.\n   *\n   * @deprecated Use texture instead.\n   * @return {Texture} The texture.\n   */ getTexture() {\n        return this.texture;\n    }\n    /**\n   * Sets the texture.\n   *\n   * @deprecated Use texture instead.\n   * @param {Texture} value - The texture.\n   */ setTexture(value) {\n        this.texture = value;\n    }\n    /**\n   * Indicates whether aspect correction is enabled.\n   *\n   * @type {Number}\n   * @deprecated Adjust the texture's offset, repeat, rotation and center instead.\n   */ get aspectCorrection() {\n        return this.defines.has(\"ASPECT_CORRECTION\");\n    }\n    set aspectCorrection(value) {\n        if (this.aspectCorrection !== value) {\n            if (value) {\n                this.defines.set(\"ASPECT_CORRECTION\", \"1\");\n            } else {\n                this.defines.delete(\"ASPECT_CORRECTION\");\n            }\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether the texture UV coordinates will be transformed using the transformation matrix of the texture.\n   *\n   * @type {Boolean}\n   * @deprecated Use texture.matrixAutoUpdate instead.\n   */ get uvTransform() {\n        const texture = this.texture;\n        return texture !== null && texture.matrixAutoUpdate;\n    }\n    set uvTransform(value) {\n        const texture = this.texture;\n        if (texture !== null) {\n            texture.matrixAutoUpdate = value;\n        }\n    }\n    /**\n   * Sets the swizzles that will be applied to the components of a texel before it is written to the output color.\n   *\n   * @param {ColorChannel} r - The swizzle for the `r` component.\n   * @param {ColorChannel} [g=r] - The swizzle for the `g` component.\n   * @param {ColorChannel} [b=r] - The swizzle for the `b` component.\n   * @param {ColorChannel} [a=r] - The swizzle for the `a` component.\n   */ setTextureSwizzleRGBA(r, g = r, b = r, a = r) {\n        const rgba = \"rgba\";\n        let swizzle = \"\";\n        if (r !== ColorChannel.RED || g !== ColorChannel.GREEN || b !== ColorChannel.BLUE || a !== ColorChannel.ALPHA) {\n            swizzle = [\n                \".\",\n                rgba[r],\n                rgba[g],\n                rgba[b],\n                rgba[a]\n            ].join(\"\");\n        }\n        this.defines.set(\"TEXEL\", \"texel\" + swizzle);\n        this.setChanged();\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        if (this.texture.matrixAutoUpdate) {\n            this.texture.updateMatrix();\n        }\n    }\n};\n// src/effects/TiltShiftEffect.js\n\n// src/effects/glsl/tilt-shift.frag\nvar tilt_shift_default = \"#ifdef FRAMEBUFFER_PRECISION_HIGH\\nuniform mediump sampler2D map;\\n#else\\nuniform lowp sampler2D map;\\n#endif\\nuniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}\";\n// src/effects/glsl/tilt-shift.vert\nvar tilt_shift_default2 = \"uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}\";\n// src/effects/TiltShiftEffect.js\nvar TiltShiftEffect = class extends Effect {\n    /**\n   * Constructs a new tilt shift Effect\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {Number} [options.offset=0.0] - The relative offset of the focus area.\n   * @param {Number} [options.rotation=0.0] - The rotation of the focus area in radians.\n   * @param {Number} [options.focusArea=0.4] - The relative size of the focus area.\n   * @param {Number} [options.feather=0.3] - The softness of the focus area edges.\n   * @param {Number} [options.bias=0.06] - Deprecated.\n   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.\n   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.\n   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.\n   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.\n   */ constructor({ blendFunction, offset = 0, rotation = 0, focusArea = 0.4, feather = 0.3, kernelSize = KernelSize.MEDIUM, resolutionScale = 0.5, resolutionX = Resolution.AUTO_SIZE, resolutionY = Resolution.AUTO_SIZE } = {}){\n        super(\"TiltShiftEffect\", tilt_shift_default, {\n            vertexShader: tilt_shift_default2,\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"rotation\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"maskParams\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(new three__WEBPACK_IMPORTED_MODULE_0__.Vector2())\n                ],\n                [\n                    \"map\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ]\n            ])\n        });\n        this._offset = offset;\n        this._focusArea = focusArea;\n        this._feather = feather;\n        this.renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            depthBuffer: false\n        });\n        this.renderTarget.texture.name = \"TiltShift.Target\";\n        this.uniforms.get(\"map\").value = this.renderTarget.texture;\n        this.blurPass = new TiltShiftBlurPass({\n            kernelSize,\n            resolutionScale,\n            resolutionX,\n            resolutionY,\n            offset,\n            rotation,\n            focusArea,\n            feather\n        });\n        const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);\n        resolution.addEventListener(\"change\", (e)=>this.setSize(resolution.baseWidth, resolution.baseHeight));\n        this.rotation = rotation;\n        this.updateParams();\n    }\n    /**\n   * Updates the mask params.\n   *\n   * @private\n   */ updateParams() {\n        const params = this.uniforms.get(\"maskParams\").value;\n        const x = Math.max(this.focusArea - this.feather, 0);\n        params.set(this.offset - x, this.offset + x);\n    }\n    /**\n   * The rotation of the focus area in radians.\n   *\n   * @type {Number}\n   */ get rotation() {\n        return Math.acos(this.uniforms.get(\"rotation\").value.x);\n    }\n    set rotation(value) {\n        this.uniforms.get(\"rotation\").value.set(Math.cos(value), Math.sin(value));\n        this.blurPass.blurMaterial.rotation = value;\n    }\n    /**\n   * The relative offset of the focus area.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this._offset;\n    }\n    set offset(value) {\n        this._offset = value;\n        this.blurPass.blurMaterial.offset = value;\n        this.updateParams();\n    }\n    /**\n   * The relative size of the focus area.\n   *\n   * @type {Number}\n   */ get focusArea() {\n        return this._focusArea;\n    }\n    set focusArea(value) {\n        this._focusArea = value;\n        this.blurPass.blurMaterial.focusArea = value;\n        this.updateParams();\n    }\n    /**\n   * The softness of the focus area edges.\n   *\n   * @type {Number}\n   */ get feather() {\n        return this._feather;\n    }\n    set feather(value) {\n        this._feather = value;\n        this.blurPass.blurMaterial.feather = value;\n        this.updateParams();\n    }\n    /**\n   * A blend bias.\n   *\n   * @type {Number}\n   * @deprecated\n   */ get bias() {\n        return 0;\n    }\n    set bias(value) {}\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        this.blurPass.render(renderer, inputBuffer, this.renderTarget);\n    }\n    /**\n   * Updates the size of internal render targets.\n   *\n   * @param {Number} width - The width.\n   * @param {Number} height - The height.\n   */ setSize(width, height) {\n        const resolution = this.resolution;\n        resolution.setBaseSize(width, height);\n        this.renderTarget.setSize(resolution.width, resolution.height);\n        this.blurPass.resolution.copy(resolution);\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.blurPass.initialize(renderer, alpha, frameBufferType);\n        if (frameBufferType !== void 0) {\n            this.renderTarget.texture.type = frameBufferType;\n            if (getOutputColorSpace(renderer) === SRGBColorSpace) {\n                setTextureColorSpace(this.renderTarget.texture, SRGBColorSpace);\n            }\n        }\n    }\n};\n// src/effects/ToneMappingEffect.js\n\n// src/effects/glsl/tone-mapping.frag\nvar tone_mapping_default = \"#include <tonemapping_pars_fragment>\\n#if THREE_REVISION < 143\\n#define luminance(v) linearToRelativeLuminance(v)\\n#endif\\nuniform float whitePoint;\\n#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2\\nuniform float middleGrey;\\n#if TONE_MAPPING_MODE == 2\\nuniform lowp sampler2D luminanceBuffer;\\n#else\\nuniform float averageLuminance;\\n#endif\\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\\n#if TONE_MAPPING_MODE == 2\\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\\n#else\\nfloat lumAvg=averageLuminance;\\n#endif\\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\\n#elif TONE_MAPPING_MODE == 3\\n#define A 0.15\\n#define B 0.50\\n#define C 0.10\\n#define D 0.20\\n#define E 0.02\\n#define F 0.30\\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\\n#endif\\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\\n#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2\\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\\n#elif TONE_MAPPING_MODE == 3\\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\\n#else\\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\\n#endif\\n}\";\n// src/effects/ToneMappingEffect.js\nvar ToneMappingEffect = class extends Effect {\n    /**\n   * Constructs a new tone mapping effect.\n   *\n   * The additional parameters only affect the Reinhard2 operator.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.\n   * @param {Boolean} [options.adaptive=false] - Deprecated. Use mode instead.\n   * @param {ToneMappingMode} [options.mode=ToneMappingMode.AGX] - The tone mapping mode.\n   * @param {Number} [options.resolution=256] - The resolution of the luminance texture. Must be a power of two.\n   * @param {Number} [options.maxLuminance=4.0] - Deprecated. Same as whitePoint.\n   * @param {Number} [options.whitePoint=4.0] - The white point.\n   * @param {Number} [options.middleGrey=0.6] - The middle grey factor.\n   * @param {Number} [options.minLuminance=0.01] - The minimum luminance. Prevents very high exposure in dark scenes.\n   * @param {Number} [options.averageLuminance=1.0] - The average luminance. Used for the non-adaptive Reinhard operator.\n   * @param {Number} [options.adaptationRate=1.0] - The luminance adaptation rate.\n   */ constructor({ blendFunction = BlendFunction.SRC, adaptive = false, mode = adaptive ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.AGX, resolution = 256, maxLuminance = 4, whitePoint = maxLuminance, middleGrey = 0.6, minLuminance = 0.01, averageLuminance = 1, adaptationRate = 1 } = {}){\n        super(\"ToneMappingEffect\", tone_mapping_default, {\n            blendFunction,\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"luminanceBuffer\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(null)\n                ],\n                [\n                    \"maxLuminance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(maxLuminance)\n                ],\n                // Unused\n                [\n                    \"whitePoint\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(whitePoint)\n                ],\n                [\n                    \"middleGrey\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(middleGrey)\n                ],\n                [\n                    \"averageLuminance\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(averageLuminance)\n                ]\n            ])\n        });\n        this.renderTargetLuminance = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n            depthBuffer: false\n        });\n        this.renderTargetLuminance.texture.generateMipmaps = true;\n        this.renderTargetLuminance.texture.name = \"Luminance\";\n        this.luminancePass = new LuminancePass({\n            renderTarget: this.renderTargetLuminance\n        });\n        this.adaptiveLuminancePass = new AdaptiveLuminancePass(this.luminancePass.texture, {\n            minLuminance,\n            adaptationRate\n        });\n        this.uniforms.get(\"luminanceBuffer\").value = this.adaptiveLuminancePass.texture;\n        this.resolution = resolution;\n        this.mode = mode;\n    }\n    /**\n   * The tone mapping mode.\n   *\n   * @type {ToneMappingMode}\n   */ get mode() {\n        return Number(this.defines.get(\"TONE_MAPPING_MODE\"));\n    }\n    set mode(value) {\n        if (this.mode !== value) {\n            this.defines.clear();\n            this.defines.set(\"TONE_MAPPING_MODE\", value.toFixed(0));\n            value = validateToneMappingMode(value);\n            switch(value){\n                case ToneMappingMode.REINHARD:\n                    this.defines.set(\"toneMapping(texel)\", \"ReinhardToneMapping(texel)\");\n                    break;\n                case ToneMappingMode.OPTIMIZED_CINEON:\n                    this.defines.set(\"toneMapping(texel)\", \"OptimizedCineonToneMapping(texel)\");\n                    break;\n                case ToneMappingMode.ACES_FILMIC:\n                    this.defines.set(\"toneMapping(texel)\", \"ACESFilmicToneMapping(texel)\");\n                    break;\n                case ToneMappingMode.AGX:\n                    this.defines.set(\"toneMapping(texel)\", \"AgXToneMapping(texel)\");\n                    break;\n                default:\n                    this.defines.set(\"toneMapping(texel)\", \"texel\");\n                    break;\n            }\n            this.adaptiveLuminancePass.enabled = value === ToneMappingMode.REINHARD2_ADAPTIVE;\n            this.setChanged();\n        }\n    }\n    /**\n   * Returns the current tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @return {ToneMappingMode} The tone mapping mode.\n   */ getMode() {\n        return this.mode;\n    }\n    /**\n   * Sets the tone mapping mode.\n   *\n   * @deprecated Use mode instead.\n   * @param {ToneMappingMode} value - The tone mapping mode.\n   */ setMode(value) {\n        this.mode = value;\n    }\n    /**\n   * The white point. Default is `4.0`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */ get whitePoint() {\n        return this.uniforms.get(\"whitePoint\").value;\n    }\n    set whitePoint(value) {\n        this.uniforms.get(\"whitePoint\").value = value;\n    }\n    /**\n   * The middle grey factor. Default is `0.6`.\n   *\n   * Only applies to Reinhard2 (Modified & Adaptive).\n   *\n   * @type {Number}\n   */ get middleGrey() {\n        return this.uniforms.get(\"middleGrey\").value;\n    }\n    set middleGrey(value) {\n        this.uniforms.get(\"middleGrey\").value = value;\n    }\n    /**\n   * The average luminance.\n   *\n   * Only applies to Reinhard2 (Modified).\n   *\n   * @type {Number}\n   */ get averageLuminance() {\n        return this.uniforms.get(\"averageLuminance\").value;\n    }\n    set averageLuminance(value) {\n        this.uniforms.get(\"averageLuminance\").value = value;\n    }\n    /**\n   * The adaptive luminance material.\n   *\n   * @type {AdaptiveLuminanceMaterial}\n   */ get adaptiveLuminanceMaterial() {\n        return this.adaptiveLuminancePass.fullscreenMaterial;\n    }\n    /**\n   * Returns the adaptive luminance material.\n   *\n   * @deprecated Use adaptiveLuminanceMaterial instead.\n   * @return {AdaptiveLuminanceMaterial} The material.\n   */ getAdaptiveLuminanceMaterial() {\n        return this.adaptiveLuminanceMaterial;\n    }\n    /**\n   * The resolution of the luminance texture. Must be a power of two.\n   *\n   * @type {Number}\n   */ get resolution() {\n        return this.luminancePass.resolution.width;\n    }\n    set resolution(value) {\n        const exponent = Math.max(0, Math.ceil(Math.log2(value)));\n        const size = Math.pow(2, exponent);\n        this.luminancePass.resolution.setPreferredSize(size, size);\n        this.adaptiveLuminanceMaterial.mipLevel1x1 = exponent;\n    }\n    /**\n   * Returns the resolution of the luminance texture.\n   *\n   * @deprecated Use resolution instead.\n   * @return {Number} The resolution.\n   */ getResolution() {\n        return this.resolution;\n    }\n    /**\n   * Sets the resolution of the luminance texture. Must be a power of two.\n   *\n   * @deprecated Use resolution instead.\n   * @param {Number} value - The resolution.\n   */ setResolution(value) {\n        this.resolution = value;\n    }\n    /**\n   * Indicates whether this pass uses adaptive luminance.\n   *\n   * @type {Boolean}\n   * @deprecated Use mode instead.\n   */ get adaptive() {\n        return this.mode === ToneMappingMode.REINHARD2_ADAPTIVE;\n    }\n    set adaptive(value) {\n        this.mode = value ? ToneMappingMode.REINHARD2_ADAPTIVE : ToneMappingMode.REINHARD2;\n    }\n    /**\n   * The luminance adaptation rate.\n   *\n   * @type {Number}\n   * @deprecated Use adaptiveLuminanceMaterial.adaptationRate instead.\n   */ get adaptationRate() {\n        return this.adaptiveLuminanceMaterial.adaptationRate;\n    }\n    set adaptationRate(value) {\n        this.adaptiveLuminanceMaterial.adaptationRate = value;\n    }\n    /**\n   * @type {Number}\n   * @deprecated\n   */ get distinction() {\n        console.warn(this.name, \"distinction was removed.\");\n        return 1;\n    }\n    set distinction(value) {\n        console.warn(this.name, \"distinction was removed.\");\n    }\n    /**\n   * Updates this effect.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.\n   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.\n   */ update(renderer, inputBuffer, deltaTime) {\n        if (this.adaptiveLuminancePass.enabled) {\n            this.luminancePass.render(renderer, inputBuffer);\n            this.adaptiveLuminancePass.render(renderer, null, null, deltaTime);\n        }\n    }\n    /**\n   * Performs initialization tasks.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.\n   * @param {Number} frameBufferType - The type of the main frame buffers.\n   */ initialize(renderer, alpha, frameBufferType) {\n        this.adaptiveLuminancePass.initialize(renderer, alpha, frameBufferType);\n    }\n};\n// src/effects/VignetteEffect.js\n\n// src/effects/glsl/vignette.frag\nvar vignette_default = \"uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\\n#if VIGNETTE_TECHNIQUE == 0\\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\\n#else\\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\\n#endif\\noutputColor=vec4(color,inputColor.a);}\";\n// src/effects/VignetteEffect.js\nvar VignetteEffect = class extends Effect {\n    /**\n   * Constructs a new Vignette effect.\n   *\n   * @param {Object} [options] - The options.\n   * @param {BlendFunction} [options.blendFunction] - The blend function of this effect.\n   * @param {VignetteTechnique} [options.technique=VignetteTechnique.DEFAULT] - The Vignette technique.\n   * @param {Boolean} [options.eskil=false] - Deprecated. Use technique instead.\n   * @param {Number} [options.offset=0.5] - The Vignette offset.\n   * @param {Number} [options.darkness=0.5] - The Vignette darkness.\n   */ constructor({ blendFunction, technique = VignetteTechnique.DEFAULT, eskil = false, offset = 0.5, darkness = 0.5 } = {}){\n        super(\"VignetteEffect\", vignette_default, {\n            blendFunction,\n            defines: /* @__PURE__ */ new Map([\n                [\n                    \"VIGNETTE_TECHNIQUE\",\n                    technique.toFixed(0)\n                ]\n            ]),\n            uniforms: /* @__PURE__ */ new Map([\n                [\n                    \"offset\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(offset)\n                ],\n                [\n                    \"darkness\",\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(darkness)\n                ]\n            ])\n        });\n    }\n    /**\n   * The Vignette technique.\n   *\n   * @type {VignetteTechnique}\n   */ get technique() {\n        return Number(this.defines.get(\"VIGNETTE_TECHNIQUE\"));\n    }\n    set technique(value) {\n        if (this.technique !== value) {\n            this.defines.set(\"VIGNETTE_TECHNIQUE\", value.toFixed(0));\n            this.setChanged();\n        }\n    }\n    /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */ get eskil() {\n        return this.technique === VignetteTechnique.ESKIL;\n    }\n    /**\n   * Indicates whether Eskil's Vignette technique is enabled.\n   *\n   * @type {Boolean}\n   * @deprecated Use technique instead.\n   */ set eskil(value) {\n        this.technique = value ? VignetteTechnique.ESKIL : VignetteTechnique.DEFAULT;\n    }\n    /**\n   * Returns the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @return {VignetteTechnique} The technique.\n   */ getTechnique() {\n        return this.technique;\n    }\n    /**\n   * Sets the Vignette technique.\n   *\n   * @deprecated Use technique instead.\n   * @param {VignetteTechnique} value - The technique.\n   */ setTechnique(value) {\n        this.technique = value;\n    }\n    /**\n   * The Vignette offset.\n   *\n   * @type {Number}\n   */ get offset() {\n        return this.uniforms.get(\"offset\").value;\n    }\n    set offset(value) {\n        this.uniforms.get(\"offset\").value = value;\n    }\n    /**\n   * Returns the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @return {Number} The offset.\n   */ getOffset() {\n        return this.offset;\n    }\n    /**\n   * Sets the Vignette offset.\n   *\n   * @deprecated Use offset instead.\n   * @param {Number} value - The offset.\n   */ setOffset(value) {\n        this.offset = value;\n    }\n    /**\n   * The Vignette darkness.\n   *\n   * @type {Number}\n   */ get darkness() {\n        return this.uniforms.get(\"darkness\").value;\n    }\n    set darkness(value) {\n        this.uniforms.get(\"darkness\").value = value;\n    }\n    /**\n   * Returns the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @return {Number} The darkness.\n   */ getDarkness() {\n        return this.darkness;\n    }\n    /**\n   * Sets the Vignette darkness.\n   *\n   * @deprecated Use darkness instead.\n   * @param {Number} value - The darkness.\n   */ setDarkness(value) {\n        this.darkness = value;\n    }\n};\n// src/loaders/LUT3dlLoader.js\n\nvar LUT3dlLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the 3dl-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */ load(url, onLoad = ()=>{}, onProgress = ()=>{}, onError = null) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"text\");\n        return new Promise((resolve, reject)=>{\n            internalManager.onError = (url2)=>{\n                externalManager.itemError(url2);\n                if (onError !== null) {\n                    onError(`Failed to load ${url2}`);\n                    resolve();\n                } else {\n                    reject(`Failed to load ${url2}`);\n                }\n            };\n            externalManager.itemStart(url);\n            loader.load(url, (data)=>{\n                try {\n                    const result = this.parse(data);\n                    externalManager.itemEnd(url);\n                    onLoad(result);\n                    resolve(result);\n                } catch (e) {\n                    console.error(e);\n                    internalManager.onError(url);\n                }\n            }, onProgress);\n        });\n    }\n    /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */ parse(input) {\n        const regExpGridInfo = /^[\\d ]+$/m;\n        const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n        let result = regExpGridInfo.exec(input);\n        if (result === null) {\n            throw new Error(\"Missing grid information\");\n        }\n        const gridLines = result[0].trim().split(/\\s+/g).map((n)=>Number(n));\n        const gridStep = gridLines[1] - gridLines[0];\n        const size = gridLines.length;\n        const sizeSq = size ** 2;\n        for(let i = 1, l = gridLines.length; i < l; ++i){\n            if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n                throw new Error(\"Inconsistent grid size\");\n            }\n        }\n        const data = new Float32Array(size ** 3 * 4);\n        let maxValue = 0;\n        let index = 0;\n        while((result = regExpDataPoints.exec(input)) !== null){\n            const r = Number(result[1]);\n            const g = Number(result[2]);\n            const b = Number(result[3]);\n            maxValue = Math.max(maxValue, r, g, b);\n            const bLayer = index % size;\n            const gLayer = Math.floor(index / size) % size;\n            const rLayer = Math.floor(index / sizeSq) % size;\n            const d4 = (bLayer * sizeSq + gLayer * size + rLayer) * 4;\n            data[d4 + 0] = r;\n            data[d4 + 1] = g;\n            data[d4 + 2] = b;\n            data[d4 + 3] = 1;\n            ++index;\n        }\n        const bits = Math.ceil(Math.log2(maxValue));\n        const maxBitValue = Math.pow(2, bits);\n        for(let i = 0, l = data.length; i < l; i += 4){\n            data[i + 0] /= maxBitValue;\n            data[i + 1] /= maxBitValue;\n            data[i + 2] /= maxBitValue;\n        }\n        return new LookupTexture(data, size);\n    }\n};\n// src/loaders/LUTCubeLoader.js\n\nvar LUTCubeLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads a LUT.\n   *\n   * @param {String} url - The URL of the CUBE-file.\n   * @param {Function} [onLoad] - A callback that receives the loaded lookup texture.\n   * @param {Function} [onProgress] - A progress callback that receives the XMLHttpRequest instance.\n   * @param {Function} [onError] - An error callback that receives the URL of the file that failed to load.\n   * @return {Promise<LookupTexture>} A promise that returns the lookup texture.\n   */ load(url, onLoad = ()=>{}, onProgress = ()=>{}, onError = null) {\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(internalManager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"text\");\n        return new Promise((resolve, reject)=>{\n            internalManager.onError = (url2)=>{\n                externalManager.itemError(url2);\n                if (onError !== null) {\n                    onError(`Failed to load ${url2}`);\n                    resolve();\n                } else {\n                    reject(`Failed to load ${url2}`);\n                }\n            };\n            externalManager.itemStart(url);\n            loader.load(url, (data)=>{\n                try {\n                    const result = this.parse(data);\n                    externalManager.itemEnd(url);\n                    onLoad(result);\n                    resolve(result);\n                } catch (e) {\n                    console.error(e);\n                    internalManager.onError(url);\n                }\n            }, onProgress);\n        });\n    }\n    /**\n   * Parses the given data.\n   *\n   * @param {String} input - The LUT data.\n   * @return {LookupTexture} The lookup texture.\n   * @throws {Error} Fails if the data is invalid.\n   */ parse(input) {\n        const regExpTitle = /TITLE +\"([^\"]*)\"/;\n        const regExpSize = /LUT_3D_SIZE +(\\d+)/;\n        const regExpDomainMin = /DOMAIN_MIN +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n        const regExpDomainMax = /DOMAIN_MAX +([\\d.]+) +([\\d.]+) +([\\d.]+)/;\n        const regExpDataPoints = /^([\\d.e+-]+) +([\\d.e+-]+) +([\\d.e+-]+) *$/gm;\n        let result = regExpTitle.exec(input);\n        const title = result !== null ? result[1] : null;\n        result = regExpSize.exec(input);\n        if (result === null) {\n            throw new Error(\"Missing LUT_3D_SIZE information\");\n        }\n        const size = Number(result[1]);\n        const data = new Float32Array(size ** 3 * 4);\n        const domainMin = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        const domainMax = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        result = regExpDomainMin.exec(input);\n        if (result !== null) {\n            domainMin.set(Number(result[1]), Number(result[2]), Number(result[3]));\n        }\n        result = regExpDomainMax.exec(input);\n        if (result !== null) {\n            domainMax.set(Number(result[1]), Number(result[2]), Number(result[3]));\n        }\n        if (domainMin.x > domainMax.x || domainMin.y > domainMax.y || domainMin.z > domainMax.z) {\n            domainMin.set(0, 0, 0);\n            domainMax.set(1, 1, 1);\n            throw new Error(\"Invalid input domain\");\n        }\n        let i = 0;\n        while((result = regExpDataPoints.exec(input)) !== null){\n            data[i++] = Number(result[1]);\n            data[i++] = Number(result[2]);\n            data[i++] = Number(result[3]);\n            data[i++] = 1;\n        }\n        const lut = new LookupTexture(data, size);\n        lut.domainMin.copy(domainMin);\n        lut.domainMax.copy(domainMax);\n        if (title !== null) {\n            lut.name = title;\n        }\n        return lut;\n    }\n};\n// src/loaders/SMAAImageLoader.js\n\nvar SMAAImageLoader = class extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n   * Loads the SMAA data images.\n   *\n   * @param {Function} [onLoad] - A callback that receives the search image and area image as a pair.\n   * @param {Function} [onError] - An error callback that receives the URL of the image that failed to load.\n   * @return {Promise<Image[]>} A promise that returns the search image and area image as a pair.\n   */ load(onLoad = ()=>{}, onError = null) {\n        if (arguments.length === 4) {\n            onLoad = arguments[1];\n            onError = arguments[3];\n        } else if (arguments.length === 3 || typeof arguments[0] !== \"function\") {\n            onLoad = arguments[1];\n            onError = null;\n        }\n        const externalManager = this.manager;\n        const internalManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n        return new Promise((resolve, reject)=>{\n            const searchImage = new Image();\n            const areaImage = new Image();\n            internalManager.onError = (url)=>{\n                externalManager.itemError(url);\n                if (onError !== null) {\n                    onError(`Failed to load ${url}`);\n                    resolve();\n                } else {\n                    reject(`Failed to load ${url}`);\n                }\n            };\n            internalManager.onLoad = ()=>{\n                const result = [\n                    searchImage,\n                    areaImage\n                ];\n                onLoad(result);\n                resolve(result);\n            };\n            searchImage.addEventListener(\"error\", (e)=>{\n                internalManager.itemError(\"smaa-search\");\n            });\n            areaImage.addEventListener(\"error\", (e)=>{\n                internalManager.itemError(\"smaa-area\");\n            });\n            searchImage.addEventListener(\"load\", ()=>{\n                externalManager.itemEnd(\"smaa-search\");\n                internalManager.itemEnd(\"smaa-search\");\n            });\n            areaImage.addEventListener(\"load\", ()=>{\n                externalManager.itemEnd(\"smaa-area\");\n                internalManager.itemEnd(\"smaa-area\");\n            });\n            externalManager.itemStart(\"smaa-search\");\n            externalManager.itemStart(\"smaa-area\");\n            internalManager.itemStart(\"smaa-search\");\n            internalManager.itemStart(\"smaa-area\");\n            searchImage.src = searchImageDataURL_default;\n            areaImage.src = areaImageDataURL_default;\n        });\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBRUQsZUFBZTtBQUNmLElBQUlBLFVBQVU7QUFFZCx5QkFBeUI7QUFDekIsSUFBSUMsYUFBYTtJQUNmOztHQUVDLEdBQ0RDLFVBQVUsQ0FDVjtBQUNGO0FBRUEsNkJBQTZCO0FBVWQ7QUFFZixzQ0FBc0M7QUFDeUM7QUFFL0UsNkNBQTZDO0FBQ2U7QUFFNUQsNkNBQTZDO0FBQzdDLElBQUlrQiw2QkFBNkI7QUFFakMsaUNBQWlDO0FBQ2pDLElBQUlDLGlCQUFpQjtBQUVyQiw2Q0FBNkM7QUFDN0MsSUFBSUMsNEJBQTRCLGNBQWNKLGlEQUFjQTtJQUMxRDs7R0FFQyxHQUNESyxhQUFjO1FBQ1osS0FBSyxDQUFDO1lBQ0pDLE1BQU07WUFDTkMsU0FBUztnQkFDUEMsZUFBZTtZQUNqQjtZQUNBQyxVQUFVO2dCQUNSQyxrQkFBa0IsSUFBSVQsMENBQU9BLENBQUM7Z0JBQzlCVSxrQkFBa0IsSUFBSVYsMENBQU9BLENBQUM7Z0JBQzlCVyxjQUFjLElBQUlYLDBDQUFPQSxDQUFDO2dCQUMxQlksV0FBVyxJQUFJWiwwQ0FBT0EsQ0FBQztnQkFDdkJhLEtBQUssSUFBSWIsMENBQU9BLENBQUM7WUFDbkI7WUFDQWMsWUFBWTtnQkFDVkMsa0JBQWtCO1lBQ3BCO1lBQ0FDLFVBQVVsQiw2Q0FBVUE7WUFDcEJtQixZQUFZO1lBQ1pDLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxnQkFBZ0JuQjtZQUNoQm9CLGNBQWNuQjtRQUNoQjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlPLGlCQUFpQmEsS0FBSyxF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QUNYM0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUkyQztRQUNYM0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUkyQztRQUNYM0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk0QztRQUNYNUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk0QztRQUNYNUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk0QztRQUNYNUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk2QztRQUNYN0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk2QztRQUNYN0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk2QztRQUNYN0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk4QztRQUNYOUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk4QztRQUNYOUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUk4QztRQUNYNW9CLE1BQU0sQ0FBQyxFQUFFLEdBQUc4bEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2pEOWxCLE1BQU0sQ0FBQyxFQUFFLEdBQUc4bEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ2pEOWxCLE1BQU0sQ0FBQyxFQUFFLEdBQUc4bEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQ25EO0FBQ0Y7QUFDQSxJQUFJK0Msc0JBQXNCO0lBQ3hCOzs7Ozs7R0FNQyxHQUNELE9BQU9DLE9BQU8xOUIsSUFBSSxFQUFFMmpCLElBQUksRUFBRTtRQUN4QixNQUFNZ2EsZUFBZWoxQyxLQUFLazFDLElBQUksQ0FBQzU5QixLQUFLbWYsTUFBTSxHQUFHO1FBQzdDLE1BQU0wZSxNQUFNLElBQUkvbkMsYUFBYTtRQUM3QixNQUFNZ29DLFFBQVEsSUFBSTk5QixLQUFLamIsV0FBVyxDQUFDNCtCLFFBQVEsSUFBSTtRQUMvQyxNQUFNb2EsV0FBVy85QixnQkFBZ0J5WixhQUFhLE1BQU07UUFDcEQsTUFBTThmLFNBQVM1VixRQUFRO1FBQ3ZCLE1BQU10Z0IsSUFBSSxJQUFLc2dCLENBQUFBLE9BQU87UUFDdEIsSUFBSyxJQUFJMlcsSUFBSSxHQUFHQSxJQUFJM1csTUFBTSxFQUFFMlcsRUFBRztZQUM3QixJQUFLLElBQUlseEMsSUFBSSxHQUFHQSxJQUFJdTZCLE1BQU0sRUFBRXY2QixFQUFHO2dCQUM3QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSXc2QixNQUFNLEVBQUV4NkIsRUFBRztvQkFDN0IsTUFBTUwsSUFBSUssSUFBSWthO29CQUNkLE1BQU1yYSxLQUFLSSxJQUFJaWE7b0JBQ2YsTUFBTTBRLElBQUl1bUIsSUFBSWozQjtvQkFDZCxNQUFNbTJCLEtBQUs5d0MsS0FBS3N4QixLQUFLLENBQUM3d0IsSUFBSUMsSUFBSXU2QixPQUFPMlcsSUFBSWYsVUFBVTtvQkFDbkR1QyxrQkFBa0I5N0IsTUFBTTI5QixjQUFjNzBDLEdBQUdFLElBQUkrcUIsR0FBRzhwQjtvQkFDaERDLEtBQUssQ0FBQ3RFLEtBQUssRUFBRSxHQUFHcUUsR0FBRyxDQUFDLEVBQUU7b0JBQ3RCQyxLQUFLLENBQUN0RSxLQUFLLEVBQUUsR0FBR3FFLEdBQUcsQ0FBQyxFQUFFO29CQUN0QkMsS0FBSyxDQUFDdEUsS0FBSyxFQUFFLEdBQUdxRSxHQUFHLENBQUMsRUFBRTtvQkFDdEJDLEtBQUssQ0FBQ3RFLEtBQUssRUFBRSxHQUFHdUU7Z0JBQ2xCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9EO0lBQ1Q7QUFDRjtBQUVBLHlDQUF5QztBQUN6QyxJQUFJRSxPQUFPO0lBQ1QsSUFBSWxvQyxhQUFhO0lBQ2pCLElBQUlBLGFBQWE7Q0FDbEI7QUFDRCxJQUFJbW9DLGtCQUFrQjtBQUN0QixJQUFJQyxnQkFBZ0I7QUFDcEIsSUFBSUMsbUJBQW1CO0FBQ3ZCLElBQUlDLHNCQUFzQjtBQUMxQixJQUFJQywrQkFBK0IsSUFBSXZvQyxhQUFhO0lBQ2xEO0lBQ0EsQ0FBQztJQUNEO0lBQ0EsQ0FBQztJQUNEO0lBQ0EsQ0FBQztJQUNEO0NBQ0Q7QUFDRCxJQUFJd29DLDZCQUE2QjtJQUMvQixJQUFJeG9DLGFBQWE7UUFBQztRQUFHO0tBQUU7SUFDdkIsSUFBSUEsYUFBYTtRQUFDO1FBQU0sQ0FBQztLQUFLO0lBQzlCLElBQUlBLGFBQWE7UUFBQyxDQUFDO1FBQU07S0FBSztJQUM5QixJQUFJQSxhQUFhO1FBQUM7UUFBTyxDQUFDO0tBQU07SUFDaEMsSUFBSUEsYUFBYTtRQUFDLENBQUM7UUFBTztLQUFNO0NBQ2pDO0FBQ0QsSUFBSXlvQyxrQkFBa0I7SUFDcEIsSUFBSTlrQixXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0NBQ3RCO0FBQ0QsSUFBSStrQixnQkFBZ0I7SUFDbEIsSUFBSS9rQixXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0lBQ3JCLElBQUlBLFdBQVc7UUFBQztRQUFHO0tBQUU7SUFDckIsSUFBSUEsV0FBVztRQUFDO1FBQUc7S0FBRTtJQUNyQixJQUFJQSxXQUFXO1FBQUM7UUFBRztLQUFFO0NBQ3RCO0FBQ0QsU0FBU2dsQixLQUFLN3dCLENBQUMsRUFBRUMsQ0FBQyxFQUFFNndCLENBQUM7SUFDbkIsT0FBTzl3QixJQUFJLENBQUNDLElBQUlELENBQUFBLElBQUs4d0I7QUFDdkI7QUFDQSxTQUFTQyxTQUFTL3dCLENBQUM7SUFDakIsT0FBT2xsQixLQUFLMkosR0FBRyxDQUFDM0osS0FBSzRKLEdBQUcsQ0FBQ3NiLEdBQUcsSUFBSTtBQUNsQztBQUNBLFNBQVNneEIsV0FBV3JpQixDQUFDO0lBQ25CLE1BQU1zaUIsS0FBS2IsSUFBSSxDQUFDLEVBQUU7SUFDbEIsTUFBTWMsS0FBS2QsSUFBSSxDQUFDLEVBQUU7SUFDbEIsTUFBTWUsTUFBTXIyQyxLQUFLQyxJQUFJLENBQUNrMkMsRUFBRSxDQUFDLEVBQUUsR0FBRyxLQUFLO0lBQ25DLE1BQU1HLE1BQU10MkMsS0FBS0MsSUFBSSxDQUFDazJDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsS0FBSztJQUNuQyxNQUFNSSxNQUFNdjJDLEtBQUtDLElBQUksQ0FBQ20yQyxFQUFFLENBQUMsRUFBRSxHQUFHLEtBQUs7SUFDbkMsTUFBTUksTUFBTXgyQyxLQUFLQyxJQUFJLENBQUNtMkMsRUFBRSxDQUFDLEVBQUUsR0FBRyxLQUFLO0lBQ25DLE1BQU1KLElBQUlDLFNBQVNwaUIsSUFBSTZoQjtJQUN2QlMsRUFBRSxDQUFDLEVBQUUsR0FBR0osS0FBS00sS0FBS0YsRUFBRSxDQUFDLEVBQUUsRUFBRUg7SUFDekJHLEVBQUUsQ0FBQyxFQUFFLEdBQUdKLEtBQUtPLEtBQUtILEVBQUUsQ0FBQyxFQUFFLEVBQUVIO0lBQ3pCSSxFQUFFLENBQUMsRUFBRSxHQUFHTCxLQUFLUSxLQUFLSCxFQUFFLENBQUMsRUFBRSxFQUFFSjtJQUN6QkksRUFBRSxDQUFDLEVBQUUsR0FBR0wsS0FBS1MsS0FBS0osRUFBRSxDQUFDLEVBQUUsRUFBRUo7QUFDM0I7QUFDQSxTQUFTUyxZQUFZQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVwMkMsQ0FBQyxFQUFFNjhCLE1BQU07SUFDaEQsTUFBTXdaLEtBQUtGLE1BQU1GO0lBQ2pCLE1BQU1LLEtBQUtGLE1BQU1GO0lBQ2pCLE1BQU1LLEtBQUt2MkM7SUFDWCxNQUFNdzJDLEtBQUt4MkMsSUFBSTtJQUNmLE1BQU15MkMsS0FBS1AsTUFBTUksS0FBTUMsQ0FBQUEsS0FBS04sR0FBRSxJQUFLSTtJQUNuQyxNQUFNSyxLQUFLUixNQUFNSSxLQUFNRSxDQUFBQSxLQUFLUCxHQUFFLElBQUtJO0lBQ25DLElBQUlFLE1BQU1OLE9BQU9NLEtBQUtKLE9BQU9LLEtBQUtQLE9BQU9PLE1BQU1MLEtBQUs7UUFDbEQsSUFBSTUyQyxLQUFLbzNDLElBQUksQ0FBQ0YsUUFBUWwzQyxLQUFLbzNDLElBQUksQ0FBQ0QsT0FBT24zQyxLQUFLa3pDLEdBQUcsQ0FBQ2dFLE1BQU0sUUFBUWwzQyxLQUFLa3pDLEdBQUcsQ0FBQ2lFLE1BQU0sTUFBTTtZQUNqRixNQUFNanlCLElBQUksQ0FBQ2d5QixLQUFLQyxFQUFDLElBQUs7WUFDdEIsSUFBSWp5QixJQUFJLEdBQUc7Z0JBQ1RvWSxNQUFNLENBQUMsRUFBRSxHQUFHdDlCLEtBQUtrekMsR0FBRyxDQUFDaHVCO2dCQUNyQm9ZLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDZCxPQUFPO2dCQUNMQSxNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNaQSxNQUFNLENBQUMsRUFBRSxHQUFHdDlCLEtBQUtrekMsR0FBRyxDQUFDaHVCO1lBQ3ZCO1FBQ0YsT0FBTztZQUNMLE1BQU1teUIsSUFBSSxDQUFDVixNQUFNRyxLQUFLQyxLQUFLTDtZQUMzQixNQUFNWSxPQUFPdDNDLEtBQUt1M0MsS0FBSyxDQUFDRjtZQUN4QixNQUFNbEIsS0FBS2tCLElBQUlYLE1BQU1RLEtBQU1HLENBQUFBLElBQUlDLElBQUcsSUFBSyxJQUFJO1lBQzNDLE1BQU1sQixLQUFLaUIsSUFBSVQsTUFBTU8sS0FBTSxLQUFLRSxDQUFBQSxJQUFJQyxJQUFHLENBQUMsSUFBSyxJQUFJO1lBQ2pELE1BQU1weUIsSUFBSWxsQixLQUFLa3pDLEdBQUcsQ0FBQ2lELE1BQU1uMkMsS0FBS2t6QyxHQUFHLENBQUNrRCxNQUFNRCxLQUFLLENBQUNDO1lBQzlDLElBQUlseEIsSUFBSSxHQUFHO2dCQUNUb1ksTUFBTSxDQUFDLEVBQUUsR0FBR3Q5QixLQUFLa3pDLEdBQUcsQ0FBQ2lEO2dCQUNyQjdZLE1BQU0sQ0FBQyxFQUFFLEdBQUd0OUIsS0FBS2t6QyxHQUFHLENBQUNrRDtZQUN2QixPQUFPO2dCQUNMOVksTUFBTSxDQUFDLEVBQUUsR0FBR3Q5QixLQUFLa3pDLEdBQUcsQ0FBQ2tEO2dCQUNyQjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUd0OUIsS0FBS2t6QyxHQUFHLENBQUNpRDtZQUN2QjtRQUNGO0lBQ0YsT0FBTztRQUNMN1ksTUFBTSxDQUFDLEVBQUUsR0FBRztRQUNaQSxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQ2Q7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU2thLHNCQUFzQkMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRW56QixNQUFNLEVBQUU4WSxNQUFNO0lBQ2pFLE1BQU02WSxLQUFLYixJQUFJLENBQUMsRUFBRTtJQUNsQixNQUFNYyxLQUFLZCxJQUFJLENBQUMsRUFBRTtJQUNsQixNQUFNc0MsS0FBSyxNQUFNcHpCO0lBQ2pCLE1BQU1xekIsS0FBSyxNQUFNcnpCLFNBQVM7SUFDMUIsTUFBTXFQLElBQUk2akIsT0FBT0MsUUFBUTtJQUN6QixPQUFRRjtRQUNOLEtBQUs7WUFBRztnQkFDTm5hLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1pBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1o7WUFDRjtRQUNBLEtBQUs7WUFBRztnQkFDTixJQUFJb2EsUUFBUUMsT0FBTztvQkFDakJsQixZQUFZLEdBQUdvQixJQUFJaGtCLElBQUksR0FBRyxHQUFHNmpCLE1BQU1wYTtnQkFDckMsT0FBTztvQkFDTEEsTUFBTSxDQUFDLEVBQUUsR0FBRztvQkFDWkEsTUFBTSxDQUFDLEVBQUUsR0FBRztnQkFDZDtnQkFDQTtZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOLElBQUlvYSxRQUFRQyxPQUFPO29CQUNqQmxCLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUdna0IsSUFBSUgsTUFBTXBhO2dCQUNyQyxPQUFPO29CQUNMQSxNQUFNLENBQUMsRUFBRSxHQUFHO29CQUNaQSxNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNkO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ05tWixZQUFZLEdBQUdvQixJQUFJaGtCLElBQUksR0FBRyxHQUFHNmpCLE1BQU12QjtnQkFDbkNNLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUdna0IsSUFBSUgsTUFBTXRCO2dCQUNuQ0YsV0FBV3JpQixHQUFHeWhCO2dCQUNkaFksTUFBTSxDQUFDLEVBQUUsR0FBRzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFO2dCQUN6QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUc2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtnQkFDekI7WUFDRjtRQUNBLEtBQUs7WUFBRztnQkFDTixJQUFJc0IsUUFBUUMsT0FBTztvQkFDakJsQixZQUFZLEdBQUdtQixJQUFJL2pCLElBQUksR0FBRyxHQUFHNmpCLE1BQU1wYTtnQkFDckMsT0FBTztvQkFDTEEsTUFBTSxDQUFDLEVBQUUsR0FBRztvQkFDWkEsTUFBTSxDQUFDLEVBQUUsR0FBRztnQkFDZDtnQkFDQTtZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOQSxNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNaQSxNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNaO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ04sSUFBSXQ5QixLQUFLa3pDLEdBQUcsQ0FBQzF1QixVQUFVLEdBQUc7b0JBQ3hCaXlCLFlBQVksR0FBR21CLElBQUkvakIsR0FBR2drQixJQUFJSCxNQUFNdkI7b0JBQ2hDTSxZQUFZLEdBQUdtQixJQUFJL2pCLElBQUksR0FBRyxHQUFHNmpCLE1BQU10QjtvQkFDbkNLLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUdna0IsSUFBSUgsTUFBTXBhO29CQUNuQzhZLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLEdBQUc5WSxNQUFNLENBQUMsRUFBRTtvQkFDekI4WSxFQUFFLENBQUMsRUFBRSxHQUFHQSxFQUFFLENBQUMsRUFBRSxHQUFHOVksTUFBTSxDQUFDLEVBQUU7b0JBQ3pCQSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO29CQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQ2hDLE9BQU87b0JBQ0xLLFlBQVksR0FBR21CLElBQUkvakIsR0FBR2drQixJQUFJSCxNQUFNcGE7Z0JBQ2xDO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ05tWixZQUFZLEdBQUdtQixJQUFJL2pCLEdBQUdna0IsSUFBSUgsTUFBTXBhO2dCQUNoQztZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOLElBQUlvYSxRQUFRQyxPQUFPO29CQUNqQmxCLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUcrakIsSUFBSUYsTUFBTXBhO2dCQUNyQyxPQUFPO29CQUNMQSxNQUFNLENBQUMsRUFBRSxHQUFHO29CQUNaQSxNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNkO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ04sSUFBSXQ5QixLQUFLa3pDLEdBQUcsQ0FBQzF1QixVQUFVLEdBQUc7b0JBQ3hCaXlCLFlBQVksR0FBR29CLElBQUloa0IsR0FBRytqQixJQUFJRixNQUFNdkI7b0JBQ2hDTSxZQUFZLEdBQUdvQixJQUFJaGtCLElBQUksR0FBRyxHQUFHNmpCLE1BQU10QjtvQkFDbkNLLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUcrakIsSUFBSUYsTUFBTXBhO29CQUNuQzhZLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLEdBQUc5WSxNQUFNLENBQUMsRUFBRTtvQkFDekI4WSxFQUFFLENBQUMsRUFBRSxHQUFHQSxFQUFFLENBQUMsRUFBRSxHQUFHOVksTUFBTSxDQUFDLEVBQUU7b0JBQ3pCQSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO29CQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQ2hDLE9BQU87b0JBQ0xLLFlBQVksR0FBR29CLElBQUloa0IsR0FBRytqQixJQUFJRixNQUFNcGE7Z0JBQ2xDO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLO1lBQUk7Z0JBQ1BBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1pBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1o7WUFDRjtRQUNBLEtBQUs7WUFBSTtnQkFDUG1aLFlBQVksR0FBR29CLElBQUloa0IsR0FBRytqQixJQUFJRixNQUFNcGE7Z0JBQ2hDO1lBQ0Y7UUFDQSxLQUFLO1lBQUk7Z0JBQ1BtWixZQUFZLEdBQUdtQixJQUFJL2pCLElBQUksR0FBRyxHQUFHNmpCLE1BQU12QjtnQkFDbkNNLFlBQVk1aUIsSUFBSSxHQUFHLEdBQUdBLEdBQUcrakIsSUFBSUYsTUFBTXRCO2dCQUNuQ0YsV0FBV3JpQixHQUFHeWhCO2dCQUNkaFksTUFBTSxDQUFDLEVBQUUsR0FBRzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFO2dCQUN6QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUc2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTtnQkFDekI7WUFDRjtRQUNBLEtBQUs7WUFBSTtnQkFDUEssWUFBWSxHQUFHb0IsSUFBSWhrQixHQUFHK2pCLElBQUlGLE1BQU1wYTtnQkFDaEM7WUFDRjtRQUNBLEtBQUs7WUFBSTtnQkFDUG1aLFlBQVksR0FBR21CLElBQUkvakIsR0FBR2drQixJQUFJSCxNQUFNcGE7Z0JBQ2hDO1lBQ0Y7UUFDQSxLQUFLO1lBQUk7Z0JBQ1BBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1pBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7Z0JBQ1o7WUFDRjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVN3YSxhQUFhQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUV6M0MsQ0FBQyxFQUFFQyxDQUFDO0lBQzVDLElBQUk0OEIsU0FBU3lhLFFBQVFFLE9BQU9ELFFBQVFFO0lBQ3BDLElBQUksQ0FBQzVhLFFBQVE7UUFDWCxNQUFNNmEsS0FBSyxDQUFDSixNQUFNRSxHQUFFLElBQUs7UUFDekIsTUFBTUcsS0FBSyxDQUFDSixNQUFNRSxHQUFFLElBQUs7UUFDekIsTUFBTWh6QixJQUFJZ3pCLE1BQU1GO1FBQ2hCLE1BQU03eUIsSUFBSTR5QixNQUFNRTtRQUNoQixNQUFNNVgsS0FBS25iLElBQUt6a0IsQ0FBQUEsSUFBSTAzQyxFQUFDLElBQUtoekIsSUFBS3prQixDQUFBQSxJQUFJMDNDLEVBQUM7UUFDcEM5YSxTQUFTK0MsS0FBSztJQUNoQjtJQUNBLE9BQU8vQztBQUNUO0FBQ0EsU0FBUythLG9CQUFvQk4sR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFSSxFQUFFLEVBQUVDLEVBQUU7SUFDckQsSUFBSTVrQixJQUFJO0lBQ1IsSUFBSyxJQUFJanpCLElBQUksR0FBR0EsSUFBSSswQyxrQkFBa0IsRUFBRS8wQyxFQUFHO1FBQ3pDLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJZzFDLGtCQUFrQixFQUFFaDFDLEVBQUc7WUFDekMsTUFBTSszQyxVQUFVLzNDLElBQUtnMUMsQ0FBQUEsbUJBQW1CO1lBQ3hDLE1BQU1nRCxVQUFVLzNDLElBQUsrMEMsQ0FBQUEsbUJBQW1CO1lBQ3hDLElBQUlxQyxhQUFhQyxLQUFLQyxLQUFLQyxLQUFLQyxLQUFLSSxLQUFLRSxTQUFTRCxLQUFLRSxVQUFVO2dCQUNoRSxFQUFFOWtCO1lBQ0o7UUFDRjtJQUNGO0lBQ0EsT0FBT0EsSUFBSzhoQixDQUFBQSxtQkFBbUJBLGdCQUFlO0FBQ2hEO0FBQ0EsU0FBU2lELFlBQVlqQixPQUFPLEVBQUVNLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRVIsSUFBSSxFQUFFbHpCLE1BQU0sRUFBRThZLE1BQU07SUFDcEUsTUFBTXZTLElBQUkrcUIsYUFBYSxDQUFDMkIsUUFBUTtJQUNoQyxNQUFNa0IsS0FBSzV0QixDQUFDLENBQUMsRUFBRTtJQUNmLE1BQU02dEIsS0FBSzd0QixDQUFDLENBQUMsRUFBRTtJQUNmLElBQUk0dEIsS0FBSyxHQUFHO1FBQ1ZaLE9BQU92ekIsTUFBTSxDQUFDLEVBQUU7UUFDaEJ3ekIsT0FBT3h6QixNQUFNLENBQUMsRUFBRTtJQUNsQjtJQUNBLElBQUlvMEIsS0FBSyxHQUFHO1FBQ1ZYLE9BQU96ekIsTUFBTSxDQUFDLEVBQUU7UUFDaEIwekIsT0FBTzF6QixNQUFNLENBQUMsRUFBRTtJQUNsQjtJQUNBOFksTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJK2Esb0JBQW9CTixLQUFLQyxLQUFLQyxLQUFLQyxLQUFLLElBQUlSLE1BQU0sSUFBSUE7SUFDdEVwYSxNQUFNLENBQUMsRUFBRSxHQUFHK2Esb0JBQW9CTixLQUFLQyxLQUFLQyxLQUFLQyxLQUFLLElBQUlSLE1BQU0sSUFBSUE7SUFDbEUsT0FBT3BhO0FBQ1Q7QUFDQSxTQUFTdWIsc0JBQXNCcEIsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRW56QixNQUFNLEVBQUU4WSxNQUFNO0lBQ2pFLE1BQU02WSxLQUFLYixJQUFJLENBQUMsRUFBRTtJQUNsQixNQUFNYyxLQUFLZCxJQUFJLENBQUMsRUFBRTtJQUNsQixNQUFNemhCLElBQUk2akIsT0FBT0MsUUFBUTtJQUN6QixPQUFRRjtRQUNOLEtBQUs7WUFBRztnQkFDTmlCLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVEyeEI7Z0JBQ3ZEdUMsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTR4QjtnQkFDdkQ5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ05zQyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRMnhCO2dCQUN2RHVDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVE0eEI7Z0JBQ3ZEOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjtZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOc0MsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTJ4QjtnQkFDdkR1QyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRNHhCO2dCQUN2RDlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI7WUFDRjtRQUNBLEtBQUs7WUFBRztnQkFDTnNDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVE4WTtnQkFDdkQ7WUFDRjtRQUNBLEtBQUs7WUFBRztnQkFDTm9iLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVEyeEI7Z0JBQ3ZEdUMsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTR4QjtnQkFDdkQ5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ05zQyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRMnhCO2dCQUN2RHVDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVE0eEI7Z0JBQ3ZEOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjtZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOc0MsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUThZO2dCQUN2RDtZQUNGO1FBQ0EsS0FBSztZQUFHO2dCQUNOb2IsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTJ4QjtnQkFDdkR1QyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRNHhCO2dCQUN2RDlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI7WUFDRjtRQUNBLEtBQUs7WUFBRztnQkFDTnNDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVEyeEI7Z0JBQ3ZEdUMsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTR4QjtnQkFDdkQ5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCO1lBQ0Y7UUFDQSxLQUFLO1lBQUc7Z0JBQ05zQyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFROFk7Z0JBQ3ZEb2IsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUThZO2dCQUN2RDtZQUNGO1FBQ0EsS0FBSztZQUFJO2dCQUNQb2IsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTJ4QjtnQkFDdkR1QyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRNHhCO2dCQUN2RDlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI7WUFDRjtRQUNBLEtBQUs7WUFBSTtnQkFDUHNDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVEyeEI7Z0JBQ3ZEdUMsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTR4QjtnQkFDdkQ5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCO1lBQ0Y7UUFDQSxLQUFLO1lBQUk7Z0JBQ1BzQyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFROFk7Z0JBQ3ZEO1lBQ0Y7UUFDQSxLQUFLO1lBQUk7Z0JBQ1BvYixZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRMnhCO2dCQUN2RHVDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVE0eEI7Z0JBQ3ZEOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjtZQUNGO1FBQ0EsS0FBSztZQUFJO2dCQUNQc0MsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTJ4QjtnQkFDdkR1QyxZQUFZakIsU0FBUyxHQUFHLEdBQUcsSUFBSTVqQixHQUFHLElBQUlBLEdBQUc2akIsTUFBTWx6QixRQUFRNHhCO2dCQUN2RDlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCOVksTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDNlksRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUI7WUFDRjtRQUNBLEtBQUs7WUFBSTtnQkFDUHNDLFlBQVlqQixTQUFTLEdBQUcsR0FBRyxJQUFJNWpCLEdBQUcsSUFBSUEsR0FBRzZqQixNQUFNbHpCLFFBQVEyeEI7Z0JBQ3ZEdUMsWUFBWWpCLFNBQVMsR0FBRyxHQUFHLElBQUk1akIsR0FBRyxJQUFJQSxHQUFHNmpCLE1BQU1sekIsUUFBUTR4QjtnQkFDdkQ5WSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUM2WSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxJQUFJO2dCQUM5QjlZLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQzZZLEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLElBQUk7Z0JBQzlCO1lBQ0Y7SUFDRjtJQUNBLE9BQU85WTtBQUNUO0FBQ0EsU0FBU3diLGlCQUFpQkMsUUFBUSxFQUFFdjBCLE1BQU0sRUFBRXcwQixVQUFVO0lBQ3BELE1BQU0xYixTQUFTLElBQUlsd0IsYUFBYTtJQUNoQyxJQUFLLElBQUl0TixJQUFJLEdBQUdxckIsSUFBSTR0QixTQUFTdGlCLE1BQU0sRUFBRTMyQixJQUFJcXJCLEdBQUcsRUFBRXJyQixFQUFHO1FBQy9DLE1BQU0yM0MsVUFBVXNCLFFBQVEsQ0FBQ2o1QyxFQUFFO1FBQzNCLE1BQU13WCxPQUFPbWdDLFFBQVFuZ0MsSUFBSTtRQUN6QixNQUFNMmpCLE9BQU93YyxRQUFRNTJDLEtBQUs7UUFDMUIsSUFBSyxJQUFJSCxJQUFJLEdBQUdBLElBQUl1NkIsTUFBTSxFQUFFdjZCLEVBQUc7WUFDN0IsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUl3NkIsTUFBTSxFQUFFeDZCLEVBQUc7Z0JBQzdCLElBQUl1NEMsWUFBWTtvQkFDZHhCLHNCQUFzQjEzQyxHQUFHVyxHQUFHQyxHQUFHOGpCLFFBQVE4WTtnQkFDekMsT0FBTztvQkFDTHViLHNCQUFzQi80QyxHQUFHVyxHQUFHQyxHQUFHOGpCLFFBQVE4WTtnQkFDekM7Z0JBQ0EsTUFBTStDLEtBQUssQ0FBQzMvQixJQUFJdTZCLE9BQU94NkIsQ0FBQUEsSUFBSztnQkFDNUI2VyxJQUFJLENBQUMrb0IsR0FBRyxHQUFHL0MsTUFBTSxDQUFDLEVBQUUsR0FBRztnQkFDdkJobUIsSUFBSSxDQUFDK29CLEtBQUssRUFBRSxHQUFHL0MsTUFBTSxDQUFDLEVBQUUsR0FBRztZQUM3QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVMyYixTQUFTQyxLQUFLLEVBQUVDLEtBQUssRUFBRUosUUFBUSxFQUFFSyxNQUFNLEVBQUVuZSxJQUFJLEVBQUUrZCxVQUFVLEVBQUVsWSxNQUFNO0lBQ3hFLE1BQU11WSxVQUFVdlksT0FBT3hwQixJQUFJO0lBQzNCLE1BQU1naUMsV0FBV3hZLE9BQU9qZ0MsS0FBSztJQUM3QixJQUFLLElBQUlmLElBQUksR0FBR3FyQixJQUFJNHRCLFNBQVN0aUIsTUFBTSxFQUFFMzJCLElBQUlxckIsR0FBRyxFQUFFcnJCLEVBQUc7UUFDL0MsTUFBTXk1QyxPQUFPSCxNQUFNLENBQUN0NUMsRUFBRTtRQUN0QixNQUFNMjNDLFVBQVVzQixRQUFRLENBQUNqNUMsRUFBRTtRQUMzQixNQUFNMDVDLFVBQVUvQixRQUFRbmdDLElBQUk7UUFDNUIsTUFBTW1pQyxXQUFXaEMsUUFBUTUyQyxLQUFLO1FBQzlCLElBQUssSUFBSUgsSUFBSSxHQUFHQSxJQUFJdTZCLE1BQU0sRUFBRXY2QixFQUFHO1lBQzdCLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJdzZCLE1BQU0sRUFBRXg2QixFQUFHO2dCQUM3QixNQUFNNjNDLEtBQUtpQixJQUFJLENBQUMsRUFBRSxHQUFHdGUsT0FBT2llLFFBQVF6NEM7Z0JBQ3BDLE1BQU04M0MsS0FBS2dCLElBQUksQ0FBQyxFQUFFLEdBQUd0ZSxPQUFPa2UsUUFBUXo0QztnQkFDcEMsTUFBTTIvQixLQUFLLENBQUNrWSxLQUFLZSxXQUFXaEIsRUFBQyxJQUFLO2dCQUNsQyxNQUFNemtCLElBQUltbEIsYUFBYSxDQUFDdDRDLElBQUlBLElBQUkrNEMsV0FBV2g1QyxJQUFJQSxDQUFBQSxJQUFLLElBQUksQ0FBQ0MsSUFBSSs0QyxXQUFXaDVDLENBQUFBLElBQUs7Z0JBQzdFNDRDLE9BQU8sQ0FBQ2haLEdBQUcsR0FBR21aLE9BQU8sQ0FBQzNsQixFQUFFO2dCQUN4QndsQixPQUFPLENBQUNoWixLQUFLLEVBQUUsR0FBR21aLE9BQU8sQ0FBQzNsQixJQUFJLEVBQUU7Z0JBQ2hDd2xCLE9BQU8sQ0FBQ2haLEtBQUssRUFBRSxHQUFHO2dCQUNsQmdaLE9BQU8sQ0FBQ2haLEtBQUssRUFBRSxHQUFHO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSXFaLG9CQUFvQjtJQUN0Qjs7OztHQUlDLEdBQ0QsT0FBTzliLFdBQVc7UUFDaEIsTUFBTS84QixRQUFRLElBQUksSUFBSTAwQztRQUN0QixNQUFNejBDLFNBQVM2MEMsNkJBQTZCbGYsTUFBTSxHQUFHLElBQUk4ZTtRQUN6RCxNQUFNaitCLE9BQU8sSUFBSXFpQyxrQkFBa0I5NEMsUUFBUUMsU0FBUztRQUNwRCxNQUFNdzhCLFNBQVMsSUFBSWdSLGFBQWF6dEMsT0FBT0MsUUFBUXdXO1FBQy9DLE1BQU1zaUMsa0JBQWtCNTVDLEtBQUsrb0MsR0FBRyxDQUFDd00sa0JBQWtCLEdBQUcsS0FBSztRQUMzRCxNQUFNc0Usa0JBQWtCckU7UUFDeEIsTUFBTXNFLHFCQUFxQixFQUFFO1FBQzdCLE1BQU1DLG1CQUFtQixFQUFFO1FBQzNCLElBQUssSUFBSWo2QyxJQUFJLEdBQUdxckIsSUFBSTdULEtBQUttZixNQUFNLEVBQUUzMkIsSUFBSXFyQixHQUFHcnJCLEtBQUssRUFBRztZQUM5Q3dYLElBQUksQ0FBQ3hYLEVBQUUsR0FBRztRQUNaO1FBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQzNCZzZDLG1CQUFtQnhoQixJQUFJLENBQUMsSUFBSWdXLGFBQzFCc0wsaUJBQ0FBLGlCQUNBLElBQUlELGtCQUFrQkMsa0JBQWtCQSxrQkFBa0IsSUFDMUQ7WUFFRkcsaUJBQWlCemhCLElBQUksQ0FBQyxJQUFJZ1csYUFDeEJ1TCxpQkFDQUEsaUJBQ0EsSUFBSUYsa0JBQWtCRSxrQkFBa0JBLGtCQUFrQixJQUMxRDtRQUVKO1FBQ0EsSUFBSyxJQUFJLzVDLElBQUksR0FBR3FyQixJQUFJd3FCLDZCQUE2QmxmLE1BQU0sRUFBRTMyQixJQUFJcXJCLEdBQUcsRUFBRXJyQixFQUFHO1lBQ25FZzVDLGlCQUFpQmdCLG9CQUFvQm5FLDRCQUE0QixDQUFDNzFDLEVBQUUsRUFBRTtZQUN0RW01QyxTQUNFLEdBQ0EsSUFBSTFELGtCQUFrQnoxQyxHQUN0Qmc2QyxvQkFDQWpFLGlCQUNBTixpQkFDQSxNQUNBalk7UUFFSjtRQUNBLElBQUssSUFBSXg5QixJQUFJLEdBQUdxckIsSUFBSXlxQiwyQkFBMkJuZixNQUFNLEVBQUUzMkIsSUFBSXFyQixHQUFHLEVBQUVyckIsRUFBRztZQUNqRWc1QyxpQkFBaUJpQixrQkFBa0JuRSwwQkFBMEIsQ0FBQzkxQyxFQUFFLEVBQUU7WUFDbEVtNUMsU0FDRSxJQUFJMUQsaUJBQ0osSUFBSUMsZ0JBQWdCMTFDLEdBQ3BCaTZDLGtCQUNBakUsZUFDQU4sZUFDQSxPQUNBbFk7UUFFSjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLDBDQUEwQztBQUNIO0FBRXZDLHNCQUFzQjtBQUN0QixJQUFJMmMsa0JBQWtCO0FBRXRCLDBDQUEwQztBQUMxQyxTQUFTcmMsU0FBU3NjLFdBQVcsSUFBSTtJQUMvQixNQUFNeEssWUFBWUMsSUFBSUMsZUFBZSxDQUFDLElBQUlDLEtBQUs7UUFBQ29LO0tBQWdCLEVBQUU7UUFDaEVuOUIsTUFBTTtJQUNSO0lBQ0EsTUFBTWd6QixTQUFTLElBQUlDLE9BQU9MO0lBQzFCQyxJQUFJTyxlQUFlLENBQUNSO0lBQ3BCLE9BQU8sSUFBSXZlLFFBQVEsQ0FBQ0MsU0FBU3FlO1FBQzNCSyxPQUFPaGxCLGdCQUFnQixDQUFDLFNBQVMsQ0FBQzZKLFFBQVU4YSxPQUFPOWEsTUFBTXFiLEtBQUs7UUFDOURGLE9BQU9obEIsZ0JBQWdCLENBQUMsV0FBVyxDQUFDNko7WUFDbEMsTUFBTXdsQixrQkFBa0I3TCxhQUFhRyxJQUFJLENBQUM5WixNQUFNcmQsSUFBSSxDQUFDNmlDLGVBQWU7WUFDcEUsTUFBTUMsZ0JBQWdCOUwsYUFBYUcsSUFBSSxDQUFDOVosTUFBTXJkLElBQUksQ0FBQzhpQyxhQUFhO1lBQ2hFLE1BQU1DLE9BQU87Z0JBQ1hGLGdCQUFnQjNMLFFBQVEsR0FBRzhMLFNBQVMsQ0FBQyxhQUFhO2dCQUNsREYsY0FBYzVMLFFBQVEsR0FBRzhMLFNBQVMsQ0FBQyxhQUFhO2FBQ2pEO1lBQ0QsSUFBSUosVUFBVTtnQkFDWkssYUFBYUMsT0FBTyxDQUFDLGVBQWVILElBQUksQ0FBQyxFQUFFO2dCQUMzQ0UsYUFBYUMsT0FBTyxDQUFDLGFBQWFILElBQUksQ0FBQyxFQUFFO1lBQzNDO1lBQ0FqcEIsUUFBUWlwQjtRQUNWO1FBQ0F2SyxPQUFPTSxXQUFXLENBQUM7SUFDckI7QUFDRjtBQUNBLElBQUlxSyxxQkFBcUI7SUFDdkI7O0dBRUMsR0FDRHArQyxhQUFjO1FBQ1osSUFBSSxDQUFDcStDLFlBQVksR0FBRztJQUN0QjtJQUNBOzs7O0dBSUMsR0FDREMsZ0JBQWdCcDlDLEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUNtOUMsWUFBWSxHQUFHLENBQUNuOUM7SUFDdkI7SUFDQTs7Ozs7Ozs7R0FRQyxHQUNEcWdDLFdBQVc7UUFDVCxNQUFNc2MsV0FBVyxDQUFDLElBQUksQ0FBQ1EsWUFBWSxJQUFJRSxPQUFPTCxZQUFZLEtBQUssS0FBSztRQUNwRSxNQUFNTSxhQUFhWCxXQUFXO1lBQzVCSyxhQUFhTyxPQUFPLENBQUM7WUFDckJQLGFBQWFPLE9BQU8sQ0FBQztTQUN0QixHQUFHO1lBQUM7WUFBTTtTQUFLO1FBQ2hCLE1BQU10TCxVQUFVcUwsVUFBVSxDQUFDLEVBQUUsS0FBSyxRQUFRQSxVQUFVLENBQUMsRUFBRSxLQUFLLE9BQU8xcEIsUUFBUUMsT0FBTyxDQUFDeXBCLGNBQWNqZCxTQUFTc2M7UUFDMUcsT0FBTzFLLFFBQVF1TCxJQUFJLENBQUMsQ0FBQ1Y7WUFDbkIsT0FBTyxJQUFJbHBCLFFBQVEsQ0FBQ0MsU0FBU3FlO2dCQUMzQixNQUFNdUwsY0FBYyxJQUFJL007Z0JBQ3hCLE1BQU1nTixZQUFZLElBQUloTjtnQkFDdEIsTUFBTWxnQixVQUFVLElBQUlpc0IsaURBQWNBO2dCQUNsQ2pzQixRQUFRbXRCLE1BQU0sR0FBRyxJQUFNOXBCLFFBQVE7d0JBQUM0cEI7d0JBQWFDO3FCQUFVO2dCQUN2RGx0QixRQUFRb3RCLE9BQU8sR0FBRzFMO2dCQUNsQnVMLFlBQVlsd0IsZ0JBQWdCLENBQUMsU0FBUyxDQUFDQyxJQUFNZ0QsUUFBUXF0QixTQUFTLENBQUM7Z0JBQy9ESCxVQUFVbndCLGdCQUFnQixDQUFDLFNBQVMsQ0FBQ0MsSUFBTWdELFFBQVFxdEIsU0FBUyxDQUFDO2dCQUM3REosWUFBWWx3QixnQkFBZ0IsQ0FBQyxRQUFRLElBQU1pRCxRQUFRc3RCLE9BQU8sQ0FBQztnQkFDM0RKLFVBQVVud0IsZ0JBQWdCLENBQUMsUUFBUSxJQUFNaUQsUUFBUXN0QixPQUFPLENBQUM7Z0JBQ3pEdHRCLFFBQVF1dEIsU0FBUyxDQUFDO2dCQUNsQnZ0QixRQUFRdXRCLFNBQVMsQ0FBQztnQkFDbEJOLFlBQVlseUMsR0FBRyxHQUFHdXhDLElBQUksQ0FBQyxFQUFFO2dCQUN6QlksVUFBVW55QyxHQUFHLEdBQUd1eEMsSUFBSSxDQUFDLEVBQUU7WUFDekI7UUFDRjtJQUNGO0FBQ0Y7QUFFQSwyQ0FBMkM7QUFDM0MsSUFBSWtCLFFBQVEsYUFBYSxHQUFHLElBQUlyekMsSUFBSTtJQUNsQztRQUFDc3pDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7SUFDdEQ7UUFBQ291QyxTQUFTLEdBQUcsR0FBRyxHQUFHO1FBQUksSUFBSXB1QyxhQUFhO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtLQUFFO0lBQ3REO1FBQUNvdUMsU0FBUyxHQUFHLEdBQUcsR0FBRztRQUFJLElBQUlwdUMsYUFBYTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7S0FBRTtJQUN0RDtRQUFDb3VDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7SUFDdEQ7UUFBQ291QyxTQUFTLEdBQUcsR0FBRyxHQUFHO1FBQUksSUFBSXB1QyxhQUFhO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtLQUFFO0lBQ3REO1FBQUNvdUMsU0FBUyxHQUFHLEdBQUcsR0FBRztRQUFJLElBQUlwdUMsYUFBYTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7S0FBRTtJQUN0RDtRQUFDb3VDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7SUFDdEQ7UUFBQ291QyxTQUFTLEdBQUcsR0FBRyxHQUFHO1FBQUksSUFBSXB1QyxhQUFhO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtLQUFFO0lBQ3REO1FBQUNvdUMsU0FBUyxHQUFHLEdBQUcsR0FBRztRQUFJLElBQUlwdUMsYUFBYTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7S0FBRTtJQUN0RDtRQUFDb3VDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7SUFDdEQ7UUFBQ291QyxTQUFTLEdBQUcsR0FBRyxHQUFHO1FBQUksSUFBSXB1QyxhQUFhO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtLQUFFO0lBQ3REO1FBQUNvdUMsU0FBUyxHQUFHLEdBQUcsR0FBRztRQUFJLElBQUlwdUMsYUFBYTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7S0FBRTtJQUN0RDtRQUFDb3VDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7SUFDdEQ7UUFBQ291QyxTQUFTLEdBQUcsR0FBRyxHQUFHO1FBQUksSUFBSXB1QyxhQUFhO1lBQUM7WUFBRztZQUFHO1lBQUc7U0FBRTtLQUFFO0lBQ3REO1FBQUNvdUMsU0FBUyxHQUFHLEdBQUcsR0FBRztRQUFJLElBQUlwdUMsYUFBYTtZQUFDO1lBQUc7WUFBRztZQUFHO1NBQUU7S0FBRTtJQUN0RDtRQUFDb3VDLFNBQVMsR0FBRyxHQUFHLEdBQUc7UUFBSSxJQUFJcHVDLGFBQWE7WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO0tBQUU7Q0FDdkQ7QUFDRCxTQUFTcXVDLE1BQU12MkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU2d0IsQ0FBQztJQUNwQixPQUFPOXdCLElBQUksQ0FBQ0MsSUFBSUQsQ0FBQUEsSUFBSzh3QjtBQUN2QjtBQUNBLFNBQVN3RixTQUFTRSxFQUFFLEVBQUUvQyxFQUFFLEVBQUVDLEVBQUUsRUFBRStDLEVBQUU7SUFDOUIsTUFBTXoyQixJQUFJdTJCLE1BQU1DLElBQUkvQyxJQUFJLElBQUk7SUFDNUIsTUFBTXh6QixJQUFJczJCLE1BQU03QyxJQUFJK0MsSUFBSSxJQUFJO0lBQzVCLE9BQU9GLE1BQU12MkIsR0FBR0MsR0FBRyxJQUFJO0FBQ3pCO0FBQ0EsU0FBU3kyQixVQUFVbEUsSUFBSSxFQUFFbUUsR0FBRztJQUMxQixJQUFJaG9CLElBQUk7SUFDUixJQUFJZ29CLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUNoQmhvQixLQUFLO0lBQ1A7SUFDQSxJQUFJQSxNQUFNLEtBQUtnb0IsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLbkUsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxJQUFJLENBQUMsRUFBRSxLQUFLLEdBQUc7UUFDN0Q3akIsS0FBSztJQUNQO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNpb0IsV0FBV3BFLElBQUksRUFBRW1FLEdBQUc7SUFDM0IsSUFBSWhvQixJQUFJO0lBQ1IsSUFBSWdvQixHQUFHLENBQUMsRUFBRSxLQUFLLEtBQUtuRSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLElBQUksQ0FBQyxFQUFFLEtBQUssR0FBRztRQUNsRDdqQixLQUFLO0lBQ1A7SUFDQSxJQUFJQSxNQUFNLEtBQUtnb0IsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLbkUsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxJQUFJLENBQUMsRUFBRSxLQUFLLEdBQUc7UUFDN0Q3akIsS0FBSztJQUNQO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLElBQUlrb0Isc0JBQXNCO0lBQ3hCOzs7O0dBSUMsR0FDRCxPQUFPbmUsV0FBVztRQUNoQixNQUFNLzhCLFFBQVE7UUFDZCxNQUFNQyxTQUFTO1FBQ2YsTUFBTWs3QyxZQUFZbjdDLFFBQVE7UUFDMUIsTUFBTW83QyxlQUFlO1FBQ3JCLE1BQU1DLGdCQUFnQjtRQUN0QixNQUFNNWtDLE9BQU8sSUFBSXFpQyxrQkFBa0I5NEMsUUFBUUM7UUFDM0MsTUFBTXE3QyxjQUFjLElBQUl4QyxrQkFBa0JzQyxlQUFlQyxnQkFBZ0I7UUFDekUsSUFBSyxJQUFJeDdDLElBQUksR0FBR0EsSUFBSUksUUFBUSxFQUFFSixFQUFHO1lBQy9CLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJSSxPQUFPLEVBQUVKLEVBQUc7Z0JBQzlCLE1BQU1rYSxJQUFJLFVBQVVsYTtnQkFDcEIsTUFBTTQyQyxJQUFJLFVBQVUzMkM7Z0JBQ3BCLElBQUk2NkMsTUFBTTFZLEdBQUcsQ0FBQ2xvQixNQUFNNGdDLE1BQU0xWSxHQUFHLENBQUN3VSxJQUFJO29CQUNoQyxNQUFNc0IsS0FBSzRDLE1BQU1oekMsR0FBRyxDQUFDb1M7b0JBQ3JCLE1BQU1pK0IsS0FBSzJDLE1BQU1oekMsR0FBRyxDQUFDOHVDO29CQUNyQixNQUFNdjNDLElBQUlZLElBQUlHLFFBQVFKO29CQUN0QjZXLElBQUksQ0FBQ3hYLEVBQUUsR0FBRyxNQUFNODdDLFVBQVVqRCxJQUFJQztvQkFDOUJ0aEMsSUFBSSxDQUFDeFgsSUFBSWs4QyxVQUFVLEdBQUcsTUFBTUYsV0FBV25ELElBQUlDO2dCQUM3QztZQUNGO1FBQ0Y7UUFDQSxJQUFLLElBQUk5NEMsSUFBSSxHQUFHWSxJQUFJSSxTQUFTbzdDLGVBQWV4N0MsSUFBSUksUUFBUSxFQUFFSixFQUFHO1lBQzNELElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJdzdDLGNBQWMsRUFBRXg3QyxHQUFHWCxLQUFLLEVBQUc7Z0JBQzdDcThDLFdBQVcsQ0FBQ3I4QyxFQUFFLEdBQUd3WCxJQUFJLENBQUM1VyxJQUFJRyxRQUFRSixFQUFFO2dCQUNwQzA3QyxXQUFXLENBQUNyOEMsSUFBSSxFQUFFLEdBQUc7WUFDdkI7UUFDRjtRQUNBLE9BQU8sSUFBSXd1QyxhQUFhMk4sY0FBY0MsZUFBZUM7SUFDdkQ7QUFDRjtBQUVBLCtCQUErQjtBQVFoQjtBQUNmLFNBQVNPLFNBQVN6aEIsSUFBSSxFQUFFYyxNQUFNLEVBQUVqZixJQUFJO0lBQ2xDLE1BQU02L0IsV0FBVyxhQUFhLEdBQUcsSUFBSXowQyxJQUFJO1FBQ3ZDO1lBQUNtMEMsa0RBQWVBO1lBQUU7U0FBRTtRQUNwQjtZQUFDQyw0Q0FBU0E7WUFBRTtTQUFFO1FBQ2Q7WUFBQ0MsMkNBQVFBO1lBQUU7U0FBRTtRQUNiO1lBQUNDLDZDQUFXQTtZQUFFO1NBQUU7S0FDakI7SUFDRCxJQUFJbGxDO0lBQ0osSUFBSSxDQUFDcWxDLFNBQVM5WixHQUFHLENBQUM5RyxTQUFTO1FBQ3pCNXlCLFFBQVE2bUMsS0FBSyxDQUFDO0lBQ2hCO0lBQ0EsSUFBSWx6QixTQUFTMi9CLG1EQUFrQkEsRUFBRTtRQUMvQm5sQyxPQUFPLElBQUl5WixXQUFXa0ssT0FBTzBoQixTQUFTcDBDLEdBQUcsQ0FBQ3d6QjtRQUMxQyxJQUFLLElBQUlqOEIsSUFBSSxHQUFHcXJCLElBQUk3VCxLQUFLbWYsTUFBTSxFQUFFMzJCLElBQUlxckIsR0FBRyxFQUFFcnJCLEVBQUc7WUFDM0N3WCxJQUFJLENBQUN4WCxFQUFFLEdBQUdFLEtBQUs0OEMsTUFBTSxLQUFLLE1BQU07UUFDbEM7SUFDRixPQUFPO1FBQ0x0bEMsT0FBTyxJQUFJbEssYUFBYTZ0QixPQUFPMGhCLFNBQVNwMEMsR0FBRyxDQUFDd3pCO1FBQzVDLElBQUssSUFBSWo4QixJQUFJLEdBQUdxckIsSUFBSTdULEtBQUttZixNQUFNLEVBQUUzMkIsSUFBSXFyQixHQUFHLEVBQUVyckIsRUFBRztZQUMzQ3dYLElBQUksQ0FBQ3hYLEVBQUUsR0FBR0UsS0FBSzQ4QyxNQUFNO1FBQ3ZCO0lBQ0Y7SUFDQSxPQUFPdGxDO0FBQ1Q7QUFDQSxJQUFJdWxDLGVBQWUsY0FBY1QsOENBQVlBO0lBQzNDOzs7Ozs7Ozs7O0dBVUMsR0FDRC8vQyxZQUFZd0UsS0FBSyxFQUFFQyxNQUFNLEVBQUVpN0IsU0FBU3NnQixrREFBZSxFQUFFdi9CLE9BQU8yL0IsbURBQWtCLENBQUU7UUFDOUUsS0FBSyxDQUFDQyxTQUFTNzdDLFFBQVFDLFFBQVFpN0IsUUFBUWpmLE9BQU9qYyxPQUFPQyxRQUFRaTdCLFFBQVFqZjtRQUNyRSxJQUFJLENBQUNsZixXQUFXLEdBQUc7SUFDckI7QUFDRjtBQUVBLCtCQUErQjtBQUMvQixJQUFJay9DLGlCQUFpQjtBQUVyQiw4QkFBOEI7QUFDOUIsSUFBSUMsYUFBYTtBQUNqQixTQUFTQyxZQUFZQyxHQUFHLEVBQUVDLElBQUk7SUFDNUIsT0FBT0QsTUFBTWo5QyxLQUFLNDhDLE1BQU0sS0FBTU0sQ0FBQUEsT0FBT0QsR0FBRTtBQUN6QztBQUNBLElBQUlFLGVBQWUsY0FBY3BYO0lBQy9COzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRDFwQyxZQUFZLEVBQ1YrZ0QsNEJBQTRCLElBQUksRUFDaENDLFFBQVEsSUFBSWhRLDBDQUFTQSxDQUFDLEtBQUssSUFBSSxFQUMvQmlRLFdBQVcsSUFBSWpRLDBDQUFTQSxDQUFDLEtBQUssRUFBRSxFQUNoQzN3QixXQUFXLElBQUkyd0IsMENBQVNBLENBQUMsS0FBSyxFQUFFLEVBQ2hDa1EsVUFBVSxJQUFJLEVBQ2RDLFFBQVEsSUFBSSxFQUNaQyxrQkFBa0IsSUFBSSxFQUN0QkMsU0FBUyxFQUFFLEVBQ1osR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNOLEtBQUssQ0FBQyxnQkFBZ0JaLGdCQUFnQjtZQUNwQ3JnRCxVQUFVLGFBQWEsR0FBRyxJQUFJeUwsSUFBSTtnQkFDaEM7b0JBQUM7b0JBQW1CLElBQUlrbEMsMENBQVNBLENBQUM7aUJBQU07Z0JBQ3hDO29CQUFDO29CQUFXLElBQUlBLDBDQUFTQSxDQUFDbVE7aUJBQVM7Z0JBQ25DO29CQUFDO29CQUFVLElBQUluUSwwQ0FBU0EsQ0FBQztpQkFBTztnQkFDaEM7b0JBQUM7b0JBQVUsSUFBSUEsMENBQVNBLENBQUM7aUJBQUc7Z0JBQzVCO29CQUFDO29CQUFTLElBQUlBLDBDQUFTQSxDQUFDLElBQUlDLDBDQUFTQTtpQkFBSTtnQkFDekM7b0JBQUM7b0JBQWMsSUFBSUQsMENBQVNBLENBQUMsSUFBSUMsMENBQVNBO2lCQUFJO2FBQy9DO1FBQ0g7UUFDQSxJQUFJb1Esb0JBQW9CLE1BQU07WUFDNUIsTUFBTXJkLE1BQU0sSUFBSXljLGFBQWFhLFFBQVFBLFFBQVF2USw2Q0FBV0E7WUFDeEQvTSxJQUFJOWpDLElBQUksR0FBR3lnRDtZQUNYLElBQUksQ0FBQ1UsZUFBZSxHQUFHcmQ7UUFDekIsT0FBTztZQUNMLElBQUksQ0FBQ3FkLGVBQWUsR0FBR0E7UUFDekI7UUFDQSxJQUFJLENBQUN4bUMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMG1DLFVBQVUsR0FBRyxJQUFJLENBQUNsaEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGNBQWNoTCxLQUFLO1FBQ3ZELElBQUksQ0FBQzgvQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ00sVUFBVSxHQUFHLElBQUl2USwwQ0FBU0EsQ0FDN0IyUCxZQUFZLElBQUksQ0FBQ0ssS0FBSyxDQUFDNThDLENBQUMsRUFBRSxJQUFJLENBQUM0OEMsS0FBSyxDQUFDMzhDLENBQUMsR0FDdENzOEMsWUFBWSxJQUFJLENBQUNNLFFBQVEsQ0FBQzc4QyxDQUFDLEVBQUUsSUFBSSxDQUFDNjhDLFFBQVEsQ0FBQzU4QyxDQUFDO1FBRTlDLElBQUksQ0FBQ2djLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDeFQsSUFBSSxHQUFHNUQsV0FBV0UsUUFBUTtRQUMvQixJQUFJLENBQUNnNEMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0oseUJBQXlCLEdBQUdBO0lBQ25DO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJUyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNwaEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFNBQVNoTCxLQUFLO0lBQ3pDO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUl1Z0QsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDcmhELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxVQUFVaEwsS0FBSztJQUMxQztJQUNBOzs7OztHQUtDLEdBQ0R3Z0QsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDRCxNQUFNO0lBQ3BCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlFLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1gsS0FBSyxDQUFDNThDLENBQUM7SUFDckI7SUFDQSxJQUFJdTlDLFNBQVN6Z0QsS0FBSyxFQUFFO1FBQ2xCLElBQUksQ0FBQzgvQyxLQUFLLENBQUM1OEMsQ0FBQyxHQUFHbEQ7SUFDakI7SUFDQTs7Ozs7R0FLQyxHQUNEMGdELGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQ1osS0FBSyxDQUFDNThDLENBQUM7SUFDckI7SUFDQTs7Ozs7R0FLQyxHQUNEeTlDLFlBQVkzZ0QsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQzgvQyxLQUFLLENBQUM1OEMsQ0FBQyxHQUFHbEQ7SUFDakI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSTRnRCxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNkLEtBQUssQ0FBQzM4QyxDQUFDO0lBQ3JCO0lBQ0EsSUFBSXk5QyxTQUFTNWdELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUM4L0MsS0FBSyxDQUFDMzhDLENBQUMsR0FBR25EO0lBQ2pCO0lBQ0E7Ozs7O0dBS0MsR0FDRDZnRCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUNmLEtBQUssQ0FBQzM4QyxDQUFDO0lBQ3JCO0lBQ0E7Ozs7O0dBS0MsR0FDRDI5QyxZQUFZOWdELEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUM4L0MsS0FBSyxDQUFDMzhDLENBQUMsR0FBR25EO0lBQ2pCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUkrZ0QsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ2hCLFFBQVEsQ0FBQzc4QyxDQUFDO0lBQ3hCO0lBQ0EsSUFBSTY5QyxZQUFZL2dELEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUMrL0MsUUFBUSxDQUFDNzhDLENBQUMsR0FBR2xEO0lBQ3BCO0lBQ0E7Ozs7O0dBS0MsR0FDRGdoRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQzc4QyxDQUFDO0lBQ3hCO0lBQ0E7Ozs7O0dBS0MsR0FDRCs5QyxlQUFlamhELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUMrL0MsUUFBUSxDQUFDNzhDLENBQUMsR0FBR2xEO0lBQ3BCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlraEQsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ25CLFFBQVEsQ0FBQzU4QyxDQUFDO0lBQ3hCO0lBQ0EsSUFBSSs5QyxZQUFZbGhELEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUMrL0MsUUFBUSxDQUFDNThDLENBQUMsR0FBR25EO0lBQ3BCO0lBQ0E7Ozs7O0dBS0MsR0FDRG1oRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQ3BCLFFBQVEsQ0FBQzU4QyxDQUFDO0lBQ3hCO0lBQ0E7Ozs7O0dBS0MsR0FDRGkrQyxlQUFlcGhELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUMrL0MsUUFBUSxDQUFDNThDLENBQUMsR0FBR25EO0lBQ3BCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlxaEQsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ2xpQyxRQUFRLENBQUNqYyxDQUFDO0lBQ3hCO0lBQ0EsSUFBSW0rQyxZQUFZcmhELEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUNtZixRQUFRLENBQUNqYyxDQUFDLEdBQUdsRDtJQUNwQjtJQUNBOzs7OztHQUtDLEdBQ0RzaEQsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUNuaUMsUUFBUSxDQUFDamMsQ0FBQztJQUN4QjtJQUNBOzs7OztHQUtDLEdBQ0RxK0MsZUFBZXZoRCxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDbWYsUUFBUSxDQUFDamMsQ0FBQyxHQUFHbEQ7SUFDcEI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXdoRCxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDcmlDLFFBQVEsQ0FBQ2hjLENBQUM7SUFDeEI7SUFDQSxJQUFJcStDLFlBQVl4aEQsS0FBSyxFQUFFO1FBQ3JCLElBQUksQ0FBQ21mLFFBQVEsQ0FBQ2hjLENBQUMsR0FBR25EO0lBQ3BCO0lBQ0E7Ozs7O0dBS0MsR0FDRHloRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQ3RpQyxRQUFRLENBQUNoYyxDQUFDO0lBQ3hCO0lBQ0E7Ozs7O0dBS0MsR0FDRHUrQyxlQUFlMWhELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNtZixRQUFRLENBQUNoYyxDQUFDLEdBQUduRDtJQUNwQjtJQUNBOzs7OztHQUtDLEdBQ0R5UyxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUM5RyxJQUFJO0lBQ2xCO0lBQ0E7Ozs7O0dBS0MsR0FDRCtHLFFBQVExUyxLQUFLLEVBQUU7UUFDYixJQUFJLENBQUMyTCxJQUFJLEdBQUczTDtJQUNkO0lBQ0E7Ozs7O0dBS0MsR0FDRDJoRCxpQkFBaUI7UUFDZixPQUFPLElBQUksSUFBSSxDQUFDMUIsS0FBSztJQUN2QjtJQUNBOzs7OztHQUtDLEdBQ0QyQixlQUFlNWhELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNpZ0QsS0FBSyxHQUFHeDlDLEtBQUsySixHQUFHLENBQUMzSixLQUFLNEosR0FBRyxDQUFDLElBQUlyTSxPQUFPLElBQUk7SUFDaEQ7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSWdnRCxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUM5Z0QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFdBQVdoTCxLQUFLO0lBQzNDO0lBQ0EsSUFBSWdnRCxRQUFRaGdELEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxXQUFXaEwsS0FBSyxHQUFHQTtJQUN2QztJQUNBOzs7OztHQUtDLEdBQ0Q2aEQsbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDN0IsT0FBTztJQUNyQjtJQUNBOzs7OztHQUtDLEdBQ0Q4QixpQkFBaUI5aEQsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ2dnRCxPQUFPLEdBQUdoZ0Q7SUFDakI7SUFDQTs7Ozs7R0FLQyxHQUNEK2hELCtCQUErQjtRQUM3QixPQUFPLElBQUksQ0FBQ2xDLHlCQUF5QjtJQUN2QztJQUNBOzs7OztHQUtDLEdBQ0RtQyw2QkFBNkJoaUQsS0FBSyxFQUFFO1FBQ2xDLElBQUksQ0FBQzYvQyx5QkFBeUIsR0FBRzcvQztJQUNuQztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJa2dELGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQ2hoRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsbUJBQW1CaEwsS0FBSztJQUNuRDtJQUNBLElBQUlrZ0QsZ0JBQWdCbGdELEtBQUssRUFBRTtRQUN6QixNQUFNaWlELGFBQWEsSUFBSSxDQUFDL0IsZUFBZTtRQUN2QyxJQUFJK0IsZUFBZSxRQUFRQSxXQUFXbGpELElBQUksS0FBS3lnRCxZQUFZO1lBQ3pEeUMsV0FBV3hrRCxPQUFPO1FBQ3BCO1FBQ0F1QyxNQUFNMnJCLFNBQVMsR0FBRzNyQixNQUFNNHJCLFNBQVMsR0FBRzZqQixnREFBY0E7UUFDbER6dkMsTUFBTXd4QyxLQUFLLEdBQUd4eEMsTUFBTXl4QyxLQUFLLEdBQUcvQixpREFBY0E7UUFDMUMxdkMsTUFBTW95QixlQUFlLEdBQUc7UUFDeEIsSUFBSSxDQUFDbHpCLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxtQkFBbUJoTCxLQUFLLEdBQUdBO0lBQy9DO0lBQ0E7Ozs7O0dBS0MsR0FDRGtpRCxxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUNoQyxlQUFlO0lBQzdCO0lBQ0E7Ozs7Ozs7R0FPQyxHQUNEaUMsbUJBQW1CbmlELEtBQUssRUFBRTtRQUN4QixJQUFJLENBQUNrZ0QsZUFBZSxHQUFHbGdEO0lBQ3pCO0lBQ0E7Ozs7OztHQU1DLEdBQ0RvaUQsd0JBQXdCcGlELFFBQVEsRUFBRSxFQUFFO1FBQ2xDLE1BQU02aUMsTUFBTSxJQUFJeWMsYUFBYXQvQyxPQUFPQSxPQUFPNHZDLDZDQUFXQTtRQUN0RC9NLElBQUk5akMsSUFBSSxHQUFHeWdEO1FBQ1gsT0FBTzNjO0lBQ1Q7SUFDQTs7Ozs7O0dBTUMsR0FDRHZLLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLE1BQU1xTSxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNMDBDLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDLE1BQU1wNUIsU0FBUyxJQUFJLENBQUM0NEIseUJBQXlCO1FBQzdDLE1BQU16aUMsSUFBSSxJQUFJLENBQUMrQixRQUFRO1FBQ3ZCLElBQUl6RixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixJQUFJNm1DLFNBQVM7UUFDYixJQUFJMzlDLElBQUksR0FBRytrQixJQUFJO1FBQ2YsSUFBSTA2QjtRQUNKLElBQUkxMkMsU0FBUzVELFdBQVdDLFFBQVEsRUFBRTtZQUNoQyxJQUFJMkQsU0FBUzVELFdBQVdFLFFBQVEsRUFBRTtnQkFDaEN5UixRQUFRcGE7Z0JBQ1IraUQsVUFBVTNvQyxPQUFPMm1DLFdBQVduOUMsQ0FBQztnQkFDN0IsSUFBSXdXLFFBQVEybUMsV0FBV245QyxDQUFDLEdBQUdtOUMsV0FBV2w5QyxDQUFDLEVBQUU7b0JBQ3ZDazlDLFdBQVdqOUMsR0FBRyxDQUNacThDLFlBQVksSUFBSSxDQUFDSyxLQUFLLENBQUM1OEMsQ0FBQyxFQUFFLElBQUksQ0FBQzQ4QyxLQUFLLENBQUMzOEMsQ0FBQyxHQUN0Q3M4QyxZQUFZLElBQUksQ0FBQ00sUUFBUSxDQUFDNzhDLENBQUMsRUFBRSxJQUFJLENBQUM2OEMsUUFBUSxDQUFDNThDLENBQUM7b0JBRTlDdVcsT0FBTztnQkFDVDtZQUNGO1lBQ0E5VyxJQUFJSCxLQUFLNDhDLE1BQU07WUFDZixJQUFJLENBQUNuZ0QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFVBQVVoTCxLQUFLLEdBQUc0QztZQUNwQyxJQUFJeS9DLFdBQVd6L0MsSUFBSSxJQUFJLENBQUNxOUMsS0FBSyxJQUFJdDBDLFNBQVM1RCxXQUFXSSxhQUFhLEVBQUU7Z0JBQ2xFbzRDLFNBQVM7Z0JBQ1QzOUMsS0FBS3dhLEVBQUVqYSxDQUFDLEdBQUc7Z0JBQ1h3a0IsSUFBSTgzQixZQUFZLENBQUNoOUMsS0FBS21zQyxFQUFFLEVBQUVuc0MsS0FBS21zQyxFQUFFO2dCQUNqQyxJQUFJLENBQUMwUixLQUFLLENBQUNsOUMsR0FBRyxDQUFDcThDLFlBQVksQ0FBQ3JpQyxFQUFFamEsQ0FBQyxFQUFFaWEsRUFBRWphLENBQUMsR0FBR3M4QyxZQUFZLENBQUNyaUMsRUFBRWphLENBQUMsRUFBRWlhLEVBQUVqYSxDQUFDO2dCQUM1RCxJQUFJLENBQUNpOUMsVUFBVSxDQUFDaDlDLEdBQUcsQ0FBQ3E4QyxZQUFZLEdBQUcsSUFBSUEsWUFBWSxHQUFHO1lBQ3hELE9BQU8sSUFBSTRDLFdBQVcxMkMsU0FBUzVELFdBQVdHLGFBQWEsRUFBRTtnQkFDdkRxNEMsU0FBUztnQkFDVDM5QyxLQUFLd2EsRUFBRWxhLENBQUMsR0FBRztnQkFDWHlrQixJQUFJODNCLFlBQVksQ0FBQ2g5QyxLQUFLbXNDLEVBQUUsRUFBRW5zQyxLQUFLbXNDLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQzBSLEtBQUssQ0FBQ2w5QyxHQUFHLENBQUNxOEMsWUFBWSxDQUFDcmlDLEVBQUVsYSxDQUFDLEVBQUVrYSxFQUFFbGEsQ0FBQyxHQUFHdThDLFlBQVksQ0FBQ3JpQyxFQUFFbGEsQ0FBQyxFQUFFa2EsRUFBRWxhLENBQUM7Z0JBQzVELElBQUksQ0FBQ2s5QyxVQUFVLENBQUNoOUMsR0FBRyxDQUFDcThDLFlBQVksR0FBRyxJQUFJQSxZQUFZLEdBQUc7WUFDeEQ7WUFDQSxJQUFJLENBQUMvbEMsSUFBSSxHQUFHQTtRQUNkO1FBQ0EsSUFBSXVOLFdBQVcsTUFBTTtZQUNuQixJQUFJczVCLFFBQVE7Z0JBQ1Z0NUIsT0FBTzdqQixHQUFHLENBQUNYLEtBQUtLLEdBQUcsQ0FBQzZrQixJQUFJbGxCLEtBQUtPLEdBQUcsQ0FBQzJrQixJQUFJMjZCLGNBQWMsQ0FBQzEvQztZQUN0RCxPQUFPO2dCQUNMcWtCLE9BQU83akIsR0FBRyxDQUFDLEdBQUc7WUFDaEI7UUFDRjtRQUNBLElBQUksQ0FBQ2xFLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxVQUFVaEwsS0FBSyxHQUFHdWdEO0lBQ3RDO0lBQ0E7O0dBRUMsR0FDRDlpRCxVQUFVO1FBQ1IsTUFBTW9sQyxNQUFNLElBQUksQ0FBQ3FkLGVBQWU7UUFDaEMsSUFBSXJkLFFBQVEsUUFBUUEsSUFBSTlqQyxJQUFJLEtBQUt5Z0QsWUFBWTtZQUMzQzNjLElBQUlwbEMsT0FBTztRQUNiO0lBQ0Y7QUFDRjtBQUVBLCtCQUErQjtBQVdoQjtBQUVmLGlDQUFpQztBQUNqQyxJQUFJdWxELG1CQUFtQjtBQUV2QiwrQkFBK0I7QUFDL0IsSUFBSUMsSUFBSSxhQUFhLEdBQUcsSUFBSUgsMENBQVFBO0FBQ3BDLElBQUlJLElBQUksYUFBYSxHQUFHLElBQUlSLDBDQUFRQTtBQUNwQyxJQUFJUyxnQkFBZ0IsY0FBYzNhO0lBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQyxHQUNEMXBDLFlBQVlpUCxNQUFNLEVBQUVxMUMsV0FBVyxFQUFFLEVBQy9CdnNCLGdCQUFnQjd5QixjQUFjK0IsTUFBTSxFQUNwQ29YLFVBQVUsRUFBRSxFQUNabEIsVUFBVSxJQUFJLEVBQ2RDLFFBQVEsR0FBRyxFQUNYQyxTQUFTLEdBQUcsRUFDWkMsV0FBVyxHQUFHLEVBQ2RDLFdBQVcsQ0FBQyxFQUNaZ25DLE9BQU8sSUFBSSxFQUNYMzJDLGFBQWF0RSxXQUFXRSxLQUFLLEVBQzdCd2tCLGtCQUFrQixHQUFHLEVBQ3JCeHBCLFFBQVEwcEIsV0FBV0MsU0FBUyxFQUM1QjFwQixTQUFTeXBCLFdBQVdDLFNBQVMsRUFDN0JGLGNBQWN6cEIsS0FBSyxFQUNuQjRwQixjQUFjM3BCLE1BQU0sRUFDckIsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNOLEtBQUssQ0FBQyxpQkFBaUJ5L0Msa0JBQWtCO1lBQ3ZDbnNCO1lBQ0F4QixZQUFZL3RCLGdCQUFnQkYsS0FBSztZQUNqQ2xJLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBTyxJQUFJaTRDLDBDQUFTQSxDQUFDO2lCQUFNO2FBQzdCO1FBQ0g7UUFDQSxJQUFJLENBQUM3MEMsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3UxQyxZQUFZLEdBQUdGO1FBQ3BCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNHLFVBQVUsR0FBRyxJQUFJWix3Q0FBTUE7UUFDNUIsSUFBSSxDQUFDYSxjQUFjLEdBQUcsSUFBSVgsMENBQVNBO1FBQ25DLElBQUksQ0FBQzExQixhQUFhLEdBQUcsSUFBSTQxQixvREFBbUJBLENBQUMsR0FBRyxHQUFHO1lBQUVsMkMsYUFBYTtRQUFNO1FBQ3hFLElBQUksQ0FBQ3NnQixhQUFhLENBQUNoaUIsT0FBTyxDQUFDcE0sSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQ3F1QixhQUFhLEdBQUcsSUFBSSxDQUFDRCxhQUFhLENBQUNaLEtBQUs7UUFDN0MsSUFBSSxDQUFDYSxhQUFhLENBQUNqaUIsT0FBTyxDQUFDcE0sSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQ0csUUFBUSxDQUFDOEwsR0FBRyxDQUFDLE9BQU9oTCxLQUFLLEdBQUcsSUFBSSxDQUFDb3RCLGFBQWEsQ0FBQ2ppQixPQUFPO1FBQzNELElBQUksQ0FBQ3M0QyxpQkFBaUIsR0FBRyxJQUFJVixvREFBbUJBLENBQUMsR0FBRztRQUNwRCxJQUFJLENBQUNVLGlCQUFpQixDQUFDdDRDLE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUN0QyxJQUFJLENBQUMwa0QsaUJBQWlCLENBQUN0eUMsWUFBWSxHQUFHLElBQUlzeEMsK0NBQWFBO1FBQ3ZELElBQUksQ0FBQ2lCLGVBQWUsR0FBRyxJQUFJMXpCLFdBQVcsSUFBSSxDQUFDdXpCLFVBQVUsRUFBRXgxQztRQUN2RCxJQUFJLENBQUMyMUMsZUFBZSxDQUFDeHpCLFNBQVMsQ0FBQ3RCLGtCQUFrQixHQUFHLElBQUk0ekIsd0NBQU1BLENBQUM7UUFDL0QsSUFBSSxDQUFDdHlCLFNBQVMsR0FBRyxJQUFJeEIsVUFBVSxNQUFNLE9BQU87UUFDNUMsSUFBSSxDQUFDd0IsU0FBUyxDQUFDdEIsa0JBQWtCLEdBQUcsSUFBSTR6Qix3Q0FBTUEsQ0FBQztRQUMvQyxJQUFJLENBQUMvWSxRQUFRLEdBQUcsSUFBSTdRLGVBQWU7WUFBRWxzQjtRQUFXO1FBQ2hELElBQUksQ0FBQys4QixRQUFRLENBQUMzZixPQUFPLEdBQUd1NUI7UUFDeEIsSUFBSSxDQUFDTSxhQUFhLEdBQUcsSUFBSW5vQixXQUFXLElBQUlubkI7UUFDeEMsTUFBTXV2QyxvQkFBb0IsSUFBSSxDQUFDQSxpQkFBaUI7UUFDaERBLGtCQUFrQmp2QyxZQUFZLEdBQUcsSUFBSSxDQUFDOHVDLGlCQUFpQixDQUFDdHlDLFlBQVk7UUFDcEV5eUMsa0JBQWtCOTFDLGtCQUFrQixDQUFDQztRQUNyQyxJQUFJLENBQUM4MUMsV0FBVyxHQUFHLElBQUlyb0IsV0FBVyxJQUFJM2YsZ0JBQWdCLElBQUksQ0FBQzJuQyxjQUFjO1FBQ3pFLE1BQU1NLGtCQUFrQixJQUFJLENBQUNBLGVBQWU7UUFDNUNBLGdCQUFnQjduQyxPQUFPLEdBQUdBO1FBQzFCNm5DLGdCQUFnQjVuQyxLQUFLLEdBQUdBO1FBQ3hCNG5DLGdCQUFnQjNuQyxNQUFNLEdBQUdBO1FBQ3pCMm5DLGdCQUFnQjFuQyxRQUFRLEdBQUdBO1FBQzNCMG5DLGdCQUFnQjltQyxZQUFZLEdBQUdYO1FBQy9CeW5DLGdCQUFnQjNtQyxPQUFPLEdBQUdBO1FBQzFCLE1BQU0zRCxhQUFhLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUl3VCxXQUFXLElBQUksRUFBRUQsYUFBYUcsYUFBYUo7UUFDcEZ0VCxXQUFXK1QsZ0JBQWdCLENBQUMsVUFBVSxDQUFDQyxJQUFNLElBQUksQ0FBQ25xQixPQUFPLENBQUNtVyxXQUFXaVUsU0FBUyxFQUFFalUsV0FBV2tVLFVBQVU7SUFDdkc7SUFDQSxJQUFJdkQsV0FBV25xQixLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDK04sTUFBTSxHQUFHL047UUFDZCxJQUFJLENBQUMwakQsZUFBZSxDQUFDdjVCLFVBQVUsR0FBR25xQjtRQUNsQyxJQUFJLENBQUM0akQsaUJBQWlCLENBQUM5MUMsa0JBQWtCLENBQUM5TjtJQUM1QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJb2pELGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUNFLFlBQVk7SUFDMUI7SUFDQSxJQUFJRixZQUFZcGpELEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUNzakQsWUFBWSxHQUFHdGpEO1FBQ3BCLElBQUlBLFVBQVUsTUFBTTtZQUNsQkEsTUFBTWdxQixRQUFRLENBQUNwcUIsVUFBVSxHQUFHO1lBQzVCSSxNQUFNZ3FCLFFBQVEsQ0FBQys1QixXQUFXLEdBQUc7UUFDL0I7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0RsYSxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUNKLFFBQVE7SUFDdEI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXQrQixVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNpaUIsYUFBYSxDQUFDamlCLE9BQU87SUFDbkM7SUFDQTs7Ozs7R0FLQyxHQUNENGdCLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQzVnQixPQUFPO0lBQ3JCO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJeTRDLG9CQUFvQjtRQUN0QixPQUFPLElBQUksQ0FBQ0QsYUFBYSxDQUFDMTVCLGtCQUFrQjtJQUM5QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJNjVCLGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQ0QsV0FBVyxDQUFDNTVCLGtCQUFrQjtJQUM1QztJQUNBOzs7OztHQUtDLEdBQ0QrNUIscUJBQXFCO1FBQ25CLE9BQU8sSUFBSSxDQUFDRixlQUFlO0lBQzdCO0lBQ0E7Ozs7O0dBS0MsR0FDRGx5QixnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQ3BZLFVBQVU7SUFDeEI7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUlsVyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNrVyxVQUFVLENBQUNsVyxLQUFLO0lBQzlCO0lBQ0EsSUFBSUEsTUFBTXRELEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ3daLFVBQVUsQ0FBQ3NmLGNBQWMsR0FBRzk0QjtJQUNuQztJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXVELFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ2lXLFVBQVUsQ0FBQ2pXLE1BQU07SUFDL0I7SUFDQSxJQUFJQSxPQUFPdkQsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQ3daLFVBQVUsQ0FBQ3VmLGVBQWUsR0FBRy80QjtJQUNwQztJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXNaLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQ3dxQyxlQUFlLENBQUN4cUMsU0FBUztJQUN2QztJQUNBLElBQUlBLFVBQVV0WixLQUFLLEVBQUU7UUFDbkIsTUFBTWdxQixXQUFXLElBQUksQ0FBQzg1QixlQUFlO1FBQ3JDOTVCLFNBQVMxUSxTQUFTLEdBQUd0WjtRQUNyQmdxQixTQUFTM3BCLFdBQVcsR0FBRztJQUN6QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSWdqRCxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUM1WixRQUFRLENBQUMzZixPQUFPO0lBQzlCO0lBQ0EsSUFBSXU1QixLQUFLcmpELEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQ3lwQyxRQUFRLENBQUMzZixPQUFPLEdBQUc5cEI7SUFDMUI7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUkwTSxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMrOEIsUUFBUSxDQUFDLzhCLFVBQVU7SUFDakM7SUFDQSxJQUFJQSxXQUFXMU0sS0FBSyxFQUFFO1FBQ3BCLElBQUksQ0FBQ3lwQyxRQUFRLENBQUMvOEIsVUFBVSxHQUFHMU07SUFDN0I7SUFDQTs7Ozs7R0FLQyxHQUNENnhCLHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQ3JZLFVBQVUsQ0FBQzlYLEtBQUs7SUFDOUI7SUFDQTs7Ozs7R0FLQyxHQUNEb3dCLG1CQUFtQnB3QixLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDOFgsVUFBVSxDQUFDOVgsS0FBSyxHQUFHQTtJQUMxQjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXliLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQzJtQyxlQUFlLENBQUMzbUMsT0FBTztJQUNyQztJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSUEsUUFBUW5kLEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUM4akQsZUFBZSxDQUFDM21DLE9BQU8sR0FBR25kO0lBQ2pDO0lBQ0E7Ozs7O0dBS0MsR0FDRDRxQixnQkFBZ0J6WixZQUFZLEVBQUV6RCxlQUFlNjBDLG9EQUFtQixFQUFFO1FBQ2hFLElBQUksQ0FBQ29CLGFBQWEsQ0FBQzE1QixrQkFBa0IsQ0FBQ3ZWLFlBQVksR0FBR3ZEO1FBQ3JELElBQUksQ0FBQ3d5QyxhQUFhLENBQUMxNUIsa0JBQWtCLENBQUNwVixhQUFhLEdBQUduSDtJQUN4RDtJQUNBOzs7Ozs7R0FNQyxHQUNENHFCLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLE1BQU04akQsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDcEMsTUFBTWxsQixTQUFTa2xCLFlBQVlsbEIsTUFBTTtRQUNqQyxNQUFNK2xCLG1CQUFtQmIsWUFBWWEsZ0JBQWdCO1FBQ3JELE1BQU05MkIsZ0JBQWdCLElBQUksQ0FBQ0EsYUFBYTtRQUN4QyxNQUFNczJCLG9CQUFvQixJQUFJLENBQUNBLGlCQUFpQjtRQUNoREwsWUFBWXA1QixRQUFRLENBQUNwcUIsVUFBVSxHQUFHO1FBQ2xDd2pELFlBQVlhLGdCQUFnQixHQUFHO1FBQy9CYixZQUFZYyxpQkFBaUIsQ0FBQyxNQUFNO1FBQ3BDLElBQUlobUIsV0FBVyxNQUFNO1lBQ25CLElBQUksQ0FBQytsQixrQkFBa0I7Z0JBQ3JCZixFQUFFMThCLElBQUksQ0FBQzQ4QixZQUFZZSxNQUFNO1lBQzNCO1lBQ0FmLFlBQVllLE1BQU0sQ0FBQzM5QixJQUFJLENBQUM0OEIsWUFBWWdCLFdBQVc7UUFDakQ7UUFDQSxJQUFJLENBQUNiLFVBQVUsQ0FBQy80QixHQUFHLENBQUM0NEI7UUFDcEIsSUFBSSxDQUFDTSxlQUFlLENBQUM3NEIsTUFBTSxDQUFDL2YsVUFBVTI0QztRQUN0QyxJQUFJLENBQUN2ekIsU0FBUyxDQUFDckYsTUFBTSxDQUFDL2YsVUFBVXFpQjtRQUNoQyxJQUFJLENBQUN3MkIsYUFBYSxDQUFDOTRCLE1BQU0sQ0FBQy9mLFVBQVUyNEMsbUJBQW1CdDJCO1FBQ3ZEaTJCLFlBQVlwNUIsUUFBUSxDQUFDcHFCLFVBQVUsR0FBRztRQUNsQ3dqRCxZQUFZYSxnQkFBZ0IsR0FBR0E7UUFDL0IsSUFBSS9sQixXQUFXLE1BQU07WUFDbkIsSUFBSSxDQUFDK2xCLGtCQUFrQjtnQkFDckJiLFlBQVllLE1BQU0sQ0FBQzM5QixJQUFJLENBQUMwOEI7WUFDMUI7WUFDQWhsQixPQUFPMVQsR0FBRyxDQUFDNDRCO1FBQ2I7UUFDQUgsRUFBRW9CLHFCQUFxQixDQUFDakIsWUFBWWdCLFdBQVcsRUFBRUUsT0FBTyxDQUFDLElBQUksQ0FBQ3YyQyxNQUFNO1FBQ3BFLElBQUksQ0FBQ3kxQyxjQUFjLENBQUNwZ0QsR0FBRyxDQUNyQlgsS0FBSzJKLEdBQUcsQ0FBQzNKLEtBQUs0SixHQUFHLENBQUMsQ0FBQzQyQyxFQUFFLy9DLENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQyxJQUFJLElBQ3hDVCxLQUFLMkosR0FBRyxDQUFDM0osS0FBSzRKLEdBQUcsQ0FBQyxDQUFDNDJDLEVBQUU5L0MsQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDLElBQUk7UUFFMUMsSUFBSSxJQUFJLENBQUNzbUMsUUFBUSxDQUFDM2YsT0FBTyxFQUFFO1lBQ3pCLElBQUksQ0FBQzJmLFFBQVEsQ0FBQzVlLE1BQU0sQ0FBQy9mLFVBQVVxaUIsZUFBZUE7UUFDaEQ7UUFDQSxJQUFJLENBQUMwMkIsV0FBVyxDQUFDaDVCLE1BQU0sQ0FBQy9mLFVBQVVxaUIsZUFBZSxJQUFJLENBQUNDLGFBQWE7SUFDckU7SUFDQTs7Ozs7R0FLQyxHQUNEL3BCLFFBQVFDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3JCLE1BQU1pVyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQ0EsV0FBV3FVLFdBQVcsQ0FBQ3ZxQixPQUFPQztRQUM5QixNQUFNdXFCLElBQUl0VSxXQUFXbFcsS0FBSyxFQUFFeXFCLElBQUl2VSxXQUFXalcsTUFBTTtRQUNqRCxJQUFJLENBQUM0cEIsYUFBYSxDQUFDOXBCLE9BQU8sQ0FBQ3lxQixHQUFHQztRQUM5QixJQUFJLENBQUNYLGFBQWEsQ0FBQy9wQixPQUFPLENBQUN5cUIsR0FBR0M7UUFDOUIsSUFBSSxDQUFDMDFCLGlCQUFpQixDQUFDcGdELE9BQU8sQ0FBQ3lxQixHQUFHQztRQUNsQyxJQUFJLENBQUMwYixRQUFRLENBQUNqd0IsVUFBVSxDQUFDZ04sSUFBSSxDQUFDaE47SUFDaEM7SUFDQTs7Ozs7O0dBTUMsR0FDRHdSLFdBQVdsZ0IsUUFBUSxFQUFFbWdCLEtBQUssRUFBRUMsZUFBZSxFQUFFO1FBQzNDLElBQUksQ0FBQ3VlLFFBQVEsQ0FBQ3plLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO1FBQzFDLElBQUksQ0FBQ3c0QixlQUFlLENBQUMxNEIsVUFBVSxDQUFDbGdCLFVBQVVtZ0IsT0FBT0M7UUFDakQsSUFBSSxDQUFDeTRCLGFBQWEsQ0FBQzM0QixVQUFVLENBQUNsZ0IsVUFBVW1nQixPQUFPQztRQUMvQyxJQUFJLENBQUMyNEIsV0FBVyxDQUFDNzRCLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO1FBQzdDLElBQUlBLG9CQUFvQixLQUFLLEdBQUc7WUFDOUIsSUFBSSxDQUFDaUMsYUFBYSxDQUFDaGlCLE9BQU8sQ0FBQ29VLElBQUksR0FBRzJMO1lBQ2xDLElBQUksQ0FBQ2tDLGFBQWEsQ0FBQ2ppQixPQUFPLENBQUNvVSxJQUFJLEdBQUcyTDtZQUNsQyxJQUFJLENBQUN1NEIsaUJBQWlCLENBQUN0NEMsT0FBTyxDQUFDb1UsSUFBSSxHQUFHMkw7WUFDdEMsSUFBSXJnQixvQkFBb0JDLGNBQWNyRSxnQkFBZ0I7Z0JBQ3BEeUUscUJBQXFCLElBQUksQ0FBQ2lpQixhQUFhLENBQUNoaUIsT0FBTyxFQUFFMUU7Z0JBQ2pEeUUscUJBQXFCLElBQUksQ0FBQ2tpQixhQUFhLENBQUNqaUIsT0FBTyxFQUFFMUU7Z0JBQ2pEeUUscUJBQXFCLElBQUksQ0FBQ3U0QyxpQkFBaUIsQ0FBQ3Q0QyxPQUFPLEVBQUUxRTtZQUN2RDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLDRCQUE0QjtBQUN1QztBQUVuRSw2QkFBNkI7QUFDN0IsSUFBSWcrQyxlQUFlO0FBRW5CLDRCQUE0QjtBQUM1QixJQUFJQyxhQUFhLGNBQWNsYztJQUM3Qjs7Ozs7OztHQU9DLEdBQ0QxcEMsWUFBWSxFQUFFKzNCLGdCQUFnQjd5QixjQUFjMkIsT0FBTyxFQUFFakUsUUFBUSxDQUFDLEVBQUVpakQsWUFBWSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNwRixLQUFLLENBQUMsY0FBY0YsY0FBYztZQUNoQzV0QjtZQUNBMzNCLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBUyxJQUFJNDVDLDBDQUFTQSxDQUFDLElBQUlDLDBDQUFTQTtpQkFBSTtnQkFDekM7b0JBQUM7b0JBQWEsSUFBSUQsMENBQVNBLENBQUNJO2lCQUFXO2FBQ3hDO1FBQ0g7UUFDQSxJQUFJLENBQUNuckMsVUFBVSxHQUFHLElBQUlnckMsMENBQVNBO1FBQy9CLElBQUksQ0FBQ3BuQyxDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUMxYixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDa3NCLENBQUMsR0FBRztRQUNULElBQUksQ0FBQysyQixTQUFTLEdBQUdBO0lBQ25CO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlqakQsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDMGIsQ0FBQztJQUNmO0lBQ0EsSUFBSTFiLE1BQU0xQixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNvZCxDQUFDLEdBQUczYSxLQUFLNEosR0FBRyxDQUFDck0sT0FBTztRQUN6QixJQUFJLENBQUNxRCxPQUFPLENBQUMsSUFBSSxDQUFDbVcsVUFBVSxDQUFDbFcsS0FBSyxFQUFFLElBQUksQ0FBQ2tXLFVBQVUsQ0FBQ2pXLE1BQU07SUFDNUQ7SUFDQTs7Ozs7R0FLQyxHQUNEeEIsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDTCxLQUFLO0lBQ25CO0lBQ0E7Ozs7O0dBS0MsR0FDRE0sU0FBU2hDLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQzBCLEtBQUssR0FBRzFCO0lBQ2Y7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSTJrRCxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMvMkIsQ0FBQztJQUNmO0lBQ0EsSUFBSSsyQixVQUFVM2tELEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUM0dEIsQ0FBQyxHQUFHNXRCO1FBQ1QsSUFBSSxDQUFDcUQsT0FBTyxDQUFDLElBQUksQ0FBQ21XLFVBQVUsQ0FBQ2xXLEtBQUssRUFBRSxJQUFJLENBQUNrVyxVQUFVLENBQUNqVyxNQUFNO0lBQzVEO0lBQ0E7Ozs7O0dBS0MsR0FDRHFoRCxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUNELFNBQVM7SUFDdkI7SUFDQTs7Ozs7R0FLQyxHQUNERSxhQUFhN2tELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUMya0QsU0FBUyxHQUFHM2tEO0lBQ25CO0lBQ0E7Ozs7O0dBS0MsR0FDRHFELFFBQVFDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3JCLElBQUksQ0FBQ2lXLFVBQVUsQ0FBQ3BXLEdBQUcsQ0FBQ0UsT0FBT0M7UUFDM0IsTUFBTWtXLFNBQVNuVyxRQUFRQztRQUN2QixNQUFNN0IsUUFBUSxJQUFJLENBQUNBLEtBQUssR0FBSTZCLENBQUFBLFNBQVMsS0FBSTtRQUN6QyxJQUFJLENBQUNyRSxRQUFRLENBQUM4TCxHQUFHLENBQUMsU0FBU2hMLEtBQUssQ0FBQ29ELEdBQUcsQ0FBQ3FXLFNBQVMvWCxPQUFPQTtRQUNyRCxJQUFJLENBQUN4QyxRQUFRLENBQUM4TCxHQUFHLENBQUMsYUFBYWhMLEtBQUssR0FBRzBCLFFBQVE2QixTQUFTLElBQUksQ0FBQ29oRCxTQUFTO0lBQ3hFO0FBQ0Y7QUFFQSxxQ0FBcUM7QUFDNkI7QUFFbEUsdUNBQXVDO0FBQ3ZDLElBQUlLLHlCQUF5QjtBQUU3QixxQ0FBcUM7QUFDckMsSUFBSUMsc0JBQXNCLGNBQWN6YztJQUN0Qzs7Ozs7OztHQU9DLEdBQ0QxcEMsWUFBWSxFQUFFKzNCLGdCQUFnQjd5QixjQUFjaUMsR0FBRyxFQUFFaS9DLE1BQU0sQ0FBQyxFQUFFQyxhQUFhLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQy9FLEtBQUssQ0FBQyx1QkFBdUJILHdCQUF3QjtZQUNuRG51QjtZQUNBMzNCLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBTyxJQUFJbTZDLDBDQUFTQSxDQUFDLElBQUlDLDBDQUFRQTtpQkFBSTtnQkFDdEM7b0JBQUM7b0JBQWMsSUFBSUQsMENBQVNBLENBQUNLO2lCQUFZO2FBQzFDO1FBQ0g7UUFDQSxJQUFJLENBQUNELEdBQUcsR0FBR0E7SUFDYjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJQyxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNqbUQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGNBQWNoTCxLQUFLO0lBQzlDO0lBQ0EsSUFBSW1sRCxXQUFXbmxELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxjQUFjaEwsS0FBSyxHQUFHQTtJQUMxQztJQUNBOzs7OztHQUtDLEdBQ0RvbEQsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUNELFVBQVU7SUFDeEI7SUFDQTs7Ozs7R0FLQyxHQUNERSxjQUFjcmxELEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNtbEQsVUFBVSxHQUFHbmxEO0lBQ3BCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlrbEQsTUFBTTtRQUNSLE1BQU1BLE1BQU0sSUFBSSxDQUFDaG1ELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxPQUFPaEwsS0FBSztRQUMxQyxPQUFPeUMsS0FBS29sQixJQUFJLENBQUMsQ0FBQ3E5QixJQUFJaGlELENBQUMsR0FBRyxJQUFJLEtBQUs7SUFDckM7SUFDQSxJQUFJZ2lELElBQUlsbEQsS0FBSyxFQUFFO1FBQ2IsTUFBTW9kLElBQUkzYSxLQUFLTyxHQUFHLENBQUNoRCxRQUFROGlDLEtBQUtyZ0MsS0FBS0ssR0FBRyxDQUFDOUM7UUFDekMsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsT0FBT2hMLEtBQUssQ0FBQ29ELEdBQUcsQ0FDaEMsQ0FBQyxJQUFJMC9CLEtBQUssS0FBSyxHQUNmLENBQUMsQ0FBQ3JnQyxLQUFLQyxJQUFJLENBQUMsS0FBSzBhLElBQUkwbEIsS0FBSyxLQUFLLEdBQy9CLENBQUNyZ0MsS0FBS0MsSUFBSSxDQUFDLEtBQUswYSxJQUFJMGxCLEtBQUssS0FBSztJQUVsQztJQUNBOzs7OztHQUtDLEdBQ0R3aUIsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDSixHQUFHO0lBQ2pCO0lBQ0E7Ozs7O0dBS0MsR0FDREssT0FBT3ZsRCxLQUFLLEVBQUU7UUFDWixJQUFJLENBQUNrbEQsR0FBRyxHQUFHbGxEO0lBQ2I7QUFDRjtBQUVBLHNDQUFzQztBQUM2QjtBQUVuRSx3Q0FBd0M7QUFDeEMsSUFBSTBsRCwwQkFBMEI7QUFFOUIsc0NBQXNDO0FBQ3RDLElBQUlDLHVCQUF1QixjQUFjbmQ7SUFDdkM7Ozs7Ozs7O0dBUUMsR0FDRDFwQyxZQUFZLEVBQ1ZzaEQsYUFBYSxJQUFJcUYsMENBQVNBLENBQUMsR0FBRyxFQUFFLEVBQ2hDRyxpQkFBaUIsSUFBSUgsMENBQVNBLENBQUMsR0FBRyxFQUFFLEVBQ3BDNzJDLGNBQWMsSUFBSTYyQywwQ0FBU0EsQ0FBQyxHQUFHLEVBQUUsRUFDakNJLE9BQU8sQ0FBQyxFQUNULEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsd0JBQXdCSCx5QkFBeUI7WUFDckR4bUQsVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFjLElBQUk2NkMsMENBQVNBLENBQUNwRjtpQkFBWTtnQkFDekM7b0JBQUM7b0JBQWtCLElBQUlvRiwwQ0FBU0EsQ0FBQ0k7aUJBQWdCO2dCQUNqRDtvQkFBQztvQkFBZSxJQUFJSiwwQ0FBU0EsQ0FBQzUyQztpQkFBYTtnQkFDM0M7b0JBQUM7b0JBQVEsSUFBSTQyQywwQ0FBU0EsQ0FBQ0s7aUJBQU07YUFDOUI7UUFDSDtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUl6RixhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNsaEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGNBQWNoTCxLQUFLO0lBQzlDO0lBQ0EsSUFBSW9nRCxXQUFXcGdELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxjQUFjaEwsS0FBSyxHQUFHQTtJQUMxQztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJNGxELGlCQUFpQjtRQUNuQixPQUFPLElBQUksQ0FBQzFtRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsa0JBQWtCaEwsS0FBSztJQUNsRDtJQUNBLElBQUk0bEQsZUFBZTVsRCxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsa0JBQWtCaEwsS0FBSyxHQUFHQTtJQUM5QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJNE8sY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQzFQLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxlQUFlaEwsS0FBSztJQUMvQztJQUNBLElBQUk0TyxZQUFZNU8sS0FBSyxFQUFFO1FBQ3JCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGVBQWVoTCxLQUFLLEdBQUdBO0lBQzNDO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUk2bEQsT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDM21ELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxRQUFRaEwsS0FBSztJQUN4QztJQUNBLElBQUk2bEQsS0FBSzdsRCxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxRQUFRaEwsS0FBSyxHQUFHQTtJQUNwQztBQUNGO0FBRUEsNkJBQTZCO0FBQ3dEO0FBRXJGLCtCQUErQjtBQUMvQixJQUFJaW1ELGlCQUFpQjtBQUVyQiw2QkFBNkI7QUFDN0IsSUFBSUMsY0FBYyxjQUFjMWQ7SUFDOUI7Ozs7OztHQU1DLEdBQ0QxcEMsWUFBWTR6QyxHQUFHLEVBQUUsRUFBRTdiLGdCQUFnQjd5QixjQUFjaUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDM0QsS0FBSyxDQUFDLGVBQWVnZ0QsZ0JBQWdCO1lBQ25DcHZCO1lBQ0EzM0IsVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQUM7b0JBQUM7b0JBQU8sSUFBSXE3QywwQ0FBU0EsQ0FBQztpQkFBTTthQUFDO1FBQ2xFO1FBQ0EsSUFBSSxDQUFDdFQsR0FBRyxHQUFHQTtJQUNiO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlBLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQ3h6QyxRQUFRLENBQUM4TCxHQUFHLENBQUMsT0FBT2hMLEtBQUs7SUFDdkM7SUFDQSxJQUFJMHlDLElBQUkxeUMsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsT0FBT2hMLEtBQUssR0FBR0E7UUFDakMsSUFBSUEsVUFBVSxRQUFTQSxDQUFBQSxNQUFNdWYsSUFBSSxLQUFLdW1DLDRDQUFVQSxJQUFJOWxELE1BQU11ZixJQUFJLEtBQUt3bUMsZ0RBQVksR0FBSTtZQUNqRixJQUFJLENBQUMvbUQsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLHNCQUFzQjtRQUN6QztJQUNGO0FBQ0Y7QUFFQSw2QkFBNkI7QUFVZDtBQUVmLCtCQUErQjtBQUMvQixJQUFJdWpELGlCQUFpQjtBQUVyQiw2QkFBNkI7QUFDN0IsSUFBSUMsY0FBYyxjQUFjcGU7SUFDOUI7Ozs7Ozs7OztHQVNDLEdBQ0QxcEMsWUFBWTR6QyxHQUFHLEVBQUUsRUFDZjdiLGdCQUFnQjd5QixjQUFjaUMsR0FBRyxFQUNqQzRnRCwyQkFBMkIsS0FBSyxFQUNoQ0MsZ0JBQWdCTiwrQ0FBYSxFQUM3QjF2QixlQUFlLEVBQ2hCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsZUFBZTZ2QixnQkFBZ0I7WUFDbkM5dkI7WUFDQTMzQixVQUFVLGFBQWEsR0FBRyxJQUFJeUwsSUFBSTtnQkFDaEM7b0JBQUM7b0JBQU8sSUFBSTg3QywwQ0FBU0EsQ0FBQztpQkFBTTtnQkFDNUI7b0JBQUM7b0JBQVMsSUFBSUEsMENBQVNBLENBQUMsSUFBSUMsMENBQVFBO2lCQUFJO2dCQUN4QztvQkFBQztvQkFBVSxJQUFJRCwwQ0FBU0EsQ0FBQyxJQUFJQywwQ0FBUUE7aUJBQUk7Z0JBQ3pDO29CQUFDO29CQUFhLElBQUlELDBDQUFTQSxDQUFDO2lCQUFNO2dCQUNsQztvQkFBQztvQkFBYSxJQUFJQSwwQ0FBU0EsQ0FBQztpQkFBTTthQUNuQztRQUNIO1FBQ0EsSUFBSSxDQUFDSSx3QkFBd0IsR0FBR0E7UUFDaEMsSUFBSSxDQUFDL3ZCLGVBQWUsR0FBR0EsbUJBQW1CcHNCLHFCQUFxQk0sR0FBRyxDQUFDODdDO1FBQ25FLElBQUksQ0FBQ3BVLEdBQUcsR0FBR0E7SUFDYjtJQUNBOzs7Ozs7O0dBT0MsR0FDRCxJQUFJb1UsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDaHdCLGVBQWU7SUFDN0I7SUFDQSxJQUFJZ3dCLGNBQWM5bUQsS0FBSyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzgyQixlQUFlLEdBQUc5MkI7SUFDekI7SUFDQTs7Ozs7R0FLQyxHQUNEK21ELG1CQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQ2p3QixlQUFlO0lBQzdCO0lBQ0E7Ozs7O0dBS0MsR0FDRGt3QixpQkFBaUJobkQsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQzgyQixlQUFlLEdBQUc5MkI7SUFDekI7SUFDQTs7Ozs7R0FLQyxHQUNEaW5ELG9CQUFvQjtRQUNsQixPQUFPLElBQUksQ0FBQ2w4QyxnQkFBZ0I7SUFDOUI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSTJuQyxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUN4ekMsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLE9BQU9oTCxLQUFLO0lBQ3ZDO0lBQ0EsSUFBSTB5QyxJQUFJMXlDLEtBQUssRUFBRTtRQUNiLE1BQU1oQixVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUM1QixNQUFNRSxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixJQUFJLElBQUksQ0FBQ3d6QyxHQUFHLEtBQUsxeUMsT0FBTztZQUN0QmQsU0FBUzhMLEdBQUcsQ0FBQyxPQUFPaEwsS0FBSyxHQUFHQTtZQUM1QixJQUFJQSxVQUFVLE1BQU07Z0JBQ2xCLE1BQU0wbUIsUUFBUTFtQixNQUFNMG1CLEtBQUs7Z0JBQ3pCLE1BQU1tZ0MsMkJBQTJCLElBQUksQ0FBQ0Esd0JBQXdCO2dCQUM5RDduRCxRQUFRMHdCLEtBQUs7Z0JBQ2Ixd0IsUUFBUW9FLEdBQUcsQ0FBQyxZQUFZWCxLQUFLMkosR0FBRyxDQUFDc2EsTUFBTXBqQixLQUFLLEVBQUVvakIsTUFBTW5qQixNQUFNLEVBQUVuRCxPQUFPLENBQUM7Z0JBQ3BFcEIsUUFBUW9FLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJc2pCLE1BQU1wakIsS0FBSyxFQUFFbEQsT0FBTyxDQUFDO2dCQUN6RHBCLFFBQVFvRSxHQUFHLENBQUMsb0JBQW9CLENBQUMsSUFBSXNqQixNQUFNbmpCLE1BQU0sRUFBRW5ELE9BQU8sQ0FBQztnQkFDM0RsQixTQUFTOEwsR0FBRyxDQUFDLGFBQWFoTCxLQUFLLEdBQUc7Z0JBQ2xDZCxTQUFTOEwsR0FBRyxDQUFDLGFBQWFoTCxLQUFLLEdBQUc7Z0JBQ2xDLElBQUlBLE1BQU11ZixJQUFJLEtBQUs2bUMsNENBQVVBLElBQUlwbUQsTUFBTXVmLElBQUksS0FBSzhtQyxnREFBY0EsRUFBRTtvQkFDOURybkQsUUFBUW9FLEdBQUcsQ0FBQyxzQkFBc0I7Z0JBQ3BDO2dCQUNBLElBQUlzakIsTUFBTXBqQixLQUFLLEdBQUdvakIsTUFBTW5qQixNQUFNLEVBQUU7b0JBQzlCdkUsUUFBUW9FLEdBQUcsQ0FBQyx3QkFBd0I7Z0JBQ3RDLE9BQU8sSUFBSXBELGlCQUFpQm1tRCxnREFBY0EsRUFBRTtvQkFDMUNubkQsUUFBUW9FLEdBQUcsQ0FBQyxVQUFVO2dCQUN4QjtnQkFDQSxJQUFJcEQsaUJBQWlCc3hDLGVBQWU7b0JBQ2xDLE1BQU1sbEMsTUFBTXBNLE1BQU00eEMsU0FBUztvQkFDM0IsTUFBTXZsQyxNQUFNck0sTUFBTTZ4QyxTQUFTO29CQUMzQixJQUFJemxDLElBQUlsSixDQUFDLEtBQUssS0FBS2tKLElBQUlqSixDQUFDLEtBQUssS0FBS2lKLElBQUlpb0MsQ0FBQyxLQUFLLEtBQUtob0MsSUFBSW5KLENBQUMsS0FBSyxLQUFLbUosSUFBSWxKLENBQUMsS0FBSyxLQUFLa0osSUFBSWdvQyxDQUFDLEtBQUssR0FBRzt3QkFDMUZyMUMsUUFBUW9FLEdBQUcsQ0FBQyx1QkFBdUI7d0JBQ25DbEUsU0FBUzhMLEdBQUcsQ0FBQyxhQUFhaEwsS0FBSyxHQUFHb00sSUFBSW1nQixLQUFLO3dCQUMzQ3J0QixTQUFTOEwsR0FBRyxDQUFDLGFBQWFoTCxLQUFLLEdBQUdxTSxJQUFJa2dCLEtBQUs7b0JBQzdDO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3M2Qix3QkFBd0IsR0FBR0E7WUFDbEM7UUFDRjtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FDREssU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDeFUsR0FBRztJQUNqQjtJQUNBOzs7OztHQUtDLEdBQ0R5VSxPQUFPbm5ELEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQzB5QyxHQUFHLEdBQUcxeUM7SUFDYjtJQUNBOzs7O0dBSUMsR0FDRG9uRCxvQkFBb0I7UUFDbEIsTUFBTTFVLE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLElBQUlBLFFBQVEsTUFBTTtZQUNoQixNQUFNaFYsT0FBT2o3QixLQUFLMkosR0FBRyxDQUFDc21DLElBQUloc0IsS0FBSyxDQUFDcGpCLEtBQUssRUFBRW92QyxJQUFJaHNCLEtBQUssQ0FBQ25qQixNQUFNO1lBQ3ZELE1BQU03QixRQUFRLElBQUksQ0FBQ3hDLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxTQUFTaEwsS0FBSztZQUM5QyxNQUFNaW5CLFNBQVMsSUFBSSxDQUFDL25CLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxVQUFVaEwsS0FBSztZQUNoRCxJQUFJLElBQUksQ0FBQzZtRCx3QkFBd0IsSUFBSW5VLGVBQWV5VCxnREFBY0EsRUFBRTtnQkFDbEUsSUFBSSxJQUFJLENBQUNubkQsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQyx3QkFBd0I7b0JBQzNDLE1BQU0raEIsY0FBYzNVLElBQUliLFNBQVMsQ0FBQ3RsQixLQUFLLEdBQUcrNkIsR0FBRyxDQUFDNVUsSUFBSWQsU0FBUztvQkFDM0Rsd0MsTUFBTXFpQyxTQUFTLENBQUNyRyxPQUFPLEdBQUc2cEIsTUFBTSxDQUFDRjtvQkFDakNwZ0MsT0FBT1QsSUFBSSxDQUFDa3NCLElBQUlkLFNBQVMsRUFBRTRWLE1BQU0sR0FBR0MsUUFBUSxDQUFDL2xEO2dCQUMvQyxPQUFPO29CQUNMQSxNQUFNcWlDLFNBQVMsQ0FBQ3JHLE9BQU87b0JBQ3ZCelcsT0FBTzhjLFNBQVMsQ0FBQztnQkFDbkI7WUFDRixPQUFPO2dCQUNMLElBQUksSUFBSSxDQUFDL2tDLE9BQU8sQ0FBQ3NtQyxHQUFHLENBQUMsd0JBQXdCO29CQUMzQyxNQUFNK2hCLGNBQWMzVSxJQUFJYixTQUFTLENBQUN0bEIsS0FBSyxHQUFHKzZCLEdBQUcsQ0FBQzVVLElBQUlkLFNBQVMsRUFBRTBRLGNBQWMsQ0FBQzVrQjtvQkFDNUVoOEIsTUFBTXFpQyxTQUFTLENBQUNyRyxPQUFPLEdBQUc2cEIsTUFBTSxDQUFDRjtvQkFDakNwZ0MsT0FBT1QsSUFBSSxDQUFDa3NCLElBQUlkLFNBQVMsRUFBRTRWLE1BQU0sR0FBR0MsUUFBUSxDQUFDL2xELE9BQU9nbUQsU0FBUyxDQUFDLElBQUssS0FBSWhxQixJQUFHO2dCQUM1RSxPQUFPO29CQUNMaDhCLE1BQU1xaUMsU0FBUyxDQUFDLENBQUNyRyxPQUFPLEtBQUtBO29CQUM3QnpXLE9BQU84YyxTQUFTLENBQUMsSUFBSyxLQUFJckcsSUFBRztnQkFDL0I7WUFDRjtRQUNGO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0RpcUIsb0NBQW9DO1FBQ2xDLE1BQU1qVixNQUFNLElBQUksQ0FBQ0EsR0FBRztRQUNwQixJQUFJQSxRQUFRLE1BQU07WUFDaEJBLElBQUkvbUIsU0FBUyxHQUFHMjZCLCtDQUFhQTtZQUM3QjVULElBQUk5bUIsU0FBUyxHQUFHMDZCLCtDQUFhQTtZQUM3QixJQUFJLElBQUksQ0FBQ08sd0JBQXdCLEVBQUU7Z0JBQ2pDLElBQUluVSxlQUFleVQsZ0RBQWNBLEVBQUU7b0JBQ2pDelQsSUFBSS9tQixTQUFTLEdBQUc0NkIsZ0RBQWNBO29CQUM5QjdULElBQUk5bUIsU0FBUyxHQUFHMjZCLGdEQUFjQTtnQkFDaEMsT0FBTztvQkFDTDM2QyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2Y7WUFDRjtZQUNBLElBQUk2bUMsSUFBSWtWLE1BQU0sS0FBSyxLQUFLLEdBQUc7Z0JBQ3pCbFYsSUFBSXJ5QyxXQUFXLEdBQUc7WUFDcEI7UUFDRjtJQUNGO0lBQ0E7Ozs7OztHQU1DLEdBQ0QsSUFBSXdtRCwyQkFBMkI7UUFDN0IsT0FBTyxJQUFJLENBQUM3bkQsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQztJQUMxQjtJQUNBLElBQUl1aEIseUJBQXlCN21ELEtBQUssRUFBRTtRQUNsQyxJQUFJQSxPQUFPO1lBQ1QsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLDZCQUE2QjtRQUNoRCxPQUFPO1lBQ0wsSUFBSSxDQUFDcEUsT0FBTyxDQUFDdTNCLE1BQU0sQ0FBQztRQUN0QjtRQUNBLElBQUksQ0FBQ294QixpQ0FBaUM7UUFDdEMsSUFBSSxDQUFDUCxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDM2UsVUFBVTtJQUNqQjtJQUNBOzs7OztHQUtDLEdBQ0RvZixtQ0FBbUM3bkQsS0FBSyxFQUFFO1FBQ3hDLElBQUksQ0FBQzZtRCx3QkFBd0IsR0FBRzdtRDtJQUNsQztBQUNGO0FBRUEsOEJBQThCO0FBQzlCLElBQUk4bkQsZ0JBQWdCO0FBRXBCLDZCQUE2QjtBQUM3QixJQUFJQyxjQUFjLGNBQWN2ZjtJQUM5Qjs7Ozs7O0dBTUMsR0FDRDFwQyxZQUFZLEVBQUUrM0IsZ0JBQWdCN3lCLGNBQWMrQixNQUFNLEVBQUVpaUQsY0FBYyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUM5RSxLQUFLLENBQUMsZUFBZUYsZUFBZTtZQUFFanhCO1FBQWM7UUFDcEQsSUFBSSxDQUFDbXhCLFdBQVcsR0FBR0E7SUFDckI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSUEsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ2hwRCxPQUFPLENBQUNzbUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsSUFBSTBpQixZQUFZaG9ELEtBQUssRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ2dvRCxXQUFXLEtBQUtob0QsT0FBTztZQUM5QixJQUFJQSxPQUFPO2dCQUNULElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxlQUFlO1lBQ2xDLE9BQU87Z0JBQ0wsSUFBSSxDQUFDcEUsT0FBTyxDQUFDdTNCLE1BQU0sQ0FBQztZQUN0QjtZQUNBLElBQUksQ0FBQ2tTLFVBQVU7UUFDakI7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0R3ZixrQkFBa0I7UUFDaEIsT0FBTyxJQUFJLENBQUNELFdBQVc7SUFDekI7SUFDQTs7Ozs7R0FLQyxHQUNERSxpQkFBaUJsb0QsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ2dvRCxXQUFXLEdBQUdob0Q7SUFDckI7QUFDRjtBQUVBLCtCQUErQjtBQUNvSjtBQUVuTCxnQ0FBZ0M7QUFDaEMsSUFBSXdvRCxtQkFBbUI7QUFFdkIsZ0NBQWdDO0FBQ2hDLElBQUlDLG1CQUFtQjtBQUV2QiwrQkFBK0I7QUFDL0IsSUFBSUMsZ0JBQWdCLGNBQWNsZ0I7SUFDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkMsR0FDRDFwQyxZQUFZMnFCLEtBQUssRUFBRTFiLE1BQU0sRUFBRSxFQUN6QjhvQixnQkFBZ0I3eUIsY0FBYytCLE1BQU0sRUFDcEM0aUQsaUJBQWlCLElBQUksRUFDckJDLGVBQWUsQ0FBQyxFQUNoQkMsZUFBZSxDQUFDLEVBQ2hCQyxhQUFhLENBQUMsRUFDZEMsbUJBQW1CLFFBQVEsRUFDM0JDLGtCQUFrQixPQUFPLEVBQ3pCdDhDLGFBQWF0RSxXQUFXQyxVQUFVLEVBQ2xDZzdDLE9BQU8sS0FBSyxFQUNaNEYsT0FBTyxJQUFJLEVBQ1g5ckIsZ0JBQWdCLENBQUMsRUFDakJyUSxrQkFBa0IsR0FBRyxFQUNyQnhwQixRQUFRMHBCLFdBQVdDLFNBQVMsRUFDNUIxcEIsU0FBU3lwQixXQUFXQyxTQUFTLEVBQzdCRixjQUFjenBCLEtBQUssRUFDbkI0cEIsY0FBYzNwQixNQUFNLEVBQ3JCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsaUJBQWlCaWxELGtCQUFrQjtZQUN2Q3RwRCxVQUFVLGFBQWEsR0FBRyxJQUFJeUwsSUFBSTtnQkFDaEM7b0JBQUM7b0JBQWUsSUFBSTA5QywwQ0FBU0EsQ0FBQztpQkFBTTtnQkFDcEM7b0JBQUM7b0JBQWUsSUFBSUEsMENBQVNBLENBQUM7aUJBQU07Z0JBQ3BDO29CQUFDO29CQUFnQixJQUFJQSwwQ0FBU0EsQ0FBQ1E7aUJBQWM7Z0JBQzdDO29CQUFDO29CQUFvQixJQUFJUiwwQ0FBU0EsQ0FBQyxJQUFJRix3Q0FBTUEsQ0FBQ1k7aUJBQW1CO2dCQUNqRTtvQkFBQztvQkFBbUIsSUFBSVYsMENBQVNBLENBQUMsSUFBSUYsd0NBQU1BLENBQUNhO2lCQUFrQjtnQkFDL0Q7b0JBQUM7b0JBQVMsSUFBSVgsMENBQVNBLENBQUM7aUJBQUc7Z0JBQzNCO29CQUFDO29CQUFnQixJQUFJQSwwQ0FBU0EsQ0FBQ087aUJBQWM7Z0JBQzdDO29CQUFDO29CQUFrQixJQUFJUCwwQ0FBU0EsQ0FBQztpQkFBTTthQUN4QztRQUNIO1FBQ0EsSUFBSSxDQUFDMXhCLFNBQVMsQ0FBQ3BKLGdCQUFnQixDQUFDLFVBQVUsQ0FBQzZKO1lBQ3pDLElBQUksSUFBSSxDQUFDVCxTQUFTLENBQUNFLGFBQWEsS0FBSzd5QixjQUFjSSxLQUFLLEVBQUU7Z0JBQ3hELElBQUksQ0FBQ3BGLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxTQUFTO1lBQzVCLE9BQU87Z0JBQ0wsSUFBSSxDQUFDcEUsT0FBTyxDQUFDdTNCLE1BQU0sQ0FBQztZQUN0QjtZQUNBLElBQUksQ0FBQ2tTLFVBQVU7UUFDakI7UUFDQSxJQUFJLENBQUM5UixTQUFTLENBQUNFLGFBQWEsR0FBR0E7UUFDL0IsSUFBSSxDQUFDOHhCLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDTSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeC9CLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMxYixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDbTdDLGdCQUFnQixHQUFHLElBQUlYLG9EQUFtQkEsQ0FBQyxHQUFHO1FBQ25ELElBQUksQ0FBQ1csZ0JBQWdCLENBQUMvckMsT0FBTyxHQUFHZ2dCO1FBQ2hDLElBQUksQ0FBQytyQixnQkFBZ0IsQ0FBQy85QyxPQUFPLENBQUNwTSxJQUFJLEdBQUc7UUFDckMsSUFBSSxDQUFDRyxRQUFRLENBQUM4TCxHQUFHLENBQUMsZUFBZWhMLEtBQUssR0FBRyxJQUFJLENBQUNrcEQsZ0JBQWdCLENBQUMvOUMsT0FBTztRQUN0RSxJQUFJLENBQUNnK0MsbUJBQW1CLEdBQUcsSUFBSVosb0RBQW1CQSxDQUFDLEdBQUcsR0FBRztZQUFFMTdDLGFBQWE7UUFBTTtRQUM5RSxJQUFJLENBQUNzOEMsbUJBQW1CLENBQUNoK0MsT0FBTyxDQUFDcE0sSUFBSSxHQUFHO1FBQ3hDLElBQUksQ0FBQ0csUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGVBQWVoTCxLQUFLLEdBQUcsSUFBSSxDQUFDbXBELG1CQUFtQixDQUFDaCtDLE9BQU87UUFDekUsSUFBSSxDQUFDK2tCLFNBQVMsR0FBRyxJQUFJeEI7UUFDckIsSUFBSSxDQUFDd0IsU0FBUyxDQUFDdEIsa0JBQWtCLEdBQUcsSUFBSXU1Qix3Q0FBTUEsQ0FBQztRQUMvQyxJQUFJLENBQUNqNEIsU0FBUyxDQUFDckIsa0JBQWtCLEdBQUc7UUFDcEMsSUFBSSxDQUFDdTZCLFNBQVMsR0FBRyxJQUFJMTNCLFVBQVVqSSxPQUFPMWI7UUFDdEMsSUFBSSxDQUFDcS9CLFFBQVEsR0FBRyxJQUFJcGQsV0FBV3ZHLE9BQU8xYixRQUFRLElBQUltRCx3QkFBd0IsSUFBSSxDQUFDazRDLFNBQVMsQ0FBQ2orQyxPQUFPLEVBQUU0QztRQUNsRyxNQUFNbWlCLFlBQVksSUFBSSxDQUFDa2QsUUFBUSxDQUFDbGQsU0FBUztRQUN6Q0EsVUFBVXRCLGtCQUFrQixHQUFHLElBQUl1NUIsd0NBQU1BLENBQUM7UUFDMUNqNEIsVUFBVXJCLGtCQUFrQixHQUFHO1FBQy9CLElBQUksQ0FBQzRhLFFBQVEsR0FBRyxJQUFJN1EsZUFBZTtZQUFFOUw7WUFBaUJDO1lBQWFHO1lBQWF4Z0I7UUFBVztRQUMzRixJQUFJLENBQUMrOEIsUUFBUSxDQUFDM2YsT0FBTyxHQUFHdTVCO1FBQ3hCLE1BQU03cEMsYUFBYSxJQUFJLENBQUNpd0IsUUFBUSxDQUFDandCLFVBQVU7UUFDM0NBLFdBQVcrVCxnQkFBZ0IsQ0FBQyxVQUFVLENBQUNDLElBQU0sSUFBSSxDQUFDbnFCLE9BQU8sQ0FBQ21XLFdBQVdpVSxTQUFTLEVBQUVqVSxXQUFXa1UsVUFBVTtRQUNyRyxJQUFJLENBQUMyN0IsV0FBVyxHQUFHLElBQUk3dEIsV0FBVyxJQUFJL2E7UUFDdEMsTUFBTTZvQyxrQkFBa0IsSUFBSSxDQUFDRCxXQUFXLENBQUNwL0Isa0JBQWtCO1FBQzNEcS9CLGdCQUFnQmpvRCxXQUFXLEdBQUcsSUFBSSxDQUFDNm5ELGdCQUFnQixDQUFDLzlDLE9BQU87UUFDM0QsSUFBSSxDQUFDdU8sSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDNnZDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNoNUIsU0FBUyxHQUFHLElBQUltVTtRQUNyQixJQUFJLENBQUNuVSxTQUFTLENBQUNxVSxLQUFLLEdBQUc7UUFDdkIsSUFBSSxDQUFDa2tCLFVBQVUsR0FBR0E7SUFDcEI7SUFDQSxJQUFJNStCLFVBQVVscUIsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ3lwQixLQUFLLEdBQUd6cEI7UUFDYixJQUFJLENBQUNvcEQsU0FBUyxDQUFDbC9CLFNBQVMsR0FBR2xxQjtRQUMzQixJQUFJLENBQUNvdEMsUUFBUSxDQUFDbGpCLFNBQVMsR0FBR2xxQjtJQUM1QjtJQUNBLElBQUltcUIsV0FBV25xQixLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDK04sTUFBTSxHQUFHL047UUFDZCxJQUFJLENBQUNvcEQsU0FBUyxDQUFDai9CLFVBQVUsR0FBR25xQjtRQUM1QixJQUFJLENBQUNvdEMsUUFBUSxDQUFDampCLFVBQVUsR0FBR25xQjtRQUMzQixJQUFJLENBQUNvdEMsUUFBUSxDQUFDbmQsZ0JBQWdCLENBQUNuaUIsa0JBQWtCLENBQUM5TjtJQUNwRDtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJd1osYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDaXdCLFFBQVEsQ0FBQ2p3QixVQUFVO0lBQ2pDO0lBQ0E7Ozs7R0FJQyxHQUNEb1ksZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUM2WCxRQUFRLENBQUM3WCxhQUFhO0lBQ3BDO0lBQ0E7Ozs7Ozs7R0FPQyxHQUNELElBQUl1TCxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUMrckIsZ0JBQWdCLENBQUMvckMsT0FBTztJQUN0QztJQUNBLElBQUlnZ0IsY0FBY245QixLQUFLLEVBQUU7UUFDdkIsSUFBSSxDQUFDa3BELGdCQUFnQixDQUFDL3JDLE9BQU8sR0FBR25kO1FBQ2hDLElBQUksQ0FBQ2twRCxnQkFBZ0IsQ0FBQ3pyRCxPQUFPO0lBQy9CO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUltckQsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQzFwRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsZ0JBQWdCaEwsS0FBSztJQUNoRDtJQUNBLElBQUk0b0QsYUFBYTVvRCxLQUFLLEVBQUU7UUFDdEIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsZ0JBQWdCaEwsS0FBSyxHQUFHQTtJQUM1QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJNm9ELGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMzcEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGdCQUFnQmhMLEtBQUs7SUFDaEQ7SUFDQSxJQUFJNm9ELGFBQWE3b0QsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGdCQUFnQmhMLEtBQUssR0FBR0E7SUFDNUM7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSStvRCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUM3cEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLG9CQUFvQmhMLEtBQUs7SUFDcEQ7SUFDQSxJQUFJK29ELGlCQUFpQi9vRCxLQUFLLEVBQUU7UUFDMUIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsb0JBQW9CaEwsS0FBSyxHQUFHQTtJQUNoRDtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJZ3BELGtCQUFrQjtRQUNwQixPQUFPLElBQUksQ0FBQzlwRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsbUJBQW1CaEwsS0FBSztJQUNuRDtJQUNBLElBQUlncEQsZ0JBQWdCaHBELEtBQUssRUFBRTtRQUN6QixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxtQkFBbUJoTCxLQUFLLEdBQUdBO0lBQy9DO0lBQ0E7Ozs7O0dBS0MsR0FDRDZwQyxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUNKLFFBQVE7SUFDdEI7SUFDQTs7Ozs7R0FLQyxHQUNEN1ksZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDTCxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7O0dBS0MsR0FDRGk1QixnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQ1YsVUFBVTtJQUN4QjtJQUNBOzs7OztHQUtDLEdBQ0RXLGNBQWN6cEQsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQzhvRCxVQUFVLEdBQUc5b0Q7SUFDcEI7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUlzRCxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNrVyxVQUFVLENBQUNsVyxLQUFLO0lBQzlCO0lBQ0EsSUFBSUEsTUFBTXRELEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ3daLFVBQVUsQ0FBQ3NmLGNBQWMsR0FBRzk0QjtJQUNuQztJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXVELFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ2lXLFVBQVUsQ0FBQ2pXLE1BQU07SUFDL0I7SUFDQSxJQUFJQSxPQUFPdkQsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQ3daLFVBQVUsQ0FBQ3VmLGVBQWUsR0FBRy80QjtJQUNwQztJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSTBwRCxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUNuNUIsU0FBUyxDQUFDcVUsS0FBSztJQUM3QjtJQUNBLElBQUk4a0IsZUFBZTFwRCxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDdXdCLFNBQVMsQ0FBQ3FVLEtBQUssR0FBRzVrQztJQUN6QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXNaLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQ213QixRQUFRLENBQUNud0IsU0FBUztJQUNoQztJQUNBLElBQUlBLFVBQVV0WixLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDeXBDLFFBQVEsQ0FBQ253QixTQUFTLEdBQUd0WjtJQUM1QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSTBNLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQys4QixRQUFRLENBQUMvOEIsVUFBVTtJQUNqQztJQUNBLElBQUlBLFdBQVcxTSxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDeXBDLFFBQVEsQ0FBQy84QixVQUFVLEdBQUcxTTtJQUM3QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXFqRCxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUM1WixRQUFRLENBQUMzZixPQUFPO0lBQzlCO0lBQ0EsSUFBSXU1QixLQUFLcmpELEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQ3lwQyxRQUFRLENBQUMzZixPQUFPLEdBQUc5cEI7SUFDMUI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSWlwRCxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNqcUQsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQztJQUMxQjtJQUNBLElBQUkyakIsS0FBS2pwRCxLQUFLLEVBQUU7UUFDZCxJQUFJLElBQUksQ0FBQ2lwRCxJQUFJLEtBQUtqcEQsT0FBTztZQUN2QixJQUFJQSxPQUFPO2dCQUNULElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxTQUFTO1lBQzVCLE9BQU87Z0JBQ0wsSUFBSSxDQUFDcEUsT0FBTyxDQUFDdTNCLE1BQU0sQ0FBQztZQUN0QjtZQUNBLElBQUksQ0FBQ2tTLFVBQVU7UUFDakI7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0RraEIsZ0JBQWdCO1FBQ2QsT0FBTyxJQUFJLENBQUNWLElBQUk7SUFDbEI7SUFDQTs7Ozs7R0FLQyxHQUNEVyxlQUFlNXBELEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNpcEQsSUFBSSxHQUFHanBEO0lBQ2Q7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSTJvRCxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUN6cEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGtCQUFrQmhMLEtBQUs7SUFDbEQ7SUFDQSxJQUFJMm9ELGVBQWUzb0QsS0FBSyxFQUFFO1FBQ3hCLElBQUlBLFVBQVUsTUFBTTtZQUNsQkEsTUFBTXd4QyxLQUFLLEdBQUd4eEMsTUFBTXl4QyxLQUFLLEdBQUcyVyxpREFBZUE7WUFDM0MsSUFBSSxDQUFDcHBELE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxlQUFlO1lBQ2hDLElBQUksQ0FBQytsQyxlQUFlLENBQUNzZjtRQUN2QixPQUFPO1lBQ0wsSUFBSSxDQUFDenBELE9BQU8sQ0FBQ3UzQixNQUFNLENBQUM7WUFDcEIsSUFBSSxDQUFDNFMsZUFBZSxDQUFDO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDanFDLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxrQkFBa0JoTCxLQUFLLEdBQUdBO1FBQzVDLElBQUksQ0FBQ3lvQyxVQUFVO0lBQ2pCO0lBQ0E7Ozs7O0dBS0MsR0FDRG9oQixrQkFBa0I3cEQsS0FBSyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzJvRCxjQUFjLEdBQUczb0Q7SUFDeEI7SUFDQTs7Ozs7R0FLQyxHQUNENnhCLHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQ3JZLFVBQVUsQ0FBQzlYLEtBQUs7SUFDOUI7SUFDQTs7Ozs7R0FLQyxHQUNEb3dCLG1CQUFtQnB3QixLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDOFgsVUFBVSxDQUFDOVgsS0FBSyxHQUFHQTtJQUMxQjtJQUNBOzs7Ozs7R0FNQyxHQUNEbXZCLGFBQWF3VSxPQUFPLEVBQUU7UUFDcEIsSUFBSSxDQUFDOVUsU0FBUyxDQUFDbnRCLEdBQUcsQ0FBQ2lpQztRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBOzs7OztHQUtDLEdBQ0R5a0IsaUJBQWlCO1FBQ2YsSUFBSSxDQUFDdjVCLFNBQVMsQ0FBQ2IsS0FBSztRQUNwQixPQUFPLElBQUk7SUFDYjtJQUNBOzs7Ozs7R0FNQyxHQUNEcTZCLGFBQWFobEIsTUFBTSxFQUFFO1FBQ25CLElBQUksQ0FBQ3hVLFNBQVMsQ0FBQy9GLEdBQUcsQ0FBQ3VhO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0E7Ozs7OztHQU1DLEdBQ0RpbEIsZUFBZWpsQixNQUFNLEVBQUU7UUFDckIsSUFBSSxDQUFDeFUsU0FBUyxDQUFDZ0csTUFBTSxDQUFDd087UUFDdEIsT0FBTyxJQUFJO0lBQ2I7SUFDQTs7Ozs7O0dBTUMsR0FDRHpNLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLE1BQU1tcUIsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDeEIsTUFBTTFiLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU13aUIsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDaEMsTUFBTXJ4QixXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNK3FELFFBQVEvcUQsU0FBUzhMLEdBQUcsQ0FBQztRQUMzQixNQUFNcW1CLGFBQWE1SCxNQUFNNEgsVUFBVTtRQUNuQyxNQUFNRixPQUFPcGpCLE9BQU9xakIsTUFBTSxDQUFDRCxJQUFJO1FBQy9CLElBQUksSUFBSSxDQUFDbzRCLFdBQVcsSUFBSWg1QixVQUFVbU4sSUFBSSxHQUFHLEdBQUc7WUFDMUNqVSxNQUFNNEgsVUFBVSxHQUFHO1lBQ25CNDRCLE1BQU1qcUQsS0FBSyxHQUFHO1lBQ2QsSUFBSSxJQUFJLENBQUM4b0QsVUFBVSxHQUFHLEdBQUc7Z0JBQ3ZCbUIsTUFBTWpxRCxLQUFLLEdBQUd5QyxLQUFLSyxHQUFHLENBQUMsSUFBSSxDQUFDNFcsSUFBSSxHQUFHLElBQUksQ0FBQ292QyxVQUFVLEdBQUcsTUFBTSxRQUFRO1lBQ3JFO1lBQ0EsSUFBSSxDQUFDcHZDLElBQUksSUFBSXBhO1lBQ2JpeEIsVUFBVWlWLFVBQVUsQ0FBQztZQUNyQixJQUFJLENBQUM0akIsU0FBUyxDQUFDditCLE1BQU0sQ0FBQy9mO1lBQ3RCeWxCLFVBQVVpVixVQUFVLENBQUM7WUFDckJ6M0IsT0FBT3FqQixNQUFNLENBQUNodUIsR0FBRyxDQUFDbXRCLFVBQVVxVSxLQUFLO1lBQ2pDLElBQUksQ0FBQ3dJLFFBQVEsQ0FBQ3ZpQixNQUFNLENBQUMvZixVQUFVLElBQUksQ0FBQ28rQyxnQkFBZ0I7WUFDcERuN0MsT0FBT3FqQixNQUFNLENBQUNELElBQUksR0FBR0E7WUFDckIxSCxNQUFNNEgsVUFBVSxHQUFHQTtZQUNuQixJQUFJLENBQUNnNEIsV0FBVyxDQUFDeCtCLE1BQU0sQ0FBQy9mLFVBQVUsTUFBTSxJQUFJLENBQUNxK0MsbUJBQW1CO1lBQ2hFLElBQUksSUFBSSxDQUFDMWYsUUFBUSxDQUFDM2YsT0FBTyxFQUFFO2dCQUN6QixJQUFJLENBQUMyZixRQUFRLENBQUM1ZSxNQUFNLENBQUMvZixVQUFVLElBQUksQ0FBQ3ErQyxtQkFBbUIsRUFBRSxJQUFJLENBQUNBLG1CQUFtQjtZQUNuRjtRQUNGO1FBQ0EsSUFBSSxDQUFDSSxXQUFXLEdBQUdoNUIsVUFBVW1OLElBQUksR0FBRztJQUN0QztJQUNBOzs7OztHQUtDLEdBQ0RyNkIsUUFBUUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDckIsSUFBSSxDQUFDa21DLFFBQVEsQ0FBQ3BtQyxPQUFPLENBQUNDLE9BQU9DO1FBQzdCLElBQUksQ0FBQzJsRCxnQkFBZ0IsQ0FBQzdsRCxPQUFPLENBQUNDLE9BQU9DO1FBQ3JDLE1BQU1pVyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQ0EsV0FBV3FVLFdBQVcsQ0FBQ3ZxQixPQUFPQztRQUM5QixNQUFNdXFCLElBQUl0VSxXQUFXbFcsS0FBSyxFQUFFeXFCLElBQUl2VSxXQUFXalcsTUFBTTtRQUNqRCxJQUFJLENBQUM2bEQsU0FBUyxDQUFDL2xELE9BQU8sQ0FBQ3lxQixHQUFHQztRQUMxQixJQUFJLENBQUNvN0IsbUJBQW1CLENBQUM5bEQsT0FBTyxDQUFDeXFCLEdBQUdDO1FBQ3BDLElBQUksQ0FBQ3M3QixXQUFXLENBQUNwL0Isa0JBQWtCLENBQUM1bUIsT0FBTyxDQUFDeXFCLEdBQUdDO0lBQ2pEO0lBQ0E7Ozs7OztHQU1DLEdBQ0QvQyxXQUFXbGdCLFFBQVEsRUFBRW1nQixLQUFLLEVBQUVDLGVBQWUsRUFBRTtRQUMzQyxJQUFJLENBQUN1ZSxRQUFRLENBQUN6ZSxVQUFVLENBQUNsZ0IsVUFBVW1nQixPQUFPcTlCLG1EQUFrQkE7UUFDNUQsSUFBSXA5QixvQkFBb0IsS0FBSyxHQUFHO1lBQzlCLElBQUksQ0FBQ2srQixTQUFTLENBQUNwK0IsVUFBVSxDQUFDbGdCLFVBQVVtZ0IsT0FBT0M7WUFDM0MsSUFBSSxDQUFDa2lCLFFBQVEsQ0FBQ3BpQixVQUFVLENBQUNsZ0IsVUFBVW1nQixPQUFPQztZQUMxQyxJQUFJLENBQUNtK0IsV0FBVyxDQUFDcitCLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO1FBQy9DO0lBQ0Y7QUFDRjtBQUVBLGtDQUFrQztBQUNzRDtBQUV4RixtQ0FBbUM7QUFDbkMsSUFBSW0vQixxQkFBcUI7QUFFekIsa0NBQWtDO0FBQ2xDLElBQUlDLG1CQUFtQixjQUFjOWhCO0lBQ25DOzs7O0dBSUMsR0FDRDFwQyxZQUFZeXJELGNBQWMsRUFBRSxDQUFFO1FBQzVCLEtBQUssQ0FBQyxvQkFBb0JGLG9CQUFvQjtZQUM1Q25yRCxVQUFVLGFBQWEsR0FBRyxJQUFJeUwsSUFBSTtnQkFDaEM7b0JBQUM7b0JBQVUsSUFBSXUvQywwQ0FBU0EsQ0FBQztpQkFBTztnQkFDaEM7b0JBQUM7b0JBQUssSUFBSUEsMENBQVNBLENBQUMsSUFBSUUsMENBQVFBO2lCQUFJO2FBQ3JDO1FBQ0g7UUFDQSxJQUFJLENBQUM1d0MsVUFBVSxHQUFHLElBQUkyd0MsMENBQVNBO1FBQy9CLElBQUksQ0FBQ0ssWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0QsV0FBVyxHQUFHQTtJQUNyQjtJQUNBOzs7Ozs7R0FNQyxHQUNELElBQUlBLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUNDLFlBQVk7SUFDMUI7SUFDQSxJQUFJRCxZQUFZdnFELEtBQUssRUFBRTtRQUNyQixJQUFJczJCLElBQUk3ekIsS0FBSzRLLEtBQUssQ0FBQ3JOO1FBQ25CLElBQUlzMkIsSUFBSSxJQUFJLEdBQUc7WUFDYkEsS0FBSztRQUNQO1FBQ0EsSUFBSSxDQUFDazBCLFlBQVksR0FBR2wwQjtRQUNwQixJQUFJLENBQUNwM0IsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFVBQVVoTCxLQUFLLEdBQUdzMkIsSUFBSTtRQUN4QyxJQUFJLENBQUNqekIsT0FBTyxDQUFDLElBQUksQ0FBQ21XLFVBQVUsQ0FBQ2xXLEtBQUssRUFBRSxJQUFJLENBQUNrVyxVQUFVLENBQUNqVyxNQUFNO0lBQzVEO0lBQ0E7Ozs7O0dBS0MsR0FDRGtuRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQ0YsV0FBVztJQUN6QjtJQUNBOzs7OztHQUtDLEdBQ0RHLGVBQWUxcUQsS0FBSyxFQUFFO1FBQ3BCLElBQUksQ0FBQ3VxRCxXQUFXLEdBQUd2cUQ7SUFDckI7SUFDQTs7Ozs7R0FLQyxHQUNEcUQsUUFBUUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDckIsTUFBTWlXLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDQSxXQUFXcFcsR0FBRyxDQUFDRSxPQUFPQztRQUN0QixNQUFNK3lCLElBQUksSUFBSSxDQUFDaTBCLFdBQVc7UUFDMUIsTUFBTXJuRCxJQUFJb3pCLElBQUk5YyxXQUFXdFcsQ0FBQztRQUMxQixNQUFNQyxJQUFJbXpCLElBQUk5YyxXQUFXclcsQ0FBQztRQUMxQixJQUFJLENBQUNqRSxRQUFRLENBQUM4TCxHQUFHLENBQUMsS0FBS2hMLEtBQUssQ0FBQ29ELEdBQUcsQ0FBQ0YsR0FBR0MsR0FBRyxJQUFJRCxHQUFHLElBQUlDO0lBQ3BEO0FBQ0Y7QUFFQSxzQ0FBc0M7QUFDNEI7QUFFbEUsd0NBQXdDO0FBQ3hDLElBQUkwbkQsMEJBQTBCO0FBRTlCLHNDQUFzQztBQUN0QyxJQUFJQyx1QkFBdUIsY0FBY3RpQjtJQUN2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBQ0QxcEMsWUFBWSxFQUNWKzNCLGFBQWEsRUFDYnVULFFBQVEsQ0FBQyxFQUNUeDdCLGNBQWMsRUFBRSxFQUNoQm04QyxRQUFRLEdBQUcsRUFDWHpoQixxQkFBcUIsR0FBRyxFQUN4QjBoQixnQkFBZ0IsQ0FBQyxFQUNqQnhtQyxPQUFPLEdBQUcsRUFDVnltQyxTQUFTLEdBQUcsRUFDWjFnQixVQUFVLENBQUMsRUFDWDVsQixRQUFRLENBQUMsRUFDVHhILFVBQVUsQ0FBQyxFQUNYK3RDLFlBQVksS0FBSyxFQUNqQkMsWUFBWSxLQUFLLEVBQ2pCQyxXQUFXLEtBQUssRUFDakIsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNOLEtBQUssQ0FBQyx3QkFBd0JQLHlCQUF5QjtZQUNyRGgwQjtZQUNBeEIsWUFBWS90QixnQkFBZ0JFLFdBQVcsR0FBR0YsZ0JBQWdCRixLQUFLO1lBQy9EbEksVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFTLElBQUlnZ0QsMENBQVNBLENBQUN2Z0I7aUJBQU87Z0JBQy9CO29CQUFDO29CQUFlLElBQUl1Z0IsMENBQVNBLENBQUMvN0M7aUJBQWE7Z0JBQzNDO29CQUFDO29CQUFTLElBQUkrN0MsMENBQVNBLENBQUNJO2lCQUFPO2dCQUMvQjtvQkFBQztvQkFBc0IsSUFBSUosMENBQVNBLENBQUNyaEI7aUJBQW9CO2dCQUN6RDtvQkFBQztvQkFBaUIsSUFBSXFoQiwwQ0FBU0EsQ0FBQ0s7aUJBQWU7Z0JBQy9DO29CQUFDO29CQUFRLElBQUlMLDBDQUFTQSxDQUFDbm1DO2lCQUFNO2dCQUM3QjtvQkFBQztvQkFBVSxJQUFJbW1DLDBDQUFTQSxDQUFDTTtpQkFBUTtnQkFDakM7b0JBQUM7b0JBQVcsSUFBSU4sMENBQVNBLENBQUNwZ0I7aUJBQVM7Z0JBQ25DO29CQUFDO29CQUFPLElBQUlvZ0IsMENBQVNBLENBQUM7aUJBQU07YUFDN0I7UUFDSDtRQUNBLElBQUksQ0FBQ2htQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDeEgsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQyt0QyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDbEI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXptQyxRQUFRO1FBQ1YsT0FBT3BhLE9BQU84Z0QsUUFBUSxDQUFDLElBQUksQ0FBQ3JzRCxPQUFPLENBQUNnTSxHQUFHLENBQUM7SUFDMUM7SUFDQSxJQUFJMlosTUFBTTNrQixLQUFLLEVBQUU7UUFDZixNQUFNNEMsSUFBSUgsS0FBSzRLLEtBQUssQ0FBQ3JOO1FBQ3JCLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxhQUFhUixFQUFFeEMsT0FBTyxDQUFDO1FBQ3hDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxlQUFlUixFQUFFeEMsT0FBTyxDQUFDO1FBQzFDLElBQUksQ0FBQ3FvQyxVQUFVO0lBQ2pCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUl0ckIsVUFBVTtRQUNaLE9BQU81UyxPQUFPOGdELFFBQVEsQ0FBQyxJQUFJLENBQUNyc0QsT0FBTyxDQUFDZ00sR0FBRyxDQUFDO0lBQzFDO0lBQ0EsSUFBSW1TLFFBQVFuZCxLQUFLLEVBQUU7UUFDakIsTUFBTW9kLElBQUkzYSxLQUFLNEssS0FBSyxDQUFDck47UUFDckIsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLGVBQWVnYSxFQUFFaGQsT0FBTyxDQUFDO1FBQzFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxpQkFBaUJnYSxFQUFFaGQsT0FBTyxDQUFDO1FBQzVDLElBQUksQ0FBQ3FvQyxVQUFVO0lBQ2pCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUl5aUIsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDbHNELE9BQU8sQ0FBQ3NtQyxHQUFHLENBQUM7SUFDMUI7SUFDQSxJQUFJNGxCLFVBQVVsckQsS0FBSyxFQUFFO1FBQ25CLElBQUksSUFBSSxDQUFDa3JELFNBQVMsS0FBS2xyRCxPQUFPO1lBQzVCLElBQUlBLE9BQU87Z0JBQ1QsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLGNBQWM7WUFDakMsT0FBTztnQkFDTCxJQUFJLENBQUNwRSxPQUFPLENBQUN1M0IsTUFBTSxDQUFDO1lBQ3RCO1lBQ0EsSUFBSSxDQUFDa1MsVUFBVTtRQUNqQjtJQUNGO0lBQ0E7Ozs7OztHQU1DLEdBQ0QsSUFBSTBpQixZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUNuc0QsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQztJQUMxQjtJQUNBLElBQUk2bEIsVUFBVW5yRCxLQUFLLEVBQUU7UUFDbkIsSUFBSSxJQUFJLENBQUNtckQsU0FBUyxLQUFLbnJELE9BQU87WUFDNUIsSUFBSUEsT0FBTztnQkFDVCxJQUFJLENBQUNoQixPQUFPLENBQUNvRSxHQUFHLENBQUMsY0FBYztnQkFDL0IsSUFBSSxDQUFDbEUsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLE9BQU9oTCxLQUFLLEdBQUcsSUFBSTRxRCwwQ0FBUUEsQ0FBQyxLQUFLLEdBQUcsS0FBSztZQUM3RCxPQUFPO2dCQUNMLElBQUksQ0FBQzVyRCxPQUFPLENBQUN1M0IsTUFBTSxDQUFDO2dCQUNwQixJQUFJLENBQUNyM0IsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLE9BQU9oTCxLQUFLLEdBQUc7WUFDbkM7WUFDQSxJQUFJLENBQUN5b0MsVUFBVTtRQUNqQjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUkyaUIsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDcHNELE9BQU8sQ0FBQ3NtQyxHQUFHLENBQUM7SUFDMUI7SUFDQSxJQUFJOGxCLFNBQVNwckQsS0FBSyxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDb3JELFFBQVEsS0FBS3ByRCxPQUFPO1lBQzNCLElBQUlBLE9BQU87Z0JBQ1QsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLFlBQVk7WUFDL0IsT0FBTztnQkFDTCxJQUFJLENBQUNwRSxPQUFPLENBQUN1M0IsTUFBTSxDQUFDO1lBQ3RCO1lBQ0EsSUFBSSxDQUFDa1MsVUFBVTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDbUM7QUFFbkUsa0NBQWtDO0FBQ2xDLElBQUkraUIsb0JBQW9CO0FBRXhCLGdDQUFnQztBQUNoQyxJQUFJQyxpQkFBaUIsY0FBY2pqQjtJQUNqQzs7Ozs7OztHQU9DLEdBQ0QxcEMsWUFBWSxFQUFFKzNCLGdCQUFnQjd5QixjQUFjMkIsT0FBTyxFQUFFc1csVUFBVSxJQUFJLEVBQUV5dkMsY0FBYyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUMzRixLQUFLLENBQUMsa0JBQWtCRixtQkFBbUI7WUFDekMzMEI7WUFDQTMzQixVQUFVLGFBQWEsR0FBRyxJQUFJeUwsSUFBSTtnQkFDaEM7b0JBQUM7b0JBQVMsSUFBSTJnRCwwQ0FBU0EsQ0FBQztpQkFBRztnQkFDM0I7b0JBQUM7b0JBQWUsSUFBSUEsMENBQVNBLENBQUM7aUJBQUc7YUFDbEM7UUFDSDtRQUNBLElBQUksQ0FBQzl4QyxVQUFVLEdBQUcsSUFBSSt4QywwQ0FBU0E7UUFDL0IsSUFBSSxDQUFDajFCLENBQUMsR0FBR3JhO1FBQ1QsSUFBSSxDQUFDeXZDLFdBQVcsR0FBR0E7SUFDckI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXp2QyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNxYSxDQUFDO0lBQ2Y7SUFDQSxJQUFJcmEsUUFBUWpjLEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUNzMkIsQ0FBQyxHQUFHdDJCO1FBQ1QsSUFBSSxDQUFDcUQsT0FBTyxDQUFDLElBQUksQ0FBQ21XLFVBQVUsQ0FBQ2xXLEtBQUssRUFBRSxJQUFJLENBQUNrVyxVQUFVLENBQUNqVyxNQUFNO0lBQzVEO0lBQ0E7Ozs7O0dBS0MsR0FDRGlaLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ1AsT0FBTztJQUNyQjtJQUNBOzs7OztHQUtDLEdBQ0RRLFdBQVd6YyxLQUFLLEVBQUU7UUFDaEIsSUFBSSxDQUFDaWMsT0FBTyxHQUFHamM7SUFDakI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSTByRCxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDeHNELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxlQUFlaEwsS0FBSztJQUMvQztJQUNBLElBQUkwckQsWUFBWTFyRCxLQUFLLEVBQUU7UUFDckIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsZUFBZWhMLEtBQUssR0FBR0E7UUFDekMsSUFBSUEsVUFBVSxHQUFHO1lBQ2YsSUFBSSxJQUFJLENBQUNoQixPQUFPLENBQUN1M0IsTUFBTSxDQUFDLFdBQVc7Z0JBQ2pDLElBQUksQ0FBQ2tTLFVBQVU7WUFDakI7UUFDRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUN6cEMsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQyxXQUFXO1lBQ3RDLElBQUksQ0FBQ3RtQyxPQUFPLENBQUNvRSxHQUFHLENBQUMsVUFBVTtZQUMzQixJQUFJLENBQUNxbEMsVUFBVTtRQUNqQjtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FDRHBsQyxRQUFRQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUNyQixJQUFJLENBQUNpVyxVQUFVLENBQUNwVyxHQUFHLENBQUNFLE9BQU9DO1FBQzNCLElBQUksQ0FBQ3JFLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxTQUFTaEwsS0FBSyxHQUFHeUMsS0FBS3N4QixLQUFLLENBQUN4d0IsU0FBUyxJQUFJLENBQUMwWSxPQUFPO0lBQ3JFO0FBQ0Y7QUFFQSxpQ0FBaUM7QUFDdUQ7QUFFeEYsbUNBQW1DO0FBQ25DLElBQUk2dkMscUJBQXFCO0FBRXpCLG1DQUFtQztBQUNuQyxJQUFJQyxzQkFBc0I7QUFFMUIsaUNBQWlDO0FBQ2pDLElBQUlDLFVBQVV2cEQsS0FBS21zQyxFQUFFLEdBQUc7QUFDeEIsSUFBSXFkLEtBQUssYUFBYSxHQUFHLElBQUlKLDBDQUFRQTtBQUNyQyxJQUFJSyxLQUFLLGFBQWEsR0FBRyxJQUFJTCwwQ0FBUUE7QUFDckMsSUFBSU0sa0JBQWtCLGNBQWMzakI7SUFDbEM7Ozs7Ozs7Ozs7R0FVQyxHQUNEMXBDLFlBQVlpUCxNQUFNLEVBQUVvZ0MsV0FBVyxJQUFJMGQsMENBQVFBLEVBQUUsRUFBRSxFQUM3Q08sUUFBUSxDQUFDLEVBQ1RDLFlBQVksQ0FBQyxFQUNiQyxXQUFXLEdBQUcsRUFDZEMsWUFBWSxJQUFJLEVBQ2pCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsbUJBQW1CVCxvQkFBb0I7WUFDM0MvckQsY0FBY2dzRDtZQUNkN3NELFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBVSxJQUFJZ2hELDBDQUFTQSxDQUFDO2lCQUFPO2dCQUNoQztvQkFBQztvQkFBVSxJQUFJQSwwQ0FBU0EsQ0FBQyxJQUFJQywwQ0FBU0EsQ0FBQyxLQUFLO2lCQUFNO2dCQUNsRDtvQkFBQztvQkFBa0IsSUFBSUQsMENBQVNBLENBQUM7aUJBQUc7Z0JBQ3BDO29CQUFDO29CQUFRLElBQUlBLDBDQUFTQSxDQUFDO2lCQUFHO2dCQUMxQjtvQkFBQztvQkFBVSxJQUFJQSwwQ0FBU0EsQ0FBQyxDQUFDVztpQkFBVTtnQkFDcEM7b0JBQUM7b0JBQWEsSUFBSVgsMENBQVNBLENBQUNVO2lCQUFXO2dCQUN2QztvQkFBQztvQkFBWSxJQUFJViwwQ0FBU0EsQ0FBQ1c7aUJBQVU7Z0JBQ3JDO29CQUFDO29CQUFhLElBQUlYLDBDQUFTQSxDQUFDWTtpQkFBVzthQUN4QztRQUNIO1FBQ0EsSUFBSSxDQUFDcGUsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNpZSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDcitDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN5MUMsY0FBYyxHQUFHLElBQUksQ0FBQ3RrRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsVUFBVWhMLEtBQUs7UUFDdkQsSUFBSSxDQUFDMFosSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDNm1DLE1BQU0sR0FBRztJQUNoQjtJQUNBLElBQUlwMkIsV0FBV25xQixLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDK04sTUFBTSxHQUFHL047SUFDaEI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXVzRCxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUNydEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGFBQWFoTCxLQUFLO0lBQzdDO0lBQ0EsSUFBSXVzRCxVQUFVdnNELEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxhQUFhaEwsS0FBSyxHQUFHQTtJQUN6QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJc3NELFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQ3B0RCxRQUFRLENBQUM4TCxHQUFHLENBQUMsWUFBWWhMLEtBQUs7SUFDNUM7SUFDQSxJQUFJc3NELFNBQVN0c0QsS0FBSyxFQUFFO1FBQ2xCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFlBQVloTCxLQUFLLEdBQUdBO0lBQ3hDO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlxc0QsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDbnRELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxhQUFhaEwsS0FBSztJQUM3QztJQUNBLElBQUlxc0QsVUFBVXJzRCxLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsYUFBYWhMLEtBQUssR0FBR0E7SUFDekM7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUl3c0QsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDcmUsUUFBUTtJQUN0QjtJQUNBLElBQUlxZSxVQUFVeHNELEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNtdUMsUUFBUSxHQUFHbnVDO0lBQ2xCO0lBQ0E7Ozs7O0dBS0MsR0FDRHlzRCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUN0ZSxRQUFRO0lBQ3RCO0lBQ0E7Ozs7O0dBS0MsR0FDRHVlLFlBQVkxc0QsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQ211QyxRQUFRLEdBQUdudUM7SUFDbEI7SUFDQTs7Ozs7R0FLQyxHQUNEMnNELFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ1AsS0FBSztJQUNuQjtJQUNBOzs7OztHQUtDLEdBQ0RRLFNBQVM1c0QsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDb3NELEtBQUssR0FBR3BzRDtJQUNmO0lBQ0E7O0dBRUMsR0FDRDZzRCxVQUFVO1FBQ1IsSUFBSSxDQUFDbnpDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQzZtQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNyaEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFVBQVVoTCxLQUFLLEdBQUc7SUFDdEM7SUFDQTs7Ozs7O0dBTUMsR0FDRHM0QixPQUFPeHRCLFFBQVEsRUFBRXpKLFdBQVcsRUFBRXc3QixLQUFLLEVBQUU7UUFDbkMsTUFBTXNSLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU1wZ0MsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTTdPLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU00dEQsVUFBVTV0RCxTQUFTOEwsR0FBRyxDQUFDO1FBQzdCLElBQUksSUFBSSxDQUFDdTFDLE1BQU0sRUFBRTtZQUNmLE1BQU0rTCxXQUFXcHRELFNBQVM4TCxHQUFHLENBQUMsWUFBWWhMLEtBQUs7WUFDL0MrTixPQUFPZy9DLGlCQUFpQixDQUFDZDtZQUN6QkMsR0FBRzFsQyxJQUFJLENBQUN6WSxPQUFPb2dDLFFBQVEsRUFBRW1aLEdBQUcsQ0FBQ25aO1lBQzdCMmUsUUFBUTlzRCxLQUFLLEdBQUdpc0QsR0FBR2UsT0FBTyxDQUFDZCxNQUFNRjtZQUNqQyxJQUFJYyxRQUFROXNELEtBQUssRUFBRTtnQkFDakJkLFNBQVM4TCxHQUFHLENBQUMsa0JBQWtCaEwsS0FBSyxHQUFHK04sT0FBT29nQyxRQUFRLENBQUNDLFVBQVUsQ0FBQ0Q7Z0JBQ2xFOGQsR0FBR3psQyxJQUFJLENBQUMybkIsVUFBVW1XLE9BQU8sQ0FBQ3YyQztnQkFDMUIsSUFBSSxDQUFDeTFDLGNBQWMsQ0FBQ3BnRCxHQUFHLENBQUMsQ0FBQzZvRCxHQUFHL29ELENBQUMsR0FBRyxLQUFLLEtBQUssQ0FBQytvRCxHQUFHOW9ELENBQUMsR0FBRyxLQUFLO1lBQ3pEO1lBQ0EsSUFBSSxDQUFDdVcsSUFBSSxJQUFJbWpCLFFBQVEsSUFBSSxDQUFDdXZCLEtBQUs7WUFDL0IsTUFBTTVtQyxTQUFTLElBQUksQ0FBQzlMLElBQUksR0FBRzR5QztZQUMzQnB0RCxTQUFTOEwsR0FBRyxDQUFDLFVBQVVoTCxLQUFLLEdBQUd3bEI7WUFDL0IsSUFBSUEsVUFBVSxDQUFDdG1CLFNBQVM4TCxHQUFHLENBQUMsYUFBYWhMLEtBQUssR0FBR3NzRCxRQUFPLElBQUssR0FBRztnQkFDOUQsSUFBSSxDQUFDL0wsTUFBTSxHQUFHO2dCQUNkdU0sUUFBUTlzRCxLQUFLLEdBQUc7WUFDbEI7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxzQ0FBc0M7QUFRdkI7QUFDZixJQUFJdXRELHVCQUF1QixjQUFjbGtCO0lBQ3ZDOzs7Ozs7R0FNQyxHQUNEdnFDLFlBQVkycUIsS0FBSyxFQUFFMWIsTUFBTSxFQUFFNHdCLE9BQU8sQ0FBRTtRQUNsQyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDc0ssYUFBYSxDQUFDLElBQUksQ0FBQzNULGFBQWEsS0FBS2h1QixnQkFBZ0JGLEtBQUs7UUFDL0QsSUFBSSxDQUFDMkcsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3E3QyxTQUFTLEdBQUcsSUFBSTEzQixVQUFVakksT0FBTzFiO1FBQ3RDLElBQUksQ0FBQ21pQixTQUFTLEdBQUcsSUFBSXhCLFVBQVUsTUFBTSxPQUFPO1FBQzVDLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQ3RCLGtCQUFrQixHQUFHLElBQUlzK0Isd0NBQU1BLENBQUM7UUFDL0MsSUFBSSxDQUFDdkosYUFBYSxHQUFHLElBQUlub0IsV0FBVyxJQUFJbm5CO1FBQ3hDLE1BQU11dkMsb0JBQW9CLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hEQSxrQkFBa0I5MUMsa0JBQWtCLENBQUNDO1FBQ3JDNjFDLGtCQUFrQmp2QyxZQUFZLEdBQUcsSUFBSSxDQUFDeTBDLFNBQVMsQ0FBQ2orQyxPQUFPO1FBQ3ZEeTRDLGtCQUFrQjd1QyxhQUFhLEdBQUdzNEMsbURBQWlCQTtRQUNuRHpKLGtCQUFrQmh2QyxTQUFTLEdBQUd3NEMsNkNBQVdBO1FBQ3pDLElBQUksQ0FBQ3ZnQixrQkFBa0IsR0FBRyxJQUFJeWdCLG9EQUFtQkEsQ0FBQyxHQUFHLEdBQUc7WUFBRXpnRCxhQUFhO1FBQU07UUFDN0UsSUFBSSxDQUFDZ2dDLGtCQUFrQixDQUFDMWhDLE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUN2QyxJQUFJLENBQUN3eEIsU0FBUyxHQUFHLElBQUltVTtRQUNyQixJQUFJLENBQUNuVSxTQUFTLENBQUNxVSxLQUFLLEdBQUc7UUFDdkIsSUFBSSxDQUFDNG9CLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzNCO0lBQ0EsSUFBSXZqQyxVQUFVbHFCLEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNvcEQsU0FBUyxDQUFDbC9CLFNBQVMsR0FBR2xxQjtJQUM3QjtJQUNBLElBQUltcUIsV0FBV25xQixLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDK04sTUFBTSxHQUFHL047UUFDZCxJQUFJLENBQUNvcEQsU0FBUyxDQUFDai9CLFVBQVUsR0FBR25xQjtRQUM1QixJQUFJLENBQUM0akQsaUJBQWlCLENBQUM5MUMsa0JBQWtCLENBQUM5TjtJQUM1QztJQUNBOzs7OztHQUtDLEdBQ0Q0d0IsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDTCxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJcXpCLG9CQUFvQjtRQUN0QixPQUFPLElBQUksQ0FBQ0QsYUFBYSxDQUFDMTVCLGtCQUFrQjtJQUM5QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJcEssV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDMnRDLFNBQVM7SUFDdkI7SUFDQSxJQUFJM3RDLFNBQVM3ZixLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDd3RELFNBQVMsR0FBR3h0RDtRQUNqQixJQUFJLENBQUM0akQsaUJBQWlCLENBQUNodkMsU0FBUyxHQUFHNVUsUUFBUW10RCxnREFBY0EsR0FBR0MsNkNBQVdBO0lBQ3pFO0lBQ0E7Ozs7O0dBS0MsR0FDRHJ0QyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNGLFFBQVE7SUFDdEI7SUFDQTs7Ozs7R0FLQyxHQUNERyxZQUFZaGdCLEtBQUssRUFBRTtRQUNqQixJQUFJLENBQUM2ZixRQUFRLEdBQUc3ZjtJQUNsQjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJcXdCLG1CQUFtQjtRQUNyQixPQUFPLElBQUksQ0FBQ285QixpQkFBaUI7SUFDL0I7SUFDQSxJQUFJcDlCLGlCQUFpQnJ3QixLQUFLLEVBQUU7UUFDMUIsSUFBSSxDQUFDeXRELGlCQUFpQixHQUFHenREO1FBQ3pCLElBQUksQ0FBQzRqRCxpQkFBaUIsQ0FBQzN1QyxnQkFBZ0IsR0FBR2pWLFFBQVErRyxrQkFBa0JHLGlCQUFpQixHQUFHSCxrQkFBa0JFLGNBQWM7SUFDMUg7SUFDQTs7Ozs7R0FLQyxHQUNENnBCLHVCQUF1QjtRQUNyQixPQUFPLElBQUksQ0FBQ1QsZ0JBQWdCO0lBQzlCO0lBQ0E7Ozs7O0dBS0MsR0FDRFUsc0JBQXNCL3dCLEtBQUssRUFBRTtRQUMzQixJQUFJLENBQUNxd0IsZ0JBQWdCLEdBQUdyd0I7SUFDMUI7SUFDQTs7Ozs7R0FLQyxHQUNENHFCLGdCQUFnQnpaLFlBQVksRUFBRXpELGVBQWV1L0Msb0RBQW1CLEVBQUU7UUFDaEUsSUFBSSxDQUFDckosaUJBQWlCLENBQUNsdkMsWUFBWSxHQUFHdkQ7UUFDdEMsSUFBSSxDQUFDeXlDLGlCQUFpQixDQUFDL3VDLGFBQWEsR0FBR25IO0lBQ3pDO0lBQ0E7Ozs7OztHQU1DLEdBQ0Q0cUIsT0FBT3h0QixRQUFRLEVBQUV6SixXQUFXLEVBQUUvQixTQUFTLEVBQUU7UUFDdkMsTUFBTXlPLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU13aUIsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDaEMsTUFBTTFRLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLElBQUk0TCxlQUFlcHFCO1FBQ25CLElBQUksSUFBSSxDQUFDZ3ZCLGdCQUFnQixJQUFJLENBQUN4USxZQUFZMFEsVUFBVW1OLElBQUksR0FBRyxHQUFHO1lBQzVELE1BQU12TSxPQUFPcGpCLE9BQU9xakIsTUFBTSxDQUFDRCxJQUFJO1lBQy9CcGpCLE9BQU9xakIsTUFBTSxDQUFDaHVCLEdBQUcsQ0FBQ210QixVQUFVcVUsS0FBSztZQUNqQyxJQUFJLENBQUN3a0IsU0FBUyxDQUFDditCLE1BQU0sQ0FBQy9mO1lBQ3RCaUQsT0FBT3FqQixNQUFNLENBQUNELElBQUksR0FBR0E7WUFDckIxRixlQUFlLElBQUksQ0FBQ29oQixrQkFBa0I7WUFDdEMsSUFBSSxDQUFDM2MsU0FBUyxDQUFDckYsTUFBTSxDQUFDL2YsVUFBVTJnQjtZQUNoQyxJQUFJLENBQUNrNEIsYUFBYSxDQUFDOTRCLE1BQU0sQ0FBQy9mLFVBQVV6SixhQUFhb3FCO1FBQ25EO1FBQ0EsS0FBSyxDQUFDNk0sT0FBT3h0QixVQUFVMmdCLGNBQWNuc0I7SUFDdkM7SUFDQTs7Ozs7R0FLQyxHQUNEK0QsUUFBUUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDckIsS0FBSyxDQUFDRixRQUFRQyxPQUFPQztRQUNyQixJQUFJLENBQUNzcEMsa0JBQWtCLENBQUN4cEMsT0FBTyxDQUFDQyxPQUFPQztRQUN2QyxJQUFJLENBQUM2bEQsU0FBUyxDQUFDL2xELE9BQU8sQ0FBQ0MsT0FBT0M7SUFDaEM7SUFDQTs7Ozs7O0dBTUMsR0FDRHluQixXQUFXbGdCLFFBQVEsRUFBRW1nQixLQUFLLEVBQUVDLGVBQWUsRUFBRTtRQUMzQyxLQUFLLENBQUNGLFdBQVdsZ0IsVUFBVW1nQixPQUFPQztRQUNsQyxJQUFJLENBQUNnRixTQUFTLENBQUNsRixVQUFVLENBQUNsZ0IsVUFBVW1nQixPQUFPQztRQUMzQyxJQUFJLENBQUNrK0IsU0FBUyxDQUFDcCtCLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO1FBQzNDLElBQUksQ0FBQ3k0QixhQUFhLENBQUMzNEIsVUFBVSxDQUFDbGdCLFVBQVVtZ0IsT0FBT0M7UUFDL0MsSUFBSXBnQixTQUFTa2pCLFlBQVksQ0FBQ3FnQixzQkFBc0IsRUFBRTtZQUNoRCxJQUFJLENBQUNzVixhQUFhLENBQUMxNUIsa0JBQWtCLENBQUNqckIsT0FBTyxDQUFDc3ZDLFNBQVMsR0FBRztRQUM1RDtRQUNBLElBQUlwakIsb0JBQW9CLEtBQUssR0FBRztZQUM5QixJQUFJLENBQUMyaEIsa0JBQWtCLENBQUMxaEMsT0FBTyxDQUFDb1UsSUFBSSxHQUFHMkw7WUFDdkMsSUFBSXJnQixvQkFBb0JDLGNBQWNyRSxnQkFBZ0I7Z0JBQ3BEeUUscUJBQXFCLElBQUksQ0FBQzJoQyxrQkFBa0IsQ0FBQzFoQyxPQUFPLEVBQUUxRTtZQUN4RDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLDZCQUE2QjtBQUNxQztBQUVsRSw4QkFBOEI7QUFDOUIsSUFBSW1uRCxnQkFBZ0I7QUFFcEIsNkJBQTZCO0FBQzdCLElBQUlDLGNBQWMsY0FBY3JsQjtJQUM5Qjs7Ozs7O0dBTUMsR0FDRDFwQyxZQUFZLEVBQUUrM0IsYUFBYSxFQUFFdlMsWUFBWSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNqRCxLQUFLLENBQUMsZUFBZXNwQyxlQUFlO1lBQ2xDLzJCO1lBQ0EzM0IsVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFZLElBQUkraUQsMENBQVNBLENBQUMsSUFBSUMsMENBQVFBLENBQUMsT0FBTyxPQUFPO2lCQUFRO2dCQUM5RDtvQkFBQztvQkFBWSxJQUFJRCwwQ0FBU0EsQ0FBQyxJQUFJQywwQ0FBUUEsQ0FBQyxPQUFPLE9BQU87aUJBQVE7Z0JBQzlEO29CQUFDO29CQUFZLElBQUlELDBDQUFTQSxDQUFDLElBQUlDLDBDQUFRQSxDQUFDLE9BQU8sT0FBTztpQkFBUTthQUMvRDtRQUNIO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUlycEMsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDcVMsU0FBUyxDQUFDbm1CLE9BQU8sQ0FBQ3hRLEtBQUs7SUFDckM7SUFDQSxJQUFJc2tCLFVBQVV0a0IsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQzIyQixTQUFTLENBQUNubUIsT0FBTyxDQUFDeFEsS0FBSyxHQUFHQTtJQUNqQztJQUNBOzs7OztHQUtDLEdBQ0Qra0IsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDVCxTQUFTO0lBQ3ZCO0lBQ0E7Ozs7O0dBS0MsR0FDRFUsYUFBYWhsQixLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDc2tCLFNBQVMsR0FBR3RrQjtJQUNuQjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJOHRELFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQzV1RCxRQUFRLENBQUM4TCxHQUFHLENBQUMsWUFBWWhMLEtBQUs7SUFDNUM7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSSt0RCxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUM3dUQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFlBQVloTCxLQUFLO0lBQzVDO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlndUQsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDOXVELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxZQUFZaEwsS0FBSztJQUM1QztBQUNGO0FBRUEsNEJBQTRCO0FBVWI7QUFFZiwwQ0FBMEM7QUFDMUMsSUFBSXl1RCw2QkFBNkI7QUFFakMsd0NBQXdDO0FBQ3hDLElBQUlDLDJCQUEyQjtBQUUvQiw2QkFBNkI7QUFDN0IsSUFBSUMsZUFBZTtBQUVuQiw2QkFBNkI7QUFDN0IsSUFBSUMsZ0JBQWdCO0FBRXBCLDRCQUE0QjtBQUM1QixJQUFJQyxhQUFhLGNBQWNybUI7SUFDN0I7Ozs7Ozs7O0dBUUMsR0FDRDFwQyxZQUFZLEVBQ1YrM0IsZ0JBQWdCN3lCLGNBQWNpQyxHQUFHLEVBQ2pDNm9ELFNBQVMzbEQsV0FBV1osTUFBTSxFQUMxQjZPLG9CQUFvQmpRLGtCQUFrQjdDLEtBQUssRUFDM0N3VCxrQkFBa0I3TyxnQkFBZ0JqQixRQUFRLEVBQzNDLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsY0FBYzJtRCxjQUFjO1lBQ2hDNXVELGNBQWM2dUQ7WUFDZC8zQjtZQUNBeEIsWUFBWS90QixnQkFBZ0JFLFdBQVcsR0FBR0YsZ0JBQWdCRixLQUFLO1lBQy9EbEksVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFhLElBQUk0akQsMENBQVNBLENBQUM7aUJBQU07YUFDbkM7UUFDSDtRQUNBLElBQUk5USxhQUFhQztRQUNqQixJQUFJcVIsVUFBVTcxQixNQUFNLEdBQUcsR0FBRztZQUN4QnVrQixjQUFjc1IsU0FBUyxDQUFDLEVBQUU7WUFDMUJyUixZQUFZcVIsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSUEsVUFBVTcxQixNQUFNLEdBQUcsR0FBRztnQkFDeEI0MUIsU0FBU0MsU0FBUyxDQUFDLEVBQUU7WUFDdkI7WUFDQSxJQUFJQSxVQUFVNzFCLE1BQU0sR0FBRyxHQUFHO2dCQUN4QjloQixvQkFBb0IyM0MsU0FBUyxDQUFDLEVBQUU7WUFDbEM7UUFDRjtRQUNBLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSVIsb0RBQW1CQSxDQUFDLEdBQUcsR0FBRztZQUFFM2hELGFBQWE7UUFBTTtRQUM1RSxJQUFJLENBQUNtaUQsaUJBQWlCLENBQUM3akQsT0FBTyxDQUFDcE0sSUFBSSxHQUFHO1FBQ3RDLElBQUksQ0FBQ2t3RCxtQkFBbUIsR0FBRyxJQUFJLENBQUNELGlCQUFpQixDQUFDemlDLEtBQUs7UUFDdkQsSUFBSSxDQUFDMGlDLG1CQUFtQixDQUFDOWpELE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUN4QyxJQUFJLENBQUNHLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxhQUFhaEwsS0FBSyxHQUFHLElBQUksQ0FBQ2l2RCxtQkFBbUIsQ0FBQzlqRCxPQUFPO1FBQ3ZFLElBQUksQ0FBQytrQixTQUFTLEdBQUcsSUFBSXhCLFVBQVUsTUFBTSxPQUFPO1FBQzVDLElBQUksQ0FBQ3dCLFNBQVMsQ0FBQ3RCLGtCQUFrQixHQUFHLElBQUlzL0Isd0NBQU1BLENBQUM7UUFDL0MsSUFBSSxDQUFDaCtCLFNBQVMsQ0FBQ3JCLGtCQUFrQixHQUFHO1FBQ3BDLElBQUksQ0FBQ3FnQyxpQkFBaUIsR0FBRyxJQUFJMXpCLFdBQVcsSUFBSTlrQjtRQUM1QyxJQUFJLENBQUN5NEMscUJBQXFCLENBQUMvM0MsaUJBQWlCLEdBQUdBO1FBQy9DLElBQUksQ0FBQyszQyxxQkFBcUIsQ0FBQ3IzQyxlQUFlLEdBQUdBO1FBQzdDLElBQUksQ0FBQ3MzQyxXQUFXLEdBQUcsSUFBSTV6QixXQUFXLElBQUl4YTtRQUN0QyxNQUFNcXVDLGlCQUFpQixJQUFJakIsaURBQWVBO1FBQzFDaUIsZUFBZTFSLE1BQU0sR0FBRztZQUN0QixNQUFNOTdCLGdCQUFnQixJQUFJeXNDLDBDQUFRQSxDQUFDN1E7WUFDbkM1N0IsY0FBYzlpQixJQUFJLEdBQUc7WUFDckI4aUIsY0FBYytKLFNBQVMsR0FBR3lpQyxnREFBY0E7WUFDeEN4c0MsY0FBYzhKLFNBQVMsR0FBRzBpQyxnREFBY0E7WUFDeEN4c0MsY0FBY3VRLGVBQWUsR0FBRztZQUNoQ3ZRLGNBQWN4aEIsV0FBVyxHQUFHO1lBQzVCd2hCLGNBQWN5dEMsS0FBSyxHQUFHO1lBQ3RCLElBQUksQ0FBQ0MsZUFBZSxDQUFDMXRDLGFBQWEsR0FBR0E7WUFDckMsTUFBTUMsY0FBYyxJQUFJd3NDLDBDQUFRQSxDQUFDNVE7WUFDakM1N0IsWUFBWS9pQixJQUFJLEdBQUc7WUFDbkIraUIsWUFBWThKLFNBQVMsR0FBR3VpQywrQ0FBYUE7WUFDckNyc0MsWUFBWTZKLFNBQVMsR0FBR3dpQywrQ0FBYUE7WUFDckNyc0MsWUFBWXNRLGVBQWUsR0FBRztZQUM5QnRRLFlBQVl6aEIsV0FBVyxHQUFHO1lBQzFCeWhCLFlBQVl3dEMsS0FBSyxHQUFHO1lBQ3BCLElBQUksQ0FBQ0MsZUFBZSxDQUFDenRDLFdBQVcsR0FBR0E7WUFDbkMsSUFBSSxDQUFDa2lCLGFBQWEsQ0FBQztnQkFBRXprQixNQUFNO1lBQU87UUFDcEM7UUFDQTh2QyxlQUFldFIsU0FBUyxDQUFDO1FBQ3pCc1IsZUFBZXRSLFNBQVMsQ0FBQztRQUN6QixJQUFJTixnQkFBZ0IsS0FBSyxLQUFLQyxjQUFjLEtBQUssR0FBRztZQUNsRDJSLGVBQWV2UixPQUFPLENBQUM7WUFDdkJ1UixlQUFldlIsT0FBTyxDQUFDO1FBQ3pCLE9BQU8sSUFBSSxPQUFPcE4sVUFBVSxhQUFhO1lBQ3ZDK00sY0FBYyxJQUFJL007WUFDbEJnTixZQUFZLElBQUloTjtZQUNoQitNLFlBQVlsd0IsZ0JBQWdCLENBQUMsUUFBUSxJQUFNOGhDLGVBQWV2UixPQUFPLENBQUM7WUFDbEVKLFVBQVVud0IsZ0JBQWdCLENBQUMsUUFBUSxJQUFNOGhDLGVBQWV2UixPQUFPLENBQUM7WUFDaEVMLFlBQVlseUMsR0FBRyxHQUFHa2pEO1lBQ2xCL1EsVUFBVW55QyxHQUFHLEdBQUdtakQ7UUFDbEI7UUFDQSxJQUFJLENBQUNjLFdBQVcsQ0FBQ1Y7SUFDbkI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSVcsZUFBZTtRQUNqQixPQUFPLElBQUksQ0FBQ1QsaUJBQWlCLENBQUM3akQsT0FBTztJQUN2QztJQUNBOzs7OztHQUtDLEdBQ0R1a0Qsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDRCxZQUFZO0lBQzFCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlFLGlCQUFpQjtRQUNuQixPQUFPLElBQUksQ0FBQ1YsbUJBQW1CLENBQUM5akQsT0FBTztJQUN6QztJQUNBOzs7OztHQUtDLEdBQ0R5a0Qsb0JBQW9CO1FBQ2xCLE9BQU8sSUFBSSxDQUFDRCxjQUFjO0lBQzVCO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlSLHdCQUF3QjtRQUMxQixPQUFPLElBQUksQ0FBQ0QsaUJBQWlCLENBQUNqbEMsa0JBQWtCO0lBQ2xEO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJNGxDLHFCQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQ1YscUJBQXFCO0lBQ25DO0lBQ0E7Ozs7O0dBS0MsR0FDRFcsMkJBQTJCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDWCxxQkFBcUI7SUFDbkM7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSUksa0JBQWtCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDSCxXQUFXLENBQUNubEMsa0JBQWtCO0lBQzVDO0lBQ0E7Ozs7O0dBS0MsR0FDRDhsQyxxQkFBcUI7UUFDbkIsT0FBTyxJQUFJLENBQUNSLGVBQWU7SUFDN0I7SUFDQTs7Ozs7OztHQU9DLEdBQ0QxM0MsMEJBQTBCaEssU0FBUyxFQUFFO1FBQ25DLElBQUksQ0FBQ3NoRCxxQkFBcUIsQ0FBQ3gzQyxzQkFBc0IsR0FBRzlKO0lBQ3REO0lBQ0E7Ozs7Ozs7R0FPQyxHQUNEc1UseUJBQXlCakgsS0FBSyxFQUFFO1FBQzlCLElBQUksQ0FBQ3EwQyxlQUFlLENBQUNydEMscUJBQXFCLEdBQUdoSDtJQUMvQztJQUNBOzs7O0dBSUMsR0FDRHMwQyxZQUFZVixNQUFNLEVBQUU7UUFDbEIsTUFBTUssd0JBQXdCLElBQUksQ0FBQ0EscUJBQXFCO1FBQ3hELE1BQU1JLGtCQUFrQixJQUFJLENBQUNBLGVBQWU7UUFDNUMsT0FBUVQ7WUFDTixLQUFLM2xELFdBQVdDLEdBQUc7Z0JBQ2pCK2xELHNCQUFzQngzQyxzQkFBc0IsR0FBRztnQkFDL0M0M0MsZ0JBQWdCcnRDLHFCQUFxQixHQUFHO2dCQUN4Q3F0QyxnQkFBZ0JqdEMsaUJBQWlCLEdBQUc7Z0JBQ3BDaXRDLGdCQUFnQjNzQyxlQUFlLEdBQUc7Z0JBQ2xDO1lBQ0YsS0FBS3paLFdBQVdaLE1BQU07Z0JBQ3BCNG1ELHNCQUFzQngzQyxzQkFBc0IsR0FBRztnQkFDL0M0M0MsZ0JBQWdCcnRDLHFCQUFxQixHQUFHO2dCQUN4Q3F0QyxnQkFBZ0JqdEMsaUJBQWlCLEdBQUc7Z0JBQ3BDaXRDLGdCQUFnQjNzQyxlQUFlLEdBQUc7Z0JBQ2xDO1lBQ0YsS0FBS3paLFdBQVdFLElBQUk7Z0JBQ2xCOGxELHNCQUFzQngzQyxzQkFBc0IsR0FBRztnQkFDL0M0M0MsZ0JBQWdCcnRDLHFCQUFxQixHQUFHO2dCQUN4Q3F0QyxnQkFBZ0JudEMsbUJBQW1CLEdBQUc7Z0JBQ3RDbXRDLGdCQUFnQjdzQyxjQUFjLEdBQUc7Z0JBQ2pDNnNDLGdCQUFnQmp0QyxpQkFBaUIsR0FBRztnQkFDcENpdEMsZ0JBQWdCM3NDLGVBQWUsR0FBRztnQkFDbEM7WUFDRixLQUFLelosV0FBV0csS0FBSztnQkFDbkI2bEQsc0JBQXNCeDNDLHNCQUFzQixHQUFHO2dCQUMvQzQzQyxnQkFBZ0JydEMscUJBQXFCLEdBQUc7Z0JBQ3hDcXRDLGdCQUFnQm50QyxtQkFBbUIsR0FBRztnQkFDdENtdEMsZ0JBQWdCN3NDLGNBQWMsR0FBRztnQkFDakM2c0MsZ0JBQWdCanRDLGlCQUFpQixHQUFHO2dCQUNwQ2l0QyxnQkFBZ0Izc0MsZUFBZSxHQUFHO2dCQUNsQztRQUNKO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUNEZ0ksZ0JBQWdCelosWUFBWSxFQUFFekQsZUFBZXVnRCxvREFBbUIsRUFBRTtRQUNoRSxJQUFJLENBQUNrQixxQkFBcUIsQ0FBQ3RpRCxXQUFXLEdBQUdzRTtRQUN6QyxJQUFJLENBQUNnK0MscUJBQXFCLENBQUN6aEQsWUFBWSxHQUFHQTtJQUM1QztJQUNBOzs7Ozs7R0FNQyxHQUNENHFCLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLElBQUksQ0FBQzR3QixTQUFTLENBQUNyRixNQUFNLENBQUMvZixVQUFVLElBQUksQ0FBQ2trRCxpQkFBaUI7UUFDdEQsSUFBSSxDQUFDRSxpQkFBaUIsQ0FBQ3JrQyxNQUFNLENBQUMvZixVQUFVekosYUFBYSxJQUFJLENBQUMydEQsaUJBQWlCO1FBQzNFLElBQUksQ0FBQ0ksV0FBVyxDQUFDdmtDLE1BQU0sQ0FBQy9mLFVBQVUsSUFBSSxDQUFDa2tELGlCQUFpQixFQUFFLElBQUksQ0FBQ0MsbUJBQW1CO0lBQ3BGO0lBQ0E7Ozs7O0dBS0MsR0FDRDVyRCxRQUFRQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtRQUNyQixJQUFJLENBQUM0ckQscUJBQXFCLENBQUM5ckQsT0FBTyxDQUFDQyxPQUFPQztRQUMxQyxJQUFJLENBQUNnc0QsZUFBZSxDQUFDbHNELE9BQU8sQ0FBQ0MsT0FBT0M7UUFDcEMsSUFBSSxDQUFDeXJELGlCQUFpQixDQUFDM3JELE9BQU8sQ0FBQ0MsT0FBT0M7UUFDdEMsSUFBSSxDQUFDMHJELG1CQUFtQixDQUFDNXJELE9BQU8sQ0FBQ0MsT0FBT0M7SUFDMUM7SUFDQTs7R0FFQyxHQUNEOUYsVUFBVTtRQUNSLE1BQU0sRUFBRW9rQixhQUFhLEVBQUVDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQ3l0QyxlQUFlO1FBQzNELElBQUkxdEMsa0JBQWtCLFFBQVFDLGdCQUFnQixNQUFNO1lBQ2xERCxjQUFjcGtCLE9BQU87WUFDckJxa0IsWUFBWXJrQixPQUFPO1FBQ3JCO1FBQ0EsS0FBSyxDQUFDQTtJQUNSO0lBQ0E7Ozs7O0dBS0MsR0FDRCxXQUFXdXlELHFCQUFxQjtRQUM5QixPQUFPdkI7SUFDVDtJQUNBOzs7OztHQUtDLEdBQ0QsV0FBV3dCLG1CQUFtQjtRQUM1QixPQUFPdkI7SUFDVDtBQUNGO0FBRUEsNEJBQTRCO0FBQ29MO0FBRWhOLDZCQUE2QjtBQUM3QixJQUFJOEIsZ0JBQWdCO0FBRXBCLDRCQUE0QjtBQUM1QixJQUFJQyxxQkFBcUI7QUFDekIsSUFBSUMsYUFBYSxjQUFjbG9CO0lBQzdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQ0MsR0FDRDFwQyxZQUFZaVAsTUFBTSxFQUFFb0YsWUFBWSxFQUFFLEVBQ2hDMGpCLGdCQUFnQjd5QixjQUFjd0IsUUFBUSxFQUN0QzJYLFVBQVUsQ0FBQyxFQUNYd0gsUUFBUSxDQUFDLEVBQ1Q3WCxvQkFBb0IsSUFBSSxFQUN4QjZqRCx1QkFBdUIsSUFBSSxFQUMzQi9pRCxzQkFBc0IsRUFDdEJvWSxvQkFBb0IsRUFDcEJLLHVCQUF1QixFQUN2QkMscUJBQXFCLEVBQ3JCUixvQkFBb0IsSUFBSSxFQUN4QkMsa0JBQWtCLElBQUksRUFDdEI2cUMsaUJBQWlCLElBQUksRUFDckJDLGVBQWUsSUFBSSxFQUNuQnhzQyxpQkFBaUIsR0FBRyxFQUNwQnlzQyxxQkFBcUIsR0FBRyxFQUN4QnRyQyxTQUFTLE1BQU0sRUFDZmxCLFlBQVksQ0FBQyxFQUNiRSxPQUFPLEtBQUssRUFDWkQsT0FBTyxJQUFJLEVBQ1hrSyxPQUFPRSxTQUFTLElBQUksRUFDcEI3QixrQkFBa0IsQ0FBQyxFQUNuQnhwQixRQUFRMHBCLFdBQVdDLFNBQVMsRUFDNUIxcEIsU0FBU3lwQixXQUFXQyxTQUFTLEVBQzdCRixjQUFjenBCLEtBQUssRUFDbkI0cEIsY0FBYzNwQixNQUFNLEVBQ3JCLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMsY0FBY2l0RCxlQUFlO1lBQ2pDMzVCO1lBQ0F4QixZQUFZL3RCLGdCQUFnQkYsS0FBSztZQUNqQ3BJLFNBQVMsYUFBYSxHQUFHLElBQUkyTCxJQUFJO2dCQUMvQjtvQkFBQztvQkFBYTtpQkFBUTthQUN2QjtZQUNEekwsVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFZLElBQUkybEQsMENBQVNBLENBQUM7aUJBQU07Z0JBQ2pDO29CQUFDO29CQUFxQixJQUFJQSwwQ0FBU0EsQ0FBQ3hqRDtpQkFBbUI7Z0JBQ3ZEO29CQUFDO29CQUFzQixJQUFJd2pELDBDQUFTQSxDQUFDUTtpQkFBb0I7Z0JBQ3pEO29CQUFDO29CQUFTLElBQUlSLDBDQUFTQSxDQUFDO2lCQUFNO2dCQUM5QjtvQkFBQztvQkFBYSxJQUFJQSwwQ0FBU0EsQ0FBQ2hzQztpQkFBVztnQkFDdkM7b0JBQUM7b0JBQVMsSUFBSWdzQywwQ0FBU0EsQ0FBQztpQkFBRzthQUU1QjtRQUNIO1FBQ0EsSUFBSSxDQUFDN2tDLFlBQVksR0FBRyxJQUFJOGtDLG9EQUFtQkEsQ0FBQyxHQUFHLEdBQUc7WUFBRTFqRCxhQUFhO1FBQU07UUFDdkUsSUFBSSxDQUFDNGUsWUFBWSxDQUFDdGdCLE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUNqQyxJQUFJLENBQUNHLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxZQUFZaEwsS0FBSyxHQUFHLElBQUksQ0FBQ3lyQixZQUFZLENBQUN0Z0IsT0FBTztRQUMvRCxNQUFNcU8sYUFBYSxJQUFJLENBQUNBLFVBQVUsR0FBRyxJQUFJd1QsV0FBVyxJQUFJLEVBQUVELGFBQWFHLGFBQWFKO1FBQ3BGdFQsV0FBVytULGdCQUFnQixDQUFDLFVBQVUsQ0FBQ0MsSUFBTSxJQUFJLENBQUNucUIsT0FBTyxDQUFDbVcsV0FBV2lVLFNBQVMsRUFBRWpVLFdBQVdrVSxVQUFVO1FBQ3JHLElBQUksQ0FBQzNmLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNnakQscUJBQXFCLEdBQUcsSUFBSTUrQixzQkFBc0I7WUFBRWhmO1lBQWMyWjtRQUFnQjtRQUN2RixJQUFJLENBQUNpa0MscUJBQXFCLENBQUNqbkMsT0FBTyxHQUFHaGQsc0JBQXNCO1FBQzNELElBQUksQ0FBQ2trRCxRQUFRLEdBQUcsSUFBSXgxQixXQUFXLElBQUkvWCxhQUFhMVY7UUFDaEQsTUFBTWdXLGVBQWUsSUFBSXU3QixhQUFhbVIsb0JBQW9CQSxvQkFBb0JKLDZDQUFXQTtRQUN6RnRzQyxhQUFheXRCLEtBQUssR0FBR3p0QixhQUFhMHRCLEtBQUssR0FBRzJlLGlEQUFlQTtRQUN6RCxNQUFNYSxlQUFlLElBQUksQ0FBQ0EsWUFBWTtRQUN0Q0EsYUFBYTk5QyxZQUFZLEdBQUdBO1FBQzVCODlDLGFBQWFsdEMsWUFBWSxHQUFHQTtRQUM1Qmt0QyxhQUFhNXNDLGNBQWMsR0FBR0E7UUFDOUI0c0MsYUFBYTl6QyxPQUFPLEdBQUdBO1FBQ3ZCOHpDLGFBQWF6ckMsTUFBTSxHQUFHQTtRQUN0QnlyQyxhQUFhdHNDLEtBQUssR0FBR0E7UUFDckJzc0MsYUFBYTFzQyxJQUFJLEdBQUdBO1FBQ3BCMHNDLGFBQWF6c0MsSUFBSSxHQUFHQTtRQUNwQnlzQyxhQUFhbnJDLGlCQUFpQixHQUFHQTtRQUNqQ21yQyxhQUFhbHJDLGVBQWUsR0FBR0E7UUFDL0JrckMsYUFBYTlxQyxrQkFBa0IsR0FBR3lxQztRQUNsQ0ssYUFBYTdxQyxnQkFBZ0IsR0FBR3lxQztRQUNoQyxJQUFJampELDJCQUEyQixLQUFLLEdBQUc7WUFDckNxakQsYUFBYXJqRCxzQkFBc0IsR0FBR0E7UUFDeEM7UUFDQSxJQUFJb1kseUJBQXlCLEtBQUssR0FBRztZQUNuQ2lyQyxhQUFhanJDLG9CQUFvQixHQUFHQTtRQUN0QztRQUNBLElBQUlLLDRCQUE0QixLQUFLLEdBQUc7WUFDdEM0cUMsYUFBYTVxQyx1QkFBdUIsR0FBR0E7UUFDekM7UUFDQSxJQUFJQywwQkFBMEIsS0FBSyxHQUFHO1lBQ3BDMnFDLGFBQWEzcUMscUJBQXFCLEdBQUdBO1FBQ3ZDO1FBQ0EsSUFBSXhaLHNCQUFzQixNQUFNO1lBQzlCLElBQUksQ0FBQ21rRCxZQUFZLENBQUNua0QsaUJBQWlCLEdBQUdBO1lBQ3RDLElBQUksQ0FBQzlOLE9BQU8sQ0FBQ29FLEdBQUcsQ0FBQyxnQkFBZ0I7UUFDbkM7UUFDQSxJQUFJLENBQUN1dEQsb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ2xpQyxLQUFLLEdBQUdFO0lBQ2Y7SUFDQSxJQUFJeEUsV0FBV25xQixLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDK04sTUFBTSxHQUFHL047UUFDZCxJQUFJLENBQUNpeEQsWUFBWSxDQUFDbmpELGtCQUFrQixDQUFDOU47SUFDdkM7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSW1ULGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUM4OUMsWUFBWSxDQUFDOTlDLFlBQVk7SUFDdkM7SUFDQSxJQUFJQSxhQUFhblQsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQ2l4RCxZQUFZLENBQUM5OUMsWUFBWSxHQUFHblQ7UUFDakMsSUFBSSxDQUFDK3dELHFCQUFxQixDQUFDOW1DLGtCQUFrQixDQUFDOVcsWUFBWSxHQUFHblQ7SUFDL0Q7SUFDQTs7Ozs7R0FLQyxHQUNENHhCLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDcFksVUFBVTtJQUN4QjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJeTNDLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUNELFFBQVEsQ0FBQy9tQyxrQkFBa0I7SUFDekM7SUFDQTs7Ozs7R0FLQyxHQUNEaW5DLGtCQUFrQjtRQUNoQixPQUFPLElBQUksQ0FBQ0QsWUFBWTtJQUMxQjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSTl6QyxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUM4ekMsWUFBWSxDQUFDOXpDLE9BQU87SUFDbEM7SUFDQSxJQUFJQSxRQUFRbmQsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQ2l4RCxZQUFZLENBQUM5ekMsT0FBTyxHQUFHbmQ7SUFDOUI7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUkya0IsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDc3NDLFlBQVksQ0FBQ3RzQyxLQUFLO0lBQ2hDO0lBQ0EsSUFBSUEsTUFBTTNrQixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNpeEQsWUFBWSxDQUFDdHNDLEtBQUssR0FBRzNrQjtJQUM1QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSXdsQixTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUN5ckMsWUFBWSxDQUFDenJDLE1BQU07SUFDakM7SUFDQSxJQUFJQSxPQUFPeGxCLEtBQUssRUFBRTtRQUNoQixJQUFJLENBQUNpeEQsWUFBWSxDQUFDenJDLE1BQU0sR0FBR3hsQjtJQUM3QjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJMndELHVCQUF1QjtRQUN6QixPQUFPLElBQUksQ0FBQzN4RCxPQUFPLENBQUNzbUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsSUFBSXFyQixxQkFBcUIzd0QsS0FBSyxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDMndELG9CQUFvQixLQUFLM3dELE9BQU87WUFDdkMsSUFBSUEsT0FBTztnQkFDVCxJQUFJLENBQUNoQixPQUFPLENBQUNvRSxHQUFHLENBQUMsMEJBQTBCO1lBQzdDLE9BQU87Z0JBQ0wsSUFBSSxDQUFDcEUsT0FBTyxDQUFDdTNCLE1BQU0sQ0FBQztZQUN0QjtZQUNBLElBQUksQ0FBQ2tTLFVBQVU7UUFDakI7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0Qwb0IsZ0NBQWdDO1FBQzlCLE9BQU8sSUFBSSxDQUFDUixvQkFBb0I7SUFDbEM7SUFDQTs7Ozs7R0FLQyxHQUNEUywrQkFBK0JweEQsS0FBSyxFQUFFO1FBQ3BDLElBQUksQ0FBQzJ3RCxvQkFBb0IsR0FBRzN3RDtJQUM5QjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSTJsQixrQkFBa0I7UUFDcEIsT0FBTztJQUNUO0lBQ0EsSUFBSUEsZ0JBQWdCM2xCLEtBQUssRUFBRSxDQUMzQjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJeXVCLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQ3Z2QixRQUFRLENBQUM4TCxHQUFHLENBQUMsU0FBU2hMLEtBQUs7SUFDekM7SUFDQSxJQUFJeXVCLE1BQU16dUIsS0FBSyxFQUFFO1FBQ2YsTUFBTWQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUYsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSWdCLFVBQVUsTUFBTTtZQUNsQixJQUFJaEIsUUFBUXNtQyxHQUFHLENBQUMsYUFBYTtnQkFDM0JwbUMsU0FBUzhMLEdBQUcsQ0FBQyxTQUFTaEwsS0FBSyxDQUFDb0QsR0FBRyxDQUFDcEQ7WUFDbEMsT0FBTztnQkFDTGhCLFFBQVFvRSxHQUFHLENBQUMsWUFBWTtnQkFDeEJsRSxTQUFTOEwsR0FBRyxDQUFDLFNBQVNoTCxLQUFLLEdBQUcsSUFBSW13RCx3Q0FBTUEsQ0FBQ253RDtnQkFDekMsSUFBSSxDQUFDeW9DLFVBQVU7WUFDakI7UUFDRixPQUFPLElBQUl6cEMsUUFBUXNtQyxHQUFHLENBQUMsYUFBYTtZQUNsQ3RtQyxRQUFRdTNCLE1BQU0sQ0FBQztZQUNmcjNCLFNBQVM4TCxHQUFHLENBQUMsU0FBU2hMLEtBQUssR0FBRztZQUM5QixJQUFJLENBQUN5b0MsVUFBVTtRQUNqQjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlxb0IscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDNXhELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxzQkFBc0JoTCxLQUFLO0lBQ3REO0lBQ0EsSUFBSTh3RCxtQkFBbUI5d0QsS0FBSyxFQUFFO1FBQzVCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLHNCQUFzQmhMLEtBQUssR0FBR0E7SUFDbEQ7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSXNrQixZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUNwbEIsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGFBQWFoTCxLQUFLO0lBQzdDO0lBQ0EsSUFBSXNrQixVQUFVdGtCLEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxhQUFhaEwsS0FBSyxHQUFHQTtJQUN6QztJQUNBOzs7OztHQUtDLEdBQ0RxeEQsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDNWlDLEtBQUs7SUFDbkI7SUFDQTs7Ozs7R0FLQyxHQUNENmlDLFNBQVN0eEQsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDeXVCLEtBQUssR0FBR3p1QjtJQUNmO0lBQ0E7Ozs7OztHQU1DLEdBQ0RpbUIsa0JBQWtCcFksU0FBUyxFQUFFcVksT0FBTyxFQUFFO1FBQ3BDLElBQUksQ0FBQytxQyxZQUFZLENBQUNuckMsaUJBQWlCLEdBQUdqWTtRQUN0QyxJQUFJLENBQUNvakQsWUFBWSxDQUFDbHJDLGVBQWUsR0FBR0c7SUFDdEM7SUFDQTs7Ozs7O0dBTUMsR0FDREssbUJBQW1CMVksU0FBUyxFQUFFcVksT0FBTyxFQUFFO1FBQ3JDLElBQUksQ0FBQytxQyxZQUFZLENBQUM5cUMsa0JBQWtCLEdBQUd0WTtRQUN2QyxJQUFJLENBQUNvakQsWUFBWSxDQUFDN3FDLGdCQUFnQixHQUFHRjtJQUN2QztJQUNBOzs7OztHQUtDLEdBQ0QwRSxnQkFBZ0J6WixZQUFZLEVBQUV6RCxlQUFld2lELG9EQUFtQixFQUFFO1FBQ2hFLElBQUksQ0FBQ2EscUJBQXFCLENBQUNubUMsZUFBZSxDQUFDelosY0FBY3pEO1FBQ3pELElBQUksQ0FBQ3VqRCxZQUFZLENBQUNwa0QsV0FBVyxHQUFHc0U7UUFDaEMsSUFBSSxDQUFDOC9DLFlBQVksQ0FBQ3ZqRCxZQUFZLEdBQUdBO0lBQ25DO0lBQ0E7Ozs7OztHQU1DLEdBQ0Q0cUIsT0FBT3h0QixRQUFRLEVBQUV6SixXQUFXLEVBQUUvQixTQUFTLEVBQUU7UUFDdkMsTUFBTW1zQixlQUFlLElBQUksQ0FBQ0EsWUFBWTtRQUN0QyxJQUFJLElBQUksQ0FBQ3NsQyxxQkFBcUIsQ0FBQ2puQyxPQUFPLEVBQUU7WUFDdEMsSUFBSSxDQUFDaW5DLHFCQUFxQixDQUFDbG1DLE1BQU0sQ0FBQy9mO1FBQ3BDO1FBQ0EsSUFBSSxDQUFDa21ELFFBQVEsQ0FBQ25tQyxNQUFNLENBQUMvZixVQUFVLE1BQU0yZ0I7SUFDdkM7SUFDQTs7Ozs7R0FLQyxHQUNEcG9CLFFBQVFDLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3JCLE1BQU1pVyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQ0EsV0FBV3FVLFdBQVcsQ0FBQ3ZxQixPQUFPQztRQUM5QixNQUFNdXFCLElBQUl0VSxXQUFXbFcsS0FBSyxFQUFFeXFCLElBQUl2VSxXQUFXalcsTUFBTTtRQUNqRCxJQUFJLENBQUMwdEQsWUFBWSxDQUFDbmpELGtCQUFrQixDQUFDLElBQUksQ0FBQ0MsTUFBTTtRQUNoRCxJQUFJLENBQUNrakQsWUFBWSxDQUFDNXRELE9BQU8sQ0FBQ3lxQixHQUFHQztRQUM3QixJQUFJLENBQUN0QyxZQUFZLENBQUNwb0IsT0FBTyxDQUFDeXFCLEdBQUdDO1FBQzdCLElBQUksQ0FBQ2dqQyxxQkFBcUIsQ0FBQ3YzQyxVQUFVLENBQUM5WCxLQUFLLEdBQUc4WCxXQUFXOVgsS0FBSztRQUM5RCxJQUFJLENBQUNxdkQscUJBQXFCLENBQUMxdEQsT0FBTyxDQUFDQyxPQUFPQztJQUM1QztJQUNBOzs7Ozs7R0FNQyxHQUNEeW5CLFdBQVdsZ0IsUUFBUSxFQUFFbWdCLEtBQUssRUFBRUMsZUFBZSxFQUFFO1FBQzNDLElBQUk7WUFDRixJQUFJcGUsb0JBQW9CLElBQUksQ0FBQzVOLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxxQkFBcUJoTCxLQUFLO1lBQ3BFLElBQUk4TSxzQkFBc0IsTUFBTTtnQkFDOUIsSUFBSSxDQUFDaWtELHFCQUFxQixDQUFDL2xDLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO2dCQUN2RHBlLG9CQUFvQixJQUFJLENBQUNpa0QscUJBQXFCLENBQUM1bEQsT0FBTztnQkFDdEQsSUFBSSxDQUFDak0sUUFBUSxDQUFDOEwsR0FBRyxDQUFDLHFCQUFxQmhMLEtBQUssR0FBRzhNO2dCQUMvQyxJQUFJLENBQUNta0QsWUFBWSxDQUFDbmtELGlCQUFpQixHQUFHQTtnQkFDdEMsSUFBSSxDQUFDOU4sT0FBTyxDQUFDb0UsR0FBRyxDQUFDLGdCQUFnQjtZQUNuQztRQUNGLEVBQUUsT0FBT29xQixHQUFHO1lBQ1YsSUFBSSxDQUFDdWpDLHFCQUFxQixDQUFDam5DLE9BQU8sR0FBRztRQUN2QztJQUNGO0FBQ0Y7QUFFQSwrQkFBK0I7QUFDc0Q7QUFFckYsZ0NBQWdDO0FBQ2hDLElBQUkybkMsa0JBQWtCO0FBRXRCLGdDQUFnQztBQUNoQyxJQUFJQyxtQkFBbUI7QUFFdkIsK0JBQStCO0FBQy9CLElBQUlDLGdCQUFnQixjQUFjbnBCO0lBQ2hDOzs7Ozs7O0dBT0MsR0FDRDFwQyxZQUFZLEVBQUUrM0IsYUFBYSxFQUFFMXJCLFVBQVUsSUFBSSxFQUFFeW1ELG1CQUFtQixLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUM1RSxLQUFLLENBQUMsaUJBQWlCSCxpQkFBaUI7WUFDdEM1NkI7WUFDQTczQixTQUFTLGFBQWEsR0FBRyxJQUFJMkwsSUFBSTtnQkFDL0I7b0JBQUM7b0JBQVM7aUJBQVE7YUFDbkI7WUFDRHpMLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBTyxJQUFJNG1ELDBDQUFTQSxDQUFDO2lCQUFNO2dCQUM1QjtvQkFBQztvQkFBUyxJQUFJQSwwQ0FBU0EsQ0FBQztpQkFBRztnQkFDM0I7b0JBQUM7b0JBQWUsSUFBSUEsMENBQVNBLENBQUM7aUJBQU07YUFDckM7UUFDSDtRQUNBLElBQUksQ0FBQ3BtRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDeW1ELGdCQUFnQixHQUFHQTtJQUMxQjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJem1ELFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQ2pNLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxPQUFPaEwsS0FBSztJQUN2QztJQUNBLElBQUltTCxRQUFRbkwsS0FBSyxFQUFFO1FBQ2pCLE1BQU02eEQsY0FBYyxJQUFJLENBQUMxbUQsT0FBTztRQUNoQyxNQUFNak0sV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUYsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSTZ5RCxnQkFBZ0I3eEQsT0FBTztZQUN6QmQsU0FBUzhMLEdBQUcsQ0FBQyxPQUFPaEwsS0FBSyxHQUFHQTtZQUM1QmQsU0FBUzhMLEdBQUcsQ0FBQyxlQUFlaEwsS0FBSyxHQUFHQSxNQUFNbWtELE1BQU07WUFDaERubEQsUUFBUXUzQixNQUFNLENBQUM7WUFDZixJQUFJdjJCLFVBQVUsTUFBTTtnQkFDbEIsSUFBSUEsTUFBTWlrRCxnQkFBZ0IsRUFBRTtvQkFDMUJqbEQsUUFBUW9FLEdBQUcsQ0FBQyxnQkFBZ0I7b0JBQzVCLElBQUksQ0FBQytsQyxlQUFlLENBQUN1b0I7Z0JBQ3ZCLE9BQU87b0JBQ0wxeUQsUUFBUXUzQixNQUFNLENBQUM7b0JBQ2YsSUFBSSxDQUFDNFMsZUFBZSxDQUFDO2dCQUN2QjtnQkFDQSxJQUFJbnBDLE1BQU11ZixJQUFJLEtBQUtpeUMsbURBQWtCQSxFQUFFO29CQUNyQ3h5RCxRQUFRb0UsR0FBRyxDQUFDLDBCQUEwQjtnQkFDeEM7Z0JBQ0EsSUFBSXl1RCxnQkFBZ0IsUUFBUUEsWUFBWXR5QyxJQUFJLEtBQUt2ZixNQUFNdWYsSUFBSSxJQUFJc3lDLFlBQVl4bUQsUUFBUSxLQUFLckwsTUFBTXFMLFFBQVEsRUFBRTtvQkFDdEcsSUFBSSxDQUFDbzlCLFVBQVU7Z0JBQ2pCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FDRDFjLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQzVnQixPQUFPO0lBQ3JCO0lBQ0E7Ozs7O0dBS0MsR0FDRDJtRCxXQUFXOXhELEtBQUssRUFBRTtRQUNoQixJQUFJLENBQUNtTCxPQUFPLEdBQUduTDtJQUNqQjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSTR4RCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUM1eUQsT0FBTyxDQUFDc21DLEdBQUcsQ0FBQztJQUMxQjtJQUNBLElBQUlzc0IsaUJBQWlCNXhELEtBQUssRUFBRTtRQUMxQixJQUFJLElBQUksQ0FBQzR4RCxnQkFBZ0IsS0FBSzV4RCxPQUFPO1lBQ25DLElBQUlBLE9BQU87Z0JBQ1QsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLHFCQUFxQjtZQUN4QyxPQUFPO2dCQUNMLElBQUksQ0FBQ3BFLE9BQU8sQ0FBQ3UzQixNQUFNLENBQUM7WUFDdEI7WUFDQSxJQUFJLENBQUNrUyxVQUFVO1FBQ2pCO0lBQ0Y7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUlzcEIsY0FBYztRQUNoQixNQUFNNW1ELFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLE9BQU9BLFlBQVksUUFBUUEsUUFBUTg0QyxnQkFBZ0I7SUFDckQ7SUFDQSxJQUFJOE4sWUFBWS94RCxLQUFLLEVBQUU7UUFDckIsTUFBTW1MLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLElBQUlBLFlBQVksTUFBTTtZQUNwQkEsUUFBUTg0QyxnQkFBZ0IsR0FBR2prRDtRQUM3QjtJQUNGO0lBQ0E7Ozs7Ozs7R0FPQyxHQUNEZ3lELHNCQUFzQnB2RCxDQUFDLEVBQUU0d0MsSUFBSTV3QyxDQUFDLEVBQUVnbEIsSUFBSWhsQixDQUFDLEVBQUUra0IsSUFBSS9rQixDQUFDLEVBQUU7UUFDNUMsTUFBTXF2RCxPQUFPO1FBQ2IsSUFBSUMsVUFBVTtRQUNkLElBQUl0dkQsTUFBTXdELGFBQWFDLEdBQUcsSUFBSW10QyxNQUFNcHRDLGFBQWFFLEtBQUssSUFBSXNoQixNQUFNeGhCLGFBQWFHLElBQUksSUFBSW9oQixNQUFNdmhCLGFBQWFoQyxLQUFLLEVBQUU7WUFDN0c4dEQsVUFBVTtnQkFBQztnQkFBS0QsSUFBSSxDQUFDcnZELEVBQUU7Z0JBQUVxdkQsSUFBSSxDQUFDemUsRUFBRTtnQkFBRXllLElBQUksQ0FBQ3JxQyxFQUFFO2dCQUFFcXFDLElBQUksQ0FBQ3RxQyxFQUFFO2FBQUMsQ0FBQ3dxQyxJQUFJLENBQUM7UUFDM0Q7UUFDQSxJQUFJLENBQUNuekQsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLFNBQVMsVUFBVTh1RDtRQUNwQyxJQUFJLENBQUN6cEIsVUFBVTtJQUNqQjtJQUNBOzs7Ozs7R0FNQyxHQUNEblEsT0FBT3h0QixRQUFRLEVBQUV6SixXQUFXLEVBQUUvQixTQUFTLEVBQUU7UUFDdkMsSUFBSSxJQUFJLENBQUM2TCxPQUFPLENBQUM4NEMsZ0JBQWdCLEVBQUU7WUFDakMsSUFBSSxDQUFDOTRDLE9BQU8sQ0FBQ2luRCxZQUFZO1FBQzNCO0lBQ0Y7QUFDRjtBQUVBLGlDQUFpQztBQUM0RTtBQUU3RyxtQ0FBbUM7QUFDbkMsSUFBSUkscUJBQXFCO0FBRXpCLG1DQUFtQztBQUNuQyxJQUFJQyxzQkFBc0I7QUFFMUIsaUNBQWlDO0FBQ2pDLElBQUlDLGtCQUFrQixjQUFjbHFCO0lBQ2xDOzs7Ozs7Ozs7Ozs7OztHQWNDLEdBQ0QxcEMsWUFBWSxFQUNWKzNCLGFBQWEsRUFDYjVQLFNBQVMsQ0FBQyxFQUNWQyxXQUFXLENBQUMsRUFDWkMsWUFBWSxHQUFHLEVBQ2ZDLFVBQVUsR0FBRyxFQUNiMWEsYUFBYXRFLFdBQVdHLE1BQU0sRUFDOUJ1a0Isa0JBQWtCLEdBQUcsRUFDckJDLGNBQWNDLFdBQVdDLFNBQVMsRUFDbENDLGNBQWNGLFdBQVdDLFNBQVMsRUFDbkMsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNOLEtBQUssQ0FBQyxtQkFBbUJ1bEMsb0JBQW9CO1lBQzNDenlELGNBQWMweUQ7WUFDZDU3QjtZQUNBMzNCLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBWSxJQUFJMG5ELDBDQUFTQSxDQUFDLElBQUlDLDBDQUFTQTtpQkFBSTtnQkFDNUM7b0JBQUM7b0JBQWMsSUFBSUQsMENBQVNBLENBQUMsSUFBSUMsMENBQVNBO2lCQUFJO2dCQUM5QztvQkFBQztvQkFBTyxJQUFJRCwwQ0FBU0EsQ0FBQztpQkFBTTthQUM3QjtRQUNIO1FBQ0EsSUFBSSxDQUFDL3FDLE9BQU8sR0FBR0w7UUFDZixJQUFJLENBQUNNLFVBQVUsR0FBR0o7UUFDbEIsSUFBSSxDQUFDSyxRQUFRLEdBQUdKO1FBQ2hCLElBQUksQ0FBQ3FFLFlBQVksR0FBRyxJQUFJOG1DLG9EQUFtQkEsQ0FBQyxHQUFHLEdBQUc7WUFBRTFsRCxhQUFhO1FBQU07UUFDdkUsSUFBSSxDQUFDNGUsWUFBWSxDQUFDdGdCLE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUNqQyxJQUFJLENBQUNHLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxPQUFPaEwsS0FBSyxHQUFHLElBQUksQ0FBQ3lyQixZQUFZLENBQUN0Z0IsT0FBTztRQUMxRCxJQUFJLENBQUNzK0IsUUFBUSxHQUFHLElBQUk5TixrQkFBa0I7WUFDcENqdkI7WUFDQW9nQjtZQUNBQztZQUNBRztZQUNBakc7WUFDQUM7WUFDQUM7WUFDQUM7UUFDRjtRQUNBLE1BQU01TixhQUFhLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUl3VCxXQUFXLElBQUksRUFBRUQsYUFBYUcsYUFBYUo7UUFDcEZ0VCxXQUFXK1QsZ0JBQWdCLENBQUMsVUFBVSxDQUFDQyxJQUFNLElBQUksQ0FBQ25xQixPQUFPLENBQUNtVyxXQUFXaVUsU0FBUyxFQUFFalUsV0FBV2tVLFVBQVU7UUFDckcsSUFBSSxDQUFDeEcsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNPLFlBQVk7SUFDbkI7SUFDQTs7OztHQUlDLEdBQ0RBLGVBQWU7UUFDYixNQUFNQyxTQUFTLElBQUksQ0FBQ3hvQixRQUFRLENBQUM4TCxHQUFHLENBQUMsY0FBY2hMLEtBQUs7UUFDcEQsTUFBTWtELElBQUlULEtBQUs0SixHQUFHLENBQUMsSUFBSSxDQUFDOGEsU0FBUyxHQUFHLElBQUksQ0FBQ0MsT0FBTyxFQUFFO1FBQ2xETSxPQUFPdGtCLEdBQUcsQ0FBQyxJQUFJLENBQUM2akIsTUFBTSxHQUFHL2pCLEdBQUcsSUFBSSxDQUFDK2pCLE1BQU0sR0FBRy9qQjtJQUM1QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJZ2tCLFdBQVc7UUFDYixPQUFPemtCLEtBQUtvbEIsSUFBSSxDQUFDLElBQUksQ0FBQzNvQixRQUFRLENBQUM4TCxHQUFHLENBQUMsWUFBWWhMLEtBQUssQ0FBQ2tELENBQUM7SUFDeEQ7SUFDQSxJQUFJZ2tCLFNBQVNsbkIsS0FBSyxFQUFFO1FBQ2xCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFlBQVloTCxLQUFLLENBQUNvRCxHQUFHLENBQUNYLEtBQUtLLEdBQUcsQ0FBQzlDLFFBQVF5QyxLQUFLTyxHQUFHLENBQUNoRDtRQUNsRSxJQUFJLENBQUN5cEMsUUFBUSxDQUFDcGMsWUFBWSxDQUFDbkcsUUFBUSxHQUFHbG5CO0lBQ3hDO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlpbkIsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDSyxPQUFPO0lBQ3JCO0lBQ0EsSUFBSUwsT0FBT2puQixLQUFLLEVBQUU7UUFDaEIsSUFBSSxDQUFDc25CLE9BQU8sR0FBR3RuQjtRQUNmLElBQUksQ0FBQ3lwQyxRQUFRLENBQUNwYyxZQUFZLENBQUNwRyxNQUFNLEdBQUdqbkI7UUFDcEMsSUFBSSxDQUFDeW5CLFlBQVk7SUFDbkI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSU4sWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDSSxVQUFVO0lBQ3hCO0lBQ0EsSUFBSUosVUFBVW5uQixLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDdW5CLFVBQVUsR0FBR3ZuQjtRQUNsQixJQUFJLENBQUN5cEMsUUFBUSxDQUFDcGMsWUFBWSxDQUFDbEcsU0FBUyxHQUFHbm5CO1FBQ3ZDLElBQUksQ0FBQ3luQixZQUFZO0lBQ25CO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlMLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQ0ksUUFBUTtJQUN0QjtJQUNBLElBQUlKLFFBQVFwbkIsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQ3duQixRQUFRLEdBQUd4bkI7UUFDaEIsSUFBSSxDQUFDeXBDLFFBQVEsQ0FBQ3BjLFlBQVksQ0FBQ2pHLE9BQU8sR0FBR3BuQjtRQUNyQyxJQUFJLENBQUN5bkIsWUFBWTtJQUNuQjtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSWpELE9BQU87UUFDVCxPQUFPO0lBQ1Q7SUFDQSxJQUFJQSxLQUFLeGtCLEtBQUssRUFBRSxDQUNoQjtJQUNBOzs7Ozs7R0FNQyxHQUNEczRCLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLElBQUksQ0FBQ21xQyxRQUFRLENBQUM1ZSxNQUFNLENBQUMvZixVQUFVekosYUFBYSxJQUFJLENBQUNvcUIsWUFBWTtJQUMvRDtJQUNBOzs7OztHQUtDLEdBQ0Rwb0IsUUFBUUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDckIsTUFBTWlXLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDQSxXQUFXcVUsV0FBVyxDQUFDdnFCLE9BQU9DO1FBQzlCLElBQUksQ0FBQ2tvQixZQUFZLENBQUNwb0IsT0FBTyxDQUFDbVcsV0FBV2xXLEtBQUssRUFBRWtXLFdBQVdqVyxNQUFNO1FBQzdELElBQUksQ0FBQ2ttQyxRQUFRLENBQUNqd0IsVUFBVSxDQUFDZ04sSUFBSSxDQUFDaE47SUFDaEM7SUFDQTs7Ozs7O0dBTUMsR0FDRHdSLFdBQVdsZ0IsUUFBUSxFQUFFbWdCLEtBQUssRUFBRUMsZUFBZSxFQUFFO1FBQzNDLElBQUksQ0FBQ3VlLFFBQVEsQ0FBQ3plLFVBQVUsQ0FBQ2xnQixVQUFVbWdCLE9BQU9DO1FBQzFDLElBQUlBLG9CQUFvQixLQUFLLEdBQUc7WUFDOUIsSUFBSSxDQUFDTyxZQUFZLENBQUN0Z0IsT0FBTyxDQUFDb1UsSUFBSSxHQUFHMkw7WUFDakMsSUFBSXJnQixvQkFBb0JDLGNBQWNyRSxnQkFBZ0I7Z0JBQ3BEeUUscUJBQXFCLElBQUksQ0FBQ3VnQixZQUFZLENBQUN0Z0IsT0FBTyxFQUFFMUU7WUFDbEQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxtQ0FBbUM7QUFDOEU7QUFFakgscUNBQXFDO0FBQ3JDLElBQUlxc0QsdUJBQXVCO0FBRTNCLG1DQUFtQztBQUNuQyxJQUFJQyxvQkFBb0IsY0FBY3ZxQjtJQUNwQzs7Ozs7Ozs7Ozs7Ozs7OztHQWdCQyxHQUNEMXBDLFlBQVksRUFDViszQixnQkFBZ0I3eUIsY0FBY2lDLEdBQUcsRUFDakMrc0QsV0FBVyxLQUFLLEVBQ2hCcm5ELE9BQU9xbkQsV0FBV3pwRCxnQkFBZ0JHLGtCQUFrQixHQUFHSCxnQkFBZ0JPLEdBQUcsRUFDMUUwUCxhQUFhLEdBQUcsRUFDaEJ5NUMsZUFBZSxDQUFDLEVBQ2hCQyxhQUFhRCxZQUFZLEVBQ3pCRSxhQUFhLEdBQUcsRUFDaEI5ekQsZUFBZSxJQUFJLEVBQ25CK3pELG1CQUFtQixDQUFDLEVBQ3BCMXlELGlCQUFpQixDQUFDLEVBQ25CLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLLENBQUMscUJBQXFCb3lELHNCQUFzQjtZQUMvQ2o4QjtZQUNBMzNCLFVBQVUsYUFBYSxHQUFHLElBQUl5TCxJQUFJO2dCQUNoQztvQkFBQztvQkFBbUIsSUFBSWlvRCwwQ0FBU0EsQ0FBQztpQkFBTTtnQkFDeEM7b0JBQUM7b0JBQWdCLElBQUlBLDBDQUFTQSxDQUFDSztpQkFBYztnQkFDN0MsU0FBUztnQkFDVDtvQkFBQztvQkFBYyxJQUFJTCwwQ0FBU0EsQ0FBQ007aUJBQVk7Z0JBQ3pDO29CQUFDO29CQUFjLElBQUlOLDBDQUFTQSxDQUFDTztpQkFBWTtnQkFDekM7b0JBQUM7b0JBQW9CLElBQUlQLDBDQUFTQSxDQUFDUTtpQkFBa0I7YUFDdEQ7UUFDSDtRQUNBLElBQUksQ0FBQ0MscUJBQXFCLEdBQUcsSUFBSVIsb0RBQW1CQSxDQUFDLEdBQUcsR0FBRztZQUN6RGxuQyxXQUFXZ25DLDJEQUF3QkE7WUFDbkM5bEQsYUFBYTtRQUNmO1FBQ0EsSUFBSSxDQUFDd21ELHFCQUFxQixDQUFDbG9ELE9BQU8sQ0FBQ2luQixlQUFlLEdBQUc7UUFDckQsSUFBSSxDQUFDaWhDLHFCQUFxQixDQUFDbG9ELE9BQU8sQ0FBQ3BNLElBQUksR0FBRztRQUMxQyxJQUFJLENBQUMycUMsYUFBYSxHQUFHLElBQUluUSxjQUFjO1lBQ3JDOU4sY0FBYyxJQUFJLENBQUM0bkMscUJBQXFCO1FBQzFDO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRyxJQUFJbm5DLHNCQUFzQixJQUFJLENBQUN1ZCxhQUFhLENBQUN2K0IsT0FBTyxFQUFFO1lBQ2pGOUw7WUFDQXFCO1FBQ0Y7UUFDQSxJQUFJLENBQUN4QixRQUFRLENBQUM4TCxHQUFHLENBQUMsbUJBQW1CaEwsS0FBSyxHQUFHLElBQUksQ0FBQ3N6RCxxQkFBcUIsQ0FBQ25vRCxPQUFPO1FBQy9FLElBQUksQ0FBQ3FPLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDN04sSUFBSSxHQUFHQTtJQUNkO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlBLE9BQU87UUFDVCxPQUFPcEIsT0FBTyxJQUFJLENBQUN2TCxPQUFPLENBQUNnTSxHQUFHLENBQUM7SUFDakM7SUFDQSxJQUFJVyxLQUFLM0wsS0FBSyxFQUFFO1FBQ2QsSUFBSSxJQUFJLENBQUMyTCxJQUFJLEtBQUszTCxPQUFPO1lBQ3ZCLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQzB3QixLQUFLO1lBQ2xCLElBQUksQ0FBQzF3QixPQUFPLENBQUNvRSxHQUFHLENBQUMscUJBQXFCcEQsTUFBTUksT0FBTyxDQUFDO1lBQ3BESixRQUFRMEwsd0JBQXdCMUw7WUFDaEMsT0FBUUE7Z0JBQ04sS0FBS3VKLGdCQUFnQkMsUUFBUTtvQkFDM0IsSUFBSSxDQUFDeEssT0FBTyxDQUFDb0UsR0FBRyxDQUFDLHNCQUFzQjtvQkFDdkM7Z0JBQ0YsS0FBS21HLGdCQUFnQkssZ0JBQWdCO29CQUNuQyxJQUFJLENBQUM1SyxPQUFPLENBQUNvRSxHQUFHLENBQUMsc0JBQXNCO29CQUN2QztnQkFDRixLQUFLbUcsZ0JBQWdCTSxXQUFXO29CQUM5QixJQUFJLENBQUM3SyxPQUFPLENBQUNvRSxHQUFHLENBQUMsc0JBQXNCO29CQUN2QztnQkFDRixLQUFLbUcsZ0JBQWdCTyxHQUFHO29CQUN0QixJQUFJLENBQUM5SyxPQUFPLENBQUNvRSxHQUFHLENBQUMsc0JBQXNCO29CQUN2QztnQkFDRjtvQkFDRSxJQUFJLENBQUNwRSxPQUFPLENBQUNvRSxHQUFHLENBQUMsc0JBQXNCO29CQUN2QztZQUNKO1lBQ0EsSUFBSSxDQUFDa3dELHFCQUFxQixDQUFDeHBDLE9BQU8sR0FBRzlwQixVQUFVdUosZ0JBQWdCRyxrQkFBa0I7WUFDakYsSUFBSSxDQUFDKytCLFVBQVU7UUFDakI7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0RoMkIsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDOUcsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBQ0QrRyxRQUFRMVMsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDMkwsSUFBSSxHQUFHM0w7SUFDZDtJQUNBOzs7Ozs7R0FNQyxHQUNELElBQUlrekQsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDaDBELFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxjQUFjaEwsS0FBSztJQUM5QztJQUNBLElBQUlrekQsV0FBV2x6RCxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsY0FBY2hMLEtBQUssR0FBR0E7SUFDMUM7SUFDQTs7Ozs7O0dBTUMsR0FDRCxJQUFJbXpELGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQ2owRCxRQUFRLENBQUM4TCxHQUFHLENBQUMsY0FBY2hMLEtBQUs7SUFDOUM7SUFDQSxJQUFJbXpELFdBQVduekQsS0FBSyxFQUFFO1FBQ3BCLElBQUksQ0FBQ2QsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLGNBQWNoTCxLQUFLLEdBQUdBO0lBQzFDO0lBQ0E7Ozs7OztHQU1DLEdBQ0QsSUFBSW96RCxtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUNsMEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLG9CQUFvQmhMLEtBQUs7SUFDcEQ7SUFDQSxJQUFJb3pELGlCQUFpQnB6RCxLQUFLLEVBQUU7UUFDMUIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsb0JBQW9CaEwsS0FBSyxHQUFHQTtJQUNoRDtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJdXpELDRCQUE0QjtRQUM5QixPQUFPLElBQUksQ0FBQ0QscUJBQXFCLENBQUNycEMsa0JBQWtCO0lBQ3REO0lBQ0E7Ozs7O0dBS0MsR0FDRHVwQywrQkFBK0I7UUFDN0IsT0FBTyxJQUFJLENBQUNELHlCQUF5QjtJQUN2QztJQUNBOzs7O0dBSUMsR0FDRCxJQUFJLzVDLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQ2t3QixhQUFhLENBQUNsd0IsVUFBVSxDQUFDbFcsS0FBSztJQUM1QztJQUNBLElBQUlrVyxXQUFXeFosS0FBSyxFQUFFO1FBQ3BCLE1BQU15ekQsV0FBV2h4RCxLQUFLNEosR0FBRyxDQUFDLEdBQUc1SixLQUFLNHpDLElBQUksQ0FBQzV6QyxLQUFLaXhELElBQUksQ0FBQzF6RDtRQUNqRCxNQUFNMDlCLE9BQU9qN0IsS0FBSytvQyxHQUFHLENBQUMsR0FBR2lvQjtRQUN6QixJQUFJLENBQUMvcEIsYUFBYSxDQUFDbHdCLFVBQVUsQ0FBQ2lyQixnQkFBZ0IsQ0FBQy9HLE1BQU1BO1FBQ3JELElBQUksQ0FBQzYxQix5QkFBeUIsQ0FBQ3B6RCxXQUFXLEdBQUdzekQ7SUFDL0M7SUFDQTs7Ozs7R0FLQyxHQUNEN2hDLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDcFksVUFBVTtJQUN4QjtJQUNBOzs7OztHQUtDLEdBQ0RtNkMsY0FBYzN6RCxLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDd1osVUFBVSxHQUFHeFo7SUFDcEI7SUFDQTs7Ozs7R0FLQyxHQUNELElBQUlnekQsV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDcm5ELElBQUksS0FBS3BDLGdCQUFnQkcsa0JBQWtCO0lBQ3pEO0lBQ0EsSUFBSXNwRCxTQUFTaHpELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUMyTCxJQUFJLEdBQUczTCxRQUFRdUosZ0JBQWdCRyxrQkFBa0IsR0FBR0gsZ0JBQWdCRSxTQUFTO0lBQ3BGO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJL0ksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDNnlELHlCQUF5QixDQUFDN3lELGNBQWM7SUFDdEQ7SUFDQSxJQUFJQSxlQUFlVixLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDdXpELHlCQUF5QixDQUFDN3lELGNBQWMsR0FBR1Y7SUFDbEQ7SUFDQTs7O0dBR0MsR0FDRCxJQUFJZ3FDLGNBQWM7UUFDaEJwK0IsUUFBUUMsSUFBSSxDQUFDLElBQUksQ0FBQzlNLElBQUksRUFBRTtRQUN4QixPQUFPO0lBQ1Q7SUFDQSxJQUFJaXJDLFlBQVlocUMsS0FBSyxFQUFFO1FBQ3JCNEwsUUFBUUMsSUFBSSxDQUFDLElBQUksQ0FBQzlNLElBQUksRUFBRTtJQUMxQjtJQUNBOzs7Ozs7R0FNQyxHQUNEdTVCLE9BQU94dEIsUUFBUSxFQUFFekosV0FBVyxFQUFFL0IsU0FBUyxFQUFFO1FBQ3ZDLElBQUksSUFBSSxDQUFDZzBELHFCQUFxQixDQUFDeHBDLE9BQU8sRUFBRTtZQUN0QyxJQUFJLENBQUM0ZixhQUFhLENBQUM3ZSxNQUFNLENBQUMvZixVQUFVeko7WUFDcEMsSUFBSSxDQUFDaXlELHFCQUFxQixDQUFDem9DLE1BQU0sQ0FBQy9mLFVBQVUsTUFBTSxNQUFNeEw7UUFDMUQ7SUFDRjtJQUNBOzs7Ozs7R0FNQyxHQUNEMHJCLFdBQVdsZ0IsUUFBUSxFQUFFbWdCLEtBQUssRUFBRUMsZUFBZSxFQUFFO1FBQzNDLElBQUksQ0FBQ29vQyxxQkFBcUIsQ0FBQ3RvQyxVQUFVLENBQUNsZ0IsVUFBVW1nQixPQUFPQztJQUN6RDtBQUNGO0FBRUEsZ0NBQWdDO0FBQ2E7QUFFN0MsaUNBQWlDO0FBQ2pDLElBQUkyb0MsbUJBQW1CO0FBRXZCLGdDQUFnQztBQUNoQyxJQUFJQyxpQkFBaUIsY0FBY3RyQjtJQUNqQzs7Ozs7Ozs7O0dBU0MsR0FDRDFwQyxZQUFZLEVBQ1YrM0IsYUFBYSxFQUNiazlCLFlBQVlocUQsa0JBQWtCL0MsT0FBTyxFQUNyQ2d0RCxRQUFRLEtBQUssRUFDYi9zQyxTQUFTLEdBQUcsRUFDWmd0QyxXQUFXLEdBQUcsRUFDZixHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ04sS0FBSyxDQUFDLGtCQUFrQkosa0JBQWtCO1lBQ3hDaDlCO1lBQ0E3M0IsU0FBUyxhQUFhLEdBQUcsSUFBSTJMLElBQUk7Z0JBQy9CO29CQUFDO29CQUFzQm9wRCxVQUFVM3pELE9BQU8sQ0FBQztpQkFBRzthQUM3QztZQUNEbEIsVUFBVSxhQUFhLEdBQUcsSUFBSXlMLElBQUk7Z0JBQ2hDO29CQUFDO29CQUFVLElBQUlpcEQsMENBQVNBLENBQUMzc0M7aUJBQVE7Z0JBQ2pDO29CQUFDO29CQUFZLElBQUkyc0MsMENBQVNBLENBQUNLO2lCQUFVO2FBQ3RDO1FBQ0g7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRCxJQUFJRixZQUFZO1FBQ2QsT0FBT3hwRCxPQUFPLElBQUksQ0FBQ3ZMLE9BQU8sQ0FBQ2dNLEdBQUcsQ0FBQztJQUNqQztJQUNBLElBQUkrb0QsVUFBVS96RCxLQUFLLEVBQUU7UUFDbkIsSUFBSSxJQUFJLENBQUMrekQsU0FBUyxLQUFLL3pELE9BQU87WUFDNUIsSUFBSSxDQUFDaEIsT0FBTyxDQUFDb0UsR0FBRyxDQUFDLHNCQUFzQnBELE1BQU1JLE9BQU8sQ0FBQztZQUNyRCxJQUFJLENBQUNxb0MsVUFBVTtRQUNqQjtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FDRCxJQUFJdXJCLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQ0QsU0FBUyxLQUFLaHFELGtCQUFrQkMsS0FBSztJQUNuRDtJQUNBOzs7OztHQUtDLEdBQ0QsSUFBSWdxRCxNQUFNaDBELEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQyt6RCxTQUFTLEdBQUcvekQsUUFBUStKLGtCQUFrQkMsS0FBSyxHQUFHRCxrQkFBa0IvQyxPQUFPO0lBQzlFO0lBQ0E7Ozs7O0dBS0MsR0FDRGt0RCxlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUNILFNBQVM7SUFDdkI7SUFDQTs7Ozs7R0FLQyxHQUNESSxhQUFhbjBELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUMrekQsU0FBUyxHQUFHL3pEO0lBQ25CO0lBQ0E7Ozs7R0FJQyxHQUNELElBQUlpbkIsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDL25CLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxVQUFVaEwsS0FBSztJQUMxQztJQUNBLElBQUlpbkIsT0FBT2puQixLQUFLLEVBQUU7UUFDaEIsSUFBSSxDQUFDZCxRQUFRLENBQUM4TCxHQUFHLENBQUMsVUFBVWhMLEtBQUssR0FBR0E7SUFDdEM7SUFDQTs7Ozs7R0FLQyxHQUNEa3NDLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ2psQixNQUFNO0lBQ3BCO0lBQ0E7Ozs7O0dBS0MsR0FDRGtsQixVQUFVbnNDLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ2luQixNQUFNLEdBQUdqbkI7SUFDaEI7SUFDQTs7OztHQUlDLEdBQ0QsSUFBSWkwRCxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMvMEQsUUFBUSxDQUFDOEwsR0FBRyxDQUFDLFlBQVloTCxLQUFLO0lBQzVDO0lBQ0EsSUFBSWkwRCxTQUFTajBELEtBQUssRUFBRTtRQUNsQixJQUFJLENBQUNkLFFBQVEsQ0FBQzhMLEdBQUcsQ0FBQyxZQUFZaEwsS0FBSyxHQUFHQTtJQUN4QztJQUNBOzs7OztHQUtDLEdBQ0RvMEQsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDSCxRQUFRO0lBQ3RCO0lBQ0E7Ozs7O0dBS0MsR0FDREksWUFBWXIwRCxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDaTBELFFBQVEsR0FBR2owRDtJQUNsQjtBQUNGO0FBRUEsOEJBQThCO0FBQ2dEO0FBQzlFLElBQUl5MEQsZUFBZSxjQUFjRix5Q0FBTUE7SUFDckM7Ozs7Ozs7O0dBUUMsR0FDREcsS0FBS0MsR0FBRyxFQUFFaFgsU0FBUyxLQUNuQixDQUFDLEVBQUVpWCxhQUFhLEtBQ2hCLENBQUMsRUFBRWhYLFVBQVUsSUFBSSxFQUFFO1FBQ2pCLE1BQU1pWCxrQkFBa0IsSUFBSSxDQUFDcmtDLE9BQU87UUFDcEMsTUFBTXNrQyxrQkFBa0IsSUFBSU4saURBQWVBO1FBQzNDLE1BQU1PLFNBQVMsSUFBSVQsNkNBQVVBLENBQUNRO1FBQzlCQyxPQUFPQyxPQUFPLENBQUMsSUFBSSxDQUFDQyxJQUFJO1FBQ3hCRixPQUFPRyxlQUFlLENBQUM7UUFDdkIsT0FBTyxJQUFJdGhDLFFBQVEsQ0FBQ0MsU0FBU3FlO1lBQzNCNGlCLGdCQUFnQmxYLE9BQU8sR0FBRyxDQUFDdVg7Z0JBQ3pCTixnQkFBZ0JoWCxTQUFTLENBQUNzWDtnQkFDMUIsSUFBSXZYLFlBQVksTUFBTTtvQkFDcEJBLFFBQVEsQ0FBQyxlQUFlLEVBQUV1WCxLQUFLLENBQUM7b0JBQ2hDdGhDO2dCQUNGLE9BQU87b0JBQ0xxZSxPQUFPLENBQUMsZUFBZSxFQUFFaWpCLEtBQUssQ0FBQztnQkFDakM7WUFDRjtZQUNBTixnQkFBZ0I5VyxTQUFTLENBQUM0VztZQUMxQkksT0FBT0wsSUFBSSxDQUFDQyxLQUFLLENBQUM1NkM7Z0JBQ2hCLElBQUk7b0JBQ0YsTUFBTWdtQixTQUFTLElBQUksQ0FBQ3ExQixLQUFLLENBQUNyN0M7b0JBQzFCODZDLGdCQUFnQi9XLE9BQU8sQ0FBQzZXO29CQUN4QmhYLE9BQU81ZDtvQkFDUGxNLFFBQVFrTTtnQkFDVixFQUFFLE9BQU92UyxHQUFHO29CQUNWNWhCLFFBQVE2bUMsS0FBSyxDQUFDamxCO29CQUNkc25DLGdCQUFnQmxYLE9BQU8sQ0FBQytXO2dCQUMxQjtZQUNGLEdBQUdDO1FBQ0w7SUFDRjtJQUNBOzs7Ozs7R0FNQyxHQUNEUSxNQUFNMzVCLEtBQUssRUFBRTtRQUNYLE1BQU00NUIsaUJBQWlCO1FBQ3ZCLE1BQU1DLG1CQUFtQjtRQUN6QixJQUFJdjFCLFNBQVNzMUIsZUFBZUUsSUFBSSxDQUFDOTVCO1FBQ2pDLElBQUlzRSxXQUFXLE1BQU07WUFDbkIsTUFBTSxJQUFJNXlCLE1BQU07UUFDbEI7UUFDQSxNQUFNcW9ELFlBQVl6MUIsTUFBTSxDQUFDLEVBQUUsQ0FBQzNILElBQUksR0FBRy9CLEtBQUssQ0FBQyxRQUFRd00sR0FBRyxDQUFDLENBQUN6TSxJQUFNN3JCLE9BQU82ckI7UUFDbkUsTUFBTXEvQixXQUFXRCxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRTtRQUM1QyxNQUFNOTNCLE9BQU84M0IsVUFBVXQ4QixNQUFNO1FBQzdCLE1BQU1vYSxTQUFTNVYsUUFBUTtRQUN2QixJQUFLLElBQUluN0IsSUFBSSxHQUFHcXJCLElBQUk0bkMsVUFBVXQ4QixNQUFNLEVBQUUzMkIsSUFBSXFyQixHQUFHLEVBQUVyckIsRUFBRztZQUNoRCxJQUFJa3pELGFBQWFELFNBQVMsQ0FBQ2p6RCxFQUFFLEdBQUdpekQsU0FBUyxDQUFDanpELElBQUksRUFBRSxFQUFFO2dCQUNoRCxNQUFNLElBQUk0SyxNQUFNO1lBQ2xCO1FBQ0Y7UUFDQSxNQUFNNE0sT0FBTyxJQUFJbEssYUFBYTZ0QixRQUFRLElBQUk7UUFDMUMsSUFBSW9hLFdBQVc7UUFDZixJQUFJOVksUUFBUTtRQUNaLE1BQU8sQ0FBQ2UsU0FBU3UxQixpQkFBaUJDLElBQUksQ0FBQzk1QixNQUFLLE1BQU8sS0FBTTtZQUN2RCxNQUFNNzRCLElBQUkySCxPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFO1lBQzFCLE1BQU15VCxJQUFJanBDLE9BQU93MUIsTUFBTSxDQUFDLEVBQUU7WUFDMUIsTUFBTW5ZLElBQUlyZCxPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFO1lBQzFCK1gsV0FBV3IxQyxLQUFLNEosR0FBRyxDQUFDeXJDLFVBQVVsMUMsR0FBRzR3QyxHQUFHNXJCO1lBQ3BDLE1BQU04dEMsU0FBUzEyQixRQUFRdEI7WUFDdkIsTUFBTWk0QixTQUFTbHpELEtBQUs0SyxLQUFLLENBQUMyeEIsUUFBUXRCLFFBQVFBO1lBQzFDLE1BQU1rNEIsU0FBU256RCxLQUFLNEssS0FBSyxDQUFDMnhCLFFBQVFzVSxVQUFVNVY7WUFDNUMsTUFBTW00QixLQUFLLENBQUNILFNBQVNwaUIsU0FBU3FpQixTQUFTajRCLE9BQU9rNEIsTUFBSyxJQUFLO1lBQ3hENzdDLElBQUksQ0FBQzg3QyxLQUFLLEVBQUUsR0FBR2p6RDtZQUNmbVgsSUFBSSxDQUFDODdDLEtBQUssRUFBRSxHQUFHcmlCO1lBQ2Z6NUIsSUFBSSxDQUFDODdDLEtBQUssRUFBRSxHQUFHanVDO1lBQ2Y3TixJQUFJLENBQUM4N0MsS0FBSyxFQUFFLEdBQUc7WUFDZixFQUFFNzJCO1FBQ0o7UUFDQSxNQUFNc00sT0FBTzdvQyxLQUFLNHpDLElBQUksQ0FBQzV6QyxLQUFLaXhELElBQUksQ0FBQzViO1FBQ2pDLE1BQU1nZSxjQUFjcnpELEtBQUsrb0MsR0FBRyxDQUFDLEdBQUdGO1FBQ2hDLElBQUssSUFBSS9vQyxJQUFJLEdBQUdxckIsSUFBSTdULEtBQUttZixNQUFNLEVBQUUzMkIsSUFBSXFyQixHQUFHcnJCLEtBQUssRUFBRztZQUM5Q3dYLElBQUksQ0FBQ3hYLElBQUksRUFBRSxJQUFJdXpEO1lBQ2YvN0MsSUFBSSxDQUFDeFgsSUFBSSxFQUFFLElBQUl1ekQ7WUFDZi83QyxJQUFJLENBQUN4WCxJQUFJLEVBQUUsSUFBSXV6RDtRQUNqQjtRQUNBLE9BQU8sSUFBSXhrQixjQUFjdjNCLE1BQU0yakI7SUFDakM7QUFDRjtBQUVBLCtCQUErQjtBQUM4RjtBQUM3SCxJQUFJeTRCLGdCQUFnQixjQUFjSCx5Q0FBT0E7SUFDdkM7Ozs7Ozs7O0dBUUMsR0FDRHRCLEtBQUtDLEdBQUcsRUFBRWhYLFNBQVMsS0FDbkIsQ0FBQyxFQUFFaVgsYUFBYSxLQUNoQixDQUFDLEVBQUVoWCxVQUFVLElBQUksRUFBRTtRQUNqQixNQUFNaVgsa0JBQWtCLElBQUksQ0FBQ3JrQyxPQUFPO1FBQ3BDLE1BQU1za0Msa0JBQWtCLElBQUltQixpREFBZUE7UUFDM0MsTUFBTWxCLFNBQVMsSUFBSWdCLDZDQUFXQSxDQUFDakI7UUFDL0JDLE9BQU9DLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUk7UUFDeEJGLE9BQU9HLGVBQWUsQ0FBQztRQUN2QixPQUFPLElBQUl0aEMsUUFBUSxDQUFDQyxTQUFTcWU7WUFDM0I0aUIsZ0JBQWdCbFgsT0FBTyxHQUFHLENBQUN1WDtnQkFDekJOLGdCQUFnQmhYLFNBQVMsQ0FBQ3NYO2dCQUMxQixJQUFJdlgsWUFBWSxNQUFNO29CQUNwQkEsUUFBUSxDQUFDLGVBQWUsRUFBRXVYLEtBQUssQ0FBQztvQkFDaEN0aEM7Z0JBQ0YsT0FBTztvQkFDTHFlLE9BQU8sQ0FBQyxlQUFlLEVBQUVpakIsS0FBSyxDQUFDO2dCQUNqQztZQUNGO1lBQ0FOLGdCQUFnQjlXLFNBQVMsQ0FBQzRXO1lBQzFCSSxPQUFPTCxJQUFJLENBQUNDLEtBQUssQ0FBQzU2QztnQkFDaEIsSUFBSTtvQkFDRixNQUFNZ21CLFNBQVMsSUFBSSxDQUFDcTFCLEtBQUssQ0FBQ3I3QztvQkFDMUI4NkMsZ0JBQWdCL1csT0FBTyxDQUFDNlc7b0JBQ3hCaFgsT0FBTzVkO29CQUNQbE0sUUFBUWtNO2dCQUNWLEVBQUUsT0FBT3ZTLEdBQUc7b0JBQ1Y1aEIsUUFBUTZtQyxLQUFLLENBQUNqbEI7b0JBQ2RzbkMsZ0JBQWdCbFgsT0FBTyxDQUFDK1c7Z0JBQzFCO1lBQ0YsR0FBR0M7UUFDTDtJQUNGO0lBQ0E7Ozs7OztHQU1DLEdBQ0RRLE1BQU0zNUIsS0FBSyxFQUFFO1FBQ1gsTUFBTTI2QixjQUFjO1FBQ3BCLE1BQU1DLGFBQWE7UUFDbkIsTUFBTUMsa0JBQWtCO1FBQ3hCLE1BQU1DLGtCQUFrQjtRQUN4QixNQUFNakIsbUJBQW1CO1FBQ3pCLElBQUl2MUIsU0FBU3EyQixZQUFZYixJQUFJLENBQUM5NUI7UUFDOUIsTUFBTSs2QixRQUFRejJCLFdBQVcsT0FBT0EsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUM1Q0EsU0FBU3MyQixXQUFXZCxJQUFJLENBQUM5NUI7UUFDekIsSUFBSXNFLFdBQVcsTUFBTTtZQUNuQixNQUFNLElBQUk1eUIsTUFBTTtRQUNsQjtRQUNBLE1BQU11d0IsT0FBT256QixPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFO1FBQzdCLE1BQU1obUIsT0FBTyxJQUFJbEssYUFBYTZ0QixRQUFRLElBQUk7UUFDMUMsTUFBTWtVLFlBQVksSUFBSXNrQiwwQ0FBUUEsQ0FBQyxHQUFHLEdBQUc7UUFDckMsTUFBTXJrQixZQUFZLElBQUlxa0IsMENBQVFBLENBQUMsR0FBRyxHQUFHO1FBQ3JDbjJCLFNBQVN1MkIsZ0JBQWdCZixJQUFJLENBQUM5NUI7UUFDOUIsSUFBSXNFLFdBQVcsTUFBTTtZQUNuQjZSLFVBQVV4dUMsR0FBRyxDQUFDbUgsT0FBT3cxQixNQUFNLENBQUMsRUFBRSxHQUFHeDFCLE9BQU93MUIsTUFBTSxDQUFDLEVBQUUsR0FBR3gxQixPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFO1FBQ3RFO1FBQ0FBLFNBQVN3MkIsZ0JBQWdCaEIsSUFBSSxDQUFDOTVCO1FBQzlCLElBQUlzRSxXQUFXLE1BQU07WUFDbkI4UixVQUFVenVDLEdBQUcsQ0FBQ21ILE9BQU93MUIsTUFBTSxDQUFDLEVBQUUsR0FBR3gxQixPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFLEdBQUd4MUIsT0FBT3cxQixNQUFNLENBQUMsRUFBRTtRQUN0RTtRQUNBLElBQUk2UixVQUFVMXVDLENBQUMsR0FBRzJ1QyxVQUFVM3VDLENBQUMsSUFBSTB1QyxVQUFVenVDLENBQUMsR0FBRzB1QyxVQUFVMXVDLENBQUMsSUFBSXl1QyxVQUFVeUMsQ0FBQyxHQUFHeEMsVUFBVXdDLENBQUMsRUFBRTtZQUN2RnpDLFVBQVV4dUMsR0FBRyxDQUFDLEdBQUcsR0FBRztZQUNwQnl1QyxVQUFVenVDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7WUFDcEIsTUFBTSxJQUFJK0osTUFBTTtRQUNsQjtRQUNBLElBQUk1SyxJQUFJO1FBQ1IsTUFBTyxDQUFDdzlCLFNBQVN1MUIsaUJBQWlCQyxJQUFJLENBQUM5NUIsTUFBSyxNQUFPLEtBQU07WUFDdkQxaEIsSUFBSSxDQUFDeFgsSUFBSSxHQUFHZ0ksT0FBT3cxQixNQUFNLENBQUMsRUFBRTtZQUM1QmhtQixJQUFJLENBQUN4WCxJQUFJLEdBQUdnSSxPQUFPdzFCLE1BQU0sQ0FBQyxFQUFFO1lBQzVCaG1CLElBQUksQ0FBQ3hYLElBQUksR0FBR2dJLE9BQU93MUIsTUFBTSxDQUFDLEVBQUU7WUFDNUJobUIsSUFBSSxDQUFDeFgsSUFBSSxHQUFHO1FBQ2Q7UUFDQSxNQUFNbXdDLE1BQU0sSUFBSXBCLGNBQWN2M0IsTUFBTTJqQjtRQUNwQ2dWLElBQUlkLFNBQVMsQ0FBQ3ByQixJQUFJLENBQUNvckI7UUFDbkJjLElBQUliLFNBQVMsQ0FBQ3JyQixJQUFJLENBQUNxckI7UUFDbkIsSUFBSTJrQixVQUFVLE1BQU07WUFDbEI5akIsSUFBSTN6QyxJQUFJLEdBQUd5M0Q7UUFDYjtRQUNBLE9BQU85akI7SUFDVDtBQUNGO0FBRUEsaUNBQWlDO0FBQzRDO0FBQzdFLElBQUlpa0Isa0JBQWtCLGNBQWNGLHlDQUFPQTtJQUN6Qzs7Ozs7O0dBTUMsR0FDRC9CLEtBQUsvVyxTQUFTLEtBQ2QsQ0FBQyxFQUFFQyxVQUFVLElBQUksRUFBRTtRQUNqQixJQUFJbVIsVUFBVTcxQixNQUFNLEtBQUssR0FBRztZQUMxQnlrQixTQUFTb1IsU0FBUyxDQUFDLEVBQUU7WUFDckJuUixVQUFVbVIsU0FBUyxDQUFDLEVBQUU7UUFDeEIsT0FBTyxJQUFJQSxVQUFVNzFCLE1BQU0sS0FBSyxLQUFLLE9BQU82MUIsU0FBUyxDQUFDLEVBQUUsS0FBSyxZQUFZO1lBQ3ZFcFIsU0FBU29SLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCblIsVUFBVTtRQUNaO1FBQ0EsTUFBTWlYLGtCQUFrQixJQUFJLENBQUNya0MsT0FBTztRQUNwQyxNQUFNc2tDLGtCQUFrQixJQUFJNEIsaURBQWVBO1FBQzNDLE9BQU8sSUFBSTlpQyxRQUFRLENBQUNDLFNBQVNxZTtZQUMzQixNQUFNdUwsY0FBYyxJQUFJL007WUFDeEIsTUFBTWdOLFlBQVksSUFBSWhOO1lBQ3RCb2tCLGdCQUFnQmxYLE9BQU8sR0FBRyxDQUFDK1c7Z0JBQ3pCRSxnQkFBZ0JoWCxTQUFTLENBQUM4VztnQkFDMUIsSUFBSS9XLFlBQVksTUFBTTtvQkFDcEJBLFFBQVEsQ0FBQyxlQUFlLEVBQUUrVyxJQUFJLENBQUM7b0JBQy9COWdDO2dCQUNGLE9BQU87b0JBQ0xxZSxPQUFPLENBQUMsZUFBZSxFQUFFeWlCLElBQUksQ0FBQztnQkFDaEM7WUFDRjtZQUNBRyxnQkFBZ0JuWCxNQUFNLEdBQUc7Z0JBQ3ZCLE1BQU01ZCxTQUFTO29CQUFDMGQ7b0JBQWFDO2lCQUFVO2dCQUN2Q0MsT0FBTzVkO2dCQUNQbE0sUUFBUWtNO1lBQ1Y7WUFDQTBkLFlBQVlsd0IsZ0JBQWdCLENBQUMsU0FBUyxDQUFDQztnQkFDckNzbkMsZ0JBQWdCalgsU0FBUyxDQUFDO1lBQzVCO1lBQ0FILFVBQVVud0IsZ0JBQWdCLENBQUMsU0FBUyxDQUFDQztnQkFDbkNzbkMsZ0JBQWdCalgsU0FBUyxDQUFDO1lBQzVCO1lBQ0FKLFlBQVlsd0IsZ0JBQWdCLENBQUMsUUFBUTtnQkFDbkNzbkMsZ0JBQWdCL1csT0FBTyxDQUFDO2dCQUN4QmdYLGdCQUFnQmhYLE9BQU8sQ0FBQztZQUMxQjtZQUNBSixVQUFVbndCLGdCQUFnQixDQUFDLFFBQVE7Z0JBQ2pDc25DLGdCQUFnQi9XLE9BQU8sQ0FBQztnQkFDeEJnWCxnQkFBZ0JoWCxPQUFPLENBQUM7WUFDMUI7WUFDQStXLGdCQUFnQjlXLFNBQVMsQ0FBQztZQUMxQjhXLGdCQUFnQjlXLFNBQVMsQ0FBQztZQUMxQitXLGdCQUFnQi9XLFNBQVMsQ0FBQztZQUMxQitXLGdCQUFnQi9XLFNBQVMsQ0FBQztZQUMxQk4sWUFBWWx5QyxHQUFHLEdBQUdrakQ7WUFDbEIvUSxVQUFVbnlDLEdBQUcsR0FBR21qRDtRQUNsQjtJQUNGO0FBQ0Y7QUFtSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3NpbmcvYnVpbGQvaW5kZXguanM/OWI1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHBvc3Rwcm9jZXNzaW5nIHY2LjM0LjMgYnVpbGQgU2F0IEZlYiAxMCAyMDI0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3Bvc3Rwcm9jZXNzaW5nXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0IFJhb3VsIHZhbiBSw7xzY2hlblxuICogQGxpY2Vuc2UgWmxpYlxuICovXG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjYuMzQuM1wiO1xuXG4vLyBzcmMvY29yZS9EaXNwb3NhYmxlLmpzXG52YXIgRGlzcG9zYWJsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEZyZWVzIGludGVybmFsIHJlc291cmNlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL0VmZmVjdENvbXBvc2VyLmpzXG5pbXBvcnQge1xuICBEZXB0aFN0ZW5jaWxGb3JtYXQsXG4gIERlcHRoVGV4dHVyZSxcbiAgTGluZWFyRmlsdGVyIGFzIExpbmVhckZpbHRlcjIsXG4gIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTExLFxuICBVbnNpZ25lZEludFR5cGUsXG4gIFVuc2lnbmVkSW50MjQ4VHlwZSxcbiAgVmVjdG9yMiBhcyBWZWN0b3IyMTYsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTNcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9wYXNzZXMvQWRhcHRpdmVMdW1pbmFuY2VQYXNzLmpzXG5pbXBvcnQgeyBOZWFyZXN0RmlsdGVyLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9BZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nLCBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvYWRhcHRpdmUtbHVtaW5hbmNlLmZyYWdcbnZhciBhZGFwdGl2ZV9sdW1pbmFuY2VfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2RlZmluZSBwYWNrRmxvYXRUb1JHQkEodikgcGFja0RlcHRoVG9SR0JBKHYpXFxuI2RlZmluZSB1bnBhY2tSR0JBVG9GbG9hdCh2KSB1bnBhY2tSR0JBVG9EZXB0aCh2KVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbHVtaW5hbmNlQnVmZmVyMDt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1bWluYW5jZUJ1ZmZlcjE7dW5pZm9ybSBmbG9hdCBtaW5MdW1pbmFuY2U7dW5pZm9ybSBmbG9hdCBkZWx0YVRpbWU7dW5pZm9ybSBmbG9hdCB0YXU7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtmbG9hdCBsMD11bnBhY2tSR0JBVG9GbG9hdCh0ZXh0dXJlMkQobHVtaW5hbmNlQnVmZmVyMCx2VXYpKTtcXG4jaWYgX19WRVJTSU9OX18gPCAzMDBcXG5mbG9hdCBsMT10ZXh0dXJlMkRMb2RFWFQobHVtaW5hbmNlQnVmZmVyMSx2VXYsTUlQX0xFVkVMXzFYMSkucjtcXG4jZWxzZVxcbmZsb2F0IGwxPXRleHR1cmVMb2QobHVtaW5hbmNlQnVmZmVyMSx2VXYsTUlQX0xFVkVMXzFYMSkucjtcXG4jZW5kaWZcXG5sMD1tYXgobWluTHVtaW5hbmNlLGwwKTtsMT1tYXgobWluTHVtaW5hbmNlLGwxKTtmbG9hdCBhZGFwdGVkTHVtPWwwKyhsMS1sMCkqKDEuMC1leHAoLWRlbHRhVGltZSp0YXUpKTtnbF9GcmFnQ29sb3I9KGFkYXB0ZWRMdW09PTEuMCk/dmVjNCgxLjApOnBhY2tGbG9hdFRvUkdCQShhZGFwdGVkTHVtKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb21tb24udmVydFxudmFyIGNvbW1vbl9kZWZhdWx0ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0FkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuanNcbnZhciBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGFkYXB0aXZlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBNSVBfTEVWRUxfMVgxOiBcIjAuMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgbHVtaW5hbmNlQnVmZmVyMDogbmV3IFVuaWZvcm0obnVsbCksXG4gICAgICAgIGx1bWluYW5jZUJ1ZmZlcjE6IG5ldyBVbmlmb3JtKG51bGwpLFxuICAgICAgICBtaW5MdW1pbmFuY2U6IG5ldyBVbmlmb3JtKDAuMDEpLFxuICAgICAgICBkZWx0YVRpbWU6IG5ldyBVbmlmb3JtKDApLFxuICAgICAgICB0YXU6IG5ldyBVbmlmb3JtKDEpXG4gICAgICB9LFxuICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICBzaGFkZXJUZXh0dXJlTE9EOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBhZGFwdGl2ZV9sdW1pbmFuY2VfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbHVtaW5hbmNlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBkb3duc2FtcGxlZCBhdmVyYWdlIGx1bWluYW5jZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgbHVtaW5hbmNlQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmltYXJ5IGx1bWluYW5jZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgZG93bnNhbXBsZWQgYXZlcmFnZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VCdWZmZXIwIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGx1bWluYW5jZSBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGx1bWluYW5jZUJ1ZmZlcjEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmx1bWluYW5jZUJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2Vjb25kYXJ5IGx1bWluYW5jZSBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VCdWZmZXIxIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0THVtaW5hbmNlQnVmZmVyMSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubHVtaW5hbmNlQnVmZmVyMS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogVGhpcyBsZXZlbCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzbWFsbGVzdCBtaXBtYXAgb2YgdGhlIHByaW1hcnkgbHVtaW5hbmNlIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBtaXBMZXZlbDF4MSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5NSVBfTEVWRUxfMVgxID0gdmFsdWUudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pcExldmVsMXgxIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBsZXZlbC5cbiAgICovXG4gIHNldE1pcExldmVsMXgxKHZhbHVlKSB7XG4gICAgdGhpcy5taXBMZXZlbDF4MSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVsdGEgdGltZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBkZWx0YVRpbWUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhVGltZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWx0YSB0aW1lLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVsdGFUaW1lIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZWx0YSB0aW1lLlxuICAgKi9cbiAgc2V0RGVsdGFUaW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YVRpbWUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxvd2VzdCBwb3NzaWJsZSBsdW1pbmFuY2UgdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluTHVtaW5hbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1pbkx1bWluYW5jZS52YWx1ZTtcbiAgfVxuICBzZXQgbWluTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG93ZXN0IHBvc3NpYmxlIGx1bWluYW5jZSB2YWx1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkx1bWluYW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICovXG4gIGdldE1pbkx1bWluYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5MdW1pbmFuY2UudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluTHVtaW5hbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIGx1bWluYW5jZS5cbiAgICovXG4gIHNldE1pbkx1bWluYW5jZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWluTHVtaW5hbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZTtcbiAgfVxuICBzZXQgYWRhcHRhdGlvblJhdGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRhdS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgZ2V0QWRhcHRhdGlvblJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGF1LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIHNldEFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50YXUudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Cb2tlaE1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcyLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDIsIFVuaWZvcm0gYXMgVW5pZm9ybTIsIFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmJva2VoLmZyYWdcbnZhciBjb252b2x1dGlvbl9ib2tlaF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWYgUEFTUyA9PSAxXFxudW5pZm9ybSB2ZWM0IGtlcm5lbDY0WzMyXTtcXG4jZWxzZVxcbnVuaWZvcm0gdmVjNCBrZXJuZWwxNls4XTtcXG4jZW5kaWZcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGNvY0J1ZmZlcjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXtcXG4jaWZkZWYgRk9SRUdST1VORFxcbnZlYzIgY29jTmVhckZhcj10ZXh0dXJlMkQoY29jQnVmZmVyLHZVdikucmcqc2NhbGU7ZmxvYXQgY29jPWNvY05lYXJGYXIueDtcXG4jZWxzZVxcbmZsb2F0IGNvYz10ZXh0dXJlMkQoY29jQnVmZmVyLHZVdikuZypzY2FsZTtcXG4jZW5kaWZcXG5pZihjb2M9PTAuMCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO31lbHNle1xcbiNpZmRlZiBGT1JFR1JPVU5EXFxudmVjMiBzdGVwPXRleGVsU2l6ZSptYXgoY29jTmVhckZhci54LGNvY05lYXJGYXIueSk7XFxuI2Vsc2VcXG52ZWMyIHN0ZXA9dGV4ZWxTaXplKmNvYztcXG4jZW5kaWZcXG4jaWYgUEFTUyA9PSAxXFxudmVjNCBhY2M9dmVjNCgwLjApO2ZvcihpbnQgaT0wO2k8MzI7KytpKXt2ZWM0IGtlcm5lbD1rZXJuZWw2NFtpXTt2ZWMyIHV2PXN0ZXAqa2VybmVsLnh5K3ZVdjthY2MrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1dik7dXY9c3RlcCprZXJuZWwuencrdlV2O2FjYys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KTt9Z2xfRnJhZ0NvbG9yPWFjYy82NC4wO1xcbiNlbHNlXFxudmVjNCBtYXhWYWx1ZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmb3IoaW50IGk9MDtpPDg7KytpKXt2ZWM0IGtlcm5lbD1rZXJuZWwxNltpXTt2ZWMyIHV2PXN0ZXAqa2VybmVsLnh5K3ZVdjttYXhWYWx1ZT1tYXgodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2KSxtYXhWYWx1ZSk7dXY9c3RlcCprZXJuZWwuencrdlV2O21heFZhbHVlPW1heCh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYpLG1heFZhbHVlKTt9Z2xfRnJhZ0NvbG9yPW1heFZhbHVlO1xcbiNlbmRpZlxcbn19XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qc1xudmFyIEJva2VoTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaWxsPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGJva2VoIGhpZ2hsaWdodCBmaWxsIG1vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmVncm91bmQ9ZmFsc2VdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgbWF0ZXJpYWwgd2lsbCBiZSBhcHBsaWVkIHRvIGZvcmVncm91bmQgY29sb3JzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsbCA9IGZhbHNlLCBmb3JlZ3JvdW5kID0gZmFsc2UpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJva2VoTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgUEFTUzogZmlsbCA/IFwiMlwiIDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0yKG51bGwpLFxuICAgICAgICBjb2NCdWZmZXI6IG5ldyBVbmlmb3JtMihudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTIobmV3IFZlY3RvcjIoKSksXG4gICAgICAgIGtlcm5lbDY0OiBuZXcgVW5pZm9ybTIobnVsbCksXG4gICAgICAgIGtlcm5lbDE2OiBuZXcgVW5pZm9ybTIobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTIoMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzIsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb252b2x1dGlvbl9ib2tlaF9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIGlmIChmb3JlZ3JvdW5kKSB7XG4gICAgICB0aGlzLmRlZmluZXMuRk9SRUdST1VORCA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlS2VybmVsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY2lyY2xlIG9mIGNvbmZ1c2lvbiBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGNvY0J1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuY29jQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNpcmNsZSBvZiBjb25mdXNpb24gYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29jQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0Q29DQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5jb2NCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRTY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgYmx1ciBrZXJuZWwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW5lcmF0ZUtlcm5lbCgpIHtcbiAgICBjb25zdCBHT0xERU5fQU5HTEUgPSAyLjM5OTk2MzIzO1xuICAgIGNvbnN0IHBvaW50czY0ID0gbmV3IEZsb2F0NjRBcnJheSgxMjgpO1xuICAgIGNvbnN0IHBvaW50czE2ID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgbGV0IGk2NCA9IDAsIGkxNiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNxcnQ4MCA9IE1hdGguc3FydCg4MCk7IGkgPCA4MDsgKytpKSB7XG4gICAgICBjb25zdCB0aGV0YSA9IGkgKiBHT0xERU5fQU5HTEU7XG4gICAgICBjb25zdCByID0gTWF0aC5zcXJ0KGkpIC8gc3FydDgwO1xuICAgICAgY29uc3QgdSA9IHIgKiBNYXRoLmNvcyh0aGV0YSksIHYzID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgIGlmIChpICUgNSA9PT0gMCkge1xuICAgICAgICBwb2ludHMxNltpMTYrK10gPSB1O1xuICAgICAgICBwb2ludHMxNltpMTYrK10gPSB2MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50czY0W2k2NCsrXSA9IHU7XG4gICAgICAgIHBvaW50czY0W2k2NCsrXSA9IHYzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLmtlcm5lbDY0LnZhbHVlID0gcG9pbnRzNjQ7XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWwxNi52YWx1ZSA9IHBvaW50czE2O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXhlbCBzaXplLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2l6ZSgpIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB0ZXhlbCBoZWlnaHQuXG4gICAqL1xuICBzZXRUZXhlbFNpemUoeCwgeSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0JveEJsdXJNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMywgUGVyc3BlY3RpdmVDYW1lcmEsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMywgVW5pZm9ybSBhcyBVbmlmb3JtMywgVmVjdG9yMiBhcyBWZWN0b3IyMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvdXRpbHMvQmFja0NvbXBhdC5qc1xuaW1wb3J0IHsgTGluZWFyRW5jb2RpbmcsIFJFVklTSU9OLCBzUkdCRW5jb2RpbmcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VudW1zL0JsZW5kRnVuY3Rpb24uanNcbnZhciBCbGVuZEZ1bmN0aW9uID0ge1xuICBTS0lQOiA5LFxuICBTRVQ6IDMwLFxuICBBREQ6IDAsXG4gIEFMUEhBOiAxLFxuICBBVkVSQUdFOiAyLFxuICBDT0xPUjogMyxcbiAgQ09MT1JfQlVSTjogNCxcbiAgQ09MT1JfRE9ER0U6IDUsXG4gIERBUktFTjogNixcbiAgRElGRkVSRU5DRTogNyxcbiAgRElWSURFOiA4LFxuICBEU1Q6IDksXG4gIEVYQ0xVU0lPTjogMTAsXG4gIEhBUkRfTElHSFQ6IDExLFxuICBIQVJEX01JWDogMTIsXG4gIEhVRTogMTMsXG4gIElOVkVSVDogMTQsXG4gIElOVkVSVF9SR0I6IDE1LFxuICBMSUdIVEVOOiAxNixcbiAgTElORUFSX0JVUk46IDE3LFxuICBMSU5FQVJfRE9ER0U6IDE4LFxuICBMSU5FQVJfTElHSFQ6IDE5LFxuICBMVU1JTk9TSVRZOiAyMCxcbiAgTVVMVElQTFk6IDIxLFxuICBORUdBVElPTjogMjIsXG4gIE5PUk1BTDogMjMsXG4gIE9WRVJMQVk6IDI0LFxuICBQSU5fTElHSFQ6IDI1LFxuICBSRUZMRUNUOiAyNixcbiAgU0FUVVJBVElPTjogMjcsXG4gIFNDUkVFTjogMjgsXG4gIFNPRlRfTElHSFQ6IDI5LFxuICBTUkM6IDMwLFxuICBTVUJUUkFDVDogMzEsXG4gIFZJVklEX0xJR0hUOiAzMlxufTtcblxuLy8gc3JjL2VudW1zL0NvbG9yQ2hhbm5lbC5qc1xudmFyIENvbG9yQ2hhbm5lbCA9IHtcbiAgUkVEOiAwLFxuICBHUkVFTjogMSxcbiAgQkxVRTogMixcbiAgQUxQSEE6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9Db2xvclNwYWNlLmpzXG52YXIgTm9Db2xvclNwYWNlID0gXCJcIjtcbnZhciBTUkdCQ29sb3JTcGFjZSA9IFwic3JnYlwiO1xudmFyIExpbmVhclNSR0JDb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xudmFyIERpc3BsYXlQM0NvbG9yU3BhY2UgPSBcImRpc3BsYXktcDNcIjtcblxuLy8gc3JjL2VudW1zL0RlcHRoQ29weU1vZGUuanNcbnZhciBEZXB0aENvcHlNb2RlID0ge1xuICBGVUxMOiAwLFxuICBTSU5HTEU6IDFcbn07XG5cbi8vIHNyYy9lbnVtcy9EZXB0aFRlc3RTdHJhdGVneS5qc1xudmFyIERlcHRoVGVzdFN0cmF0ZWd5ID0ge1xuICBERUZBVUxUOiAwLFxuICBLRUVQX01BWF9ERVBUSDogMSxcbiAgRElTQ0FSRF9NQVhfREVQVEg6IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9FZGdlRGV0ZWN0aW9uTW9kZS5qc1xudmFyIEVkZ2VEZXRlY3Rpb25Nb2RlID0ge1xuICBERVBUSDogMCxcbiAgTFVNQTogMSxcbiAgQ09MT1I6IDJcbn07XG5cbi8vIHNyYy9lbnVtcy9FZmZlY3RBdHRyaWJ1dGUuanNcbnZhciBFZmZlY3RBdHRyaWJ1dGUgPSB7XG4gIE5PTkU6IDAsXG4gIERFUFRIOiAxLFxuICBDT05WT0xVVElPTjogMlxufTtcblxuLy8gc3JjL2VudW1zL0VmZmVjdFNoYWRlclNlY3Rpb24uanNcbnZhciBFZmZlY3RTaGFkZXJTZWN0aW9uID0ge1xuICBGUkFHTUVOVF9IRUFEOiBcIkZSQUdNRU5UX0hFQURcIixcbiAgRlJBR01FTlRfTUFJTl9VVjogXCJGUkFHTUVOVF9NQUlOX1VWXCIsXG4gIEZSQUdNRU5UX01BSU5fSU1BR0U6IFwiRlJBR01FTlRfTUFJTl9JTUFHRVwiLFxuICBWRVJURVhfSEVBRDogXCJWRVJURVhfSEVBRFwiLFxuICBWRVJURVhfTUFJTl9TVVBQT1JUOiBcIlZFUlRFWF9NQUlOX1NVUFBPUlRcIlxufTtcblxuLy8gc3JjL2VudW1zL0dsaXRjaE1vZGUuanNcbnZhciBHbGl0Y2hNb2RlID0ge1xuICBESVNBQkxFRDogMCxcbiAgU1BPUkFESUM6IDEsXG4gIENPTlNUQU5UX01JTEQ6IDIsXG4gIENPTlNUQU5UX1dJTEQ6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9LZXJuZWxTaXplLmpzXG52YXIgS2VybmVsU2l6ZSA9IHtcbiAgVkVSWV9TTUFMTDogMCxcbiAgU01BTEw6IDEsXG4gIE1FRElVTTogMixcbiAgTEFSR0U6IDMsXG4gIFZFUllfTEFSR0U6IDQsXG4gIEhVR0U6IDVcbn07XG5cbi8vIHNyYy9lbnVtcy9MVVRPcGVyYXRpb24uanNcbnZhciBMVVRPcGVyYXRpb24gPSB7XG4gIFNDQUxFX1VQOiBcImx1dC5zY2FsZXVwXCJcbn07XG5cbi8vIHNyYy9lbnVtcy9NYXNrRnVuY3Rpb24uanNcbnZhciBNYXNrRnVuY3Rpb24gPSB7XG4gIERJU0NBUkQ6IDAsXG4gIE1VTFRJUExZOiAxLFxuICBNVUxUSVBMWV9SR0JfU0VUX0FMUEhBOiAyLFxuICBNVUxUSVBMWV9SR0I6IDNcbn07XG5cbi8vIHNyYy9lbnVtcy9QcmVkaWNhdGlvbk1vZGUuanNcbnZhciBQcmVkaWNhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEVEOiAwLFxuICBERVBUSDogMSxcbiAgQ1VTVE9NOiAyXG59O1xuXG4vLyBzcmMvZW51bXMvU01BQVByZXNldC5qc1xudmFyIFNNQUFQcmVzZXQgPSB7XG4gIExPVzogMCxcbiAgTUVESVVNOiAxLFxuICBISUdIOiAyLFxuICBVTFRSQTogM1xufTtcblxuLy8gc3JjL2VudW1zL1RvbmVNYXBwaW5nTW9kZS5qc1xudmFyIFRvbmVNYXBwaW5nTW9kZSA9IHtcbiAgUkVJTkhBUkQ6IDAsXG4gIFJFSU5IQVJEMjogMSxcbiAgUkVJTkhBUkQyX0FEQVBUSVZFOiAyLFxuICBVTkNIQVJURUQyOiAzLFxuICBPUFRJTUlaRURfQ0lORU9OOiA0LFxuICBBQ0VTX0ZJTE1JQzogNSxcbiAgQUdYOiA2XG59O1xuXG4vLyBzcmMvZW51bXMvVmlnbmV0dGVUZWNobmlxdWUuanNcbnZhciBWaWduZXR0ZVRlY2huaXF1ZSA9IHtcbiAgREVGQVVMVDogMCxcbiAgRVNLSUw6IDFcbn07XG5cbi8vIHNyYy9lbnVtcy9XZWJHTEV4dGVuc2lvbi5qc1xudmFyIFdlYkdMRXh0ZW5zaW9uID0ge1xuICBERVJJVkFUSVZFUzogXCJkZXJpdmF0aXZlc1wiLFxuICBGUkFHX0RFUFRIOiBcImZyYWdEZXB0aFwiLFxuICBEUkFXX0JVRkZFUlM6IFwiZHJhd0J1ZmZlcnNcIixcbiAgU0hBREVSX1RFWFRVUkVfTE9EOiBcInNoYWRlclRleHR1cmVMT0RcIlxufTtcblxuLy8gc3JjL3V0aWxzL0JhY2tDb21wYXQuanNcbnZhciByZXZpc2lvbiA9IE51bWJlcihSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKTtcbnZhciB1c2VDb2xvclNwYWNlID0gcmV2aXNpb24gPj0gMTUyO1xudmFyIGVuY29kaW5nVG9Db2xvclNwYWNlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbTGluZWFyRW5jb2RpbmcsIExpbmVhclNSR0JDb2xvclNwYWNlXSxcbiAgW3NSR0JFbmNvZGluZywgU1JHQkNvbG9yU3BhY2VdXG5dKTtcbnZhciBjb2xvclNwYWNlVG9FbmNvZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW0xpbmVhclNSR0JDb2xvclNwYWNlLCBMaW5lYXJFbmNvZGluZ10sXG4gIFtTUkdCQ29sb3JTcGFjZSwgc1JHQkVuY29kaW5nXVxuXSk7XG5mdW5jdGlvbiBnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSB7XG4gIHJldHVybiByZW5kZXJlciA9PT0gbnVsbCA/IG51bGwgOiB1c2VDb2xvclNwYWNlID8gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA6IGVuY29kaW5nVG9Db2xvclNwYWNlLmdldChyZW5kZXJlci5vdXRwdXRFbmNvZGluZyk7XG59XG5mdW5jdGlvbiBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0ZXh0dXJlLCBjb2xvclNwYWNlKSB7XG4gIGlmICh0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1c2VDb2xvclNwYWNlKSB7XG4gICAgdGV4dHVyZS5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0dXJlLmVuY29kaW5nID0gY29sb3JTcGFjZVRvRW5jb2RpbmcuZ2V0KGNvbG9yU3BhY2UpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5VGV4dHVyZUNvbG9yU3BhY2Uoc3JjLCBkZXN0KSB7XG4gIGlmIChzcmMgPT09IG51bGwgfHwgZGVzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodXNlQ29sb3JTcGFjZSkge1xuICAgIGRlc3QuY29sb3JTcGFjZSA9IHNyYy5jb2xvclNwYWNlO1xuICB9IGVsc2Uge1xuICAgIGRlc3QuZW5jb2RpbmcgPSBzcmMuZW5jb2Rpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50U2hhZGVyKGZyYWdtZW50U2hhZGVyKSB7XG4gIGlmIChyZXZpc2lvbiA8IDE1NCkge1xuICAgIHJldHVybiBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiY29sb3JzcGFjZV9mcmFnbWVudFwiLCBcImVuY29kaW5nc19mcmFnbWVudFwiKTtcbiAgfVxuICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRvbmVNYXBwaW5nTW9kZShtb2RlKSB7XG4gIGlmIChyZXZpc2lvbiA8IDE2MCAmJiBtb2RlID09PSBUb25lTWFwcGluZ01vZGUuQUdYKSB7XG4gICAgY29uc29sZS53YXJuKFwiQWdYIHJlcXVpcmVzIHRocmVlIHIxNjAgb3IgaGlnaGVyLCBmYWxsaW5nIGJhY2sgdG8gQUNFUyBmaWxtaWNcIik7XG4gICAgbW9kZSA9IFRvbmVNYXBwaW5nTW9kZS5BQ0VTX0ZJTE1JQztcbiAgfVxuICByZXR1cm4gbW9kZTtcbn1cblxuLy8gc3JjL3V0aWxzL29ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wi5qc1xuZnVuY3Rpb24gb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKGRlcHRoLCBuZWFyLCBmYXIpIHtcbiAgcmV0dXJuIGRlcHRoICogKG5lYXIgLSBmYXIpIC0gbmVhcjtcbn1cblxuLy8gc3JjL3V0aWxzL3ZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aC5qc1xuZnVuY3Rpb24gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLCBuZWFyLCBmYXIpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KCh2aWV3WiArIG5lYXIpIC8gKG5lYXIgLSBmYXIpLCAwKSwgMSk7XG59XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5ib3guZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWZkZWYgQklMQVRFUkFMXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxudW5pZm9ybSB2ZWMyIGNhbWVyYU5lYXJGYXI7XFxuI2lmZGVmIE5PUk1BTF9ERVBUSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XFxuI2Vsc2VcXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbmZsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZW5kaWZcXG59XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbiNkZWZpbmUgbGluZWFyRGVwdGgodikgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKGdldFZpZXdaKHJlYWREZXB0aCh2KSksIGNhbWVyYU5lYXJGYXIueCwgY2FtZXJhTmVhckZhci55KVxcbiNlbHNlXFxuI2RlZmluZSBsaW5lYXJEZXB0aCh2KSByZWFkRGVwdGgodilcXG4jZW5kaWZcXG4jZW5kaWZcXG4jZGVmaW5lIGdldFRleGVsKHYpIHRleHR1cmUyRChpbnB1dEJ1ZmZlciwgdilcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMjt2YXJ5aW5nIHZlYzIgdlV2MDMsdlV2MDQsdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2LHZVdjA3LHZVdjA4O1xcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XFxuI2Vsc2VcXG51bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZVdjtcXG4jZW5kaWZcXG52b2lkIG1haW4oKXtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZlYzQgY1tdPXZlYzRbS0VSTkVMX1NJWkVfU1FdKGdldFRleGVsKHZVdjAwKSxnZXRUZXhlbCh2VXYwMSksZ2V0VGV4ZWwodlV2MDIpLGdldFRleGVsKHZVdjAzKSxnZXRUZXhlbCh2VXYwNCksZ2V0VGV4ZWwodlV2MDUpLGdldFRleGVsKHZVdjA2KSxnZXRUZXhlbCh2VXYwNyksZ2V0VGV4ZWwodlV2MDgpKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgeltdPWZsb2F0W0tFUk5FTF9TSVpFX1NRXShsaW5lYXJEZXB0aCh2VXYwMCksbGluZWFyRGVwdGgodlV2MDEpLGxpbmVhckRlcHRoKHZVdjAyKSxsaW5lYXJEZXB0aCh2VXYwMyksbGluZWFyRGVwdGgodlV2MDQpLGxpbmVhckRlcHRoKHZVdjA1KSxsaW5lYXJEZXB0aCh2VXYwNiksbGluZWFyRGVwdGgodlV2MDcpLGxpbmVhckRlcHRoKHZVdjA4KSk7XFxuI2VuZGlmXFxuI2VsaWYgS0VSTkVMX1NJWkUgPT0gNSAmJiBNQVhfVkFSWUlOR19WRUNUT1JTID49IDEzXFxudmVjNCBjW109dmVjNFtLRVJORUxfU0laRV9TUV0oZ2V0VGV4ZWwodlV2MDApLGdldFRleGVsKHZVdjAxKSxnZXRUZXhlbCh2VXYwMiksZ2V0VGV4ZWwodlV2MDMpLGdldFRleGVsKHZVdjA0KSxnZXRUZXhlbCh2VXYwNSksZ2V0VGV4ZWwodlV2MDYpLGdldFRleGVsKHZVdjA3KSxnZXRUZXhlbCh2VXYwOCksZ2V0VGV4ZWwodlV2MDkpLGdldFRleGVsKHZVdjEwKSxnZXRUZXhlbCh2VXYxMSksZ2V0VGV4ZWwodlV2MTIpLGdldFRleGVsKHZVdjEzKSxnZXRUZXhlbCh2VXYxNCksZ2V0VGV4ZWwodlV2MTUpLGdldFRleGVsKHZVdjE2KSxnZXRUZXhlbCh2VXYxNyksZ2V0VGV4ZWwodlV2MTgpLGdldFRleGVsKHZVdjE5KSxnZXRUZXhlbCh2VXYyMCksZ2V0VGV4ZWwodlV2MjEpLGdldFRleGVsKHZVdjIyKSxnZXRUZXhlbCh2VXYyMyksZ2V0VGV4ZWwodlV2MjQpKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgeltdPWZsb2F0W0tFUk5FTF9TSVpFX1NRXShsaW5lYXJEZXB0aCh2VXYwMCksbGluZWFyRGVwdGgodlV2MDEpLGxpbmVhckRlcHRoKHZVdjAyKSxsaW5lYXJEZXB0aCh2VXYwMyksbGluZWFyRGVwdGgodlV2MDQpLGxpbmVhckRlcHRoKHZVdjA1KSxsaW5lYXJEZXB0aCh2VXYwNiksbGluZWFyRGVwdGgodlV2MDcpLGxpbmVhckRlcHRoKHZVdjA4KSxsaW5lYXJEZXB0aCh2VXYwOSksbGluZWFyRGVwdGgodlV2MTApLGxpbmVhckRlcHRoKHZVdjExKSxsaW5lYXJEZXB0aCh2VXYxMiksbGluZWFyRGVwdGgodlV2MTMpLGxpbmVhckRlcHRoKHZVdjE0KSxsaW5lYXJEZXB0aCh2VXYxNSksbGluZWFyRGVwdGgodlV2MTYpLGxpbmVhckRlcHRoKHZVdjE3KSxsaW5lYXJEZXB0aCh2VXYxOCksbGluZWFyRGVwdGgodlV2MTkpLGxpbmVhckRlcHRoKHZVdjIwKSxsaW5lYXJEZXB0aCh2VXYyMSksbGluZWFyRGVwdGgodlV2MjIpLGxpbmVhckRlcHRoKHZVdjIzKSxsaW5lYXJEZXB0aCh2VXYyNCkpO1xcbiNlbmRpZlxcbiNlbmRpZlxcbnZlYzQgcmVzdWx0PXZlYzQoMC4wKTtcXG4jaWZkZWYgQklMQVRFUkFMXFxuZmxvYXQgdz0wLjA7XFxuI2lmIEtFUk5FTF9TSVpFID09IDMgfHwgKEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxMylcXG5mbG9hdCBjZW50ZXJEZXB0aD16W0tFUk5FTF9TSVpFX1NRX0hBTEZdO2ZvcihpbnQgaT0wO2k8S0VSTkVMX1NJWkVfU1E7KytpKXtmbG9hdCBkPXN0ZXAoYWJzKHpbaV0tY2VudGVyRGVwdGgpLERJU1RBTkNFX1RIUkVTSE9MRCk7cmVzdWx0Kz1jW2ldKmQ7dys9ZDt9XFxuI2Vsc2VcXG5mbG9hdCBjZW50ZXJEZXB0aD1saW5lYXJEZXB0aCh2VXYpO3ZlYzIgcz10ZXhlbFNpemUqc2NhbGU7Zm9yKGludCB4PS1LRVJORUxfU0laRV9IQUxGO3g8PUtFUk5FTF9TSVpFX0hBTEY7Kyt4KXtmb3IoaW50IHk9LUtFUk5FTF9TSVpFX0hBTEY7eTw9S0VSTkVMX1NJWkVfSEFMRjsrK3kpe3ZlYzIgY29vcmRzPXZVdit2ZWMyKHgseSkqczt2ZWM0IGM9Z2V0VGV4ZWwoY29vcmRzKTtmbG9hdCB6PSh4PT0wJiZ5PT0wKT9jZW50ZXJEZXB0aDpsaW5lYXJEZXB0aChjb29yZHMpO2Zsb2F0IGQ9c3RlcChhYnMoei1jZW50ZXJEZXB0aCksRElTVEFOQ0VfVEhSRVNIT0xEKTtyZXN1bHQrPWMqZDt3Kz1kO319XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXJlc3VsdC9tYXgodywxLjApO1xcbiNlbHNlXFxuI2lmIEtFUk5FTF9TSVpFID09IDMgfHwgKEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxMylcXG5mb3IoaW50IGk9MDtpPEtFUk5FTF9TSVpFX1NROysraSl7cmVzdWx0Kz1jW2ldO31cXG4jZWxzZVxcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7Zm9yKGludCB4PS1LRVJORUxfU0laRV9IQUxGO3g8PUtFUk5FTF9TSVpFX0hBTEY7Kyt4KXtmb3IoaW50IHk9LUtFUk5FTF9TSVpFX0hBTEY7eTw9S0VSTkVMX1NJWkVfSEFMRjsrK3kpe3Jlc3VsdCs9Z2V0VGV4ZWwodXYrdmVjMih4LHkpKnMpO319XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXJlc3VsdCpJTlZfS0VSTkVMX1NJWkVfU1E7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uYm94LnZlcnRcbnZhciBjb252b2x1dGlvbl9ib3hfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBzY2FsZTtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMjt2YXJ5aW5nIHZlYzIgdlV2MDMsdlV2MDQsdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2LHZVdjA3LHZVdjA4O1xcbiNlbGlmIEtFUk5FTF9TSVpFID09IDUgJiYgTUFYX1ZBUllJTkdfVkVDVE9SUyA+PSAxM1xcbnZhcnlpbmcgdmVjMiB2VXYwMCx2VXYwMSx2VXYwMix2VXYwMyx2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDUsdlV2MDYsdlV2MDcsdlV2MDgsdlV2MDk7dmFyeWluZyB2ZWMyIHZVdjEwLHZVdjExLHZVdjEyLHZVdjEzLHZVdjE0O3ZhcnlpbmcgdmVjMiB2VXYxNSx2VXYxNix2VXYxNyx2VXYxOCx2VXYxOTt2YXJ5aW5nIHZlYzIgdlV2MjAsdlV2MjEsdlV2MjIsdlV2MjMsdlV2MjQ7XFxuI2Vsc2VcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTtcXG4jaWYgS0VSTkVMX1NJWkUgPT0gM1xcbnZlYzIgcz10ZXhlbFNpemUqc2NhbGU7dlV2MDA9dXYrcyp2ZWMyKC0xLjAsLTEuMCk7dlV2MDE9dXYrcyp2ZWMyKDAuMCwtMS4wKTt2VXYwMj11ditzKnZlYzIoMS4wLC0xLjApO3ZVdjAzPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MDQ9dXY7dlV2MDU9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjA2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MDc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsMS4wKTtcXG4jZWxpZiBLRVJORUxfU0laRSA9PSA1XFxudmVjMiBzPXRleGVsU2l6ZSpzY2FsZTt2VXYwMD11ditzKnZlYzIoLTIuMCwtMi4wKTt2VXYwMT11ditzKnZlYzIoLTEuMCwtMi4wKTt2VXYwMj11ditzKnZlYzIoMC4wLC0yLjApO3ZVdjAzPXV2K3MqdmVjMigxLjAsLTIuMCk7dlV2MDQ9dXYrcyp2ZWMyKDIuMCwtMi4wKTt2VXYwNT11ditzKnZlYzIoLTIuMCwtMS4wKTt2VXYwNj11ditzKnZlYzIoLTEuMCwtMS4wKTt2VXYwNz11ditzKnZlYzIoMC4wLC0xLjApO3ZVdjA4PXV2K3MqdmVjMigxLjAsLTEuMCk7dlV2MDk9dXYrcyp2ZWMyKDIuMCwtMS4wKTt2VXYxMD11ditzKnZlYzIoLTIuMCwwLjApO3ZVdjExPXV2K3MqdmVjMigtMS4wLDAuMCk7dlV2MTI9dXY7dlV2MTM9dXYrcyp2ZWMyKDEuMCwwLjApO3ZVdjE0PXV2K3MqdmVjMigyLjAsMC4wKTt2VXYxNT11ditzKnZlYzIoLTIuMCwxLjApO3ZVdjE2PXV2K3MqdmVjMigtMS4wLDEuMCk7dlV2MTc9dXYrcyp2ZWMyKDAuMCwxLjApO3ZVdjE4PXV2K3MqdmVjMigxLjAsMS4wKTt2VXYxOT11ditzKnZlYzIoMi4wLDEuMCk7dlV2MjA9dXYrcyp2ZWMyKC0yLjAsMi4wKTt2VXYyMT11ditzKnZlYzIoLTEuMCwyLjApO3ZVdjIyPXV2K3MqdmVjMigwLjAsMi4wKTt2VXYyMz11ditzKnZlYzIoMS4wLDIuMCk7dlV2MjQ9dXYrcyp2ZWMyKDIuMCwyLjApO1xcbiNlbHNlXFxudlV2PXV2O1xcbiNlbmRpZlxcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0JveEJsdXJNYXRlcmlhbC5qc1xudmFyIEJveEJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYm94IGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpbGF0ZXJhbD1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIGJpbGF0ZXJhbCBibHVycmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9NV0gLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJpbGF0ZXJhbCA9IGZhbHNlLCBrZXJuZWxTaXplID0gNSB9ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkJveEJsdXJNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRElTVEFOQ0VfVEhSRVNIT0xEOiBcIjAuMVwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMyhudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTMobmV3IFZlY3RvcjIyKCkpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTMobmV3IFZlY3RvcjIyKCkpLFxuICAgICAgICBzY2FsZTogbmV3IFVuaWZvcm0zKDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmczLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fYm94X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2JveF9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuYmlsYXRlcmFsID0gYmlsYXRlcmFsO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5tYXhWYXJ5aW5nVmVjdG9ycyA9IDg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB2YXJ5aW5nIHZlY3RvcnMuXG4gICAqXG4gICAqIFNob3VsZCBiZSBzeW5jZWQgd2l0aCBgcmVuZGVyZXIuY2FwYWJpbGl0aWVzLm1heFZhcnlpbmdzYC4gRGVmYXVsdCBpcyA4LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG1heFZhcnlpbmdWZWN0b3JzKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIC0gTXVzdCBiZSBhbiBvZGQgbnVtYmVyXG4gICAqIC0gS2VybmVsIHNpemUgMyBhbmQgNSB1c2Ugb3B0aW1pemVkIGNvZGUgcGF0aHNcbiAgICogLSBEZWZhdWx0IGlzIDVcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFKTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAlIDIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBrZXJuZWwgc2l6ZSBtdXN0IGJlIGFuIG9kZCBudW1iZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVmaW5lcy5LRVJORUxfU0laRSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLktFUk5FTF9TSVpFX0hBTEYgPSBNYXRoLmZsb29yKHZhbHVlIC8gMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1EgPSAodmFsdWUgKiogMikudG9GaXhlZCgwKTtcbiAgICB0aGlzLmRlZmluZXMuS0VSTkVMX1NJWkVfU1FfSEFMRiA9IE1hdGguZmxvb3IodmFsdWUgKiogMiAvIDIpLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLklOVl9LRVJORUxfU0laRV9TUSA9ICgxIC8gdmFsdWUgKiogMikudG9GaXhlZCg2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBuZWFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbmVhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGZhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGZhcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyRmFyLnZhbHVlLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQSBjb21iaW5lZCBub3JtYWwtZGVwdGggYnVmZmVyLiBPdmVycmlkZXMge0BsaW5rIGRlcHRoQnVmZmVyfSBpZiBzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxEZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGJpbGF0ZXJhbCBmaWx0ZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgYmlsYXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuQklMQVRFUkFMICE9PSB2b2lkIDA7XG4gIH1cbiAgc2V0IGJpbGF0ZXJhbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkJJTEFURVJBTCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkJJTEFURVJBTDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiaWxhdGVyYWwgZmlsdGVyIGRpc3RhbmNlIHRocmVzaG9sZCBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZERpc3RhbmNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiAtb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKE51bWJlcih0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEKSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgICB0aGlzLmRlZmluZXMuRElTVEFOQ0VfVEhSRVNIT0xEID0gdGhyZXNob2xkLnRvRml4ZWQoMTIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXJGYXIudmFsdWUuc2V0KGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0NpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nLCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc0LCBQZXJzcGVjdGl2ZUNhbWVyYSBhcyBQZXJzcGVjdGl2ZUNhbWVyYTIsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsNCwgVW5pZm9ybSBhcyBVbmlmb3JtNCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY2lyY2xlLW9mLWNvbmZ1c2lvbi5mcmFnXG52YXIgY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGZvY3VzRGlzdGFuY2U7dW5pZm9ybSBmbG9hdCBmb2N1c1JhbmdlO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt2YXJ5aW5nIHZlYzIgdlV2O2Zsb2F0IHJlYWREZXB0aChjb25zdCBpbiB2ZWMyIHV2KXtcXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuZmxvYXQgZGVwdGg9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5mbG9hdCBkZXB0aD10ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aCpsb2cyKGNhbWVyYUZhcisxLjApKS0xLjA7ZmxvYXQgYT1jYW1lcmFGYXIvKGNhbWVyYUZhci1jYW1lcmFOZWFyKTtmbG9hdCBiPWNhbWVyYUZhcipjYW1lcmFOZWFyLyhjYW1lcmFOZWFyLWNhbWVyYUZhcik7ZGVwdGg9YStiL2Q7XFxuI2VuZGlmXFxucmV0dXJuIGRlcHRoO312b2lkIG1haW4oKXtmbG9hdCBkZXB0aD1yZWFkRGVwdGgodlV2KTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZmxvYXQgdmlld1o9cGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO2Zsb2F0IGxpbmVhckRlcHRoPXZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WixjYW1lcmFOZWFyLGNhbWVyYUZhcik7XFxuI2Vsc2VcXG5mbG9hdCBsaW5lYXJEZXB0aD1kZXB0aDtcXG4jZW5kaWZcXG5mbG9hdCBzaWduZWREaXN0YW5jZT1saW5lYXJEZXB0aC1mb2N1c0Rpc3RhbmNlO2Zsb2F0IG1hZ25pdHVkZT1zbW9vdGhzdGVwKDAuMCxmb2N1c1JhbmdlLGFicyhzaWduZWREaXN0YW5jZSkpO2dsX0ZyYWdDb2xvci5yZz1tYWduaXR1ZGUqdmVjMihzdGVwKHNpZ25lZERpc3RhbmNlLDAuMCksc3RlcCgwLjAsc2lnbmVkRGlzdGFuY2UpKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbC5qc1xudmFyIENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvQyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtNChudWxsKSxcbiAgICAgICAgZm9jdXNEaXN0YW5jZTogbmV3IFVuaWZvcm00KDApLFxuICAgICAgICBmb2N1c1JhbmdlOiBuZXcgVW5pZm9ybTQoMCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtNCgwLjMpLFxuICAgICAgICBjYW1lcmFGYXI6IG5ldyBVbmlmb3JtNCgxZTMpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc0LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY2lyY2xlX29mX2NvbmZ1c2lvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMuZm9jYWxMZW5ndGggPSB0aGlzLnVuaWZvcm1zLmZvY3VzUmFuZ2U7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbmVhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IG5lYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmFyIHBsYW5lIHNldHRpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZmFyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c0Rpc3RhbmNlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyBkaXN0YW5jZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c0Rpc3RhbmNlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c0Rpc3RhbmNlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c0Rpc3RhbmNlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY3VzIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9jdXNEaXN0YW5jZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIGdldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZm9jdXMgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c0Rpc3RhbmNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2N1cyBkaXN0YW5jZS5cbiAgICovXG4gIHNldEZvY3VzRGlzdGFuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZvY3VzRGlzdGFuY2UudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBmb2N1c1JhbmdlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzUmFuZ2U7XG4gIH1cbiAgc2V0IGZvY2FsTGVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZS4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlO1xuICB9XG4gIHNldCBmb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mb2N1c1JhbmdlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmb2N1cyByYW5nZSBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZEZvY3VzUmFuZ2UoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5mb2N1c1JhbmdlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRGb2N1c1JhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5mb2N1c1JhbmdlID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvY2FsIGxlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvY3VzUmFuZ2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKi9cbiAgZ2V0Rm9jYWxMZW5ndGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c1JhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb2NhbCBsZW5ndGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2N1c1JhbmdlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmb2NhbCBsZW5ndGguXG4gICAqL1xuICBzZXRGb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZm9jdXNSYW5nZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTIpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvS2F3YXNlQmx1ck1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc1LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDUsIFVuaWZvcm0gYXMgVW5pZm9ybTUsIFZlY3RvcjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmthd2FzZS5mcmFnXG52YXIgY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzQgc3VtPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYxKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKTtnbF9GcmFnQ29sb3I9c3VtKjAuMjU7XFxuI2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XFxufVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24ua2F3YXNlLnZlcnRcbnZhciBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjNCB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBrZXJuZWw7dW5pZm9ybSBmbG9hdCBzY2FsZTt2YXJ5aW5nIHZlYzIgdlV2MDt2YXJ5aW5nIHZlYzIgdlV2MTt2YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2b2lkIG1haW4oKXt2ZWMyIHV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dmVjMiBkVXY9KHRleGVsU2l6ZS54eSp2ZWMyKGtlcm5lbCkrdGV4ZWxTaXplLnp3KSpzY2FsZTt2VXYwPXZlYzIodXYueC1kVXYueCx1di55K2RVdi55KTt2VXYxPXZlYzIodXYueCtkVXYueCx1di55K2RVdi55KTt2VXYyPXZlYzIodXYueCtkVXYueCx1di55LWRVdi55KTt2VXYzPXZlYzIodXYueC1kVXYueCx1di55LWRVdi55KTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9LYXdhc2VCbHVyTWF0ZXJpYWwuanNcbnZhciBrZXJuZWxQcmVzZXRzID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDFdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMl0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAyLCAyLCAzXSksXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDIsIDMsIDQsIDQsIDVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMiwgMywgNCwgNSwgNywgOCwgOSwgMTBdKVxuXTtcbnZhciBLYXdhc2VCbHVyTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSB0ZXhlbFNpemUgcGFyYW0uXG4gICAqIEBwYXJhbSB7VmVjdG9yNH0gW3RleGVsU2l6ZV0gLSBEZXByZWNhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjQoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiS2F3YXNlQmx1ck1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm01KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtNShuZXcgVmVjdG9yNCgpKSxcbiAgICAgICAgc2NhbGU6IG5ldyBVbmlmb3JtNSgxKSxcbiAgICAgICAga2VybmVsOiBuZXcgVW5pZm9ybTUoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzUsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb252b2x1dGlvbl9rYXdhc2VfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMuc2V0VGV4ZWxTaXplKHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XG4gICAgdGhpcy5rZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNlcXVlbmNlIGZvciB0aGUgY3VycmVudCBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAgICovXG4gIGdldCBrZXJuZWxTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4ga2VybmVsUHJlc2V0c1t0aGlzLmtlcm5lbFNpemVdO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibHVyIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gVGhlIGtlcm5lbC5cbiAgICogQGRlcHJlY2F0ZWQgSW1wbGVtZW50YXRpb24gZGV0YWlsLCByZW1vdmVkIHdpdGggbm8gcmVwbGFjZW1lbnQuXG4gICAqL1xuICBnZXRLZXJuZWwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBrZXJuZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMua2VybmVsLnZhbHVlO1xuICB9XG4gIHNldCBrZXJuZWwodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmtlcm5lbC52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGtlcm5lbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGtlcm5lbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUga2VybmVsLlxuICAgKi9cbiAgc2V0S2VybmVsKHZhbHVlKSB7XG4gICAgdGhpcy5rZXJuZWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB4ID0gMSAvIHdpZHRoLCB5ID0gMSAvIGhlaWdodDtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSwgeCAqIDAuNSwgeSAqIDAuNSk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvQ29weU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc2LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDYsIFVuaWZvcm0gYXMgVW5pZm9ybTYgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvcHkuZnJhZ1xudmFyIGNvcHlfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9b3BhY2l0eSp0ZXhlbDtcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Db3B5TWF0ZXJpYWwuanNcbnZhciBDb3B5TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvcHkgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkNvcHlNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtNihudWxsKSxcbiAgICAgICAgb3BhY2l0eTogbmV3IFVuaWZvcm02KDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc2LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29weV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB1cGRhdGVGcmFnbWVudFNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIGdldE9wYWNpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3BhY2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIHNldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aENvbXBhcmlzb25NYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nNywgUGVyc3BlY3RpdmVDYW1lcmEgYXMgUGVyc3BlY3RpdmVDYW1lcmEzLCBSR0JBRGVwdGhQYWNraW5nLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDcsIFVuaWZvcm0gYXMgVW5pZm9ybTcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvbXBhcmlzb24uZnJhZ1xudmFyIGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdCA9IFwiI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7Y2VudHJvaWQgdmFyeWluZyBmbG9hdCB2Vmlld1o7Y2VudHJvaWQgdmFyeWluZyB2ZWM0IHZQcm9qVGV4Q29vcmQ7dm9pZCBtYWluKCl7XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG52ZWMyIHByb2pUZXhDb29yZD0odlByb2pUZXhDb29yZC54eS92UHJvalRleENvb3JkLncpKjAuNSswLjU7cHJvalRleENvb3JkPWNsYW1wKHByb2pUZXhDb29yZCwwLjAwMiwwLjk5OCk7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbmZsb2F0IGZyYWdDb29yZFo9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHByb2pUZXhDb29yZCkpO1xcbiNlbHNlXFxuZmxvYXQgZnJhZ0Nvb3JkWj10ZXh0dXJlMkQoZGVwdGhCdWZmZXIscHJvalRleENvb3JkKS5yO1xcbiNlbmRpZlxcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbmZsb2F0IHZpZXdaPW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihmcmFnQ29vcmRaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZW5kaWZcXG5mbG9hdCBkZXB0aFRlc3Q9KC12Vmlld1o+LXZpZXdaKT8xLjA6MC4wO2dsX0ZyYWdDb2xvci5yZz12ZWMyKDAuMCxkZXB0aFRlc3QpO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWNvbXBhcmlzb24udmVydFxudmFyIGRlcHRoX2NvbXBhcmlzb25fZGVmYXVsdDIgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZhcnlpbmcgZmxvYXQgdlZpZXdaO3ZhcnlpbmcgdmVjNCB2UHJvalRleENvb3JkO3ZvaWQgbWFpbigpe1xcbiNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuI2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcbnZWaWV3Wj1tdlBvc2l0aW9uLno7dlByb2pUZXhDb29yZD1nbF9Qb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwuanNcbnZhciBEZXB0aENvbXBhcmlzb25NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw3IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29tcGFyaXNvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbZGVwdGhUZXh0dXJlPW51bGxdIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVwdGhUZXh0dXJlID0gbnVsbCwgY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEZXB0aENvbXBhcmlzb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTcobnVsbCksXG4gICAgICAgIGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtNygwLjMpLFxuICAgICAgICBjYW1lcmFGYXI6IG5ldyBVbmlmb3JtNygxZTMpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc3LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBkZXB0aF9jb21wYXJpc29uX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPVJHQkFEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmcpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTMpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb3B5TWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMiwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nOCwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWw4LCBVbmlmb3JtIGFzIFVuaWZvcm04LCBWZWN0b3IyIGFzIFZlY3RvcjIzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb3B5LmZyYWdcbnZhciBkZXB0aF9jb3B5X2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxwYWNraW5nPlxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuI2lmZGVmIE5PUk1BTF9ERVBUSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XFxuI2Vsc2VcXG4jaWYgSU5QVVRfREVQVEhfUEFDS0lORyA9PSAzMjAxXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIElOUFVUX0RFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBJTlBVVF9ERVBUSF9QQUNLSU5HID09IE9VVFBVVF9ERVBUSF9QQUNLSU5HXFxuZ2xfRnJhZ0NvbG9yPXRleHR1cmUyRChkZXB0aEJ1ZmZlcix2VXYpO1xcbiNlbHNlXFxuZmxvYXQgZGVwdGg9cmVhZERlcHRoKHZVdik7XFxuI2lmIE9VVFBVVF9ERVBUSF9QQUNLSU5HID09IDMyMDFcXG5nbF9GcmFnQ29sb3I9KGRlcHRoPT0xLjApP3ZlYzQoMS4wKTpwYWNrRGVwdGhUb1JHQkEoZGVwdGgpO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yPXZlYzQodmVjMyhkZXB0aCksMS4wKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1jb3B5LnZlcnRcbnZhciBkZXB0aF9jb3B5X2RlZmF1bHQyID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcbiNpZiBERVBUSF9DT1BZX01PREUgPT0gMVxcbnVuaWZvcm0gdmVjMiB0ZXhlbFBvc2l0aW9uO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBERVBUSF9DT1BZX01PREUgPT0gMVxcbnZVdj10ZXhlbFBvc2l0aW9uO1xcbiNlbHNlXFxudlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7XFxuI2VuZGlmXFxuZ2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhDb3B5TWF0ZXJpYWwuanNcbnZhciBEZXB0aENvcHlNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWw4IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggY29weSBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRGVwdGhDb3B5TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgSU5QVVRfREVQVEhfUEFDS0lORzogXCIwXCIsXG4gICAgICAgIE9VVFBVVF9ERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgREVQVEhfQ09QWV9NT0RFOiBcIjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRlcHRoQnVmZmVyOiBuZXcgVW5pZm9ybTgobnVsbCksXG4gICAgICAgIHRleGVsUG9zaXRpb246IG5ldyBVbmlmb3JtOChuZXcgVmVjdG9yMjMoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzgsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aF9jb3B5X2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoX2NvcHlfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLmRlcHRoQ29weU1vZGUgPSBEZXB0aENvcHlNb2RlLkZVTEw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGRlcHRoQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlcHRoQnVmZmVyLnZhbHVlO1xuICB9XG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGlucHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgZ2V0IG91dHB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgc2V0IG91dHB1dERlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBpbnB1dERlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMikge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5pbnB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBUaGUgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIGdldElucHV0RGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXREZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSB2YWx1ZSAtIFRoZSBuZXcgaW5wdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIHNldElucHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLklOUFVUX0RFUFRIX1BBQ0tJTkcgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3V0cHV0RGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFRoZSBvdXRwdXQgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICovXG4gIGdldE91dHB1dERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5PVVRQVVRfREVQVEhfUEFDS0lORyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3V0cHV0RGVwdGhQYWNraW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gdmFsdWUgLSBUaGUgbmV3IG91dHB1dCBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0T3V0cHV0RGVwdGhQYWNraW5nKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLk9VVFBVVF9ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCB0ZXhlbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRleGVsUG9zaXRpb24udmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4ZWxQb3NpdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgcG9zaXRpb24uXG4gICAqL1xuICBnZXRUZXhlbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRleGVsUG9zaXRpb24udmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjcmVlbiBzcGFjZSBwb3NpdGlvbiB1c2VkIGZvciBzaW5nbGUtdGV4ZWwgY29weSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZhbHVlIC0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgc2V0VGV4ZWxQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxQb3NpdGlvbi52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhDb3B5TW9kZX1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoQ29weU1vZGU7XG4gIH1cbiAgc2V0IG1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmRlcHRoQ29weU1vZGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfQ09QWV9NT0RFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVwdGggY29weSBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtEZXB0aENvcHlNb2RlfSBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKi9cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBjb3B5IG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhDb3B5TW9kZX0gdmFsdWUgLSBUaGUgbmV3IG1vZGUuXG4gICAqL1xuICBzZXRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmczLCBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmc5LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDksIFVuaWZvcm0gYXMgVW5pZm9ybTksIFZlY3RvcjIgYXMgVmVjdG9yMjQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy5mcmFnXG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWZkZWYgRE9XTlNBTVBMRV9OT1JNQUxTXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBub3JtYWxCdWZmZXI7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7ZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xcbiNlbmRpZlxcbn1pbnQgZmluZEJlc3REZXB0aChjb25zdCBpbiBmbG9hdCBzYW1wbGVzWzRdKXtmbG9hdCBjPShzYW1wbGVzWzBdK3NhbXBsZXNbMV0rc2FtcGxlc1syXStzYW1wbGVzWzNdKSowLjI1O2Zsb2F0IGRpc3RhbmNlc1s0XTtkaXN0YW5jZXNbMF09YWJzKGMtc2FtcGxlc1swXSk7ZGlzdGFuY2VzWzFdPWFicyhjLXNhbXBsZXNbMV0pO2Rpc3RhbmNlc1syXT1hYnMoYy1zYW1wbGVzWzJdKTtkaXN0YW5jZXNbM109YWJzKGMtc2FtcGxlc1szXSk7ZmxvYXQgbWF4RGlzdGFuY2U9bWF4KG1heChkaXN0YW5jZXNbMF0sZGlzdGFuY2VzWzFdKSxtYXgoZGlzdGFuY2VzWzJdLGRpc3RhbmNlc1szXSkpO2ludCByZW1haW5pbmdbM107aW50IHJlamVjdGVkWzNdO2ludCBpLGosaztmb3IoaT0wLGo9MCxrPTA7aTw0OysraSl7aWYoZGlzdGFuY2VzW2ldPG1heERpc3RhbmNlKXtyZW1haW5pbmdbaisrXT1pO31lbHNle3JlamVjdGVkW2srK109aTt9fWZvcig7ajwzOysrail7cmVtYWluaW5nW2pdPXJlamVjdGVkWy0ta107fXZlYzMgcz12ZWMzKHNhbXBsZXNbcmVtYWluaW5nWzBdXSxzYW1wbGVzW3JlbWFpbmluZ1sxXV0sc2FtcGxlc1tyZW1haW5pbmdbMl1dKTtjPShzLngrcy55K3MueikvMy4wO2Rpc3RhbmNlc1swXT1hYnMoYy1zLngpO2Rpc3RhbmNlc1sxXT1hYnMoYy1zLnkpO2Rpc3RhbmNlc1syXT1hYnMoYy1zLnopO2Zsb2F0IG1pbkRpc3RhbmNlPW1pbihkaXN0YW5jZXNbMF0sbWluKGRpc3RhbmNlc1sxXSxkaXN0YW5jZXNbMl0pKTtmb3IoaT0wO2k8MzsrK2kpe2lmKGRpc3RhbmNlc1tpXT09bWluRGlzdGFuY2Upe2JyZWFrO319cmV0dXJuIHJlbWFpbmluZ1tpXTt9dm9pZCBtYWluKCl7ZmxvYXQgZFs0XTtkWzBdPXJlYWREZXB0aCh2VXYwKTtkWzFdPXJlYWREZXB0aCh2VXYxKTtkWzJdPXJlYWREZXB0aCh2VXYyKTtkWzNdPXJlYWREZXB0aCh2VXYzKTtpbnQgaW5kZXg9ZmluZEJlc3REZXB0aChkKTtcXG4jaWZkZWYgRE9XTlNBTVBMRV9OT1JNQUxTXFxudmVjMyBuWzRdO25bMF09dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYwKS5yZ2I7blsxXT10ZXh0dXJlMkQobm9ybWFsQnVmZmVyLHZVdjEpLnJnYjtuWzJdPXRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2MikucmdiO25bM109dGV4dHVyZTJEKG5vcm1hbEJ1ZmZlcix2VXYzKS5yZ2I7XFxuI2Vsc2VcXG52ZWMzIG5bNF07blswXT12ZWMzKDAuMCk7blsxXT12ZWMzKDAuMCk7blsyXT12ZWMzKDAuMCk7blszXT12ZWMzKDAuMCk7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yPXZlYzQobltpbmRleF0sZFtpbmRleF0pO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2RlcHRoLWRvd25zYW1wbGluZy52ZXJ0XG52YXIgZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZvaWQgbWFpbigpe3ZlYzIgdXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXV2O3ZVdjE9dmVjMih1di54LHV2LnkrdGV4ZWxTaXplLnkpO3ZVdjI9dmVjMih1di54K3RleGVsU2l6ZS54LHV2LnkpO3ZVdjM9dXYrdGV4ZWxTaXplO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0RlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWwuanNcbnZhciBEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBkb3duc2FtcGxpbmcgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoRG93bnNhbXBsaW5nTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBkZXB0aEJ1ZmZlcjogbmV3IFVuaWZvcm05KG51bGwpLFxuICAgICAgICBub3JtYWxCdWZmZXI6IG5ldyBVbmlmb3JtOShudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTkobmV3IFZlY3RvcjI0KCkpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmc5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUyA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkRPV05TQU1QTEVfTk9STUFMUztcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy5ub3JtYWxCdWZmZXIgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9EZXB0aE1hc2tNYXRlcmlhbC5qc1xuaW1wb3J0IHtcbiAgQWx3YXlzRGVwdGgsXG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNCxcbiAgRXF1YWxEZXB0aCxcbiAgR3JlYXRlckRlcHRoLFxuICBHcmVhdGVyRXF1YWxEZXB0aCxcbiAgTGVzc0RlcHRoLFxuICBMZXNzRXF1YWxEZXB0aCxcbiAgTmV2ZXJEZXB0aCxcbiAgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTAsXG4gIE5vdEVxdWFsRGVwdGgsXG4gIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNCxcbiAgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMCxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMTAsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjVcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9kZXB0aC1tYXNrLmZyYWdcbnZhciBkZXB0aF9tYXNrX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyMTtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIwO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXIxO1xcbiNlbmRpZlxcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gdmVjMiBjYW1lcmFOZWFyRmFyO2Zsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZW5kaWZcXG59dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2ZWMyIGRlcHRoO1xcbiNpZiBERVBUSF9QQUNLSU5HXzAgPT0gMzIwMVxcbmRlcHRoLng9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpKTtcXG4jZWxzZVxcbmRlcHRoLng9dGV4dHVyZTJEKGRlcHRoQnVmZmVyMCx2VXYpLnI7XFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC54KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC54PWErYi9kO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZiBERVBUSF9QQUNLSU5HXzEgPT0gMzIwMVxcbmRlcHRoLnk9dW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyMSx2VXYpKTtcXG4jZWxzZVxcbmRlcHRoLnk9dGV4dHVyZTJEKGRlcHRoQnVmZmVyMSx2VXYpLnI7XFxuI2lmZGVmIExPR19ERVBUSFxcbmZsb2F0IGQ9cG93KDIuMCxkZXB0aC55KmxvZzIoY2FtZXJhTmVhckZhci55KzEuMCkpLTEuMDtmbG9hdCBhPWNhbWVyYU5lYXJGYXIueS8oY2FtZXJhTmVhckZhci55LWNhbWVyYU5lYXJGYXIueCk7ZmxvYXQgYj1jYW1lcmFOZWFyRmFyLnkqY2FtZXJhTmVhckZhci54LyhjYW1lcmFOZWFyRmFyLngtY2FtZXJhTmVhckZhci55KTtkZXB0aC55PWErYi9kO1xcbiNlbmRpZlxcbiNlbmRpZlxcbmJvb2wgaXNNYXhEZXB0aD0oZGVwdGgueD09MS4wKTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZGVwdGgueD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoZ2V0Vmlld1ooZGVwdGgueCksY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7ZGVwdGgueT12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoZ2V0Vmlld1ooZGVwdGgueSksY2FtZXJhTmVhckZhci54LGNhbWVyYU5lYXJGYXIueSk7XFxuI2VuZGlmXFxuI2lmIERFUFRIX1RFU1RfU1RSQVRFR1kgPT0gMFxcbmJvb2wga2VlcD1kZXB0aFRlc3QoZGVwdGgueCxkZXB0aC55KTtcXG4jZWxpZiBERVBUSF9URVNUX1NUUkFURUdZID09IDFcXG5ib29sIGtlZXA9aXNNYXhEZXB0aHx8ZGVwdGhUZXN0KGRlcHRoLngsZGVwdGgueSk7XFxuI2Vsc2VcXG5ib29sIGtlZXA9IWlzTWF4RGVwdGgmJmRlcHRoVGVzdChkZXB0aC54LGRlcHRoLnkpO1xcbiNlbmRpZlxcbmlmKGtlZXApe2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTt9ZWxzZXtkaXNjYXJkO319XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvRGVwdGhNYXNrTWF0ZXJpYWwuanNcbnZhciBEZXB0aE1hc2tNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIG1hc2sgbWF0ZXJpYWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkRlcHRoTWFza01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIERFUFRIX0VQU0lMT046IFwiMC4wMDAxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMDogXCIwXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkdfMTogXCIwXCIsXG4gICAgICAgIERFUFRIX1RFU1RfU1RSQVRFR1k6IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTAobnVsbCksXG4gICAgICAgIGRlcHRoQnVmZmVyMDogbmV3IFVuaWZvcm0xMChudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXIxOiBuZXcgVW5pZm9ybTEwKG51bGwpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTEwKG5ldyBWZWN0b3IyNSgxLCAxKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzEwLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhfbWFza19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBjb21tb25fZGVmYXVsdFxuICAgIH0pO1xuICAgIHRoaXMuZGVwdGhNb2RlID0gTGVzc0RlcHRoO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGRlcHRoQnVmZmVyMCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIwLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZzAodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lOR18wID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjAgYW5kIGRlcHRoUGFja2luZzAgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIwKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc0KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjAgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcwID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kYXJ5IGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgZGVwdGhCdWZmZXIxKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlcjEudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlY29uZGFyeSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc31cbiAgICovXG4gIHNldCBkZXB0aFBhY2tpbmcxKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkdfMSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlciB0aGF0IHdpbGwgYmUgY29tcGFyZWQgd2l0aCB0aGUgYmFzZSBkZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEJ1ZmZlcjEgYW5kIGRlcHRoUGFja2luZzEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIxKGJ1ZmZlciwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc0KSB7XG4gICAgdGhpcy5kZXB0aEJ1ZmZlcjEgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcxID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIG1heGltdW0gZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFRlc3RTdHJhdGVneX1cbiAgICovXG4gIGdldCBtYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kpO1xuICB9XG4gIHNldCBtYXhEZXB0aFN0cmF0ZWd5KHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX1RFU1RfU1RSQVRFR1kgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBtYXhpbXVtIGRlcHRoIHZhbHVlcyBzaG91bGQgYmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlcHRoU3RyYXRlZ3kgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZWVwRmFyKCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgc2V0IGtlZXBGYXIodmFsdWUpIHtcbiAgICB0aGlzLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LktFRVBfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuRElTQ0FSRF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0RlcHRoVGVzdFN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRNYXhEZXB0aFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLm1heERlcHRoU3RyYXRlZ3k7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmF0ZWd5IGZvciBkZWFsaW5nIHdpdGggbWF4aW11bSBkZXB0aCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhEZXB0aFN0cmF0ZWd5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhUZXN0U3RyYXRlZ3l9IHZhbHVlIC0gVGhlIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0TWF4RGVwdGhTdHJhdGVneSh2YWx1ZSkge1xuICAgIHRoaXMubWF4RGVwdGhTdHJhdGVneSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNtYWxsIGVycm9yIHRocmVzaG9sZCB0aGF0IGlzIHVzZWQgZm9yIGBFcXVhbERlcHRoYCBhbmQgYE5vdEVxdWFsRGVwdGhgIHRlc3RzLiBEZWZhdWx0IGlzIGAxZS00YC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlcHNpbG9uKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04pO1xuICB9XG4gIHNldCBlcHNpbG9uKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX0VQU0lMT04gPSB2YWx1ZS50b0ZpeGVkKDE2KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBlcnJvciB0aHJlc2hvbGQgZm9yIGRlcHRoIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBlcnJvciB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFcHNpbG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVwc2lsb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGNvbXBhcmlzb24gZXJyb3IgdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXBzaWxvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGVycm9yIHRocmVzaG9sZC5cbiAgICovXG4gIHNldEVwc2lsb24odmFsdWUpIHtcbiAgICB0aGlzLmVwc2lsb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL01hdGVyaWFsc1xuICAgKiBAdHlwZSB7RGVwdGhNb2Rlc31cbiAgICovXG4gIGdldCBkZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuREVQVEhfTU9ERSk7XG4gIH1cbiAgc2V0IGRlcHRoTW9kZSh2YWx1ZSkge1xuICAgIGxldCBkZXB0aFRlc3Q7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBOZXZlckRlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImZhbHNlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbHdheXNEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJ0cnVlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA8PSBERVBUSF9FUFNJTE9OXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb3RFcXVhbERlcHRoOlxuICAgICAgICBkZXB0aFRlc3QgPSBcImFicyhkMSAtIGQwKSA+IERFUFRIX0VQU0lMT05cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlc3NEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+IGQxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXNzRXF1YWxEZXB0aDpcbiAgICAgICAgZGVwdGhUZXN0ID0gXCJkMCA+PSBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPD0gZDFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdyZWF0ZXJEZXB0aDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGRlcHRoVGVzdCA9IFwiZDAgPCBkMVwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVzLkRFUFRIX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lc1tcImRlcHRoVGVzdChkMCwgZDEpXCJdID0gZGVwdGhUZXN0O1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aE1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RGVwdGhNb2Rlc30gVGhlIGRlcHRoIG1vZGUuIERlZmF1bHQgaXMgYExlc3NEZXB0aGAuXG4gICAqL1xuICBnZXREZXB0aE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhNb2RlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7RGVwdGhNb2Rlc30gbW9kZSAtIFRoZSBkZXB0aCBtb2RlLlxuICAgKi9cbiAgc2V0RGVwdGhNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmRlcHRoTW9kZSA9IG1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhNCkge1xuICAgICAgICB0aGlzLmRlZmluZXMuUEVSU1BFQ1RJVkVfQ0FNRVJBID0gXCIxXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Eb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xuaW1wb3J0IHsgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTEsIFNoYWRlck1hdGVyaWFsIGFzIFNoYWRlck1hdGVyaWFsMTEsIFVuaWZvcm0gYXMgVW5pZm9ybTExLCBWZWN0b3IyIGFzIFZlY3RvcjI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jZGVmaW5lIFdFSUdIVF9JTk5FUiAwLjEyNVxcbiNkZWZpbmUgV0VJR0hUX09VVEVSIDAuMDU1NTU1NVxcbnZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjAwO3ZhcnlpbmcgdmVjMiB2VXYwMTt2YXJ5aW5nIHZlYzIgdlV2MDI7dmFyeWluZyB2ZWMyIHZVdjAzO3ZhcnlpbmcgdmVjMiB2VXYwNDt2YXJ5aW5nIHZlYzIgdlV2MDU7dmFyeWluZyB2ZWMyIHZVdjA2O3ZhcnlpbmcgdmVjMiB2VXYwNzt2YXJ5aW5nIHZlYzIgdlV2MDg7dmFyeWluZyB2ZWMyIHZVdjA5O3ZhcnlpbmcgdmVjMiB2VXYxMDt2YXJ5aW5nIHZlYzIgdlV2MTE7ZmxvYXQgY2xhbXBUb0JvcmRlcihjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gZmxvYXQodXYucz49MC4wJiZ1di5zPD0xLjAmJnV2LnQ+PTAuMCYmdXYudDw9MS4wKTt9dm9pZCBtYWluKCl7dmVjNCBjPXZlYzQoMC4wKTt2ZWM0IHc9V0VJR0hUX0lOTkVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwMCksY2xhbXBUb0JvcmRlcih2VXYwMSksY2xhbXBUb0JvcmRlcih2VXYwMiksY2xhbXBUb0JvcmRlcih2VXYwMykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDApO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDEpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDIpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDMpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwNCksY2xhbXBUb0JvcmRlcih2VXYwNSksY2xhbXBUb0JvcmRlcih2VXYwNiksY2xhbXBUb0JvcmRlcih2VXYwNykpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDQpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDUpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDYpO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDcpO3c9V0VJR0hUX09VVEVSKnZlYzQoY2xhbXBUb0JvcmRlcih2VXYwOCksY2xhbXBUb0JvcmRlcih2VXYwOSksY2xhbXBUb0JvcmRlcih2VXYxMCksY2xhbXBUb0JvcmRlcih2VXYxMSkpO2MrPXcueCp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDgpO2MrPXcueSp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MDkpO2MrPXcueip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTApO2MrPXcudyp0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MTEpO2MrPVdFSUdIVF9PVVRFUip0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9YztcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi5kb3duc2FtcGxpbmcudmVydFxudmFyIGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwMDt2YXJ5aW5nIHZlYzIgdlV2MDE7dmFyeWluZyB2ZWMyIHZVdjAyO3ZhcnlpbmcgdmVjMiB2VXYwMzt2YXJ5aW5nIHZlYzIgdlV2MDQ7dmFyeWluZyB2ZWMyIHZVdjA1O3ZhcnlpbmcgdmVjMiB2VXYwNjt2YXJ5aW5nIHZlYzIgdlV2MDc7dmFyeWluZyB2ZWMyIHZVdjA4O3ZhcnlpbmcgdmVjMiB2VXYwOTt2YXJ5aW5nIHZlYzIgdlV2MTA7dmFyeWluZyB2ZWMyIHZVdjExO3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjAwPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDEuMCk7dlV2MDE9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwxLjApO3ZVdjAyPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLC0xLjApO3ZVdjAzPXZVdit0ZXhlbFNpemUqdmVjMigxLjAsLTEuMCk7dlV2MDQ9dlV2K3RleGVsU2l6ZSp2ZWMyKC0yLjAsMi4wKTt2VXYwNT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLDIuMCk7dlV2MDY9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwyLjApO3ZVdjA3PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLDAuMCk7dlV2MDg9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwwLjApO3ZVdjA5PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLC0yLjApO3ZVdjEwPXZVdit0ZXhlbFNpemUqdmVjMigwLjAsLTIuMCk7dlV2MTE9dlV2K3RleGVsU2l6ZSp2ZWMyKDIuMCwtMi4wKTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLnh5LDEuMCwxLjApO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Eb3duc2FtcGxpbmdNYXRlcmlhbC5qc1xudmFyIERvd25zYW1wbGluZ01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDExIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZG93bnNhbXBsaW5nIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJEb3duc2FtcGxpbmdNYXRlcmlhbFwiLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTEobnVsbCksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0xMShuZXcgVmVjdG9yMjYoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzExLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZG93bnNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB1cGRhdGVGcmFnbWVudFNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9FZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNSwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTIsIFJFVklTSU9OIGFzIFJFVklTSU9OMiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxMiwgVW5pZm9ybSBhcyBVbmlmb3JtMTIsIFZlY3RvcjIgYXMgVmVjdG9yMjcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VkZ2UtZGV0ZWN0aW9uLmZyYWdcbnZhciBlZGdlX2RldGVjdGlvbl9kZWZhdWx0ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO1xcbiNpZiBUSFJFRV9SRVZJU0lPTiA8IDE0M1xcbiNkZWZpbmUgbHVtaW5hbmNlKHYpIGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UodilcXG4jZW5kaWZcXG4jaWYgRURHRV9ERVRFQ1RJT05fTU9ERSAhPSAwXFxudmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMVxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMCB8fCBQUkVESUNBVElPTl9NT0RFID09IDFcXG4jaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2VuZGlmXFxuZmxvYXQgcmVhZERlcHRoKGNvbnN0IGluIHZlYzIgdXYpe1xcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5yZXR1cm4gdW5wYWNrUkdCQVRvRGVwdGgodGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KSk7XFxuI2Vsc2VcXG5yZXR1cm4gdGV4dHVyZTJEKGRlcHRoQnVmZmVyLHV2KS5yO1xcbiNlbmRpZlxcbn12ZWMzIGdhdGhlck5laWdoYm9ycygpe2Zsb2F0IHA9cmVhZERlcHRoKHZVdik7ZmxvYXQgcExlZnQ9cmVhZERlcHRoKHZVdjApO2Zsb2F0IHBUb3A9cmVhZERlcHRoKHZVdjEpO3JldHVybiB2ZWMzKHAscExlZnQscFRvcCk7fVxcbiNlbGlmIFBSRURJQ0FUSU9OX01PREUgPT0gMlxcbnVuaWZvcm0gc2FtcGxlcjJEIHByZWRpY2F0aW9uQnVmZmVyO3ZlYzMgZ2F0aGVyTmVpZ2hib3JzKCl7ZmxvYXQgcD10ZXh0dXJlMkQocHJlZGljYXRpb25CdWZmZXIsdlV2KS5yO2Zsb2F0IHBMZWZ0PXRleHR1cmUyRChwcmVkaWNhdGlvbkJ1ZmZlcix2VXYwKS5yO2Zsb2F0IHBUb3A9dGV4dHVyZTJEKHByZWRpY2F0aW9uQnVmZmVyLHZVdjEpLnI7cmV0dXJuIHZlYzMocCxwTGVmdCxwVG9wKTt9XFxuI2VuZGlmXFxuI2lmIFBSRURJQ0FUSU9OX01PREUgIT0gMFxcbnZlYzIgY2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpe3ZlYzMgbmVpZ2hib3Vycz1nYXRoZXJOZWlnaGJvcnMoKTt2ZWMyIGRlbHRhPWFicyhuZWlnaGJvdXJzLnh4LW5laWdoYm91cnMueXopO3ZlYzIgZWRnZXM9c3RlcChQUkVESUNBVElPTl9USFJFU0hPTEQsZGVsdGEpO3JldHVybiBQUkVESUNBVElPTl9TQ0FMRSpFREdFX1RIUkVTSE9MRCooMS4wLVBSRURJQ0FUSU9OX1NUUkVOR1RIKmVkZ2VzKTt9XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgIT0gMFxcbnVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnZvaWQgbWFpbigpe1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFID09IDBcXG5jb25zdCB2ZWMyIHRocmVzaG9sZD12ZWMyKERFUFRIX1RIUkVTSE9MRCk7XFxuI2VsaWYgUFJFRElDQVRJT05fTU9ERSAhPSAwXFxudmVjMiB0aHJlc2hvbGQ9Y2FsY3VsYXRlUHJlZGljYXRlZFRocmVzaG9sZCgpO1xcbiNlbHNlXFxuY29uc3QgdmVjMiB0aHJlc2hvbGQ9dmVjMihFREdFX1RIUkVTSE9MRCk7XFxuI2VuZGlmXFxuI2lmIEVER0VfREVURUNUSU9OX01PREUgPT0gMFxcbnZlYzMgbmVpZ2hib3JzPWdhdGhlck5laWdoYm9ycygpO3ZlYzIgZGVsdGE9YWJzKG5laWdoYm9ycy54eC12ZWMyKG5laWdoYm9ycy55LG5laWdoYm9ycy56KSk7dmVjMiBlZGdlcz1zdGVwKHRocmVzaG9sZCxkZWx0YSk7aWYoZG90KGVkZ2VzLHZlYzIoMS4wKSk9PTAuMCl7ZGlzY2FyZDt9Z2xfRnJhZ0NvbG9yPXZlYzQoZWRnZXMsMC4wLDEuMCk7XFxuI2VsaWYgRURHRV9ERVRFQ1RJT05fTU9ERSA9PSAxXFxuZmxvYXQgbD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikucmdiKTtmbG9hdCBsTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApLnJnYik7ZmxvYXQgbFRvcD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnYik7dmVjNCBkZWx0YTtkZWx0YS54eT1hYnMobC12ZWMyKGxMZWZ0LGxUb3ApKTt2ZWMyIGVkZ2VzPXN0ZXAodGhyZXNob2xkLGRlbHRhLnh5KTtpZihkb3QoZWRnZXMsdmVjMigxLjApKT09MC4wKXtkaXNjYXJkO31mbG9hdCBsUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZ2IpO2Zsb2F0IGxCb3R0b209bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYzKS5yZ2IpO2RlbHRhLnp3PWFicyhsLXZlYzIobFJpZ2h0LGxCb3R0b20pKTt2ZWMyIG1heERlbHRhPW1heChkZWx0YS54eSxkZWx0YS56dyk7ZmxvYXQgbExlZnRMZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NCkucmdiKTtmbG9hdCBsVG9wVG9wPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NSkucmdiKTtkZWx0YS56dz1hYnModmVjMihsTGVmdCxsVG9wKS12ZWMyKGxMZWZ0TGVmdCxsVG9wVG9wKSk7bWF4RGVsdGE9bWF4KG1heERlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBmaW5hbERlbHRhPW1heChtYXhEZWx0YS54LG1heERlbHRhLnkpO2VkZ2VzLnh5Kj1zdGVwKGZpbmFsRGVsdGEsTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IqZGVsdGEueHkpO2dsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xcbiNlbGlmIEVER0VfREVURUNUSU9OX01PREUgPT0gMlxcbnZlYzQgZGVsdGE7dmVjMyBjPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnYjt2ZWMzIGNMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYwKS5yZ2I7dmVjMyB0PWFicyhjLWNMZWZ0KTtkZWx0YS54PW1heChtYXgodC5yLHQuZyksdC5iKTt2ZWMzIGNUb3A9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjEpLnJnYjt0PWFicyhjLWNUb3ApO2RlbHRhLnk9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzIgZWRnZXM9c3RlcCh0aHJlc2hvbGQsZGVsdGEueHkpO2lmKGRvdChlZGdlcyx2ZWMyKDEuMCkpPT0wLjApe2Rpc2NhcmQ7fXZlYzMgY1JpZ2h0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYyKS5yZ2I7dD1hYnMoYy1jUmlnaHQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY0JvdHRvbT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MykucmdiO3Q9YWJzKGMtY0JvdHRvbSk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7dmVjMiBtYXhEZWx0YT1tYXgoZGVsdGEueHksZGVsdGEuencpO3ZlYzMgY0xlZnRMZWZ0PXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXY0KS5yZ2I7dD1hYnMoYy1jTGVmdExlZnQpO2RlbHRhLno9bWF4KG1heCh0LnIsdC5nKSx0LmIpO3ZlYzMgY1RvcFRvcD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NSkucmdiO3Q9YWJzKGMtY1RvcFRvcCk7ZGVsdGEudz1tYXgobWF4KHQucix0LmcpLHQuYik7bWF4RGVsdGE9bWF4KG1heERlbHRhLnh5LGRlbHRhLnp3KTtmbG9hdCBmaW5hbERlbHRhPW1heChtYXhEZWx0YS54LG1heERlbHRhLnkpO2VkZ2VzKj1zdGVwKGZpbmFsRGVsdGEsTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IqZGVsdGEueHkpO2dsX0ZyYWdDb2xvcj12ZWM0KGVkZ2VzLDAuMCwxLjApO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VkZ2UtZGV0ZWN0aW9uLnZlcnRcbnZhciBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcXG52YXJ5aW5nIHZlYzIgdlV2Mjt2YXJ5aW5nIHZlYzIgdlV2Mzt2YXJ5aW5nIHZlYzIgdlV2NDt2YXJ5aW5nIHZlYzIgdlV2NTtcXG4jZW5kaWZcXG52b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTt2VXYwPXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLDAuMCk7dlV2MT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLC0xLjApO1xcbiNpZiBFREdFX0RFVEVDVElPTl9NT0RFICE9IDBcXG52VXYyPXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2VXYzPXZVdit0ZXhlbFNpemUqdmVjMigwLjAsMS4wKTt2VXY0PXZVdit0ZXhlbFNpemUqdmVjMigtMi4wLDAuMCk7dlV2NT12VXYrdGV4ZWxTaXplKnZlYzIoMC4wLC0yLjApO1xcbiNlbmRpZlxcbmdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VkZ2VEZXRlY3Rpb25NYXRlcmlhbC5qc1xudmFyIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVkZ2UgZGV0ZWN0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBUT0RPIFJlbW92ZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIHNjcmVlbiB0ZXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSBbbW9kZT1FZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUl0gLSBUaGUgZWRnZSBkZXRlY3Rpb24gbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyNygpLCBtb2RlID0gRWRnZURldGVjdGlvbk1vZGUuQ09MT1IpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkVkZ2VEZXRlY3Rpb25NYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBUSFJFRV9SRVZJU0lPTjogUkVWSVNJT04yLnJlcGxhY2UoL1xcRCsvZywgXCJcIiksXG4gICAgICAgIExPQ0FMX0NPTlRSQVNUX0FEQVBUQVRJT05fRkFDVE9SOiBcIjIuMFwiLFxuICAgICAgICBFREdFX1RIUkVTSE9MRDogXCIwLjFcIixcbiAgICAgICAgREVQVEhfVEhSRVNIT0xEOiBcIjAuMDFcIixcbiAgICAgICAgUFJFRElDQVRJT05fTU9ERTogXCIwXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1RIUkVTSE9MRDogXCIwLjAxXCIsXG4gICAgICAgIFBSRURJQ0FUSU9OX1NDQUxFOiBcIjIuMFwiLFxuICAgICAgICBQUkVESUNBVElPTl9TVFJFTkdUSDogXCIxLjBcIixcbiAgICAgICAgREVQVEhfUEFDS0lORzogXCIwXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMihudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTIobnVsbCksXG4gICAgICAgIHByZWRpY2F0aW9uQnVmZmVyOiBuZXcgVW5pZm9ybTEyKG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTIodGV4ZWxTaXplKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTIsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBlZGdlX2RldGVjdGlvbl9kZWZhdWx0MlxuICAgIH0pO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1vZGUgPSBtb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNSkge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RWRnZURldGVjdGlvbk1vZGV9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuRURHRV9ERVRFQ1RJT05fTU9ERSk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25Nb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkVER0VfREVURUNUSU9OX01PREUgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvbk1vZGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7RWRnZURldGVjdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0RWRnZURldGVjdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0VkZ2VEZXRlY3Rpb25Nb2RlfSB2YWx1ZSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKi9cbiAgc2V0RWRnZURldGVjdGlvbk1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguIERlZmF1bHQgaXMgMi4wLlxuICAgKlxuICAgKiBJZiBhIG5laWdoYm9yIGVkZ2UgaGFzIF9mYWN0b3JfIHRpbWVzIGJpZ2dlciBjb250cmFzdCB0aGFuIHRoZSBjdXJyZW50IGVkZ2UsIHRoZSBlZGdlIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB0byBlbGltaW5hdGUgc3B1cmlvdXMgY3Jvc3NpbmcgZWRnZXMgYW5kIGlzIGJhc2VkIG9uIHRoZSBmYWN0IHRoYXQgaWYgdGhlcmUgaXMgdG9vIG11Y2ggY29udHJhc3QgaW4gYVxuICAgKiBkaXJlY3Rpb24sIHRoZSBwZXJjZXB0dWFsIGNvbnRyYXN0IGluIHRoZSBvdGhlciBuZWlnaGJvcnMgd2lsbCBiZSBoaWRkZW4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuTE9DQUxfQ09OVFJBU1RfQURBUFRBVElPTl9GQUNUT1IpO1xuICB9XG4gIHNldCBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5MT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUiA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZhY3Rvci5cbiAgICovXG4gIGdldExvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGZhY3Rvci4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgZWRnZSBkZXRlY3Rpb24gbW9kZSBpcyBzZXQgdG8gREVQVEguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbG9jYWwgY29udHJhc3QgYWRhcHRhdGlvbiBmYWN0b3IuIERlZmF1bHQgaXMgMi4wLlxuICAgKi9cbiAgc2V0TG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLmxvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAwLjVdLlxuICAgKlxuICAgKiBBIGxvd2VyIHZhbHVlIHJlc3VsdHMgaW4gbW9yZSBlZGdlcyBiZWluZyBkZXRlY3RlZCBhdCB0aGUgZXhwZW5zZSBvZiBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogRm9yIGx1bWEtIGFuZCBjaHJvbWEtYmFzZWQgZWRnZSBkZXRlY3Rpb24sIDAuMSBpcyBhIHJlYXNvbmFibGUgdmFsdWUgYW5kIGFsbG93cyB0byBjYXRjaCBtb3N0IHZpc2libGUgZWRnZXMuIDAuMDVcbiAgICogaXMgYSByYXRoZXIgb3ZlcmtpbGwgdmFsdWUgdGhhdCBhbGxvd3MgdG8gY2F0Y2ggJ2VtIGFsbC4gRGFya2VyIHNjZW5lcyBtYXkgcmVxdWlyZSBhbiBldmVuIGxvd2VyIHRocmVzaG9sZC5cbiAgICpcbiAgICogSWYgZGVwdGgtYmFzZWQgZWRnZSBkZXRlY3Rpb24gaXMgdXNlZCwgdGhlIHRocmVzaG9sZCB3aWxsIGRlcGVuZCBvbiB0aGUgc2NlbmUgZGVwdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWRnZURldGVjdGlvblRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5FREdFX1RIUkVTSE9MRCk7XG4gIH1cbiAgc2V0IGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuRURHRV9USFJFU0hPTEQgPSB2YWx1ZS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfVEhSRVNIT0xEID0gKHZhbHVlICogMC4xKS50b0ZpeGVkKFwiNlwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZSBkZXRlY3Rpb24gdGhyZXNob2xkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZWRnZURldGVjdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aHJlc2hvbGQuXG4gICAqL1xuICBnZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDAuNV0uXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBtb2RlLlxuICAgKlxuICAgKiBQcmVkaWNhdGVkIHRocmVzaG9sZGluZyBhbGxvd3MgdG8gYmV0dGVyIHByZXNlcnZlIHRleHR1cmUgZGV0YWlscyBhbmQgdG8gaW1wcm92ZSBlZGdlIGRldGVjdGlvbiB1c2luZyBhbiBhZGRpdGlvbmFsXG4gICAqIGJ1ZmZlciBzdWNoIGFzIGEgbGlnaHQgYWNjdW11bGF0aW9uIG9yIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1ByZWRpY2F0aW9uTW9kZX1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvbk1vZGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fTU9ERSk7XG4gIH1cbiAgc2V0IHByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9NT0RFID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtQcmVkaWNhdGlvbk1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0UHJlZGljYXRpb25Nb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uTW9kZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uTW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1ByZWRpY2F0aW9uTW9kZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICovXG4gIHNldFByZWRpY2F0aW9uTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25Nb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IHByZWRpY2F0aW9uQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcmVkaWNhdGlvbkJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHByZWRpY2F0aW9uIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgcHJlZGljYXRpb24gYnVmZmVyLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25CdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByZWRpY2F0aW9uQnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZGljYXRpb25UaHJlc2hvbGQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fVEhSRVNIT0xEID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uVGhyZXNob2xkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRocmVzaG9sZC5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGlvbiB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25UaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLnByZWRpY2F0aW9uVGhyZXNob2xkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgc2NhbGVkIHdoZW4gdXNpbmcgcHJlZGljYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufFRleHR1cmV8TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuUFJFRElDQVRJT05fU0NBTEUpO1xuICB9XG4gIHNldCBwcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NDQUxFID0gdmFsdWUudG9GaXhlZChcIjZcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWRpY2F0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FsZS5cbiAgICovXG4gIGdldFByZWRpY2F0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRpb25TY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZGljYXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVkaWNhdGlvblNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS4gUmFuZ2U6IFsxLjAsIDUuMF0uXG4gICAqL1xuICBzZXRQcmVkaWNhdGlvblNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGlvblNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIERldGVybWluZXMgaG93IG11Y2ggdGhlIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZCBzaG91bGQgYmUgZGVjcmVhc2VkIGxvY2FsbHkgd2hlbiB1c2luZyBwcmVkaWNhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlBSRURJQ0FUSU9OX1NUUkVOR1RIKTtcbiAgfVxuICBzZXQgcHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5QUkVESUNBVElPTl9TVFJFTkdUSCA9IHZhbHVlLnRvRml4ZWQoXCI2XCIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVkaWNhdGlvbiBzdHJlbmd0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByZWRpY2F0aW9uU3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRQcmVkaWNhdGlvblN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0aW9uU3RyZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByZWRpY2F0aW9uIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZGljYXRpb25TdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3RyZW5ndGguIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJlZGljYXRpb25TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZGljYXRpb25TdHJlbmd0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvRWZmZWN0TWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNiwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMTMsIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNSwgUkVWSVNJT04gYXMgUkVWSVNJT04zLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDEzLCBVbmlmb3JtIGFzIFVuaWZvcm0xMywgVmVjdG9yMiBhcyBWZWN0b3IyOCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvZWZmZWN0LmZyYWdcbnZhciBlZmZlY3RfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2RlZmluZSBwYWNrRmxvYXRUb1JHQkEodikgcGFja0RlcHRoVG9SR0JBKHYpXFxuI2RlZmluZSB1bnBhY2tSR0JBVG9GbG9hdCh2KSB1bnBhY2tSR0JBVG9EZXB0aCh2KVxcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbGlmIGRlZmluZWQoR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gpXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO3VuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSBmbG9hdCBjYW1lcmFOZWFyO3VuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO3VuaWZvcm0gZmxvYXQgYXNwZWN0O3VuaWZvcm0gZmxvYXQgdGltZTt2YXJ5aW5nIHZlYzIgdlV2O1xcbiNpZiBUSFJFRV9SRVZJU0lPTiA8IDE0M1xcbiNkZWZpbmUgbHVtaW5hbmNlKHYpIGxpbmVhclRvUmVsYXRpdmVMdW1pbmFuY2UodilcXG4jZW5kaWZcXG4jaWYgVEhSRUVfUkVWSVNJT04gPj0gMTM3XFxudmVjNCBzUkdCVG9MaW5lYXIoY29uc3QgaW4gdmVjNCB2YWx1ZSl7cmV0dXJuIHZlYzQobWl4KHBvdyh2YWx1ZS5yZ2IqMC45NDc4NjcyOTg2K3ZlYzMoMC4wNTIxMzI3MDE0KSx2ZWMzKDIuNCkpLHZhbHVlLnJnYiowLjA3NzM5OTM4MDgsdmVjMyhsZXNzVGhhbkVxdWFsKHZhbHVlLnJnYix2ZWMzKDAuMDQwNDUpKSkpLHZhbHVlLmEpO31cXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufWZsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbnJldHVybiBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooZGVwdGgsY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xcbiNlbmRpZlxcbn12ZWMzIFJHQlRvSENWKGNvbnN0IGluIHZlYzMgUkdCKXt2ZWM0IFA9bWl4KHZlYzQoUkdCLmJnLC0xLjAsMi4wLzMuMCksdmVjNChSR0IuZ2IsMC4wLC0xLjAvMy4wKSxzdGVwKFJHQi5iLFJHQi5nKSk7dmVjNCBRPW1peCh2ZWM0KFAueHl3LFJHQi5yKSx2ZWM0KFJHQi5yLFAueXp4KSxzdGVwKFAueCxSR0IucikpO2Zsb2F0IEM9US54LW1pbihRLncsUS55KTtmbG9hdCBIPWFicygoUS53LVEueSkvKDYuMCpDK0VQU0lMT04pK1Eueik7cmV0dXJuIHZlYzMoSCxDLFEueCk7fXZlYzMgUkdCVG9IU0woY29uc3QgaW4gdmVjMyBSR0Ipe3ZlYzMgSENWPVJHQlRvSENWKFJHQik7ZmxvYXQgTD1IQ1Yuei1IQ1YueSowLjU7ZmxvYXQgUz1IQ1YueS8oMS4wLWFicyhMKjIuMC0xLjApK0VQU0lMT04pO3JldHVybiB2ZWMzKEhDVi54LFMsTCk7fXZlYzMgSHVlVG9SR0IoY29uc3QgaW4gZmxvYXQgSCl7ZmxvYXQgUj1hYnMoSCo2LjAtMy4wKS0xLjA7ZmxvYXQgRz0yLjAtYWJzKEgqNi4wLTIuMCk7ZmxvYXQgQj0yLjAtYWJzKEgqNi4wLTQuMCk7cmV0dXJuIGNsYW1wKHZlYzMoUixHLEIpLDAuMCwxLjApO312ZWMzIEhTTFRvUkdCKGNvbnN0IGluIHZlYzMgSFNMKXt2ZWMzIFJHQj1IdWVUb1JHQihIU0wueCk7ZmxvYXQgQz0oMS4wLWFicygyLjAqSFNMLnotMS4wKSkqSFNMLnk7cmV0dXJuKFJHQi0wLjUpKkMrSFNMLno7fUZSQUdNRU5UX0hFQUQgdm9pZCBtYWluKCl7RlJBR01FTlRfTUFJTl9VViB2ZWM0IGNvbG9yMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsVVYpO3ZlYzQgY29sb3IxPXZlYzQoMC4wKTtGUkFHTUVOVF9NQUlOX0lNQUdFIGNvbG9yMC5hPWNsYW1wKGNvbG9yMC5hLDAuMCwxLjApO2dsX0ZyYWdDb2xvcj1jb2xvcjA7XFxuI2lmZGVmIEVOQ09ERV9PVVRQVVRcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG4jZW5kaWZcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2VmZmVjdC52ZXJ0XG52YXIgZWZmZWN0X2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjt1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjt1bmlmb3JtIGZsb2F0IGFzcGVjdDt1bmlmb3JtIGZsb2F0IHRpbWU7dmFyeWluZyB2ZWMyIHZVdjtWRVJURVhfSEVBRCB2b2lkIG1haW4oKXt2VXY9cG9zaXRpb24ueHkqMC41KzAuNTtWRVJURVhfTUFJTl9TVVBQT1JUIGdsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0VmZmVjdE1hdGVyaWFsLmpzXG52YXIgRWZmZWN0TWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW3NoYWRlclBhcnRzXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW2RlZmluZXNdIC0gRGVwcmVjYXRlZC4gVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gW3VuaWZvcm1zXSAtIERlcHJlY2F0ZWQuIFVzZSBzZXRTaGFkZXJEYXRhIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkaXRoZXJpbmc9ZmFsc2VdIC0gRGVwcmVjYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNoYWRlclBhcnRzLCBkZWZpbmVzLCB1bmlmb3JtcywgY2FtZXJhLCBkaXRoZXJpbmcgPSBmYWxzZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRWZmZWN0TWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgVEhSRUVfUkVWSVNJT046IFJFVklTSU9OMy5yZXBsYWNlKC9cXEQrL2csIFwiXCIpLFxuICAgICAgICBERVBUSF9QQUNLSU5HOiBcIjBcIixcbiAgICAgICAgRU5DT0RFX09VVFBVVDogXCIxXCJcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xMyhudWxsKSxcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMTMobnVsbCksXG4gICAgICAgIHJlc29sdXRpb246IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTMobmV3IFZlY3RvcjI4KCkpLFxuICAgICAgICBjYW1lcmFOZWFyOiBuZXcgVW5pZm9ybTEzKDAuMyksXG4gICAgICAgIGNhbWVyYUZhcjogbmV3IFVuaWZvcm0xMygxZTMpLFxuICAgICAgICBhc3BlY3Q6IG5ldyBVbmlmb3JtMTMoMSksXG4gICAgICAgIHRpbWU6IG5ldyBVbmlmb3JtMTMoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzEzLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBkaXRoZXJpbmdcbiAgICB9KTtcbiAgICBpZiAoc2hhZGVyUGFydHMpIHtcbiAgICAgIHRoaXMuc2V0U2hhZGVyUGFydHMoc2hhZGVyUGFydHMpO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lcykge1xuICAgICAgdGhpcy5zZXREZWZpbmVzKGRlZmluZXMpO1xuICAgIH1cbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgIH1cbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgZGVwdGhCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWU7XG4gIH1cbiAgc2V0IGRlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggcGFja2luZyBzdHJhdGVneS5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9XG4gICAqL1xuICBnZXQgZGVwdGhQYWNraW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkRFUFRIX1BBQ0tJTkcpO1xuICB9XG4gIHNldCBkZXB0aFBhY2tpbmcodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuREVQVEhfUEFDS0lORyA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoQnVmZmVyIGFuZCBkZXB0aFBhY2tpbmcgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBidWZmZXIgLSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhCdWZmZXIoYnVmZmVyLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzYpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtFZmZlY3RTaGFkZXJEYXRhfSBkYXRhIC0gVGhlIHNoYWRlciBkYXRhLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldFNoYWRlckRhdGEoZGF0YSkge1xuICAgIHRoaXMuc2V0U2hhZGVyUGFydHMoZGF0YS5zaGFkZXJQYXJ0cyk7XG4gICAgdGhpcy5zZXREZWZpbmVzKGRhdGEuZGVmaW5lcyk7XG4gICAgdGhpcy5zZXRVbmlmb3JtcyhkYXRhLnVuaWZvcm1zKTtcbiAgICB0aGlzLnNldEV4dGVuc2lvbnMoZGF0YS5leHRlbnNpb25zKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyIHBhcnRzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IHNoYWRlclBhcnRzIC0gQSBjb2xsZWN0aW9uIG9mIHNoYWRlciBzbmlwcGV0cy4gU2VlIHtAbGluayBFZmZlY3RTaGFkZXJTZWN0aW9ufS5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRTaGFkZXJQYXJ0cyhzaGFkZXJQYXJ0cykge1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBlZmZlY3RfZGVmYXVsdC5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCkgfHwgXCJcIikucmVwbGFjZShFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYpIHx8IFwiXCIpLnJlcGxhY2UoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFKSB8fCBcIlwiKTtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGVmZmVjdF9kZWZhdWx0Mi5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX0hFQUQsIHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFEKSB8fCBcIlwiKS5yZXBsYWNlKEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCwgc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uVkVSVEVYX01BSU5fU1VQUE9SVCkgfHwgXCJcIik7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaGFkZXIgbWFjcm9zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFN0cmluZz59IGRlZmluZXMgLSBBIGNvbGxlY3Rpb24gb2YgcHJlcHJvY2Vzc29yIG1hY3JvIGRlZmluaXRpb25zLlxuICAgKiBAcmV0dXJuIHtFZmZlY3RNYXRlcmlhbH0gVGhpcyBtYXRlcmlhbC5cbiAgICovXG4gIHNldERlZmluZXMoZGVmaW5lcykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGVmaW5lcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRoaXMuZGVmaW5lc1tlbnRyeVswXV0gPSBlbnRyeVsxXTtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNoYWRlciB1bmlmb3Jtcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNoYWRlckRhdGEgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXA8U3RyaW5nLCBVbmlmb3JtPn0gdW5pZm9ybXMgLSBBIGNvbGxlY3Rpb24gb2YgdW5pZm9ybXMuXG4gICAqIEByZXR1cm4ge0VmZmVjdE1hdGVyaWFsfSBUaGlzIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0VW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHVuaWZvcm1zLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy51bmlmb3Jtc1tlbnRyeVswXV0gPSBlbnRyeVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlcXVpcmVkIHNoYWRlciBleHRlbnNpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2hhZGVyRGF0YSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1NldDxXZWJHTEV4dGVuc2lvbj59IGV4dGVuc2lvbnMgLSBBIGNvbGxlY3Rpb24gb2YgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybiB7RWZmZWN0TWF0ZXJpYWx9IFRoaXMgbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBleHRlbnNpb25zKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvdXRwdXQgZW5jb2RpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZW5jb2RlT3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuRU5DT0RFX09VVFBVVCAhPT0gdm9pZCAwO1xuICB9XG4gIHNldCBlbmNvZGVPdXRwdXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5lbmNvZGVPdXRwdXQgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLkVOQ09ERV9PVVRQVVQgPSBcIjFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRU5DT0RFX09VVFBVVDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3V0cHV0IGVuY29kaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmNvZGVPdXRwdXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvdXRwdXQgZW5jb2RpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzT3V0cHV0RW5jb2RpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlT3V0cHV0O1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIG91dHB1dCBlbmNvZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuY29kZU91dHB1dCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBvdXRwdXQgZW5jb2Rpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRPdXRwdXRFbmNvZGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmVuY29kZU91dHB1dCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGltZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZTtcbiAgfVxuICBzZXQgdGltZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWx0YSB0aW1lLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGltZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgZGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0RGVsdGFUaW1lKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlICs9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb3B5Q2FtZXJhU2V0dGluZ3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICB0aGlzLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHNldHRpbmdzIG9mIHRoZSBnaXZlbiBjYW1lcmEuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIGNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcbiAgICBpZiAoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgdW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgIHVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IHdpZHRoIC8gaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBBbiBlbnVtZXJhdGlvbiBvZiBzaGFkZXIgY29kZSBwbGFjZWhvbGRlcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBFZmZlY3RTaGFkZXJTZWN0aW9uIGluc3RlYWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIEVmZmVjdFNoYWRlclNlY3Rpb247XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvR2F1c3NpYW5CbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE0LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE0LCBVbmlmb3JtIGFzIFVuaWZvcm0xNCwgVmVjdG9yMiBhcyBWZWN0b3IyOSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ2F1c3NpYW4uZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiBrZXJuZWxbU1RFUFNdO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O3ZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCByZXN1bHQ9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikqa2VybmVsWzBdLnk7Zm9yKGludCBpPTE7aTxTVEVQUzsrK2kpe3ZlYzIgb2Zmc2V0PWtlcm5lbFtpXS54KnZPZmZzZXQ7dmVjNCBjMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2K29mZnNldCk7dmVjNCBjMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2LW9mZnNldCk7cmVzdWx0Kz0oYzArYzEpKmtlcm5lbFtpXS55O31nbF9GcmFnQ29sb3I9cmVzdWx0O1xcbiNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLmdhdXNzaWFuLnZlcnRcbnZhciBjb252b2x1dGlvbl9nYXVzc2lhbl9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgZGlyZWN0aW9uO3VuaWZvcm0gZmxvYXQgc2NhbGU7dmFyeWluZyB2ZWMyIHZPZmZzZXQ7dmFyeWluZyB2ZWMyIHZVdjt2b2lkIG1haW4oKXt2T2Zmc2V0PWRpcmVjdGlvbip0ZXhlbFNpemUqc2NhbGU7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvR2F1c3NpYW5CbHVyTWF0ZXJpYWwuanNcbnZhciBHYXVzc2lhbkJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxNCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPTM1XSAtIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsga2VybmVsU2l6ZSA9IDM1IH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiR2F1c3NpYW5CbHVyTWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE0KG51bGwpLFxuICAgICAgICB0ZXhlbFNpemU6IG5ldyBVbmlmb3JtMTQobmV3IFZlY3RvcjI5KCkpLFxuICAgICAgICBkaXJlY3Rpb246IG5ldyBVbmlmb3JtMTQobmV3IFZlY3RvcjI5KCkpLFxuICAgICAgICBrZXJuZWw6IG5ldyBVbmlmb3JtMTQobnVsbCksXG4gICAgICAgIHNjYWxlOiBuZXcgVW5pZm9ybTE0KDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxNCxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMuX2tlcm5lbFNpemUgPSAwO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuX2tlcm5lbFNpemUgPSB2YWx1ZTtcbiAgICB0aGlzLmdlbmVyYXRlS2VybmVsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlyZWN0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBrZXJuZWwgc2NhbGUuIFZhbHVlcyBncmVhdGVyIHRoYW4gMS4wIG1heSBpbnRyb2R1Y2UgYXJ0aWZhY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBHYXVzcyBrZXJuZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0ga2VybmVsU2l6ZSAtIFRoZSBrZXJuZWwgc2l6ZS4gU2hvdWxkIGJlIGFuIG9kZCBudW1iZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW5lcmF0ZUtlcm5lbChrZXJuZWxTaXplKSB7XG4gICAgY29uc3Qga2VybmVsID0gbmV3IEdhdXNzS2VybmVsKGtlcm5lbFNpemUpO1xuICAgIGNvbnN0IHN0ZXBzID0ga2VybmVsLmxpbmVhclN0ZXBzO1xuICAgIGNvbnN0IGtlcm5lbERhdGEgPSBuZXcgRmxvYXQ2NEFycmF5KHN0ZXBzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgc3RlcHM7ICsraSkge1xuICAgICAga2VybmVsRGF0YVtqKytdID0ga2VybmVsLmxpbmVhck9mZnNldHNbaV07XG4gICAgICBrZXJuZWxEYXRhW2orK10gPSBrZXJuZWwubGluZWFyV2VpZ2h0c1tpXTtcbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5rZXJuZWwudmFsdWUgPSBrZXJuZWxEYXRhO1xuICAgIHRoaXMuZGVmaW5lcy5TVEVQUyA9IHN0ZXBzLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE1LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE1LCBVbmlmb3JtIGFzIFVuaWZvcm0xNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24uZ29kLXJheXMuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX2dvZF9yYXlzX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMiBsaWdodFBvc2l0aW9uO3VuaWZvcm0gZmxvYXQgZXhwb3N1cmU7dW5pZm9ybSBmbG9hdCBkZWNheTt1bmlmb3JtIGZsb2F0IGRlbnNpdHk7dW5pZm9ybSBmbG9hdCB3ZWlnaHQ7dW5pZm9ybSBmbG9hdCBjbGFtcE1heDt2YXJ5aW5nIHZlYzIgdlV2O3ZvaWQgbWFpbigpe3ZlYzIgY29vcmQ9dlV2O3ZlYzIgZGVsdGE9bGlnaHRQb3NpdGlvbi1jb29yZDtkZWx0YSo9MS4wL1NBTVBMRVNfRkxPQVQqZGVuc2l0eTtmbG9hdCBpbGx1bWluYXRpb25EZWNheT0xLjA7dmVjNCBjb2xvcj12ZWM0KDAuMCk7Zm9yKGludCBpPTA7aTxTQU1QTEVTX0lOVDsrK2kpe2Nvb3JkKz1kZWx0YTt2ZWM0IHRleGVsPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZCk7dGV4ZWwqPWlsbHVtaW5hdGlvbkRlY2F5KndlaWdodDtjb2xvcis9dGV4ZWw7aWxsdW1pbmF0aW9uRGVjYXkqPWRlY2F5O31nbF9GcmFnQ29sb3I9Y2xhbXAoY29sb3IqZXhwb3N1cmUsMC4wLGNsYW1wTWF4KTtcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9Hb2RSYXlzTWF0ZXJpYWwuanNcbnZhciBHb2RSYXlzTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBnb2QgcmF5cyBtYXRlcmlhbC5cbiAgICpcbiAgICogVE9ETyBSZW1vdmUgbGlnaHRQb3NpdGlvbiBwYXJhbS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBsaWdodFBvc2l0aW9uIC0gRGVwcmVjYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxpZ2h0UG9zaXRpb24pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkdvZFJheXNNYXRlcmlhbFwiLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBTQU1QTEVTX0lOVDogXCI2MFwiLFxuICAgICAgICBTQU1QTEVTX0ZMT0FUOiBcIjYwLjBcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE1KG51bGwpLFxuICAgICAgICBsaWdodFBvc2l0aW9uOiBuZXcgVW5pZm9ybTE1KGxpZ2h0UG9zaXRpb24pLFxuICAgICAgICBkZW5zaXR5OiBuZXcgVW5pZm9ybTE1KDEpLFxuICAgICAgICBkZWNheTogbmV3IFVuaWZvcm0xNSgxKSxcbiAgICAgICAgd2VpZ2h0OiBuZXcgVW5pZm9ybTE1KDEpLFxuICAgICAgICBleHBvc3VyZTogbmV3IFVuaWZvcm0xNSgxKSxcbiAgICAgICAgY2xhbXBNYXg6IG5ldyBVbmlmb3JtMTUoMSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE1LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogY29udm9sdXRpb25fZ29kX3JheXNfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAqL1xuICBnZXQgbGlnaHRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxpZ2h0UG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0TGlnaHRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY3JlZW4gc3BhY2UgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxpZ2h0UG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIHNldExpZ2h0UG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmxpZ2h0UG9zaXRpb24udmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlO1xuICB9XG4gIHNldCBkZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRlbnNpdHkuXG4gICAqL1xuICBnZXREZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRlbnNpdHkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZW5zaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkZW5zaXR5LlxuICAgKi9cbiAgc2V0RGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVjYXkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZGVjYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWU7XG4gIH1cbiAgc2V0IGRlY2F5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWNheS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNheS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlY2F5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRlY2F5LlxuICAgKi9cbiAgZ2V0RGVjYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGVjYXkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlY2F5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVjYXkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGRlY2F5LlxuICAgKi9cbiAgc2V0RGVjYXkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmRlY2F5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3ZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLndlaWdodC52YWx1ZTtcbiAgfVxuICBzZXQgd2VpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHdlaWdodC5cbiAgICovXG4gIGdldFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgd2VpZ2h0LlxuICAgKi9cbiAgc2V0V2VpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy53ZWlnaHQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGV4cG9zdXJlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGV4cG9zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlO1xuICB9XG4gIHNldCBleHBvc3VyZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZXhwb3N1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhwb3N1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHBvc3VyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBleHBvc3VyZS5cbiAgICovXG4gIGdldEV4cG9zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmV4cG9zdXJlLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBvc3VyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4cG9zdXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBleHBvc3VyZS5cbiAgICovXG4gIHNldEV4cG9zdXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5leHBvc3VyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlO1xuICB9XG4gIHNldCBtYXhJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4SW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1heGltdW0gbGlnaHQgaW50ZW5zaXR5LlxuICAgKi9cbiAgZ2V0TWF4SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXhpbXVtIGxpZ2h0IGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heEludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWF4aW11bSBsaWdodCBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRNYXhJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmNsYW1wTWF4LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgdGhpcy5kZWZpbmVzLlNBTVBMRVNfSU5UID0gcy50b0ZpeGVkKDApO1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0ZMT0FUID0gcy50b0ZpeGVkKDEpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzYW1wbGVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNhbXBsZSBjb3VudC5cbiAgICovXG4gIGdldFNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgc2V0U2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL0x1bWluYW5jZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxNiwgUkVWSVNJT04gYXMgUkVWSVNJT040LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE2LCBVbmlmb3JtIGFzIFVuaWZvcm0xNiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvbHVtaW5hbmNlLmZyYWdcbnZhciBsdW1pbmFuY2VfZGVmYXVsdCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaWYgVEhSRUVfUkVWSVNJT04gPCAxNDNcXG4jZGVmaW5lIGx1bWluYW5jZSh2KSBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKHYpXFxuI2VuZGlmXFxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxuI2lmZGVmIFJBTkdFXFxudW5pZm9ybSB2ZWMyIHJhbmdlO1xcbiNlbGlmIGRlZmluZWQoVEhSRVNIT0xEKVxcbnVuaWZvcm0gZmxvYXQgdGhyZXNob2xkO3VuaWZvcm0gZmxvYXQgc21vb3RoaW5nO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7dmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtmbG9hdCBsPWx1bWluYW5jZSh0ZXhlbC5yZ2IpO1xcbiNpZmRlZiBSQU5HRVxcbmZsb2F0IGxvdz1zdGVwKHJhbmdlLngsbCk7ZmxvYXQgaGlnaD1zdGVwKGwscmFuZ2UueSk7bCo9bG93KmhpZ2g7XFxuI2VsaWYgZGVmaW5lZChUSFJFU0hPTEQpXFxubD1zbW9vdGhzdGVwKHRocmVzaG9sZCx0aHJlc2hvbGQrc21vb3RoaW5nLGwpKmw7XFxuI2VuZGlmXFxuI2lmZGVmIENPTE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQodGV4ZWwucmdiKmNsYW1wKGwsMC4wLDEuMCksbCk7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3I9dmVjNChsKTtcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvTHVtaW5hbmNlTWF0ZXJpYWwuanNcbnZhciBMdW1pbmFuY2VNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxNiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29sb3JPdXRwdXQ9ZmFsc2VdIC0gRGVmaW5lcyB3aGV0aGVyIHRoZSBzaGFkZXIgc2hvdWxkIG91dHB1dCBjb2xvcnMgc2NhbGVkIHdpdGggdGhlaXIgbHVtaW5hbmNlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtsdW1pbmFuY2VSYW5nZV0gLSBJZiBwcm92aWRlZCwgdGhlIHNoYWRlciB3aWxsIG1hc2sgb3V0IHRleGVscyB0aGF0IGFyZW4ndCBpbiB0aGUgc3BlY2lmaWVkIGx1bWluYW5jZSByYW5nZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbG9yT3V0cHV0ID0gZmFsc2UsIGx1bWluYW5jZVJhbmdlID0gbnVsbCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiTHVtaW5hbmNlTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgVEhSRUVfUkVWSVNJT046IFJFVklTSU9ONC5yZXBsYWNlKC9cXEQrL2csIFwiXCIpXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTYobnVsbCksXG4gICAgICAgIHRocmVzaG9sZDogbmV3IFVuaWZvcm0xNigwKSxcbiAgICAgICAgc21vb3RoaW5nOiBuZXcgVW5pZm9ybTE2KDEpLFxuICAgICAgICByYW5nZTogbmV3IFVuaWZvcm0xNihudWxsKVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMTYsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBsdW1pbmFuY2VfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yT3V0cHV0ID0gY29sb3JPdXRwdXQ7XG4gICAgdGhpcy5sdW1pbmFuY2VSYW5nZSA9IGx1bWluYW5jZVJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnRocmVzaG9sZC52YWx1ZTtcbiAgfVxuICBzZXQgdGhyZXNob2xkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc21vb3RoaW5nID4gMCB8fCB2YWx1ZSA+IDApIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5USFJFU0hPTEQgPSBcIjFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5USFJFU0hPTEQ7XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMudGhyZXNob2xkLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aHJlc2hvbGQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgZ2V0VGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnRocmVzaG9sZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbHVtaW5hbmNlIHRocmVzaG9sZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRocmVzaG9sZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgdGhyZXNob2xkLlxuICAgKi9cbiAgc2V0VGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy50aHJlc2hvbGQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSB0aHJlc2hvbGQgc21vb3RoaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNtb290aGluZygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zbW9vdGhpbmcudmFsdWU7XG4gIH1cbiAgc2V0IHNtb290aGluZyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnRocmVzaG9sZCA+IDAgfHwgdmFsdWUgPiAwKSB7XG4gICAgICB0aGlzLmRlZmluZXMuVEhSRVNIT0xEID0gXCIxXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuVEhSRVNIT0xEO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnNtb290aGluZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIHNtb290aGluZyBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzbW9vdGhpbmcgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc21vb3RoaW5nIGZhY3Rvci5cbiAgICovXG4gIGdldFNtb290aGluZ0ZhY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zbW9vdGhpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGx1bWluYW5jZSB0aHJlc2hvbGQgc21vb3RoaW5nIGZhY3Rvci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNtb290aGluZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc21vb3RoaW5nIGZhY3Rvci5cbiAgICovXG4gIHNldFNtb290aGluZ0ZhY3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuc21vb3RoaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBBZGp1c3QgdGhlIHRocmVzaG9sZCBvciBzbW9vdGhpbmcgZmFjdG9yIGluc3RlYWQuXG4gICAqL1xuICBnZXQgdXNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnRocmVzaG9sZCA+IDAgfHwgdGhpcy5zbW9vdGhpbmcgPiAwO1xuICB9XG4gIHNldCB1c2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29sb3Igb3V0cHV0IGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGNvbG9yT3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuQ09MT1IgIT09IHZvaWQgMDtcbiAgfVxuICBzZXQgY29sb3JPdXRwdXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5DT0xPUiA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLkNPTE9SO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29sb3Igb3V0cHV0IGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvck91dHB1dCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGNvbG9yIG91dHB1dCBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNDb2xvck91dHB1dEVuYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvck91dHB1dDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBjb2xvciBvdXRwdXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvck91dHB1dCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBjb2xvciBvdXRwdXQgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRDb2xvck91dHB1dEVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yT3V0cHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGx1bWluYW5jZSBtYXNraW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IHVzZVJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVJhbmdlICE9PSBudWxsO1xuICB9XG4gIHNldCB1c2VSYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMubHVtaW5hbmNlUmFuZ2UgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIHJhbmdlLiBTZXQgdG8gbnVsbCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBsdW1pbmFuY2VSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yYW5nZS52YWx1ZTtcbiAgfVxuICBzZXQgbHVtaW5hbmNlUmFuZ2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5SQU5HRSA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLlJBTkdFO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbHVtaW5hbmNlIHJhbmdlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlUmFuZ2UgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yMn0gVGhlIGx1bWluYW5jZSByYW5nZS5cbiAgICovXG4gIGdldEx1bWluYW5jZVJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbHVtaW5hbmNlIHJhbmdlLiBTZXQgdG8gbnVsbCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHVtaW5hbmNlUmFuZ2UgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2YWx1ZSAtIFRoZSBsdW1pbmFuY2UgcmFuZ2UuXG4gICAqL1xuICBzZXRMdW1pbmFuY2VSYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMubHVtaW5hbmNlUmFuZ2UgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9NYXNrTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE3LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE3LCBVbmlmb3JtIGFzIFVuaWZvcm0xNywgVW5zaWduZWRCeXRlVHlwZSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvbWFzay5mcmFnXG52YXIgbWFza19kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG4jaWZkZWYgTUFTS19QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFza1RleHR1cmU7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG1hc2tUZXh0dXJlO1xcbiNlbmRpZlxcbiNpZiBNQVNLX0ZVTkNUSU9OICE9IDBcXG51bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXY7dm9pZCBtYWluKCl7XFxuI2lmIENPTE9SX0NIQU5ORUwgPT0gMFxcbmZsb2F0IG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHZVdikucjtcXG4jZWxpZiBDT0xPUl9DSEFOTkVMID09IDFcXG5mbG9hdCBtYXNrPXRleHR1cmUyRChtYXNrVGV4dHVyZSx2VXYpLmc7XFxuI2VsaWYgQ09MT1JfQ0hBTk5FTCA9PSAyXFxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5iO1xcbiNlbHNlXFxuZmxvYXQgbWFzaz10ZXh0dXJlMkQobWFza1RleHR1cmUsdlV2KS5hO1xcbiNlbmRpZlxcbiNpZiBNQVNLX0ZVTkNUSU9OID09IDBcXG4jaWZkZWYgSU5WRVJURURcXG5tYXNrPXN0ZXAobWFzaywwLjApO1xcbiNlbHNlXFxubWFzaz0xLjAtc3RlcChtYXNrLDAuMCk7XFxuI2VuZGlmXFxuI2Vsc2VcXG5tYXNrPWNsYW1wKG1hc2sqc3RyZW5ndGgsMC4wLDEuMCk7XFxuI2lmZGVmIElOVkVSVEVEXFxubWFzaz0xLjAtbWFzaztcXG4jZW5kaWZcXG4jZW5kaWZcXG4jaWYgTUFTS19GVU5DVElPTiA9PSAzXFxudmVjNCB0ZXhlbD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KTtnbF9GcmFnQ29sb3I9dmVjNChtYXNrKnRleGVsLnJnYix0ZXhlbC5hKTtcXG4jZWxpZiBNQVNLX0ZVTkNUSU9OID09IDJcXG5nbF9GcmFnQ29sb3I9dmVjNChtYXNrKnRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpLnJnYixtYXNrKTtcXG4jZWxzZVxcbmdsX0ZyYWdDb2xvcj1tYXNrKnRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXYpO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL21hdGVyaWFscy9NYXNrTWF0ZXJpYWwuanNcbnZhciBNYXNrTWF0ZXJpYWwgPSBjbGFzcyBleHRlbmRzIFNoYWRlck1hdGVyaWFsMTcge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBtYXNrIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFttYXNrVGV4dHVyZV0gLSBUaGUgbWFzayB0ZXh0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFza1RleHR1cmUgPSBudWxsKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJNYXNrTWF0ZXJpYWxcIixcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIG1hc2tUZXh0dXJlOiBuZXcgVW5pZm9ybTE3KG1hc2tUZXh0dXJlKSxcbiAgICAgICAgaW5wdXRCdWZmZXI6IG5ldyBVbmlmb3JtMTcobnVsbCksXG4gICAgICAgIHN0cmVuZ3RoOiBuZXcgVW5pZm9ybTE3KDEpXG4gICAgICB9LFxuICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcxNyxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hc2tfZGVmYXVsdCxcbiAgICAgIHZlcnRleFNoYWRlcjogY29tbW9uX2RlZmF1bHRcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5SRUQ7XG4gICAgdGhpcy5tYXNrRnVuY3Rpb24gPSBNYXNrRnVuY3Rpb24uRElTQ0FSRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBzZXQgaW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGJ1ZmZlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlucHV0QnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKi9cbiAgc2V0SW5wdXRCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmlucHV0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXNrIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG1hc2tUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuTUFTS19QUkVDSVNJT05fSElHSDtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLk1BU0tfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hc2sgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1hc2tUZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIHNldE1hc2tUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5tYXNrVGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xvciBjaGFubmVsIHRvIHVzZSBmb3IgbWFza2luZy4gRGVmYXVsdCBpcyBgQ29sb3JDaGFubmVsLlJFRGAuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvckNoYW5uZWx9XG4gICAqL1xuICBzZXQgY29sb3JDaGFubmVsKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLkNPTE9SX0NIQU5ORUwgPSB2YWx1ZS50b0ZpeGVkKDApO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xvciBjaGFubmVsIHRvIHVzZSBmb3IgbWFza2luZy4gRGVmYXVsdCBpcyBgQ29sb3JDaGFubmVsLlJFRGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvckNoYW5uZWwgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IHZhbHVlIC0gVGhlIGNoYW5uZWwuXG4gICAqL1xuICBzZXRDb2xvckNoYW5uZWwodmFsdWUpIHtcbiAgICB0aGlzLmNvbG9yQ2hhbm5lbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWFza2luZyB0ZWNobmlxdWUuIERlZmF1bHQgaXMgYE1hc2tGdW5jdGlvbi5ESVNDQVJEYC5cbiAgICpcbiAgICogQHR5cGUge01hc2tGdW5jdGlvbn1cbiAgICovXG4gIHNldCBtYXNrRnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuTUFTS19GVU5DVElPTiA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hc2tpbmcgdGVjaG5pcXVlLiBEZWZhdWx0IGlzIGBNYXNrRnVuY3Rpb24uRElTQ0FSRGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXNrRnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtNYXNrRnVuY3Rpb259IHZhbHVlIC0gVGhlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2V0TWFza0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5tYXNrRnVuY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1hc2tpbmcgaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuSU5WRVJURUQgIT09IHZvaWQgMDtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZlcnRlZCAmJiAhdmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuSU5WRVJURUQ7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLklOVkVSVEVEID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFza2luZyBpcyBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG1hc2tpbmcgaXMgaW52ZXJ0ZWQuXG4gICAqL1xuICBpc0ludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1hc2tpbmcgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIG1hc2tpbmcgc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IG1hc2sgc3RyZW5ndGguXG4gICAqXG4gICAqIEluZGl2aWR1YWwgbWFzayB2YWx1ZXMgd2lsbCBiZSBjbGFtcGVkIHRvIFswLjAsIDEuMF0uIEhhcyBubyBlZmZlY3Qgd2hlbiB0aGUgbWFzayBmdW5jdGlvbiBpcyBzZXQgdG8gYERJU0NBUkRgLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlO1xuICB9XG4gIHNldCBzdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGgudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYXNrIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWFzayBzdHJlbmd0aC5cbiAgICovXG4gIGdldFN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXNrIHN0cmVuZ3RoLlxuICAgKlxuICAgKiBIYXMgbm8gZWZmZWN0IHdoZW4gdGhlIG1hc2sgZnVuY3Rpb24gaXMgc2V0IHRvIGBESVNDQVJEYC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtYXNrIHN0cmVuZ3RoLlxuICAgKi9cbiAgc2V0U3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9tYXRlcmlhbHMvT3V0bGluZU1hdGVyaWFsLmpzXG5pbXBvcnQgeyBOb0JsZW5kaW5nIGFzIE5vQmxlbmRpbmcxOCwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwxOCwgVW5pZm9ybSBhcyBVbmlmb3JtMTgsIFZlY3RvcjIgYXMgVmVjdG9yMjEwIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9vdXRsaW5lLmZyYWdcbnZhciBvdXRsaW5lX2RlZmF1bHQgPSBcInVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiBjMD10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MCkucmc7dmVjMiBjMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSkucmc7dmVjMiBjMj10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Mikucmc7dmVjMiBjMz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2Mykucmc7ZmxvYXQgZDA9KGMwLngtYzEueCkqMC41O2Zsb2F0IGQxPShjMi54LWMzLngpKjAuNTtmbG9hdCBkPWxlbmd0aCh2ZWMyKGQwLGQxKSk7ZmxvYXQgYTA9bWluKGMwLnksYzEueSk7ZmxvYXQgYTE9bWluKGMyLnksYzMueSk7ZmxvYXQgdmlzaWJpbGl0eUZhY3Rvcj1taW4oYTAsYTEpO2dsX0ZyYWdDb2xvci5yZz0oMS4wLXZpc2liaWxpdHlGYWN0b3I+MC4wMDEpP3ZlYzIoZCwwLjApOnZlYzIoMC4wLGQpO31cIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL291dGxpbmUudmVydFxudmFyIG91dGxpbmVfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjA9dmVjMih1di54K3RleGVsU2l6ZS54LHV2LnkpO3ZVdjE9dmVjMih1di54LXRleGVsU2l6ZS54LHV2LnkpO3ZVdjI9dmVjMih1di54LHV2LnkrdGV4ZWxTaXplLnkpO3ZVdjM9dmVjMih1di54LHV2LnktdGV4ZWxTaXplLnkpO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL091dGxpbmVNYXRlcmlhbC5qc1xudmFyIE91dGxpbmVNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwxOCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG91dGxpbmUgbWF0ZXJpYWwuXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIHRleGVsU2l6ZSBwYXJhbS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyMTAoKSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiT3V0bGluZU1hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0xOChudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTE4KG5ldyBWZWN0b3IyMTAoKSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE4LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogb3V0bGluZV9kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBvdXRsaW5lX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KHRleGVsU2l6ZS54LCB0ZXhlbFNpemUueSk7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrVGV4dHVyZSA9IHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHZhbHVlIC0gVGhlIGlucHV0IGJ1ZmZlci5cbiAgICovXG4gIHNldElucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXhlbCBzaXplLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2V0U2l6ZSgpIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB0ZXhlbCBoZWlnaHQuXG4gICAqL1xuICBzZXRUZXhlbFNpemUoeCwgeSkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1NNQUFXZWlnaHRzTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzE5LCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDE5LCBVbmlmb3JtIGFzIFVuaWZvcm0xOSwgVmVjdG9yMiBhcyBWZWN0b3IyMTEgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL3NtYWEtd2VpZ2h0cy5mcmFnXG52YXIgc21hYV93ZWlnaHRzX2RlZmF1bHQgPSBcIiNkZWZpbmUgc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KHQsIGNvb3JkLCBvZmZzZXQpIHRleHR1cmUyRCh0LCBjb29yZCArIG9mZnNldCAqIHRleGVsU2l6ZSlcXG4jaWYgX19WRVJTSU9OX18gPCAzMDBcXG4jZGVmaW5lIHJvdW5kKHYpIGZsb29yKHYgKyAwLjUpXFxuI2VuZGlmXFxuI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgaW5wdXRCdWZmZXI7XFxuI2VuZGlmXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBhcmVhVGV4dHVyZTt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHNlYXJjaFRleHR1cmU7dW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTt1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjNCB2T2Zmc2V0WzNdO3ZhcnlpbmcgdmVjMiB2UGl4Q29vcmQ7dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjMiBjLGlub3V0IHZlYzIgdmFyaWFibGUsY29uc3QgaW4gdmVjMiB2YWx1ZSl7aWYoYy54KXt2YXJpYWJsZS54PXZhbHVlLng7fWlmKGMueSl7dmFyaWFibGUueT12YWx1ZS55O319dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjNCBjLGlub3V0IHZlYzQgdmFyaWFibGUsY29uc3QgaW4gdmVjNCB2YWx1ZSl7bW92ZWMoYy54eSx2YXJpYWJsZS54eSx2YWx1ZS54eSk7bW92ZWMoYy56dyx2YXJpYWJsZS56dyx2YWx1ZS56dyk7fXZlYzIgZGVjb2RlRGlhZ0JpbGluZWFyQWNjZXNzKGluIHZlYzIgZSl7ZS5yPWUuciphYnMoNS4wKmUuci01LjAqMC43NSk7cmV0dXJuIHJvdW5kKGUpO312ZWM0IGRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhpbiB2ZWM0IGUpe2UucmI9ZS5yYiphYnMoNS4wKmUucmItNS4wKjAuNzUpO3JldHVybiByb3VuZChlKTt9dmVjMiBzZWFyY2hEaWFnMShjb25zdCBpbiB2ZWMyIHRleENvb3JkLGNvbnN0IGluIHZlYzIgZGlyLG91dCB2ZWMyIGUpe3ZlYzQgY29vcmQ9dmVjNCh0ZXhDb29yZCwtMS4wLDEuMCk7dmVjMyB0PXZlYzModGV4ZWxTaXplLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEoY29vcmQuejxmbG9hdChNQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5ULTEpJiZjb29yZC53PjAuOSkpe2JyZWFrO31jb29yZC54eXo9dCp2ZWMzKGRpciwxLjApK2Nvb3JkLnh5ejtlPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZC54eSkucmc7Y29vcmQudz1kb3QoZSx2ZWMyKDAuNSkpO31yZXR1cm4gY29vcmQuenc7fXZlYzIgc2VhcmNoRGlhZzIoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGRpcixvdXQgdmVjMiBlKXt2ZWM0IGNvb3JkPXZlYzQodGV4Q29vcmQsLTEuMCwxLjApO2Nvb3JkLngrPTAuMjUqdGV4ZWxTaXplLng7dmVjMyB0PXZlYzModGV4ZWxTaXplLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEoY29vcmQuejxmbG9hdChNQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5ULTEpJiZjb29yZC53PjAuOSkpe2JyZWFrO31jb29yZC54eXo9dCp2ZWMzKGRpciwxLjApK2Nvb3JkLnh5ejtlPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZC54eSkucmc7ZT1kZWNvZGVEaWFnQmlsaW5lYXJBY2Nlc3MoZSk7Y29vcmQudz1kb3QoZSx2ZWMyKDAuNSkpO31yZXR1cm4gY29vcmQuenc7fXZlYzIgYXJlYURpYWcoY29uc3QgaW4gdmVjMiBkaXN0LGNvbnN0IGluIHZlYzIgZSxjb25zdCBpbiBmbG9hdCBvZmZzZXQpe3ZlYzIgdGV4Q29vcmQ9dmVjMihBUkVBVEVYX01BWF9ESVNUQU5DRV9ESUFHLEFSRUFURVhfTUFYX0RJU1RBTkNFX0RJQUcpKmUrZGlzdDt0ZXhDb29yZD1BUkVBVEVYX1BJWEVMX1NJWkUqdGV4Q29vcmQrMC41KkFSRUFURVhfUElYRUxfU0laRTt0ZXhDb29yZC54Kz0wLjU7dGV4Q29vcmQueSs9QVJFQVRFWF9TVUJURVhfU0laRSpvZmZzZXQ7cmV0dXJuIHRleHR1cmUyRChhcmVhVGV4dHVyZSx0ZXhDb29yZCkucmc7fXZlYzIgY2FsY3VsYXRlRGlhZ1dlaWdodHMoY29uc3QgaW4gdmVjMiB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGUsY29uc3QgaW4gdmVjNCBzdWJzYW1wbGVJbmRpY2VzKXt2ZWMyIHdlaWdodHM9dmVjMigwLjApO3ZlYzQgZDt2ZWMyIGVuZDtpZihlLnI+MC4wKXtkLnh6PXNlYXJjaERpYWcxKHRleENvb3JkLHZlYzIoLTEuMCwxLjApLGVuZCk7ZC54Kz1mbG9hdChlbmQueT4wLjkpO31lbHNle2QueHo9dmVjMigwLjApO31kLnl3PXNlYXJjaERpYWcxKHRleENvb3JkLHZlYzIoMS4wLC0xLjApLGVuZCk7aWYoZC54K2QueT4yLjApe3ZlYzQgY29vcmRzPXZlYzQoLWQueCswLjI1LGQueCxkLnksLWQueS0wLjI1KSp0ZXhlbFNpemUueHl4eSt0ZXhDb29yZC54eXh5O3ZlYzQgYztjLnh5PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigtMSwwKSkucmc7Yy56dz1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnp3LHZlYzIoMSwwKSkucmc7Yy55eHd6PWRlY29kZURpYWdCaWxpbmVhckFjY2VzcyhjLnh5encpO3ZlYzIgY2M9dmVjMigyLjApKmMueHorYy55dzttb3ZlYyhidmVjMihzdGVwKDAuOSxkLnp3KSksY2MsdmVjMigwLjApKTt3ZWlnaHRzKz1hcmVhRGlhZyhkLnh5LGNjLHN1YnNhbXBsZUluZGljZXMueik7fWQueHo9c2VhcmNoRGlhZzIodGV4Q29vcmQsdmVjMigtMS4wLC0xLjApLGVuZCk7aWYoc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLHZlYzIoMSwwKSkucj4wLjApe2QueXc9c2VhcmNoRGlhZzIodGV4Q29vcmQsdmVjMigxLjApLGVuZCk7ZC55Kz1mbG9hdChlbmQueT4wLjkpO31lbHNle2QueXc9dmVjMigwLjApO31pZihkLngrZC55PjIuMCl7dmVjNCBjb29yZHM9dmVjNCgtZC54LC1kLngsZC55LGQueSkqdGV4ZWxTaXplLnh5eHkrdGV4Q29vcmQueHl4eTt2ZWM0IGM7Yy54PXNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcixjb29yZHMueHksdmVjMigtMSwwKSkuZztjLnk9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy54eSx2ZWMyKDAsLTEpKS5yO2Muenc9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56dyx2ZWMyKDEsMCkpLmdyO3ZlYzIgY2M9dmVjMigyLjApKmMueHorYy55dzttb3ZlYyhidmVjMihzdGVwKDAuOSxkLnp3KSksY2MsdmVjMigwLjApKTt3ZWlnaHRzKz1hcmVhRGlhZyhkLnh5LGNjLHN1YnNhbXBsZUluZGljZXMudykuZ3I7fXJldHVybiB3ZWlnaHRzO31mbG9hdCBzZWFyY2hMZW5ndGgoY29uc3QgaW4gdmVjMiBlLGNvbnN0IGluIGZsb2F0IG9mZnNldCl7dmVjMiBzY2FsZT1TRUFSQ0hURVhfU0laRSp2ZWMyKDAuNSwtMS4wKTt2ZWMyIGJpYXM9U0VBUkNIVEVYX1NJWkUqdmVjMihvZmZzZXQsMS4wKTtzY2FsZSs9dmVjMigtMS4wLDEuMCk7Ymlhcys9dmVjMigwLjUsLTAuNSk7c2NhbGUqPTEuMC9TRUFSQ0hURVhfUEFDS0VEX1NJWkU7Ymlhcyo9MS4wL1NFQVJDSFRFWF9QQUNLRURfU0laRTtyZXR1cm4gdGV4dHVyZTJEKHNlYXJjaFRleHR1cmUsc2NhbGUqZStiaWFzKS5yO31mbG9hdCBzZWFyY2hYTGVmdChpbiB2ZWMyIHRleENvb3JkLGNvbnN0IGluIGZsb2F0IGVuZCl7dmVjMiBlPXZlYzIoMC4wLDEuMCk7Zm9yKGludCBpPTA7aTxNQVhfU0VBUkNIX1NURVBTX0lOVDsrK2kpe2lmKCEodGV4Q29vcmQueD5lbmQmJmUuZz4wLjgyODEmJmUucj09MC4wKSl7YnJlYWs7fWU9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHRleENvb3JkKS5yZzt0ZXhDb29yZD12ZWMyKC0yLjAsMC4wKSp0ZXhlbFNpemUrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZSwwLjApKzMuMjU7cmV0dXJuIHRleGVsU2l6ZS54Km9mZnNldCt0ZXhDb29yZC54O31mbG9hdCBzZWFyY2hYUmlnaHQodmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDAuMCwxLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLng8ZW5kJiZlLmc+MC44MjgxJiZlLnI9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigyLjAsMC4wKSp0ZXhlbFNpemUueHkrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZSwwLjUpKzMuMjU7cmV0dXJuLXRleGVsU2l6ZS54Km9mZnNldCt0ZXhDb29yZC54O31mbG9hdCBzZWFyY2hZVXAodmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDEuMCwwLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7KytpKXtpZighKHRleENvb3JkLnk+ZW5kJiZlLnI+MC44MjgxJiZlLmc9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9LXZlYzIoMC4wLDIuMCkqdGV4ZWxTaXplLnh5K3RleENvb3JkO31mbG9hdCBvZmZzZXQ9LSgyNTUuMC8xMjcuMCkqc2VhcmNoTGVuZ3RoKGUuZ3IsMC4wKSszLjI1O3JldHVybiB0ZXhlbFNpemUueSpvZmZzZXQrdGV4Q29vcmQueTt9ZmxvYXQgc2VhcmNoWURvd24odmVjMiB0ZXhDb29yZCxjb25zdCBpbiBmbG9hdCBlbmQpe3ZlYzIgZT12ZWMyKDEuMCwwLjApO2ZvcihpbnQgaT0wO2k8TUFYX1NFQVJDSF9TVEVQU19JTlQ7aSsrKXtpZighKHRleENvb3JkLnk8ZW5kJiZlLnI+MC44MjgxJiZlLmc9PTAuMCkpe2JyZWFrO31lPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix0ZXhDb29yZCkucmc7dGV4Q29vcmQ9dmVjMigwLjAsMi4wKSp0ZXhlbFNpemUueHkrdGV4Q29vcmQ7fWZsb2F0IG9mZnNldD0tKDI1NS4wLzEyNy4wKSpzZWFyY2hMZW5ndGgoZS5nciwwLjUpKzMuMjU7cmV0dXJuLXRleGVsU2l6ZS55Km9mZnNldCt0ZXhDb29yZC55O312ZWMyIGFyZWEoY29uc3QgaW4gdmVjMiBkaXN0LGNvbnN0IGluIGZsb2F0IGUxLGNvbnN0IGluIGZsb2F0IGUyLGNvbnN0IGluIGZsb2F0IG9mZnNldCl7dmVjMiB0ZXhDb29yZD12ZWMyKEFSRUFURVhfTUFYX0RJU1RBTkNFKSpyb3VuZCg0LjAqdmVjMihlMSxlMikpK2Rpc3Q7dGV4Q29vcmQ9QVJFQVRFWF9QSVhFTF9TSVpFKnRleENvb3JkKzAuNSpBUkVBVEVYX1BJWEVMX1NJWkU7dGV4Q29vcmQueT1BUkVBVEVYX1NVQlRFWF9TSVpFKm9mZnNldCt0ZXhDb29yZC55O3JldHVybiB0ZXh0dXJlMkQoYXJlYVRleHR1cmUsdGV4Q29vcmQpLnJnO312b2lkIGRldGVjdEhvcml6b250YWxDb3JuZXJQYXR0ZXJuKGlub3V0IHZlYzIgd2VpZ2h0cyxjb25zdCBpbiB2ZWM0IHRleENvb3JkLGNvbnN0IGluIHZlYzIgZCl7XFxuI2lmICFkZWZpbmVkKERJU0FCTEVfQ09STkVSX0RFVEVDVElPTilcXG52ZWMyIGxlZnRSaWdodD1zdGVwKGQueHksZC55eCk7dmVjMiByb3VuZGluZz0oMS4wLUNPUk5FUl9ST1VORElOR19OT1JNKSpsZWZ0UmlnaHQ7cm91bmRpbmcvPWxlZnRSaWdodC54K2xlZnRSaWdodC55O3ZlYzIgZmFjdG9yPXZlYzIoMS4wKTtmYWN0b3IueC09cm91bmRpbmcueCpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQueHksdmVjMigwLDEpKS5yO2ZhY3Rvci54LT1yb3VuZGluZy55KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC56dyx2ZWMyKDEsMSkpLnI7ZmFjdG9yLnktPXJvdW5kaW5nLngqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnh5LHZlYzIoMCwtMikpLnI7ZmFjdG9yLnktPXJvdW5kaW5nLnkqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnp3LHZlYzIoMSwtMikpLnI7d2VpZ2h0cyo9Y2xhbXAoZmFjdG9yLDAuMCwxLjApO1xcbiNlbmRpZlxcbn12b2lkIGRldGVjdFZlcnRpY2FsQ29ybmVyUGF0dGVybihpbm91dCB2ZWMyIHdlaWdodHMsY29uc3QgaW4gdmVjNCB0ZXhDb29yZCxjb25zdCBpbiB2ZWMyIGQpe1xcbiNpZiAhZGVmaW5lZChESVNBQkxFX0NPUk5FUl9ERVRFQ1RJT04pXFxudmVjMiBsZWZ0UmlnaHQ9c3RlcChkLnh5LGQueXgpO3ZlYzIgcm91bmRpbmc9KDEuMC1DT1JORVJfUk9VTkRJTkdfTk9STSkqbGVmdFJpZ2h0O3JvdW5kaW5nLz1sZWZ0UmlnaHQueCtsZWZ0UmlnaHQueTt2ZWMyIGZhY3Rvcj12ZWMyKDEuMCk7ZmFjdG9yLngtPXJvdW5kaW5nLngqc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLHRleENvb3JkLnh5LHZlYzIoMSwwKSkuZztmYWN0b3IueC09cm91bmRpbmcueSpzYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsdGV4Q29vcmQuencsdmVjMigxLDEpKS5nO2ZhY3Rvci55LT1yb3VuZGluZy54KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC54eSx2ZWMyKC0yLDApKS5nO2ZhY3Rvci55LT1yb3VuZGluZy55KnNhbXBsZUxldmVsWmVyb09mZnNldChpbnB1dEJ1ZmZlcix0ZXhDb29yZC56dyx2ZWMyKC0yLDEpKS5nO3dlaWdodHMqPWNsYW1wKGZhY3RvciwwLjAsMS4wKTtcXG4jZW5kaWZcXG59dm9pZCBtYWluKCl7dmVjNCB3ZWlnaHRzPXZlYzQoMC4wKTt2ZWM0IHN1YnNhbXBsZUluZGljZXM9dmVjNCgwLjApO3ZlYzIgZT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2KS5yZztpZihlLmc+MC4wKXtcXG4jaWYgIWRlZmluZWQoRElTQUJMRV9ESUFHX0RFVEVDVElPTilcXG53ZWlnaHRzLnJnPWNhbGN1bGF0ZURpYWdXZWlnaHRzKHZVdixlLHN1YnNhbXBsZUluZGljZXMpO2lmKHdlaWdodHMucj09LXdlaWdodHMuZyl7XFxuI2VuZGlmXFxudmVjMiBkO3ZlYzMgY29vcmRzO2Nvb3Jkcy54PXNlYXJjaFhMZWZ0KHZPZmZzZXRbMF0ueHksdk9mZnNldFsyXS54KTtjb29yZHMueT12T2Zmc2V0WzFdLnk7ZC54PWNvb3Jkcy54O2Zsb2F0IGUxPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixjb29yZHMueHkpLnI7Y29vcmRzLno9c2VhcmNoWFJpZ2h0KHZPZmZzZXRbMF0uencsdk9mZnNldFsyXS55KTtkLnk9Y29vcmRzLno7ZD1yb3VuZChyZXNvbHV0aW9uLnh4KmQrLXZQaXhDb29yZC54eCk7dmVjMiBzcXJ0RD1zcXJ0KGFicyhkKSk7ZmxvYXQgZTI9c2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KGlucHV0QnVmZmVyLGNvb3Jkcy56eSx2ZWMyKDEsMCkpLnI7d2VpZ2h0cy5yZz1hcmVhKHNxcnRELGUxLGUyLHN1YnNhbXBsZUluZGljZXMueSk7Y29vcmRzLnk9dlV2Lnk7ZGV0ZWN0SG9yaXpvbnRhbENvcm5lclBhdHRlcm4od2VpZ2h0cy5yZyxjb29yZHMueHl6eSxkKTtcXG4jaWYgIWRlZmluZWQoRElTQUJMRV9ESUFHX0RFVEVDVElPTilcXG59ZWxzZXtlLnI9MC4wO31cXG4jZW5kaWZcXG59aWYoZS5yPjAuMCl7dmVjMiBkO3ZlYzMgY29vcmRzO2Nvb3Jkcy55PXNlYXJjaFlVcCh2T2Zmc2V0WzFdLnh5LHZPZmZzZXRbMl0ueik7Y29vcmRzLng9dk9mZnNldFswXS54O2QueD1jb29yZHMueTtmbG9hdCBlMT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzLnh5KS5nO2Nvb3Jkcy56PXNlYXJjaFlEb3duKHZPZmZzZXRbMV0uencsdk9mZnNldFsyXS53KTtkLnk9Y29vcmRzLno7ZD1yb3VuZChyZXNvbHV0aW9uLnl5KmQtdlBpeENvb3JkLnl5KTt2ZWMyIHNxcnREPXNxcnQoYWJzKGQpKTtmbG9hdCBlMj1zYW1wbGVMZXZlbFplcm9PZmZzZXQoaW5wdXRCdWZmZXIsY29vcmRzLnh6LHZlYzIoMCwxKSkuZzt3ZWlnaHRzLmJhPWFyZWEoc3FydEQsZTEsZTIsc3Vic2FtcGxlSW5kaWNlcy54KTtjb29yZHMueD12VXYueDtkZXRlY3RWZXJ0aWNhbENvcm5lclBhdHRlcm4od2VpZ2h0cy5iYSxjb29yZHMueHl4eixkKTt9Z2xfRnJhZ0NvbG9yPXdlaWdodHM7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvc21hYS13ZWlnaHRzLnZlcnRcbnZhciBzbWFhX3dlaWdodHNfZGVmYXVsdDIgPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7dW5pZm9ybSB2ZWMyIHJlc29sdXRpb247dmFyeWluZyB2ZWMyIHZVdjt2YXJ5aW5nIHZlYzQgdk9mZnNldFszXTt2YXJ5aW5nIHZlYzIgdlBpeENvb3JkO3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZQaXhDb29yZD12VXYqcmVzb2x1dGlvbjt2T2Zmc2V0WzBdPXZVdi54eXh5K3RleGVsU2l6ZS54eXh5KnZlYzQoLTAuMjUsLTAuMTI1LDEuMjUsLTAuMTI1KTt2T2Zmc2V0WzFdPXZVdi54eXh5K3RleGVsU2l6ZS54eXh5KnZlYzQoLTAuMTI1LC0wLjI1LC0wLjEyNSwxLjI1KTt2T2Zmc2V0WzJdPXZlYzQodk9mZnNldFswXS54eix2T2Zmc2V0WzFdLnl3KSt2ZWM0KC0yLjAsMi4wLC0yLjAsMi4wKSp0ZXhlbFNpemUueHh5eSpNQVhfU0VBUkNIX1NURVBTX0ZMT0FUO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1NNQUFXZWlnaHRzTWF0ZXJpYWwuanNcbnZhciBTTUFBV2VpZ2h0c01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDE5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSB3ZWlnaHRzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtyZXNvbHV0aW9uXSAtIFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIxMSgpLCByZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIxMSgpKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJTTUFBV2VpZ2h0c01hdGVyaWFsXCIsXG4gICAgICBkZWZpbmVzOiB7XG4gICAgICAgIC8vIENvbmZpZ3VyYWJsZSBzZXR0aW5nczpcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19JTlQ6IFwiMTZcIixcbiAgICAgICAgTUFYX1NFQVJDSF9TVEVQU19GTE9BVDogXCIxNi4wXCIsXG4gICAgICAgIE1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQ6IFwiOFwiLFxuICAgICAgICBNQVhfU0VBUkNIX1NURVBTX0RJQUdfRkxPQVQ6IFwiOC4wXCIsXG4gICAgICAgIENPUk5FUl9ST1VORElORzogXCIyNVwiLFxuICAgICAgICBDT1JORVJfUk9VTkRJTkdfTk9STTogXCIwLjI1XCIsXG4gICAgICAgIC8vIE5vbi1jb25maWd1cmFibGUgc2V0dGluZ3M6XG4gICAgICAgIEFSRUFURVhfTUFYX0RJU1RBTkNFOiBcIjE2LjBcIixcbiAgICAgICAgQVJFQVRFWF9NQVhfRElTVEFOQ0VfRElBRzogXCIyMC4wXCIsXG4gICAgICAgIEFSRUFURVhfUElYRUxfU0laRTogXCIoMS4wIC8gdmVjMigxNjAuMCwgNTYwLjApKVwiLFxuICAgICAgICBBUkVBVEVYX1NVQlRFWF9TSVpFOiBcIigxLjAgLyA3LjApXCIsXG4gICAgICAgIFNFQVJDSFRFWF9TSVpFOiBcInZlYzIoNjYuMCwgMzMuMClcIixcbiAgICAgICAgU0VBUkNIVEVYX1BBQ0tFRF9TSVpFOiBcInZlYzIoNjQuMCwgMTYuMClcIlxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGlucHV0QnVmZmVyOiBuZXcgVW5pZm9ybTE5KG51bGwpLFxuICAgICAgICBzZWFyY2hUZXh0dXJlOiBuZXcgVW5pZm9ybTE5KG51bGwpLFxuICAgICAgICBhcmVhVGV4dHVyZTogbmV3IFVuaWZvcm0xOShudWxsKSxcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVuaWZvcm0xOShyZXNvbHV0aW9uKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTE5KHRleGVsU2l6ZSlcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzE5LFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogc21hYV93ZWlnaHRzX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHNtYWFfd2VpZ2h0c19kZWZhdWx0MlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBpbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRCdWZmZXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqL1xuICBzZXRJbnB1dEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW5wdXRCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlYXJjaCBsb29rdXAgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgc2VhcmNoVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zZWFyY2hUZXh0dXJlLnZhbHVlO1xuICB9XG4gIHNldCBzZWFyY2hUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zZWFyY2hUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhcmVhIGxvb2t1cCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBhcmVhVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hcmVhVGV4dHVyZS52YWx1ZTtcbiAgfVxuICBzZXQgYXJlYVRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmFyZWFUZXh0dXJlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlYXJjaCBhbmQgYXJlYSBsb29rdXAgdGV4dHVyZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWFyY2hUZXh0dXJlIGFuZCBhcmVhVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IHNlYXJjaCAtIFRoZSBzZWFyY2ggbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gYXJlYSAtIFRoZSBhcmVhIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0TG9va3VwVGV4dHVyZXMoc2VhcmNoLCBhcmVhMikge1xuICAgIHRoaXMuc2VhcmNoVGV4dHVyZSA9IHNlYXJjaDtcbiAgICB0aGlzLmFyZWFUZXh0dXJlID0gYXJlYTI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBzdGVwcyBwZXJmb3JtZWQgaW4gdGhlIGhvcml6b250YWwvdmVydGljYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC5cbiAgICogUmFuZ2U6IFswLCAxMTJdLlxuICAgKlxuICAgKiBJbiBudW1iZXIgb2YgcGl4ZWxzLCBpdCdzIGFjdHVhbGx5IHRoZSBkb3VibGUuIFNvIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHBlcmZlY3RseSBoYW5kbGVkIGJ5LCBmb3IgZXhhbXBsZSAxNiwgaXNcbiAgICogNjQgKHBlcmZlY3RseSBtZWFucyB0aGF0IGxvbmdlciBsaW5lcyB3b24ndCBsb29rIGFzIGdvb2QsIGJ1dCBhcmUgc3RpbGwgYW50aWFsaWFzZWQpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9ydGhvZ29uYWxTZWFyY2hTdGVwcygpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0lOVCk7XG4gIH1cbiAgc2V0IG9ydGhvZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDExMik7XG4gICAgdGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfSU5UID0gcy50b0ZpeGVkKFwiMFwiKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19GTE9BVCA9IHMudG9GaXhlZChcIjFcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gYW1vdW50IG9mIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBwYXR0ZXJuIHNlYXJjaGVzLCBhdCBlYWNoIHNpZGUgb2YgdGhlIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3J0aG9nb25hbFNlYXJjaFN0ZXBzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzZWFyY2ggc3RlcHMuIFJhbmdlOiBbMCwgMTEyXS5cbiAgICovXG4gIHNldE9ydGhvZ29uYWxTZWFyY2hTdGVwcyh2YWx1ZSkge1xuICAgIHRoaXMub3J0aG9nb25hbFNlYXJjaFN0ZXBzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgZGlhZ29uYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC4gVGhpcyBzZWFyY2hcbiAgICoganVtcHMgb25lIHBpeGVsIGF0IGEgdGltZS4gUmFuZ2U6IFswLCAyMF0uXG4gICAqXG4gICAqIE9uIGhpZ2gtZW5kIG1hY2hpbmVzIHRoaXMgc2VhcmNoIGlzIGNoZWFwIChiZXR3ZWVuIDAuOHggYW5kIDAuOXggc2xvd2VyIGZvciAxNiBzdGVwcyksIGJ1dCBpdCBjYW4gaGF2ZSBhXG4gICAqIHNpZ25pZmljYW50IGltcGFjdCBvbiBvbGRlciBtYWNoaW5lcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaWFnb25hbFNlYXJjaFN0ZXBzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLk1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQpO1xuICB9XG4gIHNldCBkaWFnb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMjApO1xuICAgIHRoaXMuZGVmaW5lcy5NQVhfU0VBUkNIX1NURVBTX0RJQUdfSU5UID0gcy50b0ZpeGVkKFwiMFwiKTtcbiAgICB0aGlzLmRlZmluZXMuTUFYX1NFQVJDSF9TVEVQU19ESUFHX0ZMT0FUID0gcy50b0ZpeGVkKFwiMVwiKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIHN0ZXBzIHBlcmZvcm1lZCBpbiB0aGUgZGlhZ29uYWwgcGF0dGVybiBzZWFyY2hlcywgYXQgZWFjaCBzaWRlIG9mIHRoZSBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRpYWdvbmFsU2VhcmNoU3RlcHMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNlYXJjaCBzdGVwcy4gUmFuZ2U6IFswLCAyMF0uXG4gICAqL1xuICBzZXREaWFnb25hbFNlYXJjaFN0ZXBzKHZhbHVlKSB7XG4gICAgdGhpcy5kaWFnb25hbFNlYXJjaFN0ZXBzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRpYWdvbmFsRGV0ZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuRElTQUJMRV9ESUFHX0RFVEVDVElPTiA9PT0gdm9pZCAwO1xuICB9XG4gIHNldCBkaWFnb25hbERldGVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5ESVNBQkxFX0RJQUdfREVURUNUSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuRElTQUJMRV9ESUFHX0RFVEVDVElPTiA9IFwiMVwiO1xuICAgIH1cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRpYWdvbmFsRGV0ZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRGlhZ29uYWxEZXRlY3Rpb25FbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRpYWdvbmFsRGV0ZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRpYWdvbmFsIHBhdHRlcm4gZGV0ZWN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGlhZ29uYWxEZXRlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGlhZ29uYWwgcGF0dGVybiBkZXRlY3Rpb24gc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaWFnb25hbERldGVjdGlvbkVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmRpYWdvbmFsRGV0ZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgbXVjaCBzaGFycCBjb3JuZXJzIHdpbGwgYmUgcm91bmRlZC4gUmFuZ2U6IFswLCAxMDBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvcm5lclJvdW5kaW5nKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLkNPUk5FUl9ST1VORElORyk7XG4gIH1cbiAgc2V0IGNvcm5lclJvdW5kaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgciA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMTAwKTtcbiAgICB0aGlzLmRlZmluZXMuQ09STkVSX1JPVU5ESU5HID0gci50b0ZpeGVkKFwiNFwiKTtcbiAgICB0aGlzLmRlZmluZXMuQ09STkVSX1JPVU5ESU5HX05PUk0gPSAociAvIDEwMCkudG9GaXhlZChcIjRcIik7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgbXVjaCBzaGFycCBjb3JuZXJzIHdpbGwgYmUgcm91bmRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lclJvdW5kaW5nIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBjb3JuZXIgcm91bmRpbmcgYW1vdW50LiBSYW5nZTogWzAsIDEwMF0uXG4gICAqL1xuICBzZXRDb3JuZXJSb3VuZGluZyh2YWx1ZSkge1xuICAgIHRoaXMuY29ybmVyUm91bmRpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29ybmVyIGRldGVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvcm5lckRldGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLkRJU0FCTEVfQ09STkVSX0RFVEVDVElPTiA9PT0gdm9pZCAwO1xuICB9XG4gIHNldCBjb3JuZXJEZXRlY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRlZmluZXMuRElTQUJMRV9DT1JORVJfREVURUNUSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuRElTQUJMRV9DT1JORVJfREVURUNUSU9OID0gXCIxXCI7XG4gICAgfVxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBjb3JuZXIgcm91bmRpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lckRldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGNvcm5lciByb3VuZGluZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNDb3JuZXJSb3VuZGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ybmVyRGV0ZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGNvcm5lciByb3VuZGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcm5lckRldGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBjb3JuZXIgcm91bmRpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRDb3JuZXJSb3VuZGluZ0VuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmNvcm5lckRldGVjdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIHVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoMSAvIHdpZHRoLCAxIC8gaGVpZ2h0KTtcbiAgICB1bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9TU0FPTWF0ZXJpYWwuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nNywgTWF0cml4NCwgTm9CbGVuZGluZyBhcyBOb0JsZW5kaW5nMjAsIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhNiwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyMCwgVW5pZm9ybSBhcyBVbmlmb3JtMjAsIFZlY3RvcjIgYXMgVmVjdG9yMjEyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zc2FvLmZyYWdcbnZhciBzc2FvX2RlZmF1bHQgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2lmZGVmIE5PUk1BTF9ERVBUSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7cmV0dXJuIHRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix1dikuYTt9XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5vcm1hbEJ1ZmZlcjtcXG4jaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZWxpZiBkZWZpbmVkKEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIKVxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGRlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBkZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG5mbG9hdCByZWFkRGVwdGgoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcbnJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpKTtcXG4jZWxzZVxcbnJldHVybiB0ZXh0dXJlMkQoZGVwdGhCdWZmZXIsdXYpLnI7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbm9pc2VUZXh0dXJlO3VuaWZvcm0gbWF0NCBpbnZlcnNlUHJvamVjdGlvbk1hdHJpeDt1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDt1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3VuaWZvcm0gdmVjMiBjYW1lcmFOZWFyRmFyO3VuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O3VuaWZvcm0gZmxvYXQgbWluUmFkaXVzU2NhbGU7dW5pZm9ybSBmbG9hdCBmYWRlO3VuaWZvcm0gZmxvYXQgYmlhczt1bmlmb3JtIHZlYzIgZGlzdGFuY2VDdXRvZmY7dW5pZm9ybSB2ZWMyIHByb3hpbWl0eUN1dG9mZjt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYyO2Zsb2F0IGdldFZpZXdaKGNvbnN0IGluIGZsb2F0IGRlcHRoKXtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxucmV0dXJuIHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxucmV0dXJuIG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyRmFyLngsY2FtZXJhTmVhckZhci55KTtcXG4jZW5kaWZcXG59dmVjMyBnZXRWaWV3UG9zaXRpb24oY29uc3QgaW4gdmVjMiBzY3JlZW5Qb3NpdGlvbixjb25zdCBpbiBmbG9hdCBkZXB0aCxjb25zdCBpbiBmbG9hdCB2aWV3Wil7dmVjNCBjbGlwUG9zaXRpb249dmVjNCh2ZWMzKHNjcmVlblBvc2l0aW9uLGRlcHRoKSoyLjAtMS4wLDEuMCk7ZmxvYXQgY2xpcFc9cHJvamVjdGlvbk1hdHJpeFsyXVszXSp2aWV3Witwcm9qZWN0aW9uTWF0cml4WzNdWzNdO2NsaXBQb3NpdGlvbio9Y2xpcFc7cmV0dXJuKGludmVyc2VQcm9qZWN0aW9uTWF0cml4KmNsaXBQb3NpdGlvbikueHl6O31mbG9hdCBnZXRBbWJpZW50T2NjbHVzaW9uKGNvbnN0IGluIHZlYzMgcCxjb25zdCBpbiB2ZWMzIG4sY29uc3QgaW4gZmxvYXQgZGVwdGgsY29uc3QgaW4gdmVjMiB1dil7ZmxvYXQgcmFkaXVzU2NhbGU9MS4wLXNtb290aHN0ZXAoMC4wLGRpc3RhbmNlQ3V0b2ZmLnksZGVwdGgpO3JhZGl1c1NjYWxlPXJhZGl1c1NjYWxlKigxLjAtbWluUmFkaXVzU2NhbGUpK21pblJhZGl1c1NjYWxlO2Zsb2F0IHJhZGl1cz1SQURJVVMqcmFkaXVzU2NhbGU7ZmxvYXQgbm9pc2U9dGV4dHVyZTJEKG5vaXNlVGV4dHVyZSx2VXYyKS5yO2Zsb2F0IGJhc2VBbmdsZT1ub2lzZSpQSTI7ZmxvYXQgcmluZ3M9U1BJUkFMX1RVUk5TKlBJMjtmbG9hdCBvY2NsdXNpb249MC4wO2ludCB0YXBzPTA7Zm9yKGludCBpPTA7aTxTQU1QTEVTX0lOVDsrK2kpe2Zsb2F0IGFscGhhPShmbG9hdChpKSswLjUpKklOVl9TQU1QTEVTX0ZMT0FUO2Zsb2F0IGFuZ2xlPWFscGhhKnJpbmdzK2Jhc2VBbmdsZTt2ZWMyIHJvdGF0aW9uPXZlYzIoY29zKGFuZ2xlKSxzaW4oYW5nbGUpKTt2ZWMyIGNvb3Jkcz1hbHBoYSpyYWRpdXMqcm90YXRpb24qdGV4ZWxTaXplK3V2O2lmKGNvb3Jkcy5zPDAuMHx8Y29vcmRzLnM+MS4wfHxjb29yZHMudDwwLjB8fGNvb3Jkcy50PjEuMCl7Y29udGludWU7fWZsb2F0IHNhbXBsZURlcHRoPXJlYWREZXB0aChjb29yZHMpO2Zsb2F0IHZpZXdaPWdldFZpZXdaKHNhbXBsZURlcHRoKTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZmxvYXQgbGluZWFyU2FtcGxlRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxuZmxvYXQgbGluZWFyU2FtcGxlRGVwdGg9c2FtcGxlRGVwdGg7XFxuI2VuZGlmXFxuZmxvYXQgcHJveGltaXR5PWFicyhkZXB0aC1saW5lYXJTYW1wbGVEZXB0aCk7aWYocHJveGltaXR5PHByb3hpbWl0eUN1dG9mZi55KXtmbG9hdCBmYWxsb2ZmPTEuMC1zbW9vdGhzdGVwKHByb3hpbWl0eUN1dG9mZi54LHByb3hpbWl0eUN1dG9mZi55LHByb3hpbWl0eSk7dmVjMyBRPWdldFZpZXdQb3NpdGlvbihjb29yZHMsc2FtcGxlRGVwdGgsdmlld1opO3ZlYzMgdj1RLXA7ZmxvYXQgdnY9ZG90KHYsdik7ZmxvYXQgdm49ZG90KHYsbiktYmlhcztmbG9hdCBmPW1heChSQURJVVNfU1EtdnYsMC4wKS9SQURJVVNfU1E7b2NjbHVzaW9uKz0oZipmKmYqbWF4KHZuLyhmYWRlK3Z2KSwwLjApKSpmYWxsb2ZmO30rK3RhcHM7fXJldHVybiBvY2NsdXNpb24vKDQuMCptYXgoZmxvYXQodGFwcyksMS4wKSk7fXZvaWQgbWFpbigpe1xcbiNpZmRlZiBOT1JNQUxfREVQVEhcXG52ZWM0IG5vcm1hbERlcHRoPXRleHR1cmUyRChub3JtYWxEZXB0aEJ1ZmZlcix2VXYpO1xcbiNlbHNlXFxudmVjNCBub3JtYWxEZXB0aD12ZWM0KHRleHR1cmUyRChub3JtYWxCdWZmZXIsdlV2KS54eXoscmVhZERlcHRoKHZVdikpO1xcbiNlbmRpZlxcbmZsb2F0IGFvPTAuMDtmbG9hdCBkZXB0aD1ub3JtYWxEZXB0aC5hO2Zsb2F0IHZpZXdaPWdldFZpZXdaKGRlcHRoKTtcXG4jaWZkZWYgUEVSU1BFQ1RJVkVfQ0FNRVJBXFxuZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXJGYXIueCxjYW1lcmFOZWFyRmFyLnkpO1xcbiNlbHNlXFxuZmxvYXQgbGluZWFyRGVwdGg9ZGVwdGg7XFxuI2VuZGlmXFxuaWYobGluZWFyRGVwdGg8ZGlzdGFuY2VDdXRvZmYueSl7dmVjMyB2aWV3UG9zaXRpb249Z2V0Vmlld1Bvc2l0aW9uKHZVdixkZXB0aCx2aWV3Wik7dmVjMyB2aWV3Tm9ybWFsPXVucGFja1JHQlRvTm9ybWFsKG5vcm1hbERlcHRoLnJnYik7YW8rPWdldEFtYmllbnRPY2NsdXNpb24odmlld1Bvc2l0aW9uLHZpZXdOb3JtYWwsbGluZWFyRGVwdGgsdlV2KTtmbG9hdCBkPXNtb290aHN0ZXAoZGlzdGFuY2VDdXRvZmYueCxkaXN0YW5jZUN1dG9mZi55LGxpbmVhckRlcHRoKTthbz1taXgoYW8sMC4wLGQpO1xcbiNpZmRlZiBMRUdBQ1lfSU5URU5TSVRZXFxuYW89Y2xhbXAoMS4wLXBvdygxLjAtYW8sYWJzKGludGVuc2l0eSkpLDAuMCwxLjApO1xcbiNlbmRpZlxcbn1nbF9GcmFnQ29sb3Iucj1hbzt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9zc2FvLnZlcnRcbnZhciBzc2FvX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgbm9pc2VTY2FsZTt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpbigpe3ZVdj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdjI9dlV2Km5vaXNlU2NhbGU7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvU1NBT01hdGVyaWFsLmpzXG52YXIgU1NBT01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDIwIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU1NBTyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJTU0FPTWF0ZXJpYWxcIixcbiAgICAgIGRlZmluZXM6IHtcbiAgICAgICAgU0FNUExFU19JTlQ6IFwiMFwiLFxuICAgICAgICBJTlZfU0FNUExFU19GTE9BVDogXCIwLjBcIixcbiAgICAgICAgU1BJUkFMX1RVUk5TOiBcIjAuMFwiLFxuICAgICAgICBSQURJVVM6IFwiMS4wXCIsXG4gICAgICAgIFJBRElVU19TUTogXCIxLjBcIixcbiAgICAgICAgRElTVEFOQ0VfU0NBTElORzogXCIxXCIsXG4gICAgICAgIERFUFRIX1BBQ0tJTkc6IFwiMFwiXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIG5vcm1hbEJ1ZmZlcjogbmV3IFVuaWZvcm0yMChudWxsKSxcbiAgICAgICAgbm9ybWFsRGVwdGhCdWZmZXI6IG5ldyBVbmlmb3JtMjAobnVsbCksXG4gICAgICAgIG5vaXNlVGV4dHVyZTogbmV3IFVuaWZvcm0yMChudWxsKSxcbiAgICAgICAgaW52ZXJzZVByb2plY3Rpb25NYXRyaXg6IG5ldyBVbmlmb3JtMjAobmV3IE1hdHJpeDQoKSksXG4gICAgICAgIHByb2plY3Rpb25NYXRyaXg6IG5ldyBVbmlmb3JtMjAobmV3IE1hdHJpeDQoKSksXG4gICAgICAgIHRleGVsU2l6ZTogbmV3IFVuaWZvcm0yMChuZXcgVmVjdG9yMjEyKCkpLFxuICAgICAgICBjYW1lcmFOZWFyRmFyOiBuZXcgVW5pZm9ybTIwKG5ldyBWZWN0b3IyMTIoKSksXG4gICAgICAgIGRpc3RhbmNlQ3V0b2ZmOiBuZXcgVW5pZm9ybTIwKG5ldyBWZWN0b3IyMTIoKSksXG4gICAgICAgIHByb3hpbWl0eUN1dG9mZjogbmV3IFVuaWZvcm0yMChuZXcgVmVjdG9yMjEyKCkpLFxuICAgICAgICBub2lzZVNjYWxlOiBuZXcgVW5pZm9ybTIwKG5ldyBWZWN0b3IyMTIoKSksXG4gICAgICAgIG1pblJhZGl1c1NjYWxlOiBuZXcgVW5pZm9ybTIwKDAuMzMpLFxuICAgICAgICBpbnRlbnNpdHk6IG5ldyBVbmlmb3JtMjAoMSksXG4gICAgICAgIGZhZGU6IG5ldyBVbmlmb3JtMjAoMC4wMSksXG4gICAgICAgIGJpYXM6IG5ldyBVbmlmb3JtMjAoMClcbiAgICAgIH0sXG4gICAgICBibGVuZGluZzogTm9CbGVuZGluZzIwLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBmcmFnbWVudFNoYWRlcjogc3Nhb19kZWZhdWx0LFxuICAgICAgdmVydGV4U2hhZGVyOiBzc2FvX2RlZmF1bHQyXG4gICAgfSk7XG4gICAgdGhpcy5jb3B5Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjEyKCk7XG4gICAgdGhpcy5yID0gMTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbmVhciBwbGFuZSBzZXR0aW5nLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IG5lYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS54O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmYXIgcGxhbmUgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBmYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS55O1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbWJpbmVkIG5vcm1hbC1kZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IG5vcm1hbERlcHRoQnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub3JtYWxEZXB0aEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSCA9IFwiMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5kZWZpbmVzLk5PUk1BTF9ERVBUSDtcbiAgICB9XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbWJpbmVkIG5vcm1hbC1kZXB0aCBidWZmZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBub3JtYWxEZXB0aEJ1ZmZlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYnVmZmVyLlxuICAgKi9cbiAgc2V0Tm9ybWFsRGVwdGhCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLm5vcm1hbERlcHRoQnVmZmVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3JtYWwgYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugbm9ybWFsQnVmZmVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBidWZmZXIuXG4gICAqL1xuICBzZXROb3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vcm1hbEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBkZXB0aEJ1ZmZlcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGVwdGhCdWZmZXIudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgc2V0IGRlcHRoUGFja2luZyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5ERVBUSF9QQUNLSU5HID0gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggYnVmZmVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVwdGhCdWZmZXIgYW5kIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGJ1ZmZlciAtIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcgc3RyYXRlZ3kuXG4gICAqL1xuICBzZXREZXB0aEJ1ZmZlcihidWZmZXIsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nNykge1xuICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBub2lzZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBub2lzZVRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm5vaXNlVGV4dHVyZS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2lzZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugbm9pc2VUZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0Tm9pc2VUZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5ub2lzZVRleHR1cmUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNhbXBsZSBjb3VudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLlNBTVBMRVNfSU5UKTtcbiAgfVxuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuZGVmaW5lcy5TQU1QTEVTX0lOVCA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgdGhpcy5kZWZpbmVzLklOVl9TQU1QTEVTX0ZMT0FUID0gKDEgLyB2YWx1ZSkudG9GaXhlZCg5KTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNhbXBsZXMgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgZ2V0U2FtcGxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbW91bnQgb2Ygb2NjbHVzaW9uIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2FtcGxlcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2FtcGxlIGNvdW50LlxuICAgKi9cbiAgc2V0U2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuc2FtcGxlcyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgc3BpcmFsIHJpbmcgY291bnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmluZ3MoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuU1BJUkFMX1RVUk5TKTtcbiAgfVxuICBzZXQgcmluZ3ModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuU1BJUkFMX1RVUk5TID0gdmFsdWUudG9GaXhlZCgxKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByaW5ncyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByYWRpdXMuXG4gICAqL1xuICBnZXRSaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5yaW5ncztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByaW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgcmFkaXVzLlxuICAgKi9cbiAgc2V0UmluZ3ModmFsdWUpIHtcbiAgICB0aGlzLnJpbmdzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBTU0FPRWZmZWN0LmludGVuc2l0eSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWU7XG4gIH1cbiAgc2V0IGludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuZGVmaW5lcy5MRUdBQ1lfSU5URU5TSVRZID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5MRUdBQ1lfSU5URU5TSVRZID0gXCIxXCI7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIFNTQU9FZmZlY3QuaW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIGdldEludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnRlbnNpdHkudmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIFNTQU9FZmZlY3QuaW50ZW5zaXR5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBzZXRJbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmludGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggZmFkZSBmYWN0b3IuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZmFkZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlO1xuICB9XG4gIHNldCBmYWRlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5mYWRlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlcHRoIGZhZGUgZmFjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZmFkZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmYWRlIGZhY3Rvci5cbiAgICovXG4gIGdldEZhZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZmFkZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggZmFkZSBmYWN0b3IuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmYWRlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBmYWRlIGZhY3Rvci5cbiAgICovXG4gIHNldEZhZGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZhZGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlcHRoIGJpYXMuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJpYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZTtcbiAgfVxuICBzZXQgYmlhcyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuYmlhcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBiaWFzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmlhcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiaWFzLlxuICAgKi9cbiAgZ2V0QmlhcygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5iaWFzLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCBiaWFzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmlhcyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYmlhcy5cbiAgICovXG4gIHNldEJpYXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmJpYXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5SYWRpdXNTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZTtcbiAgfVxuICBzZXQgbWluUmFkaXVzU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLm1pblJhZGl1c1NjYWxlLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1pbmltdW0gcmFkaXVzIHNjYWxlIGZvciBkaXN0YW5jZSBzY2FsaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluUmFkaXVzU2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqL1xuICBnZXRNaW5SYWRpdXNTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5taW5SYWRpdXNTY2FsZS52YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSByYWRpdXMgc2NhbGUgZm9yIGRpc3RhbmNlIHNjYWxpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtaW5SYWRpdXNTY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSByYWRpdXMgc2NhbGUuXG4gICAqL1xuICBzZXRNaW5SYWRpdXNTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWluUmFkaXVzU2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYWJzb2x1dGUgcmFkaXVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuciAqIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgdGhpcy5kZWZpbmVzLlJBRElVUyA9IHJhZGl1cy50b0ZpeGVkKDExKTtcbiAgICB0aGlzLmRlZmluZXMuUkFESVVTX1NRID0gKHJhZGl1cyAqIHJhZGl1cykudG9GaXhlZCgxMSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucjtcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5yID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIDFlLTYpLCAxKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcmFkaXVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmFkaXVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJhZGl1cy5cbiAgICovXG4gIGdldFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBzYW1wbGluZyByYWRpdXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYWRpdXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJhZGl1cy4gUmFuZ2UgWzFlLTYsIDEuMF0uXG4gICAqL1xuICBzZXRSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXN0YW5jZS1iYXNlZCByYWRpdXMgc2NhbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0YW5jZVNjYWxpbmcoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0IGRpc3RhbmNlU2NhbGluZyh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXN0YW5jZS1iYXNlZCByYWRpdXMgc2NhbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGRpc3RhbmNlIHNjYWxpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRGlzdGFuY2VTY2FsaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNjYWxpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGlzdGFuY2UtYmFzZWQgcmFkaXVzIHNjYWxpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIGRpc3RhbmNlIHNjYWxpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXREaXN0YW5jZVNjYWxpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5kaXN0YW5jZVNjYWxpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSB0aHJlc2hvbGQuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpc3RhbmNlQ3V0b2ZmLnZhbHVlLng7XG4gIH1cbiAgc2V0IGRpc3RhbmNlVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUgKyB0aGlzLmRpc3RhbmNlRmFsbG9mZiwgMCksIDEpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSB0aHJlc2hvbGQgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGREaXN0YW5jZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gLW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wih0aGlzLmRpc3RhbmNlVGhyZXNob2xkLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGREaXN0YW5jZVRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBmYWxsb2ZmLiBSYW5nZTogWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkaXN0YW5jZUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUueSAtIHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQ7XG4gIH1cbiAgc2V0IGRpc3RhbmNlRmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZGlzdGFuY2VDdXRvZmYudmFsdWUueSA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMuZGlzdGFuY2VUaHJlc2hvbGQgKyB2YWx1ZSwgMCksIDEpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIGRpc3RhbmNlIGZhbGxvZmYgaW4gd29ybGQgdW5pdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd29ybGREaXN0YW5jZUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5kaXN0YW5jZUZhbGxvZmYsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICB9XG4gIHNldCB3b3JsZERpc3RhbmNlRmFsbG9mZih2YWx1ZSkge1xuICAgIHRoaXMuZGlzdGFuY2VGYWxsb2ZmID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBkaXN0YW5jZSBjdXRvZmYuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkaXN0YW5jZVRocmVzaG9sZCBhbmQgZGlzdGFuY2VGYWxsb2ZmIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgZGlzdGFuY2UgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0RGlzdGFuY2VDdXRvZmYodGhyZXNob2xkLCBmYWxsb2ZmKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5kaXN0YW5jZUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh0aHJlc2hvbGQsIDApLCAxKSxcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCArIGZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IHRocmVzaG9sZC4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJveGltaXR5VGhyZXNob2xkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS54O1xuICB9XG4gIHNldCBwcm94aW1pdHlUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnByb3hpbWl0eUN1dG9mZi52YWx1ZS5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUgKyB0aGlzLnByb3hpbWl0eUZhbGxvZmYsIDApLCAxKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvY2NsdXNpb24gcHJveGltaXR5IHRocmVzaG9sZCBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZFByb3hpbWl0eVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gLW9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3Wih0aGlzLnByb3hpbWl0eVRocmVzaG9sZCwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgc2V0IHdvcmxkUHJveGltaXR5VGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5wcm94aW1pdHlUaHJlc2hvbGQgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoLXZhbHVlLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgZmFsbG9mZi4gUmFuZ2U6IFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJveGltaXR5RmFsbG9mZigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueSAtIHRoaXMucHJveGltaXR5VGhyZXNob2xkO1xuICB9XG4gIHNldCBwcm94aW1pdHlGYWxsb2ZmKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5wcm94aW1pdHlDdXRvZmYudmFsdWUueSA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMucHJveGltaXR5VGhyZXNob2xkICsgdmFsdWUsIDApLCAxKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgZmFsbG9mZiBpbiB3b3JsZCB1bml0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3b3JsZFByb3hpbWl0eUZhbGxvZmYoKSB7XG4gICAgcmV0dXJuIC1vcnRob2dyYXBoaWNEZXB0aFRvVmlld1oodGhpcy5wcm94aW1pdHlGYWxsb2ZmLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgfVxuICBzZXQgd29ybGRQcm94aW1pdHlGYWxsb2ZmKHZhbHVlKSB7XG4gICAgdGhpcy5wcm94aW1pdHlGYWxsb2ZmID0gdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKC12YWx1ZSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJveGltaXR5VGhyZXNob2xkIGFuZCBwcm94aW1pdHlGYWxsb2ZmIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgcmFuZ2UgdGhyZXNob2xkLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFsbG9mZiAtIFRoZSBmYWxsb2ZmLiBSYW5nZSBbMC4wLCAxLjBdLlxuICAgKi9cbiAgc2V0UHJveGltaXR5Q3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMudW5pZm9ybXMucHJveGltaXR5Q3V0b2ZmLnZhbHVlLnNldChcbiAgICAgIE1hdGgubWluKE1hdGgubWF4KHRocmVzaG9sZCwgMCksIDEpLFxuICAgICAgTWF0aC5taW4oTWF0aC5tYXgodGhyZXNob2xkICsgZmFsbG9mZiwgMCksIDEpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNldFNpemUoKSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB0ZXhlbCB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxuICAgKi9cbiAgc2V0VGV4ZWxTaXplKHgsIHkpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvcHlDYW1lcmFTZXR0aW5ncyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXG4gICAqL1xuICBhZG9wdENhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIHRoaXMuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGdpdmVuIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIEEgY2FtZXJhLlxuICAgKi9cbiAgY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSkge1xuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMuY2FtZXJhTmVhckZhci52YWx1ZS5zZXQoY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIpO1xuICAgICAgdGhpcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LnZhbHVlLmNvcHkoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgdGhpcy51bmlmb3Jtcy5pbnZlcnNlUHJvamVjdGlvbk1hdHJpeC52YWx1ZS5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKTtcbiAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYTYpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlBFUlNQRUNUSVZFX0NBTUVSQSA9IFwiMVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGVmaW5lcy5QRVJTUEVDVElWRV9DQU1FUkE7XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3Qgbm9pc2VUZXh0dXJlID0gdW5pZm9ybXMubm9pc2VUZXh0dXJlLnZhbHVlO1xuICAgIGlmIChub2lzZVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHVuaWZvcm1zLm5vaXNlU2NhbGUudmFsdWUuc2V0KFxuICAgICAgICB3aWR0aCAvIG5vaXNlVGV4dHVyZS5pbWFnZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0IC8gbm9pc2VUZXh0dXJlLmltYWdlLmhlaWdodFxuICAgICAgKTtcbiAgICB9XG4gICAgdW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXMoKTtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9UaWx0U2hpZnRCbHVyTWF0ZXJpYWwuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTIxLCBWZWN0b3IyIGFzIFZlY3RvcjIxMywgVmVjdG9yNCBhcyBWZWN0b3I0MiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL2dsc2wvY29udm9sdXRpb24udGlsdC1zaGlmdC5mcmFnXG52YXIgY29udm9sdXRpb25fdGlsdF9zaGlmdF9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzQgbWFza1BhcmFtczt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0O2Zsb2F0IGxpbmVhckdyYWRpZW50TWFzayhjb25zdCBpbiBmbG9hdCB4KXtyZXR1cm4gc21vb3Roc3RlcChtYXNrUGFyYW1zLngsbWFza1BhcmFtcy55LHgpLXNtb290aHN0ZXAobWFza1BhcmFtcy53LG1hc2tQYXJhbXMueix4KTt9dm9pZCBtYWluKCl7dmVjMiBkVXY9dk9mZnNldCooMS4wLWxpbmVhckdyYWRpZW50TWFzayh2VXYyLnkpKTt2ZWM0IHN1bT10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueC1kVXYueCx2VXYueStkVXYueSkpO3N1bSs9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZlYzIodlV2LngrZFV2LngsdlV2LnkrZFV2LnkpKTtzdW0rPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2ZWMyKHZVdi54K2RVdi54LHZVdi55LWRVdi55KSk7c3VtKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdmVjMih2VXYueC1kVXYueCx2VXYueS1kVXYueSkpO2dsX0ZyYWdDb2xvcj1zdW0qMC4yNTtcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi50aWx0LXNoaWZ0LnZlcnRcbnZhciBjb252b2x1dGlvbl90aWx0X3NoaWZ0X2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzQgdGV4ZWxTaXplO3VuaWZvcm0gZmxvYXQga2VybmVsO3VuaWZvcm0gZmxvYXQgc2NhbGU7dW5pZm9ybSBmbG9hdCBhc3BlY3Q7dW5pZm9ybSB2ZWMyIHJvdGF0aW9uO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZPZmZzZXQ7dm9pZCBtYWluKCl7dmVjMiB1dj1wb3NpdGlvbi54eSowLjUrMC41O3ZVdj11djt2VXYyPSh1di0wLjUpKjIuMCp2ZWMyKGFzcGVjdCwxLjApO3ZVdjI9dmVjMihkb3Qocm90YXRpb24sdlV2MiksZG90KHJvdGF0aW9uLHZlYzIodlV2Mi55LC12VXYyLngpKSk7dk9mZnNldD0odGV4ZWxTaXplLnh5KnZlYzIoa2VybmVsKSt0ZXhlbFNpemUuencpKnNjYWxlO2dsX1Bvc2l0aW9uPXZlYzQocG9zaXRpb24ueHksMS4wLDEuMCk7fVwiO1xuXG4vLyBzcmMvbWF0ZXJpYWxzL1RpbHRTaGlmdEJsdXJNYXRlcmlhbC5qc1xudmFyIFRpbHRTaGlmdEJsdXJNYXRlcmlhbCA9IGNsYXNzIGV4dGVuZHMgS2F3YXNlQmx1ck1hdGVyaWFsIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdGlsdCBzaGlmdCBibHVyIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MC4wXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wLjBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1c0FyZWE9MC40XSAtIFRoZSByZWxhdGl2ZSBzaXplIG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmVhdGhlcj0wLjNdIC0gVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLk1FRElVTSxcbiAgICBvZmZzZXQgPSAwLFxuICAgIHJvdGF0aW9uID0gMCxcbiAgICBmb2N1c0FyZWEgPSAwLjQsXG4gICAgZmVhdGhlciA9IDAuM1xuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBjb252b2x1dGlvbl90aWx0X3NoaWZ0X2RlZmF1bHQ7XG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBjb252b2x1dGlvbl90aWx0X3NoaWZ0X2RlZmF1bHQyO1xuICAgIHRoaXMua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHVwZGF0ZUZyYWdtZW50U2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMudW5pZm9ybXMuYXNwZWN0ID0gbmV3IFVuaWZvcm0yMSgxKTtcbiAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uID0gbmV3IFVuaWZvcm0yMShuZXcgVmVjdG9yMjEzKCkpO1xuICAgIHRoaXMudW5pZm9ybXMubWFza1BhcmFtcyA9IG5ldyBVbmlmb3JtMjEobmV3IFZlY3RvcjQyKCkpO1xuICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLl9mb2N1c0FyZWEgPSBmb2N1c0FyZWE7XG4gICAgdGhpcy5fZmVhdGhlciA9IGZlYXRoZXI7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVQYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy51bmlmb3Jtcy5tYXNrUGFyYW1zLnZhbHVlO1xuICAgIGNvbnN0IGEgPSBNYXRoLm1heCh0aGlzLmZvY3VzQXJlYSwgMCk7XG4gICAgY29uc3QgYiA9IE1hdGgubWF4KGEgLSB0aGlzLmZlYXRoZXIsIDApO1xuICAgIHBhcmFtcy5zZXQoXG4gICAgICB0aGlzLm9mZnNldCAtIGEsXG4gICAgICB0aGlzLm9mZnNldCAtIGIsXG4gICAgICB0aGlzLm9mZnNldCArIGEsXG4gICAgICB0aGlzLm9mZnNldCArIGJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGZvY3VzIGFyZWEgaW4gcmFkaWFucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKHRoaXMudW5pZm9ybXMucm90YXRpb24udmFsdWUueCk7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvbi52YWx1ZS5zZXQoTWF0aC5jb3ModmFsdWUpLCBNYXRoLnNpbih2YWx1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmb2N1c0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzQXJlYTtcbiAgfVxuICBzZXQgZm9jdXNBcmVhKHZhbHVlKSB7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZlYXRoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZlYXRoZXI7XG4gIH1cbiAgc2V0IGZlYXRoZXIodmFsdWUpIHtcbiAgICB0aGlzLl9mZWF0aGVyID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHN1cGVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy5hc3BlY3QudmFsdWUgPSB3aWR0aCAvIGhlaWdodDtcbiAgfVxufTtcblxuLy8gc3JjL21hdGVyaWFscy9VcHNhbXBsaW5nTWF0ZXJpYWwuanNcbmltcG9ydCB7IE5vQmxlbmRpbmcgYXMgTm9CbGVuZGluZzIxLCBTaGFkZXJNYXRlcmlhbCBhcyBTaGFkZXJNYXRlcmlhbDIxLCBVbmlmb3JtIGFzIFVuaWZvcm0yMiwgVmVjdG9yMiBhcyBWZWN0b3IyMTQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL21hdGVyaWFscy9nbHNsL2NvbnZvbHV0aW9uLnVwc2FtcGxpbmcuZnJhZ1xudmFyIGNvbnZvbHV0aW9uX3Vwc2FtcGxpbmdfZGVmYXVsdCA9IFwiI2lmZGVmIEZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBpbnB1dEJ1ZmZlcjt1bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIHN1cHBvcnRCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGlucHV0QnVmZmVyO3VuaWZvcm0gbG93cCBzYW1wbGVyMkQgc3VwcG9ydEJ1ZmZlcjtcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHJhZGl1czt2YXJ5aW5nIHZlYzIgdlV2O3ZhcnlpbmcgdmVjMiB2VXYwO3ZhcnlpbmcgdmVjMiB2VXYxO3ZhcnlpbmcgdmVjMiB2VXYyO3ZhcnlpbmcgdmVjMiB2VXYzO3ZhcnlpbmcgdmVjMiB2VXY0O3ZhcnlpbmcgdmVjMiB2VXY1O3ZhcnlpbmcgdmVjMiB2VXY2O3ZhcnlpbmcgdmVjMiB2VXY3O3ZvaWQgbWFpbigpe3ZlYzQgYz12ZWM0KDAuMCk7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjApKjAuMDYyNTtjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MSkqMC4xMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjIpKjAuMDYyNTtjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2MykqMC4xMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdikqMC4yNTtjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NCkqMC4xMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjUpKjAuMDYyNTtjKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2NikqMC4xMjU7Yys9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdjcpKjAuMDYyNTt2ZWM0IGJhc2VDb2xvcj10ZXh0dXJlMkQoc3VwcG9ydEJ1ZmZlcix2VXYpO2dsX0ZyYWdDb2xvcj1taXgoYmFzZUNvbG9yLGMscmFkaXVzKTtcXG4jaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cXG59XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvZ2xzbC9jb252b2x1dGlvbi51cHNhbXBsaW5nLnZlcnRcbnZhciBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO3ZhcnlpbmcgdmVjMiB2VXY7dmFyeWluZyB2ZWMyIHZVdjA7dmFyeWluZyB2ZWMyIHZVdjE7dmFyeWluZyB2ZWMyIHZVdjI7dmFyeWluZyB2ZWMyIHZVdjM7dmFyeWluZyB2ZWMyIHZVdjQ7dmFyeWluZyB2ZWMyIHZVdjU7dmFyeWluZyB2ZWMyIHZVdjY7dmFyeWluZyB2ZWMyIHZVdjc7dm9pZCBtYWluKCl7dlV2PXBvc2l0aW9uLnh5KjAuNSswLjU7dlV2MD12VXYrdGV4ZWxTaXplKnZlYzIoLTEuMCwxLjApO3ZVdjE9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwxLjApO3ZVdjI9dlV2K3RleGVsU2l6ZSp2ZWMyKDEuMCwxLjApO3ZVdjM9dlV2K3RleGVsU2l6ZSp2ZWMyKC0xLjAsMC4wKTt2VXY0PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2VXY1PXZVdit0ZXhlbFNpemUqdmVjMigtMS4wLC0xLjApO3ZVdjY9dlV2K3RleGVsU2l6ZSp2ZWMyKDAuMCwtMS4wKTt2VXY3PXZVdit0ZXhlbFNpemUqdmVjMigxLjAsLTEuMCk7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbi54eSwxLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9tYXRlcmlhbHMvVXBzYW1wbGluZ01hdGVyaWFsLmpzXG52YXIgVXBzYW1wbGluZ01hdGVyaWFsID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbDIxIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdXBzYW1wbGluZyBtYXRlcmlhbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiVXBzYW1wbGluZ01hdGVyaWFsXCIsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBpbnB1dEJ1ZmZlcjogbmV3IFVuaWZvcm0yMihudWxsKSxcbiAgICAgICAgc3VwcG9ydEJ1ZmZlcjogbmV3IFVuaWZvcm0yMihudWxsKSxcbiAgICAgICAgdGV4ZWxTaXplOiBuZXcgVW5pZm9ybTIyKG5ldyBWZWN0b3IyMTQoKSksXG4gICAgICAgIHJhZGl1czogbmV3IFVuaWZvcm0yMigwLjg1KVxuICAgICAgfSxcbiAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nMjEsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGNvbnZvbHV0aW9uX3Vwc2FtcGxpbmdfZGVmYXVsdDJcbiAgICB9KTtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gdXBkYXRlRnJhZ21lbnRTaGFkZXIodGhpcy5mcmFnbWVudFNoYWRlcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgc2V0IGlucHV0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5pbnB1dEJ1ZmZlci52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBBIHN1cHBvcnQgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIHNldCBzdXBwb3J0QnVmZmVyKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5zdXBwb3J0QnVmZmVyLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCByYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuc2V0KDEgLyB3aWR0aCwgMSAvIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ29weVBhc3MuanNcbmltcG9ydCB7IExpbmVhckZpbHRlciwgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9wYXNzZXMvUGFzcy5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc4LFxuICBCdWZmZXJBdHRyaWJ1dGUsXG4gIEJ1ZmZlckdlb21ldHJ5LFxuICBDYW1lcmEsXG4gIE1hdGVyaWFsLFxuICBNZXNoLFxuICBTY2VuZSxcbiAgVGV4dHVyZSxcbiAgV2ViR0xSZW5kZXJUYXJnZXRcbn0gZnJvbSBcInRocmVlXCI7XG52YXIgZHVtbXlDYW1lcmEgPSAvKiBAX19QVVJFX18gKi8gbmV3IENhbWVyYSgpO1xudmFyIGdlb21ldHJ5ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEZ1bGxzY3JlZW5UcmlhbmdsZSgpIHtcbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDAsIDMsIC0xLCAwLCAtMSwgMywgMF0pO1xuICAgIGNvbnN0IHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDIsIDAsIDAsIDJdKTtcbiAgICBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeS5zZXRBdHRyaWJ1dGUgIT09IHZvaWQgMCkge1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKFwidXZcIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5O1xufVxudmFyIFBhc3MgPSBjbGFzcyBfUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuIERvZXMgbm90IGhhdmUgdG8gYmUgdW5pcXVlLlxuICAgKiBAcGFyYW0ge1NjZW5lfSBbc2NlbmVdIC0gVGhlIHNjZW5lIHRvIHJlbmRlci4gVGhlIGRlZmF1bHQgc2NlbmUgY29udGFpbnMgYSBzaW5nbGUgbWVzaCB0aGF0IGZpbGxzIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLiBGdWxsc2NyZWVuIGVmZmVjdCBwYXNzZXMgZG9uJ3QgcmVxdWlyZSBhIGNhbWVyYS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUgPSBcIlBhc3NcIiwgc2NlbmUgPSBuZXcgU2NlbmUoKSwgY2FtZXJhID0gZHVtbXlDYW1lcmEpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5ydHQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIHRvIHNjcmVlbiBmbGFnLlxuICAgKlxuICAgKiBJZiB0aGlzIGZsYWcgaXMgY2hhbmdlZCwgdGhlIGZ1bGxzY3JlZW4gbWF0ZXJpYWwgd2lsbCBiZSB1cGRhdGVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHJlbmRlclRvU2NyZWVuKCkge1xuICAgIHJldHVybiAhdGhpcy5ydHQ7XG4gIH1cbiAgc2V0IHJlbmRlclRvU2NyZWVuKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucnR0ID09PSB2YWx1ZSkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICAgIGlmIChtYXRlcmlhbCAhPT0gbnVsbCkge1xuICAgICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJ0dCA9ICF2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gc2NlbmUuXG4gICAqXG4gICAqIEB0eXBlIHtTY2VuZX1cbiAgICovXG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBjYW1lcmEuXG4gICAqXG4gICAqIEB0eXBlIHtDYW1lcmF9XG4gICAqL1xuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlclxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgcGFzcyBpcyBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZW5hYmxlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgcGFzcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZ1bGxzY3JlZW4gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICovXG4gIGdldCBmdWxsc2NyZWVuTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuICE9PSBudWxsID8gdGhpcy5zY3JlZW4ubWF0ZXJpYWwgOiBudWxsO1xuICB9XG4gIHNldCBmdWxsc2NyZWVuTWF0ZXJpYWwodmFsdWUpIHtcbiAgICBsZXQgc2NyZWVuID0gdGhpcy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbiAhPT0gbnVsbCkge1xuICAgICAgc2NyZWVuLm1hdGVyaWFsID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmVlbiA9IG5ldyBNZXNoKGdldEZ1bGxzY3JlZW5UcmlhbmdsZSgpLCB2YWx1ZSk7XG4gICAgICBzY3JlZW4uZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuc2NlbmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBTY2VuZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NyZWVuKTtcbiAgICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hdGVyaWFsfSBUaGUgY3VycmVudCBmdWxsc2NyZWVuIG1hdGVyaWFsLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAqL1xuICBnZXRGdWxsc2NyZWVuTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmdWxsc2NyZWVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtNYXRlcmlhbH0gdmFsdWUgLSBBIGZ1bGxzY3JlZW4gbWF0ZXJpYWwuXG4gICAqL1xuICBzZXRGdWxsc2NyZWVuTWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICovXG4gIGdldERlcHRoVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfS5cbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIHBhc3MgcmVsaWVzIG9uIHRoZSBkZXB0aCBpbmZvcm1hdGlvbiBvZiBhIHByZWNlZGluZyB7QGxpbmsgUmVuZGVyUGFzc30uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWd5fSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc4KSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IG1ldGhvZCB0aGF0IG11c3QgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQhXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIGJlIGluZm9ybWVkIGFib3V0IHRoZSBzaXplIG9mIHRoZSBiYWNrYnVmZmVyL2NhbnZhcy5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJlZm9yZSB7QGxpbmsgaW5pdGlhbGl6ZX0gYW5kIGV2ZXJ5IHRpbWUgdGhlIHNpemUgb2YgdGhlIHtAbGluayBFZmZlY3RDb21wb3Nlcn0gY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhpcyBwYXNzIGlzIGFkZGVkIHRvIGFuIHtAbGluayBFZmZlY3RDb21wb3Nlcn0uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2hhbGxvdyBzZWFyY2ggZm9yIGRpc3Bvc2FibGUgcHJvcGVydGllcyBhbmQgZGVsZXRlcyB0aGVtLlxuICAgKlxuICAgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC4gWW91IGNhbiB1c2UgaXQgaW5kZXBlbmRlbnRseSB0byBmcmVlXG4gICAqIG1lbW9yeSB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgeW91IGRvbid0IG5lZWQgdGhpcyBwYXNzIGFueW1vcmUuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXNba2V5XTtcbiAgICAgIGNvbnN0IGlzRGlzcG9zYWJsZSA9IHByb3BlcnR5IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJUYXJnZXQgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIFRleHR1cmUgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBfUGFzcztcbiAgICAgIGlmIChpc0Rpc3Bvc2FibGUpIHtcbiAgICAgICAgdGhpc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvQ29weVBhc3MuanNcbnZhciBDb3B5UGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNhdmUgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldF0gLSBBIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F1dG9SZXNpemU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNpemUgc2hvdWxkIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlclRhcmdldCwgYXV0b1Jlc2l6ZSA9IHRydWUpIHtcbiAgICBzdXBlcihcIkNvcHlQYXNzXCIpO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHJlbmRlclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIoMSwgMSwge1xuICAgICAgICBtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcbiAgICAgICAgbWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJDb3B5UGFzcy5UYXJnZXRcIjtcbiAgICB9XG4gICAgdGhpcy5hdXRvUmVzaXplID0gYXV0b1Jlc2l6ZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvIHJlc2l6aW5nIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYXV0b1Jlc2l6ZSBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCByZXNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0b1Jlc2l6ZTtcbiAgfVxuICBzZXQgcmVzaXplKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvUmVzaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3V0cHV0IHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvIHJlc2l6aW5nIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYXV0b1Jlc2l6ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBzZXRBdXRvUmVzaXplRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgaW5wdXQgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IGlucHV0QnVmZmVyLnRleHR1cmU7XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogdGhpcy5yZW5kZXJUYXJnZXQpO1xuICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTIpIHtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9BZGFwdGl2ZUx1bWluYW5jZVBhc3MuanNcbnZhciBBZGFwdGl2ZUx1bWluYW5jZVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBhZGFwdGl2ZSBsdW1pbmFuY2UgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBsdW1pbmFuY2VCdWZmZXIgLSBBIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHNjZW5lIGx1bWluYW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluTHVtaW5hbmNlPTAuMDFdIC0gVGhlIG1pbmltdW0gbHVtaW5hbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWRhcHRhdGlvblJhdGU9MS4wXSAtIFRoZSBsdW1pbmFuY2UgYWRhcHRhdGlvbiByYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobHVtaW5hbmNlQnVmZmVyLCB7IG1pbkx1bWluYW5jZSA9IDAuMDEsIGFkYXB0YXRpb25SYXRlID0gMSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkFkYXB0aXZlTHVtaW5hbmNlUGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG5ldyBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsKCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MygxLCAxLCB7XG4gICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG4gICAgICBkZXB0aEJ1ZmZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLnRleHR1cmUubmFtZSA9IFwiTHVtaW5hbmNlLlByZXZpb3VzXCI7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBtYXRlcmlhbC5sdW1pbmFuY2VCdWZmZXIwID0gdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy50ZXh0dXJlO1xuICAgIG1hdGVyaWFsLmx1bWluYW5jZUJ1ZmZlcjEgPSBsdW1pbmFuY2VCdWZmZXI7XG4gICAgbWF0ZXJpYWwubWluTHVtaW5hbmNlID0gbWluTHVtaW5hbmNlO1xuICAgIG1hdGVyaWFsLmFkYXB0YXRpb25SYXRlID0gYWRhcHRhdGlvblJhdGU7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkID0gdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlLm5hbWUgPSBcIkx1bWluYW5jZS5BZGFwdGVkXCI7XG4gICAgdGhpcy5jb3B5UGFzcyA9IG5ldyBDb3B5UGFzcyh0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLCBmYWxzZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhZGFwdGl2ZSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFkYXB0aXZlIDF4MSBsdW1pbmFuY2UgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgMXgxIG1pcG1hcCBsZXZlbC5cbiAgICpcbiAgICogVGhpcyBsZXZlbCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzbWFsbGVzdCBtaXBtYXAgb2YgdGhlIG1haW4gbHVtaW5hbmNlIHRleHR1cmUgd2hpY2ggY29udGFpbnMgdGhlIGRvd25zYW1wbGVkXG4gICAqIGF2ZXJhZ2Ugc2NlbmUgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZnVsbHNjcmVlbk1hdGVyaWFsLm1pcExldmVsMXgxIGluc3RlYWQuXG4gICAqL1xuICBzZXQgbWlwTGV2ZWwxeDEodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5taXBMZXZlbDF4MSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFkYXB0YXRpb25SYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGFkYXB0YXRpb25SYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVsdGFUaW1lID0gZGVsdGFUaW1lO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZCk7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB0aGlzLmNvcHlQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkKTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9Cb3hCbHVyUGFzcy5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmc5LCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUzLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDQgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBCb3hCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJveCBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9NV0gLSBNdXN0IGJlIGFuIG9kZCBudW1iZXIuIFRoZSBzaXplcyAzIGFuZCA1IHVzZSBvcHRpbWl6ZWQgY29kZSBwYXRocy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MV0gLSBUaGUgYW1vdW50IG9mIHRpbWVzIHRoZSBibHVyIHNob3VsZCBiZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlsYXRlcmFsPWZhbHNlXSAtIEVuYWJsZXMgb3IgZGlzYWJsZXMgYmlsYXRlcmFsIGJsdXJyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBrZXJuZWxTaXplID0gNSxcbiAgICBpdGVyYXRpb25zID0gMSxcbiAgICBiaWxhdGVyYWwgPSBmYWxzZSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHJlc29sdXRpb25YID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblkgPSBSZXNvbHV0aW9uLkFVVE9fU0laRVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkJveEJsdXJQYXNzXCIpO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSBiaWxhdGVyYWw7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0NCgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5CXCI7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBuZXcgQm94Qmx1ck1hdGVyaWFsKHsgYmlsYXRlcmFsLCBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc5KSB7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBibHVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QSA9IHRoaXMucmVuZGVyVGFyZ2V0QTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRCO1xuICAgIGNvbnN0IGJsdXJNYXRlcmlhbCA9IHRoaXMuYmx1ck1hdGVyaWFsO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gYmx1ck1hdGVyaWFsO1xuICAgIGxldCBwcmV2aW91c0J1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gTWF0aC5tYXgodGhpcy5pdGVyYXRpb25zLCAxKTsgaSA8IGw7ICsraSkge1xuICAgICAgY29uc3QgYnVmZmVyID0gKGkgJiAxKSA9PT0gMCA/IHJlbmRlclRhcmdldEEgOiByZW5kZXJUYXJnZXRCO1xuICAgICAgYmx1ck1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChidWZmZXIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgcHJldmlvdXNCdWZmZXIgPSBidWZmZXI7XG4gICAgfVxuICAgIHRoaXMuY29weU1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLm1heFZhcnlpbmdWZWN0b3JzID0gcmVuZGVyZXIuY2FwYWJpbGl0aWVzLm1heFZhcnlpbmdzO1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlMykge1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9DbGVhck1hc2tQYXNzLmpzXG52YXIgQ2xlYXJNYXNrUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNsZWFyIG1hc2sgcGFzcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQ2xlYXJNYXNrUGFzc1wiLCBudWxsLCBudWxsKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgZ2xvYmFsIHN0ZW5jaWwgdGVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc3RlbmNpbCA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbDtcbiAgICBzdGVuY2lsLnNldExvY2tlZChmYWxzZSk7XG4gICAgc3RlbmNpbC5zZXRUZXN0KGZhbHNlKTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9DbGVhclBhc3MuanNcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcInRocmVlXCI7XG52YXIgY29sb3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IENvbG9yKCk7XG52YXIgQ2xlYXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29sb3I9dHJ1ZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbG9yIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVwdGg9dHJ1ZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRlcHRoIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbD1mYWxzZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0ZW5jaWwgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29sb3IyID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gZmFsc2UpIHtcbiAgICBzdXBlcihcIkNsZWFyUGFzc1wiLCBudWxsLCBudWxsKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc3RlbmNpbCA9IHN0ZW5jaWw7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBudWxsO1xuICAgIHRoaXMub3ZlcnJpZGVDbGVhckFscGhhID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNsZWFyIGZsYWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9yIC0gV2hldGhlciB0aGUgY29sb3IgYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRoIC0gV2hldGhlciB0aGUgZGVwdGggYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0ZW5jaWwgLSBXaGV0aGVyIHRoZSBzdGVuY2lsIGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICovXG4gIHNldENsZWFyRmxhZ3MoY29sb3IyLCBkZXB0aCwgc3RlbmNpbCkge1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuc3RlbmNpbCA9IHN0ZW5jaWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG92ZXJyaWRlIGNsZWFyIGNvbG9yLiBEZWZhdWx0IGlzIG51bGwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQ29sb3IgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q29sb3J9IFRoZSBjbGVhciBjb2xvci5cbiAgICovXG4gIGdldE92ZXJyaWRlQ2xlYXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZUNsZWFyQ29sb3I7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJyaWRlIGNsZWFyIGNvbG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVDbGVhckNvbG9yIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Q29sb3J9IHZhbHVlIC0gVGhlIGNsZWFyIGNvbG9yLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVDbGVhckNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy5vdmVycmlkZUNsZWFyQ29sb3IgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3ZlcnJpZGUgY2xlYXIgYWxwaGEuIERlZmF1bHQgaXMgLTEuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZUNsZWFyQWxwaGEgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2xlYXIgYWxwaGEuXG4gICAqL1xuICBnZXRPdmVycmlkZUNsZWFyQWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcnJpZGVDbGVhckFscGhhO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBjbGVhciBhbHBoYS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlQ2xlYXJBbHBoYSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY2xlYXIgYWxwaGEuXG4gICAqL1xuICBzZXRPdmVycmlkZUNsZWFyQWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGlucHV0IGJ1ZmZlciBvciB0aGUgc2NyZWVuLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCBvdmVycmlkZUNsZWFyQ29sb3IgPSB0aGlzLm92ZXJyaWRlQ2xlYXJDb2xvcjtcbiAgICBjb25zdCBvdmVycmlkZUNsZWFyQWxwaGEgPSB0aGlzLm92ZXJyaWRlQ2xlYXJBbHBoYTtcbiAgICBjb25zdCBjbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuICAgIGNvbnN0IGhhc092ZXJyaWRlQ2xlYXJDb2xvciA9IG92ZXJyaWRlQ2xlYXJDb2xvciAhPT0gbnVsbDtcbiAgICBjb25zdCBoYXNPdmVycmlkZUNsZWFyQWxwaGEgPSBvdmVycmlkZUNsZWFyQWxwaGEgPj0gMDtcbiAgICBpZiAoaGFzT3ZlcnJpZGVDbGVhckNvbG9yKSB7XG4gICAgICByZW5kZXJlci5nZXRDbGVhckNvbG9yKGNvbG9yKTtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3Iob3ZlcnJpZGVDbGVhckNvbG9yLCBoYXNPdmVycmlkZUNsZWFyQWxwaGEgPyBvdmVycmlkZUNsZWFyQWxwaGEgOiBjbGVhckFscGhhKTtcbiAgICB9IGVsc2UgaWYgKGhhc092ZXJyaWRlQ2xlYXJBbHBoYSkge1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJBbHBoYShvdmVycmlkZUNsZWFyQWxwaGEpO1xuICAgIH1cbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBpbnB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIuY2xlYXIodGhpcy5jb2xvciwgdGhpcy5kZXB0aCwgdGhpcy5zdGVuY2lsKTtcbiAgICBpZiAoaGFzT3ZlcnJpZGVDbGVhckNvbG9yKSB7XG4gICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKGNvbG9yLCBjbGVhckFscGhhKTtcbiAgICB9IGVsc2UgaWYgKGhhc092ZXJyaWRlQ2xlYXJBbHBoYSkge1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJBbHBoYShjbGVhckFscGhhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhQYXNzLmpzXG5pbXBvcnQgeyBDb2xvciBhcyBDb2xvcjIsIE1lc2hEZXB0aE1hdGVyaWFsLCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXIyLCBSR0JBRGVwdGhQYWNraW5nIGFzIFJHQkFEZXB0aFBhY2tpbmcyLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3Bhc3Nlcy9SZW5kZXJQYXNzLmpzXG52YXIgUmVuZGVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJlbmRlciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3ZlcnJpZGVNYXRlcmlhbD1udWxsXSAtIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCA9IG51bGwpIHtcbiAgICBzdXBlcihcIlJlbmRlclBhc3NcIiwgc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyUGFzcyA9IG5ldyBDbGVhclBhc3MoKTtcbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IG51bGwgOiBuZXcgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIob3ZlcnJpZGVNYXRlcmlhbCk7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5za2lwU2hhZG93TWFwVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIGdldCByZW5kZXJUb1NjcmVlbigpIHtcbiAgICByZXR1cm4gc3VwZXIucmVuZGVyVG9TY3JlZW47XG4gIH1cbiAgc2V0IHJlbmRlclRvU2NyZWVuKHZhbHVlKSB7XG4gICAgc3VwZXIucmVuZGVyVG9TY3JlZW4gPSB2YWx1ZTtcbiAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXJUb1NjcmVlbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IG92ZXJyaWRlTWF0ZXJpYWwoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXI7XG4gICAgcmV0dXJuIG1hbmFnZXIgIT09IG51bGwgPyBtYW5hZ2VyLm1hdGVyaWFsIDogbnVsbDtcbiAgfVxuICBzZXQgb3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgbWFuYWdlci5zZXRNYXRlcmlhbCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyID0gbmV3IE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIG1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsTWFuYWdlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0T3ZlcnJpZGVNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvdmVycmlkZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IHZhbHVlIC0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgc2V0T3ZlcnJpZGVNYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGJ1ZmZlciBzaG91bGQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGNsZWFyKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhclBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3Rpb24uIERlZmF1bHQgaXMgYG51bGxgIChubyByZXN0cmljdGlvbikuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGUgc2VsZWN0aW9uLlxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHZhbHVlIC0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzY2VuZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNCYWNrZ3JvdW5kRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2NlbmUgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNjZW5lIGJhY2tncm91bmQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzaGFkb3cgbWFwIGF1dG8gdXBkYXRlIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2tpcFNoYWRvd01hcFVwZGF0ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzaGFkb3cgbWFwIHVwZGF0ZSBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGlzU2hhZG93TWFwRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFNoYWRvd01hcFVwZGF0ZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93IG1hcCBhdXRvIHVwZGF0ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNraXBTaGFkb3dNYXBVcGRhdGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIHNoYWRvdyBtYXAgYXV0byB1cGRhdGUgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0U2hhZG93TWFwRGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLnNraXBTaGFkb3dNYXBVcGRhdGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xlYXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NsZWFyUGFzc30gVGhlIGNsZWFyIHBhc3MuXG4gICAqL1xuICBnZXRDbGVhclBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzY2VuZS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgIGNvbnN0IG1hc2sgPSBjYW1lcmEubGF5ZXJzLm1hc2s7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgY29uc3Qgc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogaW5wdXRCdWZmZXI7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgY2FtZXJhLmxheWVycy5zZXQoc2VsZWN0aW9uLmdldExheWVyKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwU2hhZG93TWFwVXBkYXRlKSB7XG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVCYWNrZ3JvdW5kIHx8IHRoaXMuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciAhPT0gbnVsbCkge1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsZWFyUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIucmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBjYW1lcmEubGF5ZXJzLm1hc2sgPSBtYXNrO1xuICAgIHNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIHJlbmRlcmVyLnNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aFBhc3MuanNcbnZhciBEZXB0aFBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZSB0byByZW5kZXIgdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IFtvcHRpb25zLnJlbmRlclRhcmdldF0gLSBBIGN1c3RvbSByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTEuMF0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwge1xuICAgIHJlbmRlclRhcmdldCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoUGFzc1wiKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEsIG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7XG4gICAgICBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcyXG4gICAgfSkpO1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSB0aGlzLnJlbmRlclBhc3M7XG4gICAgcmVuZGVyUGFzcy5za2lwU2hhZG93TWFwVXBkYXRlID0gdHJ1ZTtcbiAgICByZW5kZXJQYXNzLmlnbm9yZUJhY2tncm91bmQgPSB0cnVlO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHJlbmRlclBhc3MuY2xlYXJQYXNzO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3IyKDE2Nzc3MjE1KTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ1KDEsIDEsIHtcbiAgICAgICAgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyMixcbiAgICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyMlxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRlcHRoUGFzcy5UYXJnZXRcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgc2V0IG1haW5TY2VuZSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMucmVuZGVyUGFzcy5tYWluQ2FtZXJhID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIGRlcHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0RlcHRoRG93bnNhbXBsaW5nUGFzcy5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMCwgRmxvYXRUeXBlLCBOZWFyZXN0RmlsdGVyIGFzIE5lYXJlc3RGaWx0ZXIzLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDYgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBEZXB0aERvd25zYW1wbGluZ1Bhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBkb3duc2FtcGxpbmcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLm5vcm1hbEJ1ZmZlcj1udWxsXSAtIEEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHZpZXcgc3BhY2Ugbm9ybWFscy4gU2VlIHtAbGluayBOb3JtYWxQYXNzfS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBub3JtYWxCdWZmZXIgPSBudWxsLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDAuNSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aERvd25zYW1wbGluZ1Bhc3NcIik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgRGVwdGhEb3duc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIG1hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IG5vcm1hbEJ1ZmZlcjtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ2KDEsIDEsIHtcbiAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjMsXG4gICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIzLFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgdHlwZTogRmxvYXRUeXBlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJEZXB0aERvd25zYW1wbGluZ1Bhc3MuVGFyZ2V0XCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbChSR0IpICsgZGVwdGgoQSkgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9ybWFsKFJHQikgKyBkZXB0aChBKSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nIHN0cmF0ZWd5LlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMCkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogRG93bnNhbXBsZXMgZGVwdGggYW5kIHNjZW5lIG5vcm1hbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICBjb25zdCByZW5kZXJhYmxlID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIik7XG4gICAgaWYgKCFyZW5kZXJhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJpbmcgdG8gZmxvYXQgdGV4dHVyZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhQaWNraW5nUGFzcy5qc1xuaW1wb3J0IHsgRmxvYXRUeXBlIGFzIEZsb2F0VHlwZTMsIFJHQkFEZXB0aFBhY2tpbmcgYXMgUkdCQURlcHRoUGFja2luZzQgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL3Bhc3Nlcy9EZXB0aENvcHlQYXNzLmpzXG5pbXBvcnQge1xuICBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzExLFxuICBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlMixcbiAgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNCxcbiAgUkdCQURlcHRoUGFja2luZyBhcyBSR0JBRGVwdGhQYWNraW5nMyxcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlNCxcbiAgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ3XG59IGZyb20gXCJ0aHJlZVwiO1xudmFyIERlcHRoQ29weVBhc3MgPSBjbGFzcyBleHRlbmRzIFBhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBzYXZlIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbb3B0aW9ucy5kZXB0aFBhY2tpbmc9UkdCQURlcHRoUGFja2luZ10gLSBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmczIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiRGVwdGhDb3B5UGFzc1wiKTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBEZXB0aENvcHlNYXRlcmlhbCgpO1xuICAgIG1hdGVyaWFsLm91dHB1dERlcHRoUGFja2luZyA9IGRlcHRoUGFja2luZztcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ3KDEsIDEsIHtcbiAgICAgIHR5cGU6IGRlcHRoUGFja2luZyA9PT0gUkdCQURlcHRoUGFja2luZzMgPyBVbnNpZ25lZEJ5dGVUeXBlNCA6IEZsb2F0VHlwZTIsXG4gICAgICBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXI0LFxuICAgICAgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyNCxcbiAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRGVwdGhDb3B5UGFzcy5UYXJnZXRcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIG91dHB1dCBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUuXG4gICAqL1xuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGRlcHRoIHBhY2tpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfVxuICAgKi9cbiAgZ2V0IGRlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwub3V0cHV0RGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgZGVwdGggcGFja2luZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRlcHRoUGFja2luZyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIGdldERlcHRoUGFja2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwub3V0cHV0RGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIEEgZGVwdGggdGV4dHVyZS5cbiAgICogQHBhcmFtIHtEZXB0aFBhY2tpbmdTdHJhdGVnaWVzfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxMSkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmlucHV0RGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgZGVwdGggZnJvbSBhIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvRGVwdGhQaWNraW5nUGFzcy5qc1xudmFyIHVucGFja0ZhY3RvcnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgMjU1IC8gMjU2IC8gMjU2ICoqIDMsXG4gIDI1NSAvIDI1NiAvIDI1NiAqKiAyLFxuICAyNTUgLyAyNTYgLyAyNTYsXG4gIDI1NSAvIDI1NlxuXSk7XG5mdW5jdGlvbiB1bnBhY2tSR0JBVG9EZXB0aChwYWNrZWREZXB0aCkge1xuICByZXR1cm4gKHBhY2tlZERlcHRoWzBdICogdW5wYWNrRmFjdG9yc1swXSArIHBhY2tlZERlcHRoWzFdICogdW5wYWNrRmFjdG9yc1sxXSArIHBhY2tlZERlcHRoWzJdICogdW5wYWNrRmFjdG9yc1syXSArIHBhY2tlZERlcHRoWzNdICogdW5wYWNrRmFjdG9yc1szXSkgLyAyNTU7XG59XG52YXIgRGVwdGhQaWNraW5nUGFzcyA9IGNsYXNzIGV4dGVuZHMgRGVwdGhDb3B5UGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIHBpY2tpbmcgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtvcHRpb25zLmRlcHRoUGFja2luZz1SR0JBRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubW9kZT1EZXB0aENvcHlNb2RlLlNJTkdMRV0gLSBUaGUgZGVwdGggY29weSBtb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nNCwgbW9kZSA9IERlcHRoQ29weU1vZGUuU0lOR0xFIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgZGVwdGhQYWNraW5nIH0pO1xuICAgIHRoaXMubmFtZSA9IFwiRGVwdGhQaWNraW5nUGFzc1wiO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMucGl4ZWxCdWZmZXIgPSBkZXB0aFBhY2tpbmcgPT09IFJHQkFEZXB0aFBhY2tpbmc0ID8gbmV3IFVpbnQ4QXJyYXkoNCkgOiBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyBkZXB0aCBhdCBhIHNwZWNpZmljIHNjcmVlbiBwb3NpdGlvbi5cbiAgICpcbiAgICogT25seSBvbmUgZGVwdGggdmFsdWUgY2FuIGJlIHBpY2tlZCBwZXIgZnJhbWUuIENhbGxpbmcgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lIHdpbGwgb3ZlcndyaXRlIHRoZVxuICAgKiBwaWNraW5nIGNvb3JkaW5hdGVzLiBVbnJlc29sdmVkIHByb21pc2VzIHdpbGwgYmUgYWJhbmRvbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBuZGMgPSBuZXcgVmVjdG9yMygpO1xuICAgKiBjb25zdCBjbGllbnRSZWN0ID0gbXlWaWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICogY29uc3QgY2xpZW50WCA9IHBvaW50ZXJFdmVudC5jbGllbnRYIC0gY2xpZW50UmVjdC5sZWZ0O1xuICAgKiBjb25zdCBjbGllbnRZID0gcG9pbnRlckV2ZW50LmNsaWVudFkgLSBjbGllbnRSZWN0LnRvcDtcbiAgICogbmRjLnggPSAoY2xpZW50WCAvIG15Vmlld3BvcnQuY2xpZW50V2lkdGgpICogMi4wIC0gMS4wO1xuICAgKiBuZGMueSA9IC0oY2xpZW50WSAvIG15Vmlld3BvcnQuY2xpZW50SGVpZ2h0KSAqIDIuMCArIDEuMDtcbiAgICogY29uc3QgZGVwdGggPSBhd2FpdCBkZXB0aFBpY2tpbmdQYXNzLnJlYWREZXB0aChuZGMpO1xuICAgKiBuZGMueiA9IGRlcHRoICogMi4wIC0gMS4wO1xuICAgKlxuICAgKiBjb25zdCB3b3JsZFBvc2l0aW9uID0gbmRjLnVucHJvamVjdChjYW1lcmEpO1xuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ8VmVjdG9yM30gbmRjIC0gTm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMuIE9ubHkgWCBhbmQgWSBhcmUgcmVsZXZhbnQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TnVtYmVyPn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgZGVwdGggb24gdGhlIG5leHQgZnJhbWUuXG4gICAqL1xuICByZWFkRGVwdGgobmRjKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwudGV4ZWxQb3NpdGlvbi5zZXQobmRjLnggKiAwLjUgKyAwLjUsIG5kYy55ICogMC41ICsgMC41KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgZGVwdGggYW5kIHJlc29sdmVzIGRlcHRoIHBpY2tpbmcgcHJvbWlzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgY29uc3QgbW9kZSA9IG1hdGVyaWFsLm1vZGU7XG4gICAgaWYgKG1vZGUgPT09IERlcHRoQ29weU1vZGUuRlVMTCkge1xuICAgICAgc3VwZXIucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgICAgY29uc3QgcGl4ZWxCdWZmZXIgPSB0aGlzLnBpeGVsQnVmZmVyO1xuICAgICAgY29uc3QgcGFja2VkID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSAhPT0gRmxvYXRUeXBlMztcbiAgICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAobW9kZSA9PT0gRGVwdGhDb3B5TW9kZS5TSU5HTEUpIHtcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleGVsUG9zaXRpb24gPSBtYXRlcmlhbC50ZXhlbFBvc2l0aW9uO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh0ZXhlbFBvc2l0aW9uLnggKiByZW5kZXJUYXJnZXQud2lkdGgpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh0ZXhlbFBvc2l0aW9uLnkgKiByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMocmVuZGVyVGFyZ2V0LCB4LCB5LCAxLCAxLCBwaXhlbEJ1ZmZlcik7XG4gICAgICB0aGlzLmNhbGxiYWNrKHBhY2tlZCA/IHVucGFja1JHQkFUb0RlcHRoKHBpeGVsQnVmZmVyKSA6IHBpeGVsQnVmZmVyWzBdKTtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwubW9kZSA9PT0gRGVwdGhDb3B5TW9kZS5GVUxMKSB7XG4gICAgICBzdXBlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9FZmZlY3RQYXNzLmpzXG5pbXBvcnQgeyBCYXNpY0RlcHRoUGFja2luZyBhcyBCYXNpY0RlcHRoUGFja2luZzEyLCBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU1IH0gZnJvbSBcInRocmVlXCI7XG5mdW5jdGlvbiBwcmVmaXhTdWJzdHJpbmdzKHByZWZpeCwgc3Vic3RyaW5ncywgc3RyaW5ncykge1xuICBmb3IgKGNvbnN0IHN1YnN0cmluZyBvZiBzdWJzdHJpbmdzKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBcIiQxXCIgKyBwcmVmaXggKyBzdWJzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdWJzdHJpbmcuc2xpY2UoMSk7XG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChcIihbXlxcXFwuXSkoXFxcXGJcIiArIHN1YnN0cmluZyArIFwiXFxcXGIpXCIsIFwiZ1wiKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHN0cmluZ3MuZW50cmllcygpKSB7XG4gICAgICBpZiAoZW50cnlbMV0gIT09IG51bGwpIHtcbiAgICAgICAgc3RyaW5ncy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdLnJlcGxhY2UocmVnRXhwLCBwcmVmaXhlZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZWdyYXRlRWZmZWN0KHByZWZpeCwgZWZmZWN0LCBkYXRhKSB7XG4gIGxldCBmcmFnbWVudFNoYWRlciA9IGVmZmVjdC5nZXRGcmFnbWVudFNoYWRlcigpO1xuICBsZXQgdmVydGV4U2hhZGVyID0gZWZmZWN0LmdldFZlcnRleFNoYWRlcigpO1xuICBjb25zdCBtYWluSW1hZ2VFeGlzdHMgPSBmcmFnbWVudFNoYWRlciAhPT0gdm9pZCAwICYmIC9tYWluSW1hZ2UvLnRlc3QoZnJhZ21lbnRTaGFkZXIpO1xuICBjb25zdCBtYWluVXZFeGlzdHMgPSBmcmFnbWVudFNoYWRlciAhPT0gdm9pZCAwICYmIC9tYWluVXYvLnRlc3QoZnJhZ21lbnRTaGFkZXIpO1xuICBkYXRhLmF0dHJpYnV0ZXMgfD0gZWZmZWN0LmdldEF0dHJpYnV0ZXMoKTtcbiAgaWYgKGZyYWdtZW50U2hhZGVyID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZnJhZ21lbnQgc2hhZGVyICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgfSBlbHNlIGlmIChtYWluVXZFeGlzdHMgJiYgKGRhdGEuYXR0cmlidXRlcyAmIEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTikgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVmZmVjdHMgdGhhdCB0cmFuc2Zvcm0gVVZzIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBjb252b2x1dGlvbiBlZmZlY3RzICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgfSBlbHNlIGlmICghbWFpbkltYWdlRXhpc3RzICYmICFtYWluVXZFeGlzdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG1haW5JbWFnZSBvciBtYWluVXYgZnVuY3Rpb24gKCR7ZWZmZWN0Lm5hbWV9KWApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZ1bmN0aW9uUmVnRXhwID0gL1xcdytcXHMrKFxcdyspXFwoW1xcd1xccyxdKlxcKVxccyp7L2c7XG4gICAgY29uc3Qgc2hhZGVyUGFydHMgPSBkYXRhLnNoYWRlclBhcnRzO1xuICAgIGxldCBmcmFnbWVudEhlYWQgPSBzaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9IRUFEKSB8fCBcIlwiO1xuICAgIGxldCBmcmFnbWVudE1haW5VdiA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX01BSU5fVVYpIHx8IFwiXCI7XG4gICAgbGV0IGZyYWdtZW50TWFpbkltYWdlID0gc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSkgfHwgXCJcIjtcbiAgICBsZXQgdmVydGV4SGVhZCA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFEKSB8fCBcIlwiO1xuICAgIGxldCB2ZXJ0ZXhNYWluU3VwcG9ydCA9IHNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9NQUlOX1NVUFBPUlQpIHx8IFwiXCI7XG4gICAgY29uc3QgdmFyeWluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5hbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBpZiAobWFpblV2RXhpc3RzKSB7XG4gICAgICBmcmFnbWVudE1haW5VdiArPSBgXHQke3ByZWZpeH1NYWluVXYoVVYpO1xuYDtcbiAgICAgIGRhdGEudXZUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhTaGFkZXIgIT09IG51bGwgJiYgL21haW5TdXBwb3J0Ly50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgIGNvbnN0IG5lZWRzVXYgPSAvbWFpblN1cHBvcnQgKlxcKFtcXHdcXHNdKj91dlxccyo/XFwpLy50ZXN0KHZlcnRleFNoYWRlcik7XG4gICAgICB2ZXJ0ZXhNYWluU3VwcG9ydCArPSBgXHQke3ByZWZpeH1NYWluU3VwcG9ydChgO1xuICAgICAgdmVydGV4TWFpblN1cHBvcnQgKz0gbmVlZHNVdiA/IFwidlV2KTtcXG5cIiA6IFwiKTtcXG5cIjtcbiAgICAgIGZvciAoY29uc3QgbTIgb2YgdmVydGV4U2hhZGVyLm1hdGNoQWxsKC8oPzp2YXJ5aW5nXFxzK1xcdytcXHMrKFtcXFNcXHNdKj8pOykvZykpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIG0yWzFdLnNwbGl0KC9cXHMqLFxccyovKSkge1xuICAgICAgICAgIGRhdGEudmFyeWluZ3MuYWRkKG4pO1xuICAgICAgICAgIHZhcnlpbmdzLmFkZChuKTtcbiAgICAgICAgICBuYW1lcy5hZGQobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbTIgb2YgdmVydGV4U2hhZGVyLm1hdGNoQWxsKGZ1bmN0aW9uUmVnRXhwKSkge1xuICAgICAgICBuYW1lcy5hZGQobTJbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG0yIG9mIGZyYWdtZW50U2hhZGVyLm1hdGNoQWxsKGZ1bmN0aW9uUmVnRXhwKSkge1xuICAgICAgbmFtZXMuYWRkKG0yWzFdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkIG9mIGVmZmVjdC5kZWZpbmVzLmtleXMoKSkge1xuICAgICAgbmFtZXMuYWRkKGQucmVwbGFjZSgvXFwoW1xcd1xccyxdKlxcKS9nLCBcIlwiKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdSBvZiBlZmZlY3QudW5pZm9ybXMua2V5cygpKSB7XG4gICAgICBuYW1lcy5hZGQodSk7XG4gICAgfVxuICAgIG5hbWVzLmRlbGV0ZShcIndoaWxlXCIpO1xuICAgIG5hbWVzLmRlbGV0ZShcImZvclwiKTtcbiAgICBuYW1lcy5kZWxldGUoXCJpZlwiKTtcbiAgICBlZmZlY3QudW5pZm9ybXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGRhdGEudW5pZm9ybXMuc2V0KHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKSwgdmFsKSk7XG4gICAgZWZmZWN0LmRlZmluZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGRhdGEuZGVmaW5lcy5zZXQocHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpLCB2YWwpKTtcbiAgICBjb25zdCBzaGFkZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tcImZyYWdtZW50XCIsIGZyYWdtZW50U2hhZGVyXSwgW1widmVydGV4XCIsIHZlcnRleFNoYWRlcl1dKTtcbiAgICBwcmVmaXhTdWJzdHJpbmdzKHByZWZpeCwgbmFtZXMsIGRhdGEuZGVmaW5lcyk7XG4gICAgcHJlZml4U3Vic3RyaW5ncyhwcmVmaXgsIG5hbWVzLCBzaGFkZXJzKTtcbiAgICBmcmFnbWVudFNoYWRlciA9IHNoYWRlcnMuZ2V0KFwiZnJhZ21lbnRcIik7XG4gICAgdmVydGV4U2hhZGVyID0gc2hhZGVycy5nZXQoXCJ2ZXJ0ZXhcIik7XG4gICAgY29uc3QgYmxlbmRNb2RlID0gZWZmZWN0LmJsZW5kTW9kZTtcbiAgICBkYXRhLmJsZW5kTW9kZXMuc2V0KGJsZW5kTW9kZS5ibGVuZEZ1bmN0aW9uLCBibGVuZE1vZGUpO1xuICAgIGlmIChtYWluSW1hZ2VFeGlzdHMpIHtcbiAgICAgIGlmIChlZmZlY3QuaW5wdXRDb2xvclNwYWNlICE9PSBudWxsICYmIGVmZmVjdC5pbnB1dENvbG9yU3BhY2UgIT09IGRhdGEuY29sb3JTcGFjZSkge1xuICAgICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBlZmZlY3QuaW5wdXRDb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSA/IFwiY29sb3IwID0gTGluZWFyVG9zUkdCKGNvbG9yMCk7XFxuXHRcIiA6IFwiY29sb3IwID0gc1JHQlRvTGluZWFyKGNvbG9yMCk7XFxuXHRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlZmZlY3Qub3V0cHV0Q29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlKSB7XG4gICAgICAgIGRhdGEuY29sb3JTcGFjZSA9IGVmZmVjdC5vdXRwdXRDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChlZmZlY3QuaW5wdXRDb2xvclNwYWNlICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGEuY29sb3JTcGFjZSA9IGVmZmVjdC5pbnB1dENvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXB0aFBhcmFtUmVnRXhwID0gL01haW5JbWFnZSAqXFwoW1xcd1xccyxdKj9kZXB0aFtcXHdcXHMsXSo/XFwpLztcbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IGAke3ByZWZpeH1NYWluSW1hZ2UoY29sb3IwLCBVViwgYDtcbiAgICAgIGlmICgoZGF0YS5hdHRyaWJ1dGVzICYgRWZmZWN0QXR0cmlidXRlLkRFUFRIKSAhPT0gMCAmJiBkZXB0aFBhcmFtUmVnRXhwLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IFwiZGVwdGgsIFwiO1xuICAgICAgICBkYXRhLnJlYWREZXB0aCA9IHRydWU7XG4gICAgICB9XG4gICAgICBmcmFnbWVudE1haW5JbWFnZSArPSBcImNvbG9yMSk7XFxuXHRcIjtcbiAgICAgIGNvbnN0IGJsZW5kT3BhY2l0eSA9IHByZWZpeCArIFwiQmxlbmRPcGFjaXR5XCI7XG4gICAgICBkYXRhLnVuaWZvcm1zLnNldChibGVuZE9wYWNpdHksIGJsZW5kTW9kZS5vcGFjaXR5KTtcbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IGBjb2xvcjAgPSBibGVuZCR7YmxlbmRNb2RlLmJsZW5kRnVuY3Rpb259KGNvbG9yMCwgY29sb3IxLCAke2JsZW5kT3BhY2l0eX0pO1xuXG5cdGA7XG4gICAgICBmcmFnbWVudEhlYWQgKz0gYHVuaWZvcm0gZmxvYXQgJHtibGVuZE9wYWNpdHl9O1xuXG5gO1xuICAgIH1cbiAgICBmcmFnbWVudEhlYWQgKz0gZnJhZ21lbnRTaGFkZXIgKyBcIlxcblwiO1xuICAgIGlmICh2ZXJ0ZXhTaGFkZXIgIT09IG51bGwpIHtcbiAgICAgIHZlcnRleEhlYWQgKz0gdmVydGV4U2hhZGVyICsgXCJcXG5cIjtcbiAgICB9XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfSEVBRCwgZnJhZ21lbnRIZWFkKTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWLCBmcmFnbWVudE1haW5Vdik7XG4gICAgc2hhZGVyUGFydHMuc2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSwgZnJhZ21lbnRNYWluSW1hZ2UpO1xuICAgIHNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFELCB2ZXJ0ZXhIZWFkKTtcbiAgICBzaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5WRVJURVhfTUFJTl9TVVBQT1JULCB2ZXJ0ZXhNYWluU3VwcG9ydCk7XG4gICAgaWYgKGVmZmVjdC5leHRlbnNpb25zICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiBlZmZlY3QuZXh0ZW5zaW9ucykge1xuICAgICAgICBkYXRhLmV4dGVuc2lvbnMuYWRkKGV4dGVuc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgRWZmZWN0UGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVmZmVjdCBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0gey4uLkVmZmVjdH0gZWZmZWN0cyAtIFRoZSBlZmZlY3RzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBieSB0aGlzIHBhc3MuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIC4uLmVmZmVjdHMpIHtcbiAgICBzdXBlcihcIkVmZmVjdFBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBuZXcgRWZmZWN0TWF0ZXJpYWwobnVsbCwgbnVsbCwgbnVsbCwgY2FtZXJhKTtcbiAgICB0aGlzLmxpc3RlbmVyID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICB0aGlzLnNldEVmZmVjdHMoZWZmZWN0cyk7XG4gICAgdGhpcy5za2lwUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5taW5UaW1lID0gMTtcbiAgICB0aGlzLm1heFRpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy50aW1lU2NhbGUgPSAxO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb3B5Q2FtZXJhU2V0dGluZ3ModmFsdWUpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0Lm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBlbmNvZGVzIGl0cyBvdXRwdXQgd2hlbiByZW5kZXJpbmcgdG8gc2NyZWVuLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZ1bGxzY3JlZW5NYXRlcmlhbC5lbmNvZGVPdXRwdXQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBlbmNvZGVPdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmVuY29kZU91dHB1dDtcbiAgfVxuICBzZXQgZW5jb2RlT3V0cHV0KHZhbHVlKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZW5jb2RlT3V0cHV0ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRpdGhlcmluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkaXRoZXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBtYXRlcmlhbC5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVmZmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWZmZWN0W119IGVmZmVjdHMgLSBUaGUgZWZmZWN0cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0RWZmZWN0cyhlZmZlY3RzKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cy5zb3J0KChhLCBiKSA9PiBiLmF0dHJpYnV0ZXMgLSBhLmF0dHJpYnV0ZXMpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb3VuZCBzaGFkZXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZU1hdGVyaWFsKCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRWZmZWN0U2hhZGVyRGF0YSgpO1xuICAgIGxldCBpZCA9IDA7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBpZiAoZWZmZWN0LmJsZW5kTW9kZS5ibGVuZEZ1bmN0aW9uID09PSBCbGVuZEZ1bmN0aW9uLkRTVCkge1xuICAgICAgICBkYXRhLmF0dHJpYnV0ZXMgfD0gZWZmZWN0LmdldEF0dHJpYnV0ZXMoKSAmIEVmZmVjdEF0dHJpYnV0ZS5ERVBUSDtcbiAgICAgIH0gZWxzZSBpZiAoKGRhdGEuYXR0cmlidXRlcyAmIGVmZmVjdC5nZXRBdHRyaWJ1dGVzKCkgJiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04pICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udm9sdXRpb24gZWZmZWN0cyBjYW5ub3QgYmUgbWVyZ2VkICgke2VmZmVjdC5uYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVncmF0ZUVmZmVjdChcImVcIiArIGlkKyssIGVmZmVjdCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmcmFnbWVudEhlYWQgPSBkYXRhLnNoYWRlclBhcnRzLmdldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQpO1xuICAgIGxldCBmcmFnbWVudE1haW5JbWFnZSA9IGRhdGEuc2hhZGVyUGFydHMuZ2V0KEVmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9JTUFHRSk7XG4gICAgbGV0IGZyYWdtZW50TWFpblV2ID0gZGF0YS5zaGFkZXJQYXJ0cy5nZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWKTtcbiAgICBjb25zdCBibGVuZFJlZ0V4cCA9IC9cXGJibGVuZFxcYi9nO1xuICAgIGZvciAoY29uc3QgYmxlbmRNb2RlIG9mIGRhdGEuYmxlbmRNb2Rlcy52YWx1ZXMoKSkge1xuICAgICAgZnJhZ21lbnRIZWFkICs9IGJsZW5kTW9kZS5nZXRTaGFkZXJDb2RlKCkucmVwbGFjZShibGVuZFJlZ0V4cCwgYGJsZW5kJHtibGVuZE1vZGUuYmxlbmRGdW5jdGlvbn1gKSArIFwiXFxuXCI7XG4gICAgfVxuICAgIGlmICgoZGF0YS5hdHRyaWJ1dGVzICYgRWZmZWN0QXR0cmlidXRlLkRFUFRIKSAhPT0gMCkge1xuICAgICAgaWYgKGRhdGEucmVhZERlcHRoKSB7XG4gICAgICAgIGZyYWdtZW50TWFpbkltYWdlID0gXCJmbG9hdCBkZXB0aCA9IHJlYWREZXB0aChVVik7XFxuXFxuXHRcIiArIGZyYWdtZW50TWFpbkltYWdlO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc0RlcHRoVGV4dHVyZSA9IHRoaXMuZ2V0RGVwdGhUZXh0dXJlKCkgPT09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmVlZHNEZXB0aFRleHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgIGZyYWdtZW50TWFpbkltYWdlICs9IFwiY29sb3IwID0gc1JHQlRvTGluZWFyKGNvbG9yMCk7XFxuXHRcIjtcbiAgICB9XG4gICAgaWYgKGRhdGEudXZUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgZnJhZ21lbnRNYWluVXYgPSBcInZlYzIgdHJhbnNmb3JtZWRVdiA9IHZVdjtcXG5cIiArIGZyYWdtZW50TWFpblV2O1xuICAgICAgZGF0YS5kZWZpbmVzLnNldChcIlVWXCIsIFwidHJhbnNmb3JtZWRVdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5kZWZpbmVzLnNldChcIlVWXCIsIFwidlV2XCIpO1xuICAgIH1cbiAgICBkYXRhLnNoYWRlclBhcnRzLnNldChFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQsIGZyYWdtZW50SGVhZCk7XG4gICAgZGF0YS5zaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBmcmFnbWVudE1haW5JbWFnZSk7XG4gICAgZGF0YS5zaGFkZXJQYXJ0cy5zZXQoRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX1VWLCBmcmFnbWVudE1haW5Vdik7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YS5zaGFkZXJQYXJ0cykge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGEuc2hhZGVyUGFydHMuc2V0KGtleSwgdmFsdWUudHJpbSgpLnJlcGxhY2UoL14jLywgXCJcXG4jXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5za2lwUmVuZGVyaW5nID0gaWQgPT09IDA7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSAhdGhpcy5za2lwUmVuZGVyaW5nO1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNoYWRlckRhdGEoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYnVpbGRzIHRoZSBzaGFkZXIgbWF0ZXJpYWwuXG4gICAqL1xuICByZWNvbXBpbGUoKSB7XG4gICAgdGhpcy51cGRhdGVNYXRlcmlhbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICovXG4gIGdldERlcHRoVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzEyKSB7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5za2lwUmVuZGVyaW5nIHx8IHRoaXMucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgICBtYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IGlucHV0QnVmZmVyLnRleHR1cmU7XG4gICAgICBtYXRlcmlhbC50aW1lICs9IGRlbHRhVGltZSAqIHRoaXMudGltZVNjYWxlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogb3V0cHV0QnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICBlZmZlY3Quc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIGVmZmVjdC5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNYXRlcmlhbCgpO1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCAmJiBmcmFtZUJ1ZmZlclR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGU1KSB7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGRpc3Bvc2FibGUgb2JqZWN0cy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgZWZmZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5saXN0ZW5lcik7XG4gICAgICBlZmZlY3QuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQW4gZXZlbnQuXG4gICAqL1xuICBoYW5kbGVFdmVudChldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImNoYW5nZVwiOlxuICAgICAgICB0aGlzLnJlY29tcGlsZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvR2F1c3NpYW5CbHVyUGFzcy5qc1xuaW1wb3J0IHsgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlNiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQ4IH0gZnJvbSBcInRocmVlXCI7XG52YXIgR2F1c3NpYW5CbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdhdXNzaWFuIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMua2VybmVsU2l6ZT0zNV0gLSBUaGUga2VybmVsIHNpemUuIFNob3VsZCBiZSBhbiBvZGQgbnVtYmVyIGluIHRoZSByYW5nZSBbMywgMTAyMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTFdIC0gVGhlIGFtb3VudCBvZiB0aW1lcyB0aGUgYmx1ciBzaG91bGQgYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAga2VybmVsU2l6ZSA9IDM1LFxuICAgIGl0ZXJhdGlvbnMgPSAxLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgcmVzb2x1dGlvblggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWSA9IFJlc29sdXRpb24uQVVUT19TSVpFXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiR2F1c3NpYW5CbHVyUGFzc1wiKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQ4KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0LkFcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEEuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5CXCI7XG4gICAgdGhpcy5ibHVyTWF0ZXJpYWwgPSBuZXcgR2F1c3NpYW5CbHVyTWF0ZXJpYWwoeyBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xuICAgIHRoaXMuY29weU1hdGVyaWFsLmlucHV0QnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLmJsdXJNYXRlcmlhbDtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IGJsdXJNYXRlcmlhbDtcbiAgICBsZXQgcHJldmlvdXNCdWZmZXIgPSBpbnB1dEJ1ZmZlcjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHRoaXMuaXRlcmF0aW9ucywgMSk7IGkgPCBsOyArK2kpIHtcbiAgICAgIGJsdXJNYXRlcmlhbC5kaXJlY3Rpb24uc2V0KDEsIDApO1xuICAgICAgYmx1ck1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXRBKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIGJsdXJNYXRlcmlhbC5kaXJlY3Rpb24uc2V0KDAsIDEpO1xuICAgICAgYmx1ck1hdGVyaWFsLmlucHV0QnVmZmVyID0gcmVuZGVyVGFyZ2V0QS50ZXh0dXJlO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldEIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgaWYgKGkgPT09IDAgJiYgbCA+IDEpIHtcbiAgICAgICAgcHJldmlvdXNCdWZmZXIgPSByZW5kZXJUYXJnZXRCO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRBLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlNikge1xuICAgICAgICB0aGlzLmJsdXJNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICAgIHRoaXMuY29weU1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0T3V0cHV0Q29sb3JTcGFjZShyZW5kZXJlcikgPT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0Qi50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0thd2FzZUJsdXJQYXNzLmpzXG5pbXBvcnQgeyBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU3LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDkgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBLYXdhc2VCbHVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEthd2FzZSBibHVyIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTUVESVVNXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGtlcm5lbFNpemUgPSBLZXJuZWxTaXplLk1FRElVTSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiS2F3YXNlQmx1clBhc3NcIik7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRBID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0OSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS5uYW1lID0gXCJCbHVyLlRhcmdldC5BXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCID0gdGhpcy5yZW5kZXJUYXJnZXRBLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXQuQlwiO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuX2JsdXJNYXRlcmlhbCA9IG5ldyBLYXdhc2VCbHVyTWF0ZXJpYWwoKTtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwua2VybmVsU2l6ZSA9IGtlcm5lbFNpemU7XG4gICAgdGhpcy5jb3B5TWF0ZXJpYWwgPSBuZXcgQ29weU1hdGVyaWFsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0thd2FzZUJsdXJNYXRlcmlhbH1cbiAgICovXG4gIGdldCBibHVyTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JsdXJNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtLYXdhc2VCbHVyTWF0ZXJpYWx9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldCBibHVyTWF0ZXJpYWwodmFsdWUpIHtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgZGl0aGVyaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29weU1hdGVyaWFsLmRpdGhlcmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5TWF0ZXJpYWwuZGl0aGVyaW5nO1xuICB9XG4gIHNldCBkaXRoZXJpbmcodmFsdWUpIHtcbiAgICB0aGlzLmNvcHlNYXRlcmlhbC5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqL1xuICBnZXQga2VybmVsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwua2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi53aWR0aCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciB3aWR0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggaW5zdGVhZC5cbiAgICovXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciBoZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYmx1ciBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5zY2FsZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyTWF0ZXJpYWwuc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJsdXIgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyTWF0ZXJpYWwuc2NhbGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNjYWxlLlxuICAgKi9cbiAgc2V0U2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXJuZWwgc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0tlcm5lbFNpemV9IFRoZSBrZXJuZWwgc2l6ZS5cbiAgICovXG4gIGdldEtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMua2VybmVsU2l6ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUga2VybmVsIHNpemUuXG4gICAqXG4gICAqIExhcmdlciBrZXJuZWxzIHJlcXVpcmUgbW9yZSBwcm9jZXNzaW5nIHBvd2VyIGJ1dCBzY2FsZSB3ZWxsIHdpdGggbGFyZ2VyIHJlbmRlciByZXNvbHV0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJNYXRlcmlhbC5rZXJuZWxTaXplIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gdmFsdWUgLSBUaGUga2VybmVsIHNpemUuXG4gICAqL1xuICBzZXRLZXJuZWxTaXplKHZhbHVlKSB7XG4gICAgdGhpcy5rZXJuZWxTaXplID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmx1ci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEEgPSB0aGlzLnJlbmRlclRhcmdldEE7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0QiA9IHRoaXMucmVuZGVyVGFyZ2V0QjtcbiAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuYmx1ck1hdGVyaWFsO1xuICAgIGNvbnN0IGtlcm5lbFNlcXVlbmNlID0gbWF0ZXJpYWwua2VybmVsU2VxdWVuY2U7XG4gICAgbGV0IHByZXZpb3VzQnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtlcm5lbFNlcXVlbmNlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgY29uc3QgYnVmZmVyID0gKGkgJiAxKSA9PT0gMCA/IHJlbmRlclRhcmdldEEgOiByZW5kZXJUYXJnZXRCO1xuICAgICAgbWF0ZXJpYWwua2VybmVsID0ga2VybmVsU2VxdWVuY2VbaV07XG4gICAgICBtYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHByZXZpb3VzQnVmZmVyID0gYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xuICAgIHRoaXMuY29weU1hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiBvdXRwdXRCdWZmZXIpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJsdXJNYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpbml0aWFsaXphdGlvbiB0YXNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVCdWZmZXJUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIG1haW4gZnJhbWUgYnVmZmVycy5cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTcpIHtcbiAgICAgICAgdGhpcy5ibHVyTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgICB0aGlzLmNvcHlNYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgICB9IGVsc2UgaWYgKGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQW4gYXV0byBzaXppbmcgZmxhZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBSZXNvbHV0aW9uLkFVVE9fU0laRX0gaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBnZXQgQVVUT19TSVpFKCkge1xuICAgIHJldHVybiBSZXNvbHV0aW9uLkFVVE9fU0laRTtcbiAgfVxufTtcblxuLy8gc3JjL3Bhc3Nlcy9MYW1iZGFQYXNzLmpzXG52YXIgTGFtYmRhUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGxhbWJkYSBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIC0gQSBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGYpIHtcbiAgICBzdXBlcihcIkxhbWJkYVBhc3NcIiwgbnVsbCwgbnVsbCk7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIHRoaXMuZigpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL0x1bWluYW5jZVBhc3MuanNcbmltcG9ydCB7IFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTgsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTAgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBMdW1pbmFuY2VQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbHVtaW5hbmNlIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy4gU2VlIHtAbGluayBMdW1pbmFuY2VNYXRlcmlhbH0gZm9yIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW29wdGlvbnMucmVuZGVyVGFyZ2V0XSAtIEEgY3VzdG9tIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVuZGVyVGFyZ2V0LFxuICAgIGx1bWluYW5jZVJhbmdlLFxuICAgIGNvbG9yT3V0cHV0LFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTHVtaW5hbmNlUGFzc1wiKTtcbiAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbCA9IG5ldyBMdW1pbmFuY2VNYXRlcmlhbChjb2xvck91dHB1dCwgbHVtaW5hbmNlUmFuZ2UpO1xuICAgIHRoaXMubmVlZHNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgaWYgKHRoaXMucmVuZGVyVGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTAoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkx1bWluYW5jZVBhc3MuVGFyZ2V0XCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIHRleHR1cmUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBsdW1pbmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSBpbnB1dEJ1ZmZlci50ZXh0dXJlO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgICByZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwICYmIGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTgpIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTWFza1Bhc3MuanNcbnZhciBNYXNrUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hc2sgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhKSB7XG4gICAgc3VwZXIoXCJNYXNrUGFzc1wiLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJQYXNzID0gbmV3IENsZWFyUGFzcyhmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLnNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFzayBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVyc2U7XG4gIH1cbiAgc2V0IGludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnNlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyBzaG91bGQgY2xlYXIgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNsZWFyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJQYXNzLmVuYWJsZWQ7XG4gIH1cbiAgc2V0IGNsZWFyKHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhclBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbGVhciBwYXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2xlYXJQYXNzLmVuYWJsZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q2xlYXJQYXNzfSBUaGUgY2xlYXIgcGFzcy5cbiAgICovXG4gIGdldENsZWFyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jbGVhclBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtYXNrIGlzIGludmVydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZSBtYXNrIGludmVyc2lvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBtYXNrIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICovXG4gIHNldEludmVydGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pbnZlcnRlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBvdXRwdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IHNlcnZlcyBhcyB0aGUgb3V0cHV0IHJlbmRlciB0YXJnZXQgdW5sZXNzIHRoaXMgcGFzcyByZW5kZXJzIHRvIHNjcmVlbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0ZW5jaWxUZXN0XSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCBtYXNrIGlzIGFjdGl2ZS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgYnVmZmVycyA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnM7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHRoaXMuY2xlYXJQYXNzO1xuICAgIGNvbnN0IHdyaXRlVmFsdWUgPSB0aGlzLmludmVydGVkID8gMCA6IDE7XG4gICAgY29uc3QgY2xlYXJWYWx1ZSA9IDEgLSB3cml0ZVZhbHVlO1xuICAgIGJ1ZmZlcnMuY29sb3Iuc2V0TWFzayhmYWxzZSk7XG4gICAgYnVmZmVycy5kZXB0aC5zZXRNYXNrKGZhbHNlKTtcbiAgICBidWZmZXJzLmNvbG9yLnNldExvY2tlZCh0cnVlKTtcbiAgICBidWZmZXJzLmRlcHRoLnNldExvY2tlZCh0cnVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0VGVzdCh0cnVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0T3AoY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSk7XG4gICAgYnVmZmVycy5zdGVuY2lsLnNldEZ1bmMoY29udGV4dC5BTFdBWVMsIHdyaXRlVmFsdWUsIDQyOTQ5NjcyOTUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRDbGVhcihjbGVhclZhbHVlKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0TG9ja2VkKHRydWUpO1xuICAgIGlmICh0aGlzLmNsZWFyUGFzcy5lbmFibGVkKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJUb1NjcmVlbikge1xuICAgICAgICBjbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyKTtcbiAgICAgICAgY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgb3V0cHV0QnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGlucHV0QnVmZmVyKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvdXRwdXRCdWZmZXIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBidWZmZXJzLmNvbG9yLnNldExvY2tlZChmYWxzZSk7XG4gICAgYnVmZmVycy5kZXB0aC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRMb2NrZWQoZmFsc2UpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRGdW5jKGNvbnRleHQuRVFVQUwsIDEsIDQyOTQ5NjcyOTUpO1xuICAgIGJ1ZmZlcnMuc3RlbmNpbC5zZXRPcChjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQKTtcbiAgICBidWZmZXJzLnN0ZW5jaWwuc2V0TG9ja2VkKHRydWUpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL01pcG1hcEJsdXJQYXNzLmpzXG5pbXBvcnQgeyBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGU5LCBWZWN0b3IyIGFzIFZlY3RvcjIxNSwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxMSB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIE1pcG1hcEJsdXJQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbWlwbWFwIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJNaXBtYXBCbHVyUGFzc1wiKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTEoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJVcHNhbXBsaW5nLk1pcG1hcDBcIjtcbiAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMgPSBbXTtcbiAgICB0aGlzLnVwc2FtcGxpbmdNaXBtYXBzID0gW107XG4gICAgdGhpcy5kb3duc2FtcGxpbmdNYXRlcmlhbCA9IG5ldyBEb3duc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsID0gbmV3IFVwc2FtcGxpbmdNYXRlcmlhbCgpO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyMTUoKTtcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGJsdXJyZWQgcmVzdWx0LlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTUlQIGxldmVscy4gRGVmYXVsdCBpcyA4LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxldmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLmxlbmd0aDtcbiAgfVxuICBzZXQgbGV2ZWxzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcyA9IFtdO1xuICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1pcG1hcCA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuICAgICAgICBtaXBtYXAudGV4dHVyZS5uYW1lID0gXCJEb3duc2FtcGxpbmcuTWlwbWFwXCIgKyBpO1xuICAgICAgICB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMucHVzaChtaXBtYXApO1xuICAgICAgfVxuICAgICAgdGhpcy51cHNhbXBsaW5nTWlwbWFwcy5wdXNoKHJlbmRlclRhcmdldCk7XG4gICAgICBmb3IgKGxldCBpID0gMSwgbCA9IHZhbHVlIC0gMTsgaSA8IGw7ICsraSkge1xuICAgICAgICBjb25zdCBtaXBtYXAgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcbiAgICAgICAgbWlwbWFwLnRleHR1cmUubmFtZSA9IFwiVXBzYW1wbGluZy5NaXBtYXBcIiArIGk7XG4gICAgICAgIHRoaXMudXBzYW1wbGluZ01pcG1hcHMucHVzaChtaXBtYXApO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTaXplKHRoaXMucmVzb2x1dGlvbi54LCB0aGlzLnJlc29sdXRpb24ueSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ciByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnVwc2FtcGxpbmdNYXRlcmlhbC5yYWRpdXM7XG4gIH1cbiAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgIHRoaXMudXBzYW1wbGluZ01hdGVyaWFsLnJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBibHVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gb3V0cHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBzZXJ2ZXMgYXMgdGhlIG91dHB1dCByZW5kZXIgdGFyZ2V0IHVubGVzcyB0aGlzIHBhc3MgcmVuZGVycyB0byBzY3JlZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGVuY2lsVGVzdF0gLSBJbmRpY2F0ZXMgd2hldGhlciBhIHN0ZW5jaWwgbWFzayBpcyBhY3RpdmUuXG4gICAqL1xuICByZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBvdXRwdXRCdWZmZXIsIGRlbHRhVGltZSwgc3RlbmNpbFRlc3QpIHtcbiAgICBjb25zdCB7IHNjZW5lLCBjYW1lcmEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkb3duc2FtcGxpbmdNYXRlcmlhbCwgdXBzYW1wbGluZ01hdGVyaWFsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZG93bnNhbXBsaW5nTWlwbWFwcywgdXBzYW1wbGluZ01pcG1hcHMgfSA9IHRoaXM7XG4gICAgbGV0IHByZXZpb3VzQnVmZmVyID0gaW5wdXRCdWZmZXI7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBkb3duc2FtcGxpbmdNYXRlcmlhbDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRvd25zYW1wbGluZ01pcG1hcHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBjb25zdCBtaXBtYXAgPSBkb3duc2FtcGxpbmdNaXBtYXBzW2ldO1xuICAgICAgZG93bnNhbXBsaW5nTWF0ZXJpYWwuc2V0U2l6ZShwcmV2aW91c0J1ZmZlci53aWR0aCwgcHJldmlvdXNCdWZmZXIuaGVpZ2h0KTtcbiAgICAgIGRvd25zYW1wbGluZ01hdGVyaWFsLmlucHV0QnVmZmVyID0gcHJldmlvdXNCdWZmZXIudGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChtaXBtYXApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgcHJldmlvdXNCdWZmZXIgPSBtaXBtYXA7XG4gICAgfVxuICAgIHRoaXMuZnVsbHNjcmVlbk1hdGVyaWFsID0gdXBzYW1wbGluZ01hdGVyaWFsO1xuICAgIGZvciAobGV0IGkgPSB1cHNhbXBsaW5nTWlwbWFwcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgbWlwbWFwID0gdXBzYW1wbGluZ01pcG1hcHNbaV07XG4gICAgICB1cHNhbXBsaW5nTWF0ZXJpYWwuc2V0U2l6ZShwcmV2aW91c0J1ZmZlci53aWR0aCwgcHJldmlvdXNCdWZmZXIuaGVpZ2h0KTtcbiAgICAgIHVwc2FtcGxpbmdNYXRlcmlhbC5pbnB1dEJ1ZmZlciA9IHByZXZpb3VzQnVmZmVyLnRleHR1cmU7XG4gICAgICB1cHNhbXBsaW5nTWF0ZXJpYWwuc3VwcG9ydEJ1ZmZlciA9IGRvd25zYW1wbGluZ01pcG1hcHNbaV0udGV4dHVyZTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChtaXBtYXApO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgcHJldmlvdXNCdWZmZXIgPSBtaXBtYXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgbGV0IHcgPSByZXNvbHV0aW9uLndpZHRoLCBoID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmRvd25zYW1wbGluZ01pcG1hcHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICB3ID0gTWF0aC5yb3VuZCh3ICogMC41KTtcbiAgICAgIGggPSBNYXRoLnJvdW5kKGggKiAwLjUpO1xuICAgICAgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzW2ldLnNldFNpemUodywgaCk7XG4gICAgICBpZiAoaSA8IHRoaXMudXBzYW1wbGluZ01pcG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBzYW1wbGluZ01pcG1hcHNbaV0uc2V0U2l6ZSh3LCBoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgbWlwbWFwcyA9IHRoaXMuZG93bnNhbXBsaW5nTWlwbWFwcy5jb25jYXQodGhpcy51cHNhbXBsaW5nTWlwbWFwcyk7XG4gICAgICBmb3IgKGNvbnN0IG1pcG1hcCBvZiBtaXBtYXBzKSB7XG4gICAgICAgIG1pcG1hcC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlOSkge1xuICAgICAgICB0aGlzLmRvd25zYW1wbGluZ01hdGVyaWFsLmRlZmluZXMuRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0ggPSBcIjFcIjtcbiAgICAgICAgdGhpcy51cHNhbXBsaW5nTWF0ZXJpYWwuZGVmaW5lcy5GUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSCA9IFwiMVwiO1xuICAgICAgfSBlbHNlIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBtaXBtYXAgb2YgbWlwbWFwcykge1xuICAgICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKG1pcG1hcC50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMgYW5kIHRleHR1cmVzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgZm9yIChjb25zdCBtaXBtYXAgb2YgdGhpcy5kb3duc2FtcGxpbmdNaXBtYXBzLmNvbmNhdCh0aGlzLnVwc2FtcGxpbmdNaXBtYXBzKSkge1xuICAgICAgbWlwbWFwLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wYXNzZXMvTm9ybWFsUGFzcy5qc1xuaW1wb3J0IHsgQ29sb3IgYXMgQ29sb3IzLCBNZXNoTm9ybWFsTWF0ZXJpYWwsIE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjUsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MTIgfSBmcm9tIFwidGhyZWVcIjtcbnZhciBOb3JtYWxQYXNzID0gY2xhc3MgZXh0ZW5kcyBQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbm9ybWFsIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBjYW1lcmEgdG8gdXNlIHRvIHJlbmRlciB0aGUgc2NlbmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW29wdGlvbnMucmVuZGVyVGFyZ2V0XSAtIEEgY3VzdG9tIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MS4wXSAtIFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIGhvcml6b250YWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25ZPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSB2ZXJ0aWNhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25YIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIHJlc29sdXRpb25ZIGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhLCB7XG4gICAgcmVuZGVyVGFyZ2V0LFxuICAgIHJlc29sdXRpb25TY2FsZSA9IDEsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTm9ybWFsUGFzc1wiKTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEsIG5ldyBNZXNoTm9ybWFsTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IHRoaXMucmVuZGVyUGFzcztcbiAgICByZW5kZXJQYXNzLmlnbm9yZUJhY2tncm91bmQgPSB0cnVlO1xuICAgIHJlbmRlclBhc3Muc2tpcFNoYWRvd01hcFVwZGF0ZSA9IHRydWU7XG4gICAgY29uc3QgY2xlYXJQYXNzID0gcmVuZGVyUGFzcy5nZXRDbGVhclBhc3MoKTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yMyg3ODI5NTAzKTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxMigxLCAxLCB7XG4gICAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcjUsXG4gICAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcjVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJOb3JtYWxQYXNzLlRhcmdldFwiO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICB9XG4gIHNldCBtYWluQ2FtZXJhKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG5vcm1hbCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbm9ybWFsIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ucHJlZmVycmVkV2lkdGggb3IgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoIG9yIHJlc29sdXRpb24ucHJlZmVycmVkSGVpZ2h0IGluc3RlYWQuXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2NlbmUgbm9ybWFscy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB0aGlzLnJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIHJlbmRlclRhcmdldCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhpcyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL1NoYWRlclBhc3MuanNcbmltcG9ydCB7IFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTEwIH0gZnJvbSBcInRocmVlXCI7XG52YXIgU2hhZGVyUGFzcyA9IGNsYXNzIGV4dGVuZHMgUGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNoYWRlciBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NoYWRlck1hdGVyaWFsfSBtYXRlcmlhbCAtIEEgc2hhZGVyIG1hdGVyaWFsLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2lucHV0PVwiaW5wdXRCdWZmZXJcIl0gLSBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgYnVmZmVyIHVuaWZvcm0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXRlcmlhbCwgaW5wdXQgPSBcImlucHV0QnVmZmVyXCIpIHtcbiAgICBzdXBlcihcIlNoYWRlclBhc3NcIik7XG4gICAgdGhpcy5mdWxsc2NyZWVuTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGlucHV0IGJ1ZmZlciB1bmlmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgLSBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgYnVmZmVyIHVuaWZvcm0uXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dCBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0SW5wdXQoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgc2VydmVzIGFzIHRoZSBvdXRwdXQgcmVuZGVyIHRhcmdldCB1bmxlc3MgdGhpcyBwYXNzIHJlbmRlcnMgdG8gc2NyZWVuLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbc3RlbmNpbFRlc3RdIC0gSW5kaWNhdGVzIHdoZXRoZXIgYSBzdGVuY2lsIG1hc2sgaXMgYWN0aXZlLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC51bmlmb3JtcztcbiAgICBpZiAoaW5wdXRCdWZmZXIgIT09IG51bGwgJiYgdW5pZm9ybXMgIT09IHZvaWQgMCAmJiB1bmlmb3Jtc1t0aGlzLmlucHV0XSAhPT0gdm9pZCAwKSB7XG4gICAgICB1bmlmb3Jtc1t0aGlzLmlucHV0XS52YWx1ZSA9IGlucHV0QnVmZmVyLnRleHR1cmU7XG4gICAgfVxuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IG91dHB1dEJ1ZmZlcik7XG4gICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwICYmIGZyYW1lQnVmZmVyVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZTEwKSB7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIID0gXCIxXCI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcGFzc2VzL1RpbHRTaGlmdEJsdXJQYXNzLmpzXG52YXIgVGlsdFNoaWZ0Qmx1clBhc3MgPSBjbGFzcyBleHRlbmRzIEthd2FzZUJsdXJQYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgS2F3YXNlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuMF0gLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNBcmVhPTAuNF0gLSBUaGUgcmVsYXRpdmUgc2l6ZSBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZlYXRoZXI9MC4zXSAtIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICogQHBhcmFtIHtLZXJuZWxTaXplfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTUVESVVNXSAtIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvZmZzZXQgPSAwLFxuICAgIHJvdGF0aW9uID0gMCxcbiAgICBmb2N1c0FyZWEgPSAwLjQsXG4gICAgZmVhdGhlciA9IDAuMyxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHJlc29sdXRpb25YID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblkgPSBSZXNvbHV0aW9uLkFVVE9fU0laRVxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IGtlcm5lbFNpemUsIHJlc29sdXRpb25TY2FsZSwgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZIH0pO1xuICAgIHRoaXMuYmx1ck1hdGVyaWFsID0gbmV3IFRpbHRTaGlmdEJsdXJNYXRlcmlhbCh7IGtlcm5lbFNpemUsIG9mZnNldCwgcm90YXRpb24sIGZvY3VzQXJlYSwgZmVhdGhlciB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvVGltZXIuanNcbnZhciBNSUxMSVNFQ09ORFNfVE9fU0VDT05EUyA9IDEgLyAxZTM7XG52YXIgU0VDT05EU19UT19NSUxMSVNFQ09ORFMgPSAxZTM7XG52YXIgVGltZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHRpbWVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnByZXZpb3VzVGltZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIHRoaXMuX2VsYXBzZWQgPSAwO1xuICAgIHRoaXMuX2ZpeGVkRGVsdGEgPSAxZTMgLyA2MDtcbiAgICB0aGlzLnRpbWVzY2FsZSA9IDE7XG4gICAgdGhpcy51c2VGaXhlZERlbHRhID0gZmFsc2U7XG4gICAgdGhpcy5fYXV0b1Jlc2V0ID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYXV0byByZXNldCBiYXNlZCBvbiBwYWdlIHZpc2liaWxpdHkuXG4gICAqXG4gICAqIElmIGVuYWJsZWQsIHRoZSB0aW1lciB3aWxsIGJlIHJlc2V0IHdoZW4gdGhlIHBhZ2UgYmVjb21lcyB2aXNpYmxlLiBUaGlzIGVmZmVjdGl2ZWx5IHBhdXNlcyB0aGUgdGltZXIgd2hlbiB0aGUgcGFnZVxuICAgKiBpcyBoaWRkZW4uIEhhcyBubyBlZmZlY3QgaWYgdGhlIEFQSSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGFnZV9WaXNpYmlsaXR5X0FQSVxuICAgKi9cbiAgZ2V0IGF1dG9SZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1Jlc2V0O1xuICB9XG4gIHNldCBhdXRvUmVzZXQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmhpZGRlbiAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2F1dG9SZXNldCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgZGVsdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbHRhICogTUlMTElTRUNPTkRTX1RPX1NFQ09ORFM7XG4gIH1cbiAgZ2V0IGZpeGVkRGVsdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpeGVkRGVsdGEgKiBNSUxMSVNFQ09ORFNfVE9fU0VDT05EUztcbiAgfVxuICBzZXQgZml4ZWREZWx0YSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZpeGVkRGVsdGEgPSB2YWx1ZSAqIFNFQ09ORFNfVE9fTUlMTElTRUNPTkRTO1xuICB9XG4gIGdldCBlbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGFwc2VkICogTUlMTElTRUNPTkRTX1RPX1NFQ09ORFM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyB0aW1lci5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdGltZXN0YW1wXSAtIFRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHRpbWVzdGFtcCkge1xuICAgIGlmICh0aGlzLnVzZUZpeGVkRGVsdGEpIHtcbiAgICAgIHRoaXMuX2RlbHRhID0gdGhpcy5maXhlZERlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXZpb3VzVGltZSA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gKHRpbWVzdGFtcCAhPT0gdm9pZCAwID8gdGltZXN0YW1wIDogcGVyZm9ybWFuY2Uubm93KCkpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICB0aGlzLl9kZWx0YSA9IHRoaXMuY3VycmVudFRpbWUgLSB0aGlzLnByZXZpb3VzVGltZTtcbiAgICB9XG4gICAgdGhpcy5fZGVsdGEgKj0gdGhpcy50aW1lc2NhbGU7XG4gICAgdGhpcy5fZWxhcHNlZCArPSB0aGlzLl9kZWx0YTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgdGltZXIuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgdGhpcy5fZWxhcHNlZCA9IDA7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGlmICghZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmF1dG9SZXNldCA9IGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RDb21wb3Nlci5qc1xudmFyIEVmZmVjdENvbXBvc2VyID0gY2xhc3Mge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgY29tcG9zZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhhdCBzaG91bGQgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcHRoQnVmZmVyPXRydWVdIC0gV2hldGhlciB0aGUgbWFpbiByZW5kZXIgdGFyZ2V0cyBzaG91bGQgaGF2ZSBhIGRlcHRoIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdGVuY2lsQnVmZmVyPWZhbHNlXSAtIFdoZXRoZXIgdGhlIG1haW4gcmVuZGVyIHRhcmdldHMgc2hvdWxkIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbHBoYV0gLSBEZXByZWNhdGVkLiBCdWZmZXJzIGFyZSBhbHdheXMgUkdCQSBzaW5jZSB0aHJlZSByMTM3LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlzYW1wbGluZz0wXSAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB1c2VkIGZvciBtdWx0aXNhbXBsZSBhbnRpYWxpYXNpbmcuIFJlcXVpcmVzIFdlYkdMIDIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmFtZUJ1ZmZlclR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIGludGVybmFsIGZyYW1lIGJ1ZmZlcnMuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIEhhbGZGbG9hdFR5cGUgaWYgcG9zc2libGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciA9IG51bGwsIHtcbiAgICBkZXB0aEJ1ZmZlciA9IHRydWUsXG4gICAgc3RlbmNpbEJ1ZmZlciA9IGZhbHNlLFxuICAgIG11bHRpc2FtcGxpbmcgPSAwLFxuICAgIGZyYW1lQnVmZmVyVHlwZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoZGVwdGhCdWZmZXIsIHN0ZW5jaWxCdWZmZXIsIGZyYW1lQnVmZmVyVHlwZSwgbXVsdGlzYW1wbGluZyk7XG4gICAgdGhpcy5vdXRwdXRCdWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyLmNsb25lKCk7XG4gICAgdGhpcy5jb3B5UGFzcyA9IG5ldyBDb3B5UGFzcygpO1xuICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIoKTtcbiAgICB0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgdGhpcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFtb3VudCBvZiBzYW1wbGVzIHVzZWQgZm9yIG11bHRpc2FtcGxlIGFudGktYWxpYXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbXVsdGlzYW1wbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5zYW1wbGVzIHx8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFtb3VudCBvZiBNU0FBIHNhbXBsZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIFdlYkdMIDIuIFNldCB0byB6ZXJvIHRvIGRpc2FibGUgbXVsdGlzYW1wbGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBtdWx0aXNhbXBsaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlcjtcbiAgICBjb25zdCBtdWx0aXNhbXBsaW5nID0gdGhpcy5tdWx0aXNhbXBsaW5nO1xuICAgIGlmIChtdWx0aXNhbXBsaW5nID4gMCAmJiB2YWx1ZSA+IDApIHtcbiAgICAgIHRoaXMuaW5wdXRCdWZmZXIuc2FtcGxlcyA9IHZhbHVlO1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuc2FtcGxlcyA9IHZhbHVlO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgfSBlbHNlIGlmIChtdWx0aXNhbXBsaW5nICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm91dHB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXG4gICAgICAgIGJ1ZmZlci5kZXB0aEJ1ZmZlcixcbiAgICAgICAgYnVmZmVyLnN0ZW5jaWxCdWZmZXIsXG4gICAgICAgIGJ1ZmZlci50ZXh0dXJlLnR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kZXB0aFRleHR1cmUgPSB0aGlzLmRlcHRoVGV4dHVyZTtcbiAgICAgIHRoaXMub3V0cHV0QnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlci5jbG9uZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgdGltZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVyfSBUaGUgdGltZXIuXG4gICAqL1xuICBnZXRUaW1lcigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlci5cbiAgICovXG4gIGdldFJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIGlmIChyZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHJlbmRlcmVyLmdldFNpemUobmV3IFZlY3RvcjIxNigpKTtcbiAgICAgIGNvbnN0IGFscGhhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XG4gICAgICBjb25zdCBmcmFtZUJ1ZmZlclR5cGUgPSB0aGlzLmlucHV0QnVmZmVyLnRleHR1cmUudHlwZTtcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUxMSAmJiBnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMub3V0cHV0QnVmZmVyLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub3V0cHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgICBwYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuICAgKlxuICAgKiBUaGUgYXV0byBjbGVhciBtZWNoYW5pc20gb2YgdGhlIHByb3ZpZGVkIHJlbmRlcmVyIHdpbGwgYmUgZGlzYWJsZWQuIElmIHRoZSBuZXcgcmVuZGVyIHNpemUgZGlmZmVycyBmcm9tIHRoZVxuICAgKiBwcmV2aW91cyBvbmUsIGFsbCBwYXNzZXMgd2lsbCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IG5vZGUgYW5kIHRoZSBET01cbiAgICogZWxlbWVudCBvZiB0aGUgbmV3IHJlbmRlcmVyIHdpbGwgdGFrZSBpdHMgcGxhY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRSZW5kZXJlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIG5ldyByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGVET00gLSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb2xkIGNhbnZhcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgdGhlIG5ldyBvbmUgaW4gdGhlIERPTS5cbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gVGhlIG9sZCByZW5kZXJlci5cbiAgICovXG4gIHJlcGxhY2VSZW5kZXJlcihyZW5kZXJlciwgdXBkYXRlRE9NID0gdHJ1ZSkge1xuICAgIGNvbnN0IG9sZFJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBwYXJlbnQgPSBvbGRSZW5kZXJlci5kb21FbGVtZW50LnBhcmVudE5vZGU7XG4gICAgdGhpcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgaWYgKHVwZGF0ZURPTSAmJiBwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChvbGRSZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9sZFJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVwdGggdGV4dHVyZSBhdHRhY2htZW50IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byBhbGwgcGFzc2VzLlxuICAgKlxuICAgKiBOb3RlOiBXaGVuIGEgc2hhZGVyIHJlYWRzIGZyb20gYSBkZXB0aCB0ZXh0dXJlIGFuZCB3cml0ZXMgdG8gYSByZW5kZXIgdGFyZ2V0IHRoYXQgdXNlcyB0aGUgc2FtZSBkZXB0aCB0ZXh0dXJlXG4gICAqIGF0dGFjaG1lbnQsIHRoZSBkZXB0aCBpbmZvcm1hdGlvbiB3aWxsIGJlIGxvc3QuIFRoaXMgaGFwcGVucyBldmVuIGlmIGBkZXB0aFdyaXRlYCBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7RGVwdGhUZXh0dXJlfSBUaGUgZGVwdGggdGV4dHVyZS5cbiAgICovXG4gIGNyZWF0ZURlcHRoVGV4dHVyZSgpIHtcbiAgICBjb25zdCBkZXB0aFRleHR1cmUgPSB0aGlzLmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcbiAgICB0aGlzLmlucHV0QnVmZmVyLmRlcHRoVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5pbnB1dEJ1ZmZlci5zdGVuY2lsQnVmZmVyKSB7XG4gICAgICBkZXB0aFRleHR1cmUuZm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xuICAgICAgZGVwdGhUZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHRoVGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGhUZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBjdXJyZW50IGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWxldGVEZXB0aFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICB0aGlzLmlucHV0QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgIGZvciAoY29uc3QgcGFzcyBvZiB0aGlzLnBhc3Nlcykge1xuICAgICAgICBwYXNzLnNldERlcHRoVGV4dHVyZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyIHRhcmdldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgQ3JlYXRlIGJ1ZmZlcnMgbWFudWFsbHkgdmlhIFdlYkdMUmVuZGVyVGFyZ2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVwdGhCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgZGVwdGggYnVmZmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0ZW5jaWxCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgc3RlbmNpbCBidWZmZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIC0gVGhlIGZyYW1lIGJ1ZmZlciB0eXBlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbXVsdGlzYW1wbGluZyAtIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyB0byB1c2UgZm9yIGFudGlhbGlhc2luZy5cbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJUYXJnZXR9IEEgbmV3IHJlbmRlciB0YXJnZXQgdGhhdCBlcXVhbHMgdGhlIHJlbmRlcmVyJ3MgY2FudmFzLlxuICAgKi9cbiAgY3JlYXRlQnVmZmVyKGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyLCB0eXBlLCBtdWx0aXNhbXBsaW5nKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHNpemUgPSByZW5kZXJlciA9PT0gbnVsbCA/IG5ldyBWZWN0b3IyMTYoKSA6IHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBWZWN0b3IyMTYoKSk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1pbkZpbHRlcjogTGluZWFyRmlsdGVyMixcbiAgICAgIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyMixcbiAgICAgIHN0ZW5jaWxCdWZmZXIsXG4gICAgICBkZXB0aEJ1ZmZlcixcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDEzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICBpZiAobXVsdGlzYW1wbGluZyA+IDApIHtcbiAgICAgIHJlbmRlclRhcmdldC5pZ25vcmVEZXB0aEZvck11bHRpc2FtcGxlQ29weSA9IGZhbHNlO1xuICAgICAgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPSBtdWx0aXNhbXBsaW5nO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZTExICYmIGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UocmVuZGVyVGFyZ2V0LnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICB9XG4gICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRWZmZWN0Q29tcG9zZXIuQnVmZmVyXCI7XG4gICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbiAgfVxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBtYWluIHNjZW5lIGZvciBhbGwgcmVnaXN0ZXJlZCBwYXNzZXMgYW5kIGVmZmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lLlxuICAgKi9cbiAgc2V0TWFpblNjZW5lKHNjZW5lKSB7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLm1haW5TY2VuZSA9IHNjZW5lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZSBtYWluIGNhbWVyYSBmb3IgYWxsIHJlZ2lzdGVyZWQgcGFzc2VzIGFuZCBlZmZlY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYS5cbiAgICovXG4gIHNldE1haW5DYW1lcmEoY2FtZXJhKSB7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLm1haW5DYW1lcmEgPSBjYW1lcmE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzcywgb3B0aW9uYWxseSBhdCBhIHNwZWNpZmljIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgLSBBIG5ldyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIEFuIGluZGV4IGF0IHdoaWNoIHRoZSBwYXNzIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICovXG4gIGFkZFBhc3MocGFzcywgaW5kZXgpIHtcbiAgICBjb25zdCBwYXNzZXMgPSB0aGlzLnBhc3NlcztcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZHJhd2luZ0J1ZmZlclNpemUgPSByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShuZXcgVmVjdG9yMjE2KCkpO1xuICAgIGNvbnN0IGFscGhhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XG4gICAgY29uc3QgZnJhbWVCdWZmZXJUeXBlID0gdGhpcy5pbnB1dEJ1ZmZlci50ZXh0dXJlLnR5cGU7XG4gICAgcGFzcy5zZXRSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgcGFzcy5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIHBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhc3MucmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgdGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIHBhc3Nlcy5zcGxpY2UoaW5kZXgsIDAsIHBhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXNzZXMucHVzaChwYXNzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuKSB7XG4gICAgICBwYXNzZXNbcGFzc2VzLmxlbmd0aCAtIDFdLnJlbmRlclRvU2NyZWVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhc3MubmVlZHNEZXB0aFRleHR1cmUgfHwgdGhpcy5kZXB0aFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZXB0aFRleHR1cmUgPSB0aGlzLmNyZWF0ZURlcHRoVGV4dHVyZSgpO1xuICAgICAgICBmb3IgKHBhc3Mgb2YgcGFzc2VzKSB7XG4gICAgICAgICAgcGFzcy5zZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFzcy5zZXREZXB0aFRleHR1cmUodGhpcy5kZXB0aFRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzc30gcGFzcyAtIFRoZSBwYXNzLlxuICAgKi9cbiAgcmVtb3ZlUGFzcyhwYXNzKSB7XG4gICAgY29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XG4gICAgY29uc3QgaW5kZXggPSBwYXNzZXMuaW5kZXhPZihwYXNzKTtcbiAgICBjb25zdCBleGlzdHMgPSBpbmRleCAhPT0gLTE7XG4gICAgY29uc3QgcmVtb3ZlZCA9IGV4aXN0cyAmJiBwYXNzZXMuc3BsaWNlKGluZGV4LCAxKS5sZW5ndGggPiAwO1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChhLCBiKSA9PiBhIHx8IGIubmVlZHNEZXB0aFRleHR1cmU7XG4gICAgICAgIGNvbnN0IGRlcHRoVGV4dHVyZVJlcXVpcmVkID0gcGFzc2VzLnJlZHVjZShyZWR1Y2VyLCBmYWxzZSk7XG4gICAgICAgIGlmICghZGVwdGhUZXh0dXJlUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocGFzcy5nZXREZXB0aFRleHR1cmUoKSA9PT0gdGhpcy5kZXB0aFRleHR1cmUpIHtcbiAgICAgICAgICAgIHBhc3Muc2V0RGVwdGhUZXh0dXJlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlbGV0ZURlcHRoVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdXRvUmVuZGVyVG9TY3JlZW4pIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBwYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFzcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFzc2VzW3Bhc3Nlcy5sZW5ndGggLSAxXS5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBwYXNzZXMuXG4gICAqL1xuICByZW1vdmVBbGxQYXNzZXMoKSB7XG4gICAgY29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XG4gICAgdGhpcy5kZWxldGVEZXB0aFRleHR1cmUoKTtcbiAgICBpZiAocGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLmF1dG9SZW5kZXJUb1NjcmVlbikge1xuICAgICAgICBwYXNzZXNbcGFzc2VzLmxlbmd0aCAtIDFdLnJlbmRlclRvU2NyZWVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhbGwgZW5hYmxlZCBwYXNzZXMgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHJlbmRlcihkZWx0YVRpbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29weVBhc3MgPSB0aGlzLmNvcHlQYXNzO1xuICAgIGxldCBpbnB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXI7XG4gICAgbGV0IG91dHB1dEJ1ZmZlciA9IHRoaXMub3V0cHV0QnVmZmVyO1xuICAgIGxldCBzdGVuY2lsVGVzdCA9IGZhbHNlO1xuICAgIGxldCBjb250ZXh0LCBzdGVuY2lsLCBidWZmZXI7XG4gICAgaWYgKGRlbHRhVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRpbWVyLnVwZGF0ZSgpO1xuICAgICAgZGVsdGFUaW1lID0gdGhpcy50aW1lci5kZWx0YTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBpZiAocGFzcy5lbmFibGVkKSB7XG4gICAgICAgIHBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgb3V0cHV0QnVmZmVyLCBkZWx0YVRpbWUsIHN0ZW5jaWxUZXN0KTtcbiAgICAgICAgaWYgKHBhc3MubmVlZHNTd2FwKSB7XG4gICAgICAgICAgaWYgKHN0ZW5jaWxUZXN0KSB7XG4gICAgICAgICAgICBjb3B5UGFzcy5yZW5kZXJUb1NjcmVlbiA9IHBhc3MucmVuZGVyVG9TY3JlZW47XG4gICAgICAgICAgICBjb250ZXh0ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgc3RlbmNpbCA9IHJlbmRlcmVyLnN0YXRlLmJ1ZmZlcnMuc3RlbmNpbDtcbiAgICAgICAgICAgIHN0ZW5jaWwuc2V0RnVuYyhjb250ZXh0Lk5PVEVRVUFMLCAxLCA0Mjk0OTY3Mjk1KTtcbiAgICAgICAgICAgIGNvcHlQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIG91dHB1dEJ1ZmZlciwgZGVsdGFUaW1lLCBzdGVuY2lsVGVzdCk7XG4gICAgICAgICAgICBzdGVuY2lsLnNldEZ1bmMoY29udGV4dC5FUVVBTCwgMSwgNDI5NDk2NzI5NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9IGlucHV0QnVmZmVyO1xuICAgICAgICAgIGlucHV0QnVmZmVyID0gb3V0cHV0QnVmZmVyO1xuICAgICAgICAgIG91dHB1dEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzcyBpbnN0YW5jZW9mIE1hc2tQYXNzKSB7XG4gICAgICAgICAgc3RlbmNpbFRlc3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHBhc3MgaW5zdGFuY2VvZiBDbGVhck1hc2tQYXNzKSB7XG4gICAgICAgICAgc3RlbmNpbFRlc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVycywgcGFzc2VzIGFuZCB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VwZGF0ZVN0eWxlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc3R5bGUgb2YgdGhlIGNhbnZhcyBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY3VycmVudFNpemUgPSByZW5kZXJlci5nZXRTaXplKG5ldyBWZWN0b3IyMTYoKSk7XG4gICAgaWYgKHdpZHRoID09PSB2b2lkIDAgfHwgaGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIHdpZHRoID0gY3VycmVudFNpemUud2lkdGg7XG4gICAgICBoZWlnaHQgPSBjdXJyZW50U2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgY3VycmVudFNpemUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3aW5nQnVmZmVyU2l6ZSA9IHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKG5ldyBWZWN0b3IyMTYoKSk7XG4gICAgdGhpcy5pbnB1dEJ1ZmZlci5zZXRTaXplKGRyYXdpbmdCdWZmZXJTaXplLndpZHRoLCBkcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQpO1xuICAgIHRoaXMub3V0cHV0QnVmZmVyLnNldFNpemUoZHJhd2luZ0J1ZmZlclNpemUud2lkdGgsIGRyYXdpbmdCdWZmZXJTaXplLmhlaWdodCk7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLnNldFNpemUoZHJhd2luZ0J1ZmZlclNpemUud2lkdGgsIGRyYXdpbmdCdWZmZXJTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBjb21wb3NlciBieSBkZWxldGluZyBhbGwgcGFzc2VzIGFuZCBjcmVhdGluZyBuZXcgYnVmZmVycy5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IGF1dG9SZXNldCA9IHRoaXMudGltZXIuYXV0b1Jlc2V0O1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIHRoaXMuYXV0b1JlbmRlclRvU2NyZWVuID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVyLmF1dG9SZXNldCA9IGF1dG9SZXNldDtcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBjb21wb3NlciBhbmQgYWxsIHBhc3Nlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMucGFzc2VzKSB7XG4gICAgICBwYXNzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5wYXNzZXMgPSBbXTtcbiAgICBpZiAodGhpcy5pbnB1dEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbnB1dEJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm91dHB1dEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRwdXRCdWZmZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmRlbGV0ZURlcHRoVGV4dHVyZSgpO1xuICAgIHRoaXMuY29weVBhc3MuZGlzcG9zZSgpO1xuICAgIHRoaXMudGltZXIuZGlzcG9zZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9FZmZlY3RTaGFkZXJEYXRhLmpzXG52YXIgRWZmZWN0U2hhZGVyRGF0YSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbmV3IHNoYWRlciBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zaGFkZXJQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLkZSQUdNRU5UX0hFQUQsIG51bGxdLFxuICAgICAgW0VmZmVjdFNoYWRlclNlY3Rpb24uRlJBR01FTlRfTUFJTl9VViwgbnVsbF0sXG4gICAgICBbRWZmZWN0U2hhZGVyU2VjdGlvbi5GUkFHTUVOVF9NQUlOX0lNQUdFLCBudWxsXSxcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9IRUFELCBudWxsXSxcbiAgICAgIFtFZmZlY3RTaGFkZXJTZWN0aW9uLlZFUlRFWF9NQUlOX1NVUFBPUlQsIG51bGxdXG4gICAgXSk7XG4gICAgdGhpcy5kZWZpbmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmJsZW5kTW9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gRWZmZWN0QXR0cmlidXRlLk5PTkU7XG4gICAgdGhpcy52YXJ5aW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy51dlRyYW5zZm9ybWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkRGVwdGggPSBmYWxzZTtcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvR2F1c3NLZXJuZWwuanNcbmZ1bmN0aW9uIGdldENvZWZmaWNpZW50cyhuKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheSgwKTtcbiAgfSBlbHNlIGlmIChuID09PSAxKSB7XG4gICAgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShbMV0pO1xuICB9IGVsc2UgaWYgKG4gPiAxKSB7XG4gICAgbGV0IHJvdzAgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGxldCByb3cxID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBmb3IgKGxldCB5ID0gMTsgeSA8PSBuOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeTsgKyt4KSB7XG4gICAgICAgIHJvdzFbeF0gPSB4ID09PSAwIHx8IHggPT09IHkgLSAxID8gMSA6IHJvdzBbeCAtIDFdICsgcm93MFt4XTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJvdzE7XG4gICAgICByb3cxID0gcm93MDtcbiAgICAgIHJvdzAgPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgR2F1c3NLZXJuZWwgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdhdXNzIGtlcm5lbC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGtlcm5lbFNpemUgLSBUaGUga2VybmVsIHNpemUuIFNob3VsZCBiZSBhbiBvZGQgbnVtYmVyIGluIHRoZSByYW5nZSBbMywgMTAyMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZWRnZUJpYXM9Ml0gLSBEZXRlcm1pbmVzIGhvdyBtYW55IGVkZ2UgY29lZmZpY2llbnRzIHNob3VsZCBiZSBjdXQgb2ZmIGZvciBpbmNyZWFzZWQgYWNjdXJhY3kuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXJuZWxTaXplLCBlZGdlQmlhcyA9IDIpIHtcbiAgICB0aGlzLndlaWdodHMgPSBudWxsO1xuICAgIHRoaXMub2Zmc2V0cyA9IG51bGw7XG4gICAgdGhpcy5saW5lYXJXZWlnaHRzID0gbnVsbDtcbiAgICB0aGlzLmxpbmVhck9mZnNldHMgPSBudWxsO1xuICAgIHRoaXMuZ2VuZXJhdGUoa2VybmVsU2l6ZSwgZWRnZUJpYXMpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHN0ZXBzIGZvciBkaXNjcmV0ZSBzYW1wbGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRzID09PSBudWxsID8gMCA6IHRoaXMub2Zmc2V0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc3RlcHMgZm9yIGxpbmVhciBzYW1wbGluZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsaW5lYXJTdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lYXJPZmZzZXRzID09PSBudWxsID8gMCA6IHRoaXMubGluZWFyT2Zmc2V0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUga2VybmVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0ga2VybmVsU2l6ZSAtIFRoZSBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2VCaWFzIC0gVGhlIGFtb3VudCBvZiBlZGdlIGNvZWZmaWNpZW50cyB0byBpZ25vcmUuXG4gICAqL1xuICBnZW5lcmF0ZShrZXJuZWxTaXplLCBlZGdlQmlhcykge1xuICAgIGlmIChrZXJuZWxTaXplIDwgMyB8fCBrZXJuZWxTaXplID4gMTAyMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGtlcm5lbCBzaXplIG11c3QgYmUgaW4gdGhlIHJhbmdlIFszLCAxMDIwXVwiKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IGtlcm5lbFNpemUgKyBlZGdlQmlhcyAqIDI7XG4gICAgY29uc3QgY29lZmZpY2llbnRzID0gZWRnZUJpYXMgPiAwID8gZ2V0Q29lZmZpY2llbnRzKG4pLnNsaWNlKGVkZ2VCaWFzLCAtZWRnZUJpYXMpIDogZ2V0Q29lZmZpY2llbnRzKG4pO1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGNvZWZmaWNpZW50cy5sZW5ndGggLSAxKSAvIDIpO1xuICAgIGNvbnN0IHN1bSA9IGNvZWZmaWNpZW50cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICBjb25zdCB3ZWlnaHRzID0gY29lZmZpY2llbnRzLnNsaWNlKG1pZCk7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFsuLi5BcnJheShtaWQgKyAxKS5rZXlzKCldO1xuICAgIGNvbnN0IGxpbmVhcldlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KE1hdGguZmxvb3Iob2Zmc2V0cy5sZW5ndGggLyAyKSk7XG4gICAgY29uc3QgbGluZWFyT2Zmc2V0cyA9IG5ldyBGbG9hdDY0QXJyYXkobGluZWFyV2VpZ2h0cy5sZW5ndGgpO1xuICAgIGxpbmVhcldlaWdodHNbMF0gPSB3ZWlnaHRzWzBdIC8gc3VtO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMSwgbCA9IG9mZnNldHMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gMiwgKytqKSB7XG4gICAgICBjb25zdCBvZmZzZXQwID0gb2Zmc2V0c1tpXSwgb2Zmc2V0MSA9IG9mZnNldHNbaSArIDFdO1xuICAgICAgY29uc3Qgd2VpZ2h0MCA9IHdlaWdodHNbaV0sIHdlaWdodDEgPSB3ZWlnaHRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IHcgPSB3ZWlnaHQwICsgd2VpZ2h0MTtcbiAgICAgIGNvbnN0IG8gPSAob2Zmc2V0MCAqIHdlaWdodDAgKyBvZmZzZXQxICogd2VpZ2h0MSkgLyB3O1xuICAgICAgbGluZWFyV2VpZ2h0c1tqXSA9IHcgLyBzdW07XG4gICAgICBsaW5lYXJPZmZzZXRzW2pdID0gbztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB3ZWlnaHRzLmxlbmd0aCwgcyA9IDEgLyBzdW07IGkgPCBsOyArK2kpIHtcbiAgICAgIHdlaWdodHNbaV0gKj0gcztcbiAgICB9XG4gICAgY29uc3QgbGluZWFyV2VpZ2h0U3VtID0gKGxpbmVhcldlaWdodHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLSBsaW5lYXJXZWlnaHRzWzBdICogMC41KSAqIDI7XG4gICAgaWYgKGxpbmVhcldlaWdodFN1bSAhPT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lYXJXZWlnaHRzLmxlbmd0aCwgcyA9IDEgLyBsaW5lYXJXZWlnaHRTdW07IGkgPCBsOyArK2kpIHtcbiAgICAgICAgbGluZWFyV2VpZ2h0c1tpXSAqPSBzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9mZnNldHMgPSBvZmZzZXRzO1xuICAgIHRoaXMud2VpZ2h0cyA9IHdlaWdodHM7XG4gICAgdGhpcy5saW5lYXJPZmZzZXRzID0gbGluZWFyT2Zmc2V0cztcbiAgICB0aGlzLmxpbmVhcldlaWdodHMgPSBsaW5lYXJXZWlnaHRzO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9JbW11dGFibGVUaW1lci5qc1xudmFyIEltbXV0YWJsZVRpbWVyID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZGVsdGEgdGltZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlbHRhKCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmaXhlZCBkZWx0YSB0aW1lIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZml4ZWREZWx0YSgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWxhcHNlZCB0aW1lIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZWxhcHNlZCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9Jbml0aWFsaXphYmxlLmpzXG52YXIgSW5pdGlhbGl6YWJsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9PdmVycmlkZU1hdGVyaWFsTWFuYWdlci5qc1xuaW1wb3J0IHsgQmFja1NpZGUsIERvdWJsZVNpZGUsIEZyb250U2lkZSwgU2hhZGVyTWF0ZXJpYWwgYXMgU2hhZGVyTWF0ZXJpYWwyMiB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIHdvcmthcm91bmRFbmFibGVkID0gZmFsc2U7XG52YXIgT3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG92ZXJyaWRlIG1hdGVyaWFsIG1hbmFnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IFttYXRlcmlhbD1udWxsXSAtIEFuIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWF0ZXJpYWwgPSBudWxsKSB7XG4gICAgdGhpcy5vcmlnaW5hbE1hdGVyaWFscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHMgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzQmFja1NpZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkID0gbnVsbDtcbiAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSA9IG51bGw7XG4gICAgdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkRG91YmxlU2lkZSA9IG51bGw7XG4gICAgdGhpcy5zZXRNYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgdGhpcy5tZXNoQ291bnQgPSAwO1xuICAgIHRoaXMucmVwbGFjZU1hdGVyaWFsID0gKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLmlzTWVzaCkge1xuICAgICAgICBsZXQgbWF0ZXJpYWxzO1xuICAgICAgICBpZiAobm9kZS5tYXRlcmlhbC5mbGF0U2hhZGluZykge1xuICAgICAgICAgIHN3aXRjaCAobm9kZS5tYXRlcmlhbC5zaWRlKSB7XG4gICAgICAgICAgICBjYXNlIERvdWJsZVNpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCYWNrU2lkZTpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkQmFja1NpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLm1hdGVyaWFsLnNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRG91YmxlU2lkZTpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHNEb3VibGVTaWRlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmFja1NpZGU6XG4gICAgICAgICAgICAgIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzQmFja1NpZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzLnNldChub2RlLCBub2RlLm1hdGVyaWFsKTtcbiAgICAgICAgaWYgKG5vZGUuaXNTa2lubmVkTWVzaCkge1xuICAgICAgICAgIG5vZGUubWF0ZXJpYWwgPSBtYXRlcmlhbHNbMl07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc0luc3RhbmNlZE1lc2gpIHtcbiAgICAgICAgICBub2RlLm1hdGVyaWFsID0gbWF0ZXJpYWxzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubWF0ZXJpYWwgPSBtYXRlcmlhbHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgKyt0aGlzLm1lc2hDb3VudDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIGdpdmVuIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbCAtIFRoZSBtYXRlcmlhbC5cbiAgICogQHJldHVybiB7TWF0ZXJpYWx9IFRoZSBjbG9uZWQgbWF0ZXJpYWwuXG4gICAqL1xuICBjbG9uZU1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgaWYgKCEobWF0ZXJpYWwgaW5zdGFuY2VvZiBTaGFkZXJNYXRlcmlhbDIyKSkge1xuICAgICAgcmV0dXJuIG1hdGVyaWFsLmNsb25lKCk7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dHVyZVVuaWZvcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB1bmlmb3Jtcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB1bmlmb3Jtc1trZXldLnZhbHVlO1xuICAgICAgaWYgKHZhbHVlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSkge1xuICAgICAgICB1bmlmb3Jtc1trZXldLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGV4dHVyZVVuaWZvcm1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2xvbmUgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGV4dHVyZVVuaWZvcm1zKSB7XG4gICAgICB1bmlmb3Jtc1tlbnRyeVswXV0udmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgIGNsb25lLnVuaWZvcm1zW2VudHJ5WzBdXS52YWx1ZSA9IGVudHJ5WzFdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbCAtIFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIHNldE1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgdGhpcy5kaXNwb3NlTWF0ZXJpYWxzKCk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIGlmIChtYXRlcmlhbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHMgPSBbXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbCksXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbCksXG4gICAgICAgIHRoaXMuY2xvbmVNYXRlcmlhbChtYXRlcmlhbClcbiAgICAgIF07XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIG1hdGVyaWFscykge1xuICAgICAgICBtMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgbTIuc2lkZSA9IEZyb250U2lkZTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsc1syXS5za2lubmluZyA9IHRydWU7XG4gICAgICB0aGlzLm1hdGVyaWFsc0JhY2tTaWRlID0gbWF0ZXJpYWxzLm1hcCgobTIpID0+IHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNsb25lTWF0ZXJpYWwobTIpO1xuICAgICAgICBjMi51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGVyaWFsLnVuaWZvcm1zKTtcbiAgICAgICAgYzIuc2lkZSA9IEJhY2tTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGMyO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hdGVyaWFsc0ZsYXRTaGFkZWRCYWNrU2lkZSA9IG1hdGVyaWFscy5tYXAoKG0yKSA9PiB7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5jbG9uZU1hdGVyaWFsKG0yKTtcbiAgICAgICAgYzIudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRlcmlhbC51bmlmb3Jtcyk7XG4gICAgICAgIGMyLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYzIuc2lkZSA9IEJhY2tTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUgPSBtYXRlcmlhbHMubWFwKChtMikgPT4ge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2xvbmVNYXRlcmlhbChtMik7XG4gICAgICAgIGMyLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWwudW5pZm9ybXMpO1xuICAgICAgICBjMi5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGMyLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNjZW5lIHdpdGggdGhlIG92ZXJyaWRlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIEEgc2NlbmUuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIGNhbWVyYS5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSkge1xuICAgIGNvbnN0IHNoYWRvd01hcEVuYWJsZWQgPSByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmICh3b3JrYXJvdW5kRW5hYmxlZCkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxNYXRlcmlhbHMgPSB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzO1xuICAgICAgdGhpcy5tZXNoQ291bnQgPSAwO1xuICAgICAgc2NlbmUudHJhdmVyc2UodGhpcy5yZXBsYWNlTWF0ZXJpYWwpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBvcmlnaW5hbE1hdGVyaWFscykge1xuICAgICAgICBlbnRyeVswXS5tYXRlcmlhbCA9IGVudHJ5WzFdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVzaENvdW50ICE9PSBvcmlnaW5hbE1hdGVyaWFscy5zaXplKSB7XG4gICAgICAgIG9yaWdpbmFsTWF0ZXJpYWxzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuICAgICAgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcbiAgICB9XG4gICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBzaGFkb3dNYXBFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGNsb25lZCBvdmVycmlkZSBtYXRlcmlhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwb3NlTWF0ZXJpYWxzKCkge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscy5jb25jYXQodGhpcy5tYXRlcmlhbHNCYWNrU2lkZSkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRG91YmxlU2lkZSkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZCkuY29uY2F0KHRoaXMubWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlKS5jb25jYXQodGhpcy5tYXRlcmlhbHNGbGF0U2hhZGVkRG91YmxlU2lkZSk7XG4gICAgICBmb3IgKGNvbnN0IG0yIG9mIG1hdGVyaWFscykge1xuICAgICAgICBtMi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBjbGVhbnVwIHRhc2tzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLm9yaWdpbmFsTWF0ZXJpYWxzLmNsZWFyKCk7XG4gICAgdGhpcy5kaXNwb3NlTWF0ZXJpYWxzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBvdmVycmlkZSBtYXRlcmlhbCB3b3JrYXJvdW5kIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB3b3JrYXJvdW5kRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gd29ya2Fyb3VuZEVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIG92ZXJyaWRlIG1hdGVyaWFsIHdvcmthcm91bmQgZ2xvYmFsbHkuXG4gICAqXG4gICAqIFRoaXMgb25seSBhZmZlY3RzIHBvc3QgcHJvY2Vzc2luZyBwYXNzZXMgYW5kIGVmZmVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB3b3JrYXJvdW5kRW5hYmxlZCh2YWx1ZSkge1xuICAgIHdvcmthcm91bmRFbmFibGVkID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL1Jlc2l6YWJsZS5qc1xudmFyIFJlc2l6YWJsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvUmVzb2x1dGlvbi5qc1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyLCBWZWN0b3IyIGFzIFZlY3RvcjIxNyB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIEFVVE9fU0laRSA9IC0xO1xudmFyIFJlc29sdXRpb24gPSBjbGFzcyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJlc29sdXRpb24uXG4gICAqXG4gICAqIFRPRE8gUmVtb3ZlIHJlc2l6YWJsZSBwYXJhbS5cbiAgICogQHBhcmFtIHtSZXNpemFibGV9IHJlc2l6YWJsZSAtIEEgcmVzaXphYmxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgcHJlZmVycmVkIGhlaWdodC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xLjBdIC0gQSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzaXphYmxlLCB3aWR0aCA9IEFVVE9fU0laRSwgaGVpZ2h0ID0gQVVUT19TSVpFLCBzY2FsZSA9IDEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzaXphYmxlID0gcmVzaXphYmxlO1xuICAgIHRoaXMuYmFzZVNpemUgPSBuZXcgVmVjdG9yMjE3KDEsIDEpO1xuICAgIHRoaXMucHJlZmVycmVkU2l6ZSA9IG5ldyBWZWN0b3IyMTcod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLnByZWZlcnJlZFNpemU7XG4gICAgdGhpcy5zID0gc2NhbGU7XG4gICAgdGhpcy5lZmZlY3RpdmVTaXplID0gbmV3IFZlY3RvcjIxNygpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZUVmZmVjdGl2ZVNpemUoKSk7XG4gICAgdGhpcy51cGRhdGVFZmZlY3RpdmVTaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGVmZmVjdGl2ZSBzaXplLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlRWZmZWN0aXZlU2l6ZSgpIHtcbiAgICBjb25zdCBiYXNlID0gdGhpcy5iYXNlU2l6ZTtcbiAgICBjb25zdCBwcmVmZXJyZWQgPSB0aGlzLnByZWZlcnJlZFNpemU7XG4gICAgY29uc3QgZWZmZWN0aXZlID0gdGhpcy5lZmZlY3RpdmVTaXplO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICBpZiAocHJlZmVycmVkLndpZHRoICE9PSBBVVRPX1NJWkUpIHtcbiAgICAgIGVmZmVjdGl2ZS53aWR0aCA9IHByZWZlcnJlZC53aWR0aDtcbiAgICB9IGVsc2UgaWYgKHByZWZlcnJlZC5oZWlnaHQgIT09IEFVVE9fU0laRSkge1xuICAgICAgZWZmZWN0aXZlLndpZHRoID0gTWF0aC5yb3VuZChwcmVmZXJyZWQuaGVpZ2h0ICogKGJhc2Uud2lkdGggLyBNYXRoLm1heChiYXNlLmhlaWdodCwgMSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0aXZlLndpZHRoID0gTWF0aC5yb3VuZChiYXNlLndpZHRoICogc2NhbGUpO1xuICAgIH1cbiAgICBpZiAocHJlZmVycmVkLmhlaWdodCAhPT0gQVVUT19TSVpFKSB7XG4gICAgICBlZmZlY3RpdmUuaGVpZ2h0ID0gcHJlZmVycmVkLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHByZWZlcnJlZC53aWR0aCAhPT0gQVVUT19TSVpFKSB7XG4gICAgICBlZmZlY3RpdmUuaGVpZ2h0ID0gTWF0aC5yb3VuZChwcmVmZXJyZWQud2lkdGggLyBNYXRoLm1heChiYXNlLndpZHRoIC8gTWF0aC5tYXgoYmFzZS5oZWlnaHQsIDEpLCAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdGl2ZS5oZWlnaHQgPSBNYXRoLnJvdW5kKGJhc2UuaGVpZ2h0ICogc2NhbGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGVmZmVjdGl2ZSB3aWR0aC5cbiAgICpcbiAgICogSWYgdGhlIHByZWZlcnJlZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQgdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSwgdGhlIGJhc2Ugd2lkdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZmZlY3RpdmVTaXplLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucHJlZmVycmVkV2lkdGggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGVmZmVjdGl2ZSBoZWlnaHQuXG4gICAqXG4gICAqIElmIHRoZSBwcmVmZXJyZWQgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0IHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0sIHRoZSBiYXNlIGhlaWdodCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZmZlY3RpdmVTaXplLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIHdpZHRoLlxuICAgKlxuICAgKiBJZiB0aGUgcHJlZmVycmVkIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHNldCB0byB7QGxpbmsgUmVzaXplci5BVVRPX1NJWkV9LCB0aGUgYmFzZSB3aWR0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2lkdGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZWZmZWN0aXZlIHdpZHRoLlxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBoZWlnaHQuXG4gICAqXG4gICAqIElmIHRoZSBwcmVmZXJyZWQgd2lkdGggYW5kIGhlaWdodCBhcmUgc2V0IHRvIHtAbGluayBSZXNpemVyLkFVVE9fU0laRX0sIHRoZSBiYXNlIGhlaWdodCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaGVpZ2h0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVmZmVjdGl2ZSBoZWlnaHQuXG4gICAqL1xuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnMgPSB2YWx1ZTtcbiAgICAgIHRoaXMucHJlZmVycmVkU2l6ZS5zZXRTY2FsYXIoQVVUT19TSVpFKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEFsc28gc2V0cyB0aGUgcHJlZmVycmVkIHJlc29sdXRpb24gdG8ge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNjYWxlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzY2FsZS5cbiAgICovXG4gIHNldFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSB3aWR0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiYXNlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVNpemUud2lkdGg7XG4gIH1cbiAgc2V0IGJhc2VXaWR0aCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmJhc2VTaXplLndpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5iYXNlU2l6ZS53aWR0aCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSB3aWR0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJhc2VXaWR0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiYXNlIHdpZHRoLlxuICAgKi9cbiAgZ2V0QmFzZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VXaWR0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSB3aWR0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJhc2VXaWR0aCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgd2lkdGguXG4gICAqL1xuICBzZXRCYXNlV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLmJhc2VXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBoZWlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYmFzZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlU2l6ZS5oZWlnaHQ7XG4gIH1cbiAgc2V0IGJhc2VIZWlnaHQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5iYXNlU2l6ZS5oZWlnaHQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmJhc2VTaXplLmhlaWdodCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogXCJjaGFuZ2VcIiB9KTtcbiAgICAgIHRoaXMucmVzaXphYmxlLnNldFNpemUodGhpcy5iYXNlU2l6ZS53aWR0aCwgdGhpcy5iYXNlU2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSBoZWlnaHQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBiYXNlSGVpZ2h0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJhc2UgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0QmFzZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBiYXNlIGhlaWdodC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJhc2VIZWlnaHQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldEJhc2VIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLmJhc2VIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0aGlzLmJhc2VTaXplLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmJhc2VTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLmJhc2VTaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVmZXJyZWQgd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcHJlZmVycmVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkU2l6ZS53aWR0aDtcbiAgfVxuICBzZXQgcHJlZmVycmVkV2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5wcmVmZXJyZWRTaXplLndpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5wcmVmZXJyZWRTaXplLndpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVmZXJyZWQgd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJyZWRXaWR0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwcmVmZXJyZWQgd2lkdGguXG4gICAqL1xuICBnZXRQcmVmZXJyZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRXaWR0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHJlZmVycmVkIHdpZHRoLlxuICAgKlxuICAgKiBVc2Uge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0aGUgd2lkdGggYmFzZWQgb24gdGhlIGhlaWdodCBhbmQgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVycmVkV2lkdGggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHdpZHRoLlxuICAgKi9cbiAgc2V0UHJlZmVycmVkV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZFdpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHByZWZlcnJlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmZXJyZWRTaXplLmhlaWdodDtcbiAgfVxuICBzZXQgcHJlZmVycmVkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJlZmVycmVkU2l6ZS5oZWlnaHQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnByZWZlcnJlZFNpemUuaGVpZ2h0ID0gdmFsdWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICAgICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVycmVkSGVpZ2h0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByZWZlcnJlZCBoZWlnaHQuXG4gICAqL1xuICBnZXRQcmVmZXJyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZmVycmVkSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVmZXJyZWQgaGVpZ2h0LlxuICAgKlxuICAgKiBVc2Uge0BsaW5rIFJlc2l6ZXIuQVVUT19TSVpFfSB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGJhc2VkIG9uIHRoZSB3aWR0aCBhbmQgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlZmVycmVkSGVpZ2h0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRQcmVmZXJyZWRIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVmZXJyZWQgc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFByZWZlcnJlZFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh0aGlzLnByZWZlcnJlZFNpemUud2lkdGggIT09IHdpZHRoIHx8IHRoaXMucHJlZmVycmVkU2l6ZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgdGhpcy5wcmVmZXJyZWRTaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgICB0aGlzLnJlc2l6YWJsZS5zZXRTaXplKHRoaXMuYmFzZVNpemUud2lkdGgsIHRoaXMuYmFzZVNpemUuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgZ2l2ZW4gcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtSZXNvbHV0aW9ufSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBjb3B5KHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnMgPSByZXNvbHV0aW9uLnNjYWxlO1xuICAgIHRoaXMuYmFzZVNpemUuc2V0KHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpO1xuICAgIHRoaXMucHJlZmVycmVkU2l6ZS5zZXQocmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCwgcmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gICAgdGhpcy5yZXNpemFibGUuc2V0U2l6ZSh0aGlzLmJhc2VTaXplLndpZHRoLCB0aGlzLmJhc2VTaXplLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGF1dG8gc2l6aW5nIGNvbnN0YW50LlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0aGUgd2lkdGggb3IgaGVpZ2h0IGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEFVVE9fU0laRSgpIHtcbiAgICByZXR1cm4gQVVUT19TSVpFO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9TZWxlY3Rpb24uanNcbnZhciBTZWxlY3Rpb24gPSBjbGFzcyBleHRlbmRzIFNldCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxPYmplY3QzRD59IFtpdGVyYWJsZV0gLSBBIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGlzIHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXllcj0xMF0gLSBBIGRlZGljYXRlZCByZW5kZXIgbGF5ZXIgZm9yIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpdGVyYWJsZSwgbGF5ZXIgPSAxMCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sID0gbGF5ZXI7XG4gICAgdGhpcy5leGNsdXNpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXRlcmFibGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5zZXQoaXRlcmFibGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sO1xuICB9XG4gIHNldCBsYXllcih2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IHRoaXMubDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiB0aGlzKSB7XG4gICAgICBvYmplY3QubGF5ZXJzLmRpc2FibGUoY3VycmVudExheWVyKTtcbiAgICAgIG9iamVjdC5sYXllcnMuZW5hYmxlKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5sID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVuZGVyIGxheWVyIGZvciBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBsYXllciBpcyAxMC4gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIHlvdXIgb3duIGN1c3RvbSBsYXllcnMsIHBsZWFzZSBjaGFuZ2UgaXQgYmVmb3JlIHJlbmRlcmluZyFcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxheWVyIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxheWVyLlxuICAgKi9cbiAgZ2V0TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlbmRlciBsYXllciBmb3Igc2VsZWN0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxheWVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBsYXllci4gUmFuZ2UgaXMgWzAsIDMxXS5cbiAgICovXG4gIHNldExheWVyKHZhbHVlKSB7XG4gICAgdGhpcy5sYXllciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzIHRoYXQgYXJlIGFkZGVkIHRvIHRoaXMgc2VsZWN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleGNsdXNpdmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBXaGV0aGVyIHRoaXMgc2VsZWN0aW9uIGlzIGV4Y2x1c2l2ZS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICovXG4gIGlzRXhjbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLmV4Y2x1c2l2ZTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbHMgd2hldGhlciBvYmplY3RzIHRoYXQgYXJlIGFkZGVkIHRvIHRoaXMgc2VsZWN0aW9uIHNob3VsZCBiZSByZW1vdmVkIGZyb20gYWxsIG90aGVyIGxheWVycy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGV4Y2x1c2l2ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBXaGV0aGVyIHRoaXMgc2VsZWN0aW9uIHNob3VsZCBiZSBleGNsdXNpdmUuXG4gICAqL1xuICBzZXRFeGNsdXNpdmUodmFsdWUpIHtcbiAgICB0aGlzLmV4Y2x1c2l2ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhpcyBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXI7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKGxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGlzIHNlbGVjdGlvbiBhbmQgYWRkcyB0aGUgZ2l2ZW4gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxPYmplY3QzRD59IG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZC5cbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBUaGlzIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldChvYmplY3RzKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIHRoaXMuYWRkKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3Ige0BsaW5rIGhhc30uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIEFuIG9iamVjdC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIDAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQsIG9yIC0xIG90aGVyd2lzZS5cbiAgICogQGRlcHJlY2F0ZWQgQWRkZWQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBpbmRleE9mKG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhvYmplY3QpID8gMCA6IC0xO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIG9iamVjdCB0byB0aGlzIHNlbGVjdGlvbi5cbiAgICpcbiAgICogSWYge0BsaW5rIGV4Y2x1c2l2ZX0gaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG9iamVjdCB3aWxsIGFsc28gYmUgcmVtb3ZlZCBmcm9tIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhpcyBzZWxlY3Rpb24uXG4gICAqL1xuICBhZGQob2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuZXhjbHVzaXZlKSB7XG4gICAgICBvYmplY3QubGF5ZXJzLnNldCh0aGlzLmxheWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0LmxheWVycy5lbmFibGUodGhpcy5sYXllcik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGQob2JqZWN0KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSBkZXNlbGVjdGVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGhhcyBzdWNjZXNzZnVsbHkgYmVlbiByZW1vdmVkIGZyb20gdGhpcyBzZWxlY3Rpb247IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGRlbGV0ZShvYmplY3QpIHtcbiAgICBpZiAodGhpcy5oYXMob2JqZWN0KSkge1xuICAgICAgb2JqZWN0LmxheWVycy5kaXNhYmxlKHRoaXMubGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKG9iamVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgb2JqZWN0IGZyb20gdGhlIHNlbGVjdGlvbi4gSWYgdGhlIG9iamVjdCBkb2Vzbid0IGV4aXN0IGl0J3MgYWRkZWQgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYWRkZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHRvZ2dsZShvYmplY3QpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLmhhcyhvYmplY3QpKSB7XG4gICAgICB0aGlzLmRlbGV0ZShvYmplY3QpO1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKG9iamVjdCk7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFsbCBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBlbmFibGVzIG9yIGRpc2FibGVzIHJlbmRlciBsYXllciAwIG9mIGFsbCBzZWxlY3RlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgLSBXaGV0aGVyIHRoZSBzZWxlY3RlZCBvYmplY3RzIHNob3VsZCBiZSB2aXNpYmxlLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoaXMgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0VmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgdGhpcykge1xuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgb2JqZWN0LmxheWVycy5lbmFibGUoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QubGF5ZXJzLmRpc2FibGUoMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9CbGVuZE1vZGUuanNcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciBhcyBFdmVudERpc3BhdGNoZXIyLCBVbmlmb3JtIGFzIFVuaWZvcm0yMyB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2FkZC5mcmFnXG52YXIgYWRkX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseCt5LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9hbHBoYS5mcmFnXG52YXIgYWxwaGFfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx5LG1pbih5LmEsb3BhY2l0eSkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9hdmVyYWdlLmZyYWdcbnZhciBhdmVyYWdlX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsKHgreSkqMC41LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9jb2xvci5mcmFnXG52YXIgY29sb3JfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgeEhTTD1SR0JUb0hTTCh4LnJnYik7dmVjMyB5SFNMPVJHQlRvSFNMKHkucmdiKTt2ZWMzIHo9SFNMVG9SR0IodmVjMyh5SFNMLnJnLHhIU0wuYikpO3JldHVybiB2ZWM0KG1peCh4LnJnYix6LG9wYWNpdHkpLHkuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2NvbG9yLWJ1cm4uZnJhZ1xudmFyIGNvbG9yX2J1cm5fZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgej1taXgoc3RlcCgwLjAseSkqKDEuMC1taW4odmVjNCgxLjApLCgxLjAteCkveSkpLHZlYzQoMS4wKSxzdGVwKDEuMCx4KSk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2NvbG9yLWRvZGdlLmZyYWdcbnZhciBjb2xvcl9kb2RnZV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjNCB6PXN0ZXAoMC4wLHgpKm1peChtaW4odmVjNCgxLjApLHgvbWF4KDEuMC15LDFlLTkpKSx2ZWM0KDEuMCksc3RlcCgxLjAseSkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9kYXJrZW4uZnJhZ1xudmFyIGRhcmtlbl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LG1pbih4LHkpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9kaWZmZXJlbmNlLmZyYWdcbnZhciBkaWZmZXJlbmNlX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsYWJzKHgteSksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2RpdmlkZS5mcmFnXG52YXIgZGl2aWRlX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseC9tYXgoeSwxZS0xMiksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2V4Y2x1c2lvbi5mcmFnXG52YXIgZXhjbHVzaW9uX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsKHgreS0yLjAqeCp5KSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvaGFyZC1saWdodC5mcmFnXG52YXIgaGFyZF9saWdodF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjNCBhPW1pbih4LDEuMCksYj1taW4oeSwxLjApO3ZlYzQgej1taXgoMi4wKmEqYiwxLjAtMi4wKigxLjAtYSkqKDEuMC1iKSxzdGVwKDAuNSx5KSk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2hhcmQtbWl4LmZyYWdcbnZhciBoYXJkX21peF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LHN0ZXAoMS4wLHgreSksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2h1ZS5mcmFnXG52YXIgaHVlX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeUhTTC5yLHhIU0wuZ2IpKTtyZXR1cm4gdmVjNChtaXgoeC5yZ2IseixvcGFjaXR5KSx5LmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9pbnZlcnQuZnJhZ1xudmFyIGludmVydF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LDEuMC15LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9pbnZlcnQtcmdiLmZyYWdcbnZhciBpbnZlcnRfcmdiX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseSooMS4wLXgpLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saWdodGVuLmZyYWdcbnZhciBsaWdodGVuX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsbWF4KHgseSksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2xpbmVhci1idXJuLmZyYWdcbnZhciBsaW5lYXJfYnVybl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LGNsYW1wKHkreC0xLjAsMC4wLDEuMCksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL2xpbmVhci1kb2RnZS5mcmFnXG52YXIgbGluZWFyX2RvZGdlX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgsbWluKHgreSwxLjApLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9saW5lYXItbGlnaHQuZnJhZ1xudmFyIGxpbmVhcl9saWdodF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LGNsYW1wKDIuMCp5K3gtMS4wLDAuMCwxLjApLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9sdW1pbm9zaXR5LmZyYWdcbnZhciBsdW1pbm9zaXR5X2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXt2ZWMzIHhIU0w9UkdCVG9IU0woeC5yZ2IpO3ZlYzMgeUhTTD1SR0JUb0hTTCh5LnJnYik7dmVjMyB6PUhTTFRvUkdCKHZlYzMoeEhTTC5yZyx5SFNMLmIpKTtyZXR1cm4gdmVjNChtaXgoeC5yZ2IseixvcGFjaXR5KSx5LmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9tdWx0aXBseS5mcmFnXG52YXIgbXVsdGlwbHlfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCx4Knksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL25lZ2F0aW9uLmZyYWdcbnZhciBuZWdhdGlvbl9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7cmV0dXJuIG1peCh4LDEuMC1hYnMoMS4wLXgteSksb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL25vcm1hbC5mcmFnXG52YXIgbm9ybWFsX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvb3ZlcmxheS5mcmFnXG52YXIgb3ZlcmxheV9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjNCB6PW1peCgyLjAqeSp4LDEuMC0yLjAqKDEuMC15KSooMS4wLXgpLHN0ZXAoMC41LHgpKTtyZXR1cm4gbWl4KHgseixvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvcGluLWxpZ2h0LmZyYWdcbnZhciBwaW5fbGlnaHRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgeTI9Mi4wKnk7dmVjNCB6PW1peChtaXgoeTIseCxzdGVwKDAuNSp4LHkpKSxtYXgodmVjNCgwLjApLHkyLTEuMCksc3RlcCh4LCh5Mi0xLjApKSk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3JlZmxlY3QuZnJhZ1xudmFyIHJlZmxlY3RfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgej1taXgobWluKHgqeC9tYXgoMS4wLXksMWUtMTIpLDEuMCkseSxzdGVwKDEuMCx5KSk7cmV0dXJuIG1peCh4LHosb3BhY2l0eSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3NhdHVyYXRpb24uZnJhZ1xudmFyIHNhdHVyYXRpb25fZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzMgeEhTTD1SR0JUb0hTTCh4LnJnYik7dmVjMyB5SFNMPVJHQlRvSFNMKHkucmdiKTt2ZWMzIHo9SFNMVG9SR0IodmVjMyh4SFNMLnIseUhTTC5nLHhIU0wuYikpO3JldHVybiB2ZWM0KG1peCh4LnJnYix6LG9wYWNpdHkpLHkuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9ibGVuZGluZy9nbHNsL3NjcmVlbi5mcmFnXG52YXIgc2NyZWVuX2RlZmF1bHQgPSBcInZlYzQgYmxlbmQoY29uc3QgaW4gdmVjNCB4LGNvbnN0IGluIHZlYzQgeSxjb25zdCBpbiBmbG9hdCBvcGFjaXR5KXtyZXR1cm4gbWl4KHgseCt5LW1pbih4KnksMS4wKSxvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc29mdC1saWdodC5mcmFnXG52YXIgc29mdF9saWdodF9kZWZhdWx0ID0gXCJ2ZWM0IGJsZW5kKGNvbnN0IGluIHZlYzQgeCxjb25zdCBpbiB2ZWM0IHksY29uc3QgaW4gZmxvYXQgb3BhY2l0eSl7dmVjNCB5Mj0yLjAqeTt2ZWM0IHc9c3RlcCgwLjUseSk7dmVjNCB6PW1peCh4LSgxLjAteTIpKngqKDEuMC14KSxtaXgoeCsoeTItMS4wKSooc3FydCh4KS14KSx4Kyh5Mi0xLjApKngqKCgxNi4wKngtMTIuMCkqeCszLjApLHcqKDEuMC1zdGVwKDAuMjUseCkpKSx3KTtyZXR1cm4gbWl4KHgseixvcGFjaXR5KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2JsZW5kaW5nL2dsc2wvc3JjLmZyYWdcbnZhciBzcmNfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiB5O31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC9zdWJ0cmFjdC5mcmFnXG52YXIgc3VidHJhY3RfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3JldHVybiBtaXgoeCxtYXgoeCt5LTEuMCwwLjApLG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvZ2xzbC92aXZpZC1saWdodC5mcmFnXG52YXIgdml2aWRfbGlnaHRfZGVmYXVsdCA9IFwidmVjNCBibGVuZChjb25zdCBpbiB2ZWM0IHgsY29uc3QgaW4gdmVjNCB5LGNvbnN0IGluIGZsb2F0IG9wYWNpdHkpe3ZlYzQgej1taXgobWF4KDEuMC1taW4oKDEuMC14KS8oMi4wKnkpLDEuMCksMC4wKSxtaW4oeC8oMi4wKigxLjAteSkpLDEuMCksc3RlcCgwLjUseSkpO3JldHVybiBtaXgoeCx6LG9wYWNpdHkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvYmxlbmRpbmcvQmxlbmRNb2RlLmpzXG52YXIgYmxlbmRGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtCbGVuZEZ1bmN0aW9uLkFERCwgYWRkX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5BTFBIQSwgYWxwaGFfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkFWRVJBR0UsIGF2ZXJhZ2VfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkNPTE9SLCBjb2xvcl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQ09MT1JfQlVSTiwgY29sb3JfYnVybl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uQ09MT1JfRE9ER0UsIGNvbG9yX2RvZGdlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5EQVJLRU4sIGRhcmtlbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uRElGRkVSRU5DRSwgZGlmZmVyZW5jZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uRElWSURFLCBkaXZpZGVfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkRTVCwgbnVsbF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkVYQ0xVU0lPTiwgZXhjbHVzaW9uX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5IQVJEX0xJR0hULCBoYXJkX2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5IQVJEX01JWCwgaGFyZF9taXhfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkhVRSwgaHVlX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5JTlZFUlQsIGludmVydF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uSU5WRVJUX1JHQiwgaW52ZXJ0X3JnYl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElHSFRFTiwgbGlnaHRlbl9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElORUFSX0JVUk4sIGxpbmVhcl9idXJuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5MSU5FQVJfRE9ER0UsIGxpbmVhcl9kb2RnZV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTElORUFSX0xJR0hULCBsaW5lYXJfbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLkxVTUlOT1NJVFksIGx1bWlub3NpdHlfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLk1VTFRJUExZLCBtdWx0aXBseV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uTkVHQVRJT04sIG5lZ2F0aW9uX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5OT1JNQUwsIG5vcm1hbF9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uT1ZFUkxBWSwgb3ZlcmxheV9kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uUElOX0xJR0hULCBwaW5fbGlnaHRfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlJFRkxFQ1QsIHJlZmxlY3RfZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNBVFVSQVRJT04sIHNhdHVyYXRpb25fZGVmYXVsdF0sXG4gIFtCbGVuZEZ1bmN0aW9uLlNDUkVFTiwgc2NyZWVuX2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TT0ZUX0xJR0hULCBzb2Z0X2xpZ2h0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5TUkMsIHNyY19kZWZhdWx0XSxcbiAgW0JsZW5kRnVuY3Rpb24uU1VCVFJBQ1QsIHN1YnRyYWN0X2RlZmF1bHRdLFxuICBbQmxlbmRGdW5jdGlvbi5WSVZJRF9MSUdIVCwgdml2aWRfbGlnaHRfZGVmYXVsdF1cbl0pO1xudmFyIEJsZW5kTW9kZSA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsZW5kIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gYmxlbmRGdW5jdGlvbiAtIFRoZSBibGVuZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHkgLSBUaGUgb3BhY2l0eSBvZiB0aGUgY29sb3IgdGhhdCB3aWxsIGJlIGJsZW5kZWQgd2l0aCB0aGUgYmFzZSBjb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsZW5kRnVuY3Rpb24sIG9wYWNpdHkgPSAxKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9ibGVuZEZ1bmN0aW9uID0gYmxlbmRGdW5jdGlvbjtcbiAgICB0aGlzLm9wYWNpdHkgPSBuZXcgVW5pZm9ybTIzKG9wYWNpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBvcGFjaXR5LlxuICAgKi9cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5LnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb3BhY2l0eS5cbiAgICovXG4gIHNldE9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLm9wYWNpdHkudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7QmxlbmRGdW5jdGlvbn1cbiAgICovXG4gIGdldCBibGVuZEZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ibGVuZEZ1bmN0aW9uO1xuICB9XG4gIHNldCBibGVuZEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYmxlbmRGdW5jdGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiY2hhbmdlXCIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRGdW5jdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCbGVuZEZ1bmN0aW9ufSBUaGUgYmxlbmQgZnVuY3Rpb24uXG4gICAqL1xuICBnZXRCbGVuZEZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsZW5kRnVuY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRGdW5jdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IHZhbHVlIC0gVGhlIGJsZW5kIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2V0QmxlbmRGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuYmxlbmRGdW5jdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBibGVuZCBmdW5jdGlvbiBzaGFkZXIgY29kZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgYmxlbmQgZnVuY3Rpb24gc2hhZGVyIGNvZGUuXG4gICAqL1xuICBnZXRTaGFkZXJDb2RlKCkge1xuICAgIHJldHVybiBibGVuZEZ1bmN0aW9ucy5nZXQodGhpcy5ibGVuZEZ1bmN0aW9uKTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQmxvb21FZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI0LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL0VmZmVjdC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxMywgRXZlbnREaXNwYXRjaGVyIGFzIEV2ZW50RGlzcGF0Y2hlcjMsIE1hdGVyaWFsIGFzIE1hdGVyaWFsMiwgVGV4dHVyZSBhcyBUZXh0dXJlMiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQxNCB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyMyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGlzIGVmZmVjdC4gRG9lc24ndCBoYXZlIHRvIGJlIHVuaXF1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U2hhZGVyIC0gVGhlIGZyYWdtZW50IHNoYWRlci4gVGhpcyBzaGFkZXIgaXMgcmVxdWlyZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7RWZmZWN0QXR0cmlidXRlfSBbb3B0aW9ucy5hdHRyaWJ1dGVzPUVmZmVjdEF0dHJpYnV0ZS5OT05FXSAtIFRoZSBlZmZlY3QgYXR0cmlidXRlcyB0aGF0IGRldGVybWluZSB0aGUgZXhlY3V0aW9uIHByaW9yaXR5IGFuZCByZXNvdXJjZSByZXF1aXJlbWVudHMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLk5PUk1BTF0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TWFwPFN0cmluZywgU3RyaW5nPn0gW29wdGlvbnMuZGVmaW5lc10gLSBDdXN0b20gcHJlcHJvY2Vzc29yIG1hY3JvIGRlZmluaXRpb25zLiBLZXlzIGFyZSBuYW1lcyBhbmQgdmFsdWVzIGFyZSBjb2RlLlxuICAgKiBAcGFyYW0ge01hcDxTdHJpbmcsIFVuaWZvcm0+fSBbb3B0aW9ucy51bmlmb3Jtc10gLSBDdXN0b20gc2hhZGVyIHVuaWZvcm1zLiBLZXlzIGFyZSBuYW1lcyBhbmQgdmFsdWVzIGFyZSB1bmlmb3Jtcy5cbiAgICogQHBhcmFtIHtTZXQ8V2ViR0xFeHRlbnNpb24+fSBbb3B0aW9ucy5leHRlbnNpb25zXSAtIFdlYkdMIGV4dGVuc2lvbnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52ZXJ0ZXhTaGFkZXI9bnVsbF0gLSBUaGUgdmVydGV4IHNoYWRlci4gTW9zdCBlZmZlY3RzIGRvbid0IG5lZWQgb25lLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgZnJhZ21lbnRTaGFkZXIsIHtcbiAgICBhdHRyaWJ1dGVzID0gRWZmZWN0QXR0cmlidXRlLk5PTkUsXG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uTk9STUFMLFxuICAgIGRlZmluZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHVuaWZvcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBleHRlbnNpb25zID0gbnVsbCxcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBudWxsXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcbiAgICB0aGlzLmRlZmluZXMgPSBkZWZpbmVzO1xuICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gbmV3IEJsZW5kTW9kZShibGVuZEZ1bmN0aW9uKTtcbiAgICB0aGlzLmJsZW5kTW9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4gdGhpcy5zZXRDaGFuZ2VkKCkpO1xuICAgIHRoaXMuX2lucHV0Q29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgIHRoaXMuX291dHB1dENvbG9yU3BhY2UgPSBOb0NvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBjb2xvciBzcGFjZS5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGdldCBpbnB1dENvbG9yU3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0Q29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0IGlucHV0Q29sb3JTcGFjZSh2YWx1ZSkge1xuICAgIHRoaXMuX2lucHV0Q29sb3JTcGFjZSA9IHZhbHVlO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGlmIHRoaXMgZWZmZWN0IGNvbnZlcnRzIHRoZSBpbnB1dCBjb2xvcnMgdG8gYSBkaWZmZXJlbnQgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvclNwYWNlfVxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBnZXQgb3V0cHV0Q29sb3JTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0Q29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0NvbG9yU3BhY2V9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0IG91dHB1dENvbG9yU3BhY2UodmFsdWUpIHtcbiAgICB0aGlzLl9vdXRwdXRDb2xvclNwYWNlID0gdmFsdWU7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1haW4gc2NlbmUuXG4gICAqXG4gICAqIEB0eXBlIHtTY2VuZX1cbiAgICovXG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBjYW1lcmEuXG4gICAqXG4gICAqIEB0eXBlIHtDYW1lcmF9XG4gICAqL1xuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbmFtZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmVwcm9jZXNzb3IgbWFjcm8gZGVmaW5pdGlvbnMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZWZpbmVzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hcDxTdHJpbmcsIFN0cmluZz59IFRoZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZ2V0RGVmaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlmb3JtcyBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHVuaWZvcm1zIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge01hcDxTdHJpbmcsIFVuaWZvcm0+fSBUaGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldFVuaWZvcm1zKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBXZWJHTCBleHRlbnNpb25zIHRoYXQgYXJlIHJlcXVpcmVkIGJ5IHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTZXQ8V2ViR0xFeHRlbnNpb24+fSBUaGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldEV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmxlbmQgbW9kZS5cbiAgICpcbiAgICogVGhlIHJlc3VsdCBvZiB0aGlzIGVmZmVjdCB3aWxsIGJlIGJsZW5kZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBlZmZlY3QgdXNpbmcgdGhpcyBibGVuZCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRNb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0JsZW5kTW9kZX0gVGhlIGJsZW5kIG1vZGUuXG4gICAqL1xuICBnZXRCbGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxlbmRNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZmZlY3QgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7RWZmZWN0QXR0cmlidXRlfSBUaGUgYXR0cmlidXRlcy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWZmZWN0IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEVmZmVjdHMgdGhhdCBoYXZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuIFNvbWUgYXR0cmlidXRlc1xuICAgKiBpbXBseSBhIGhpZ2hlciBwcmlvcml0eS5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0VmZmVjdEF0dHJpYnV0ZX0gYXR0cmlidXRlcyAtIFRoZSBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqL1xuICBnZXRGcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNoYWRlciAtIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAqL1xuICBzZXRGcmFnbWVudFNoYWRlcihmcmFnbWVudFNoYWRlcikge1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdmVydGV4IHNoYWRlci5cbiAgICovXG4gIGdldFZlcnRleFNoYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNoYWRlciAtIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgKi9cbiAgc2V0VmVydGV4U2hhZGVyKHZlcnRleFNoYWRlcikge1xuICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBJbmZvcm1zIHRoZSBhc3NvY2lhdGVkIHtAbGluayBFZmZlY3RQYXNzfSB0aGF0IHRoaXMgZWZmZWN0IHJlcXVpcmVzIGEgc2hhZGVyIHJlY29tcGlsYXRpb24uXG4gICAqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgY2hhbmdpbmcgbWFjcm9zIG9yIGV4dGVuc2lvbnMgYW5kIGFmdGVyIGFkZGluZy9yZW1vdmluZyB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0Q2hhbmdlZCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoeyB0eXBlOiBcImNoYW5nZVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXB0aCB0ZXh0dXJlLlxuICAgKlxuICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdXIgZWZmZWN0IHJlcXVpcmVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGRlcHRoIHRleHR1cmUgdGhhdCBpcyBib3VuZCB0byB0aGVcbiAgICogYXNzb2NpYXRlZCB7QGxpbmsgRWZmZWN0UGFzc30uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzEzKSB7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QgYnkgcGVyZm9ybWluZyBzdXBwb3J0aW5nIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUge0BsaW5rIEVmZmVjdFBhc3N9IHJpZ2h0IGJlZm9yZSB0aGUgbWFpbiBmdWxsc2NyZWVuIHJlbmRlciBvcGVyYXRpb24sIGV2ZW4gaWYgdGhlXG4gICAqIGJsZW5kIGZ1bmN0aW9uIGlzIHNldCB0byBgU0tJUGAuXG4gICAqXG4gICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IG5lZWQgdG8gdXBkYXRlIGN1c3RvbSB1bmlmb3JtcyBvciByZW5kZXIgYWRkaXRpb25hbCBvZmYtc2NyZWVuIHRleHR1cmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBiZSBpbmZvcm1lZCBhYm91dCB0aGUgc2l6ZSBvZiB0aGUgYmFja2J1ZmZlci9jYW52YXMuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBiZWZvcmUge0BsaW5rIGluaXRpYWxpemV9IGFuZCBldmVyeSB0aW1lIHRoZSBzaXplIG9mIHRoZSB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9IGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHtAbGluayBFZmZlY3RQYXNzfSBpcyBhZGRlZCB0byBhbiB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKiBAZXhhbXBsZSBpZighYWxwaGEgJiYgZnJhbWVCdWZmZXJUeXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlKSB7IHRoaXMubXlSZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7IH1cbiAgICovXG4gIGluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpIHtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBzaGFsbG93IHNlYXJjaCBmb3IgcHJvcGVydGllcyB0aGF0IGRlZmluZSBhIGRpc3Bvc2UgbWV0aG9kIGFuZCBkZWxldGVzIHRoZW0uXG4gICAqXG4gICAqIFRoZSB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gaXQgaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzW2tleV07XG4gICAgICBjb25zdCBpc0Rpc3Bvc2FibGUgPSBwcm9wZXJ0eSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyVGFyZ2V0MTQgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBNYXRlcmlhbDIgfHwgcHJvcGVydHkgaW5zdGFuY2VvZiBUZXh0dXJlMiB8fCBwcm9wZXJ0eSBpbnN0YW5jZW9mIFBhc3M7XG4gICAgICBpZiAoaXNEaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2Jsb29tLmZyYWdcbnZhciBibG9vbV9kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG1hcDtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdXYpO291dHB1dENvbG9yPXZlYzQodGV4ZWwucmdiKmludGVuc2l0eSx0ZXhlbC5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0Jsb29tRWZmZWN0LmpzXG52YXIgQmxvb21FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsb29tIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlVGhyZXNob2xkPTAuOV0gLSBUaGUgbHVtaW5hbmNlIHRocmVzaG9sZC4gUmFpc2UgdGhpcyB2YWx1ZSB0byBtYXNrIG91dCBkYXJrZXIgZWxlbWVudHMgaW4gdGhlIHNjZW5lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlU21vb3RoaW5nPTAuMDI1XSAtIENvbnRyb2xzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBsdW1pbmFuY2UgdGhyZXNob2xkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1pcG1hcEJsdXI9ZmFsc2VdIC0gRW5hYmxlcyBvciBkaXNhYmxlcyBtaXBtYXAgYmx1ci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gVGhlIGJsb29tIGludGVuc2l0eS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0wLjg1XSAtIFRoZSBibHVyIHJhZGl1cy4gT25seSBhcHBsaWVzIHRvIG1pcG1hcCBibHVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGV2ZWxzPThdIC0gVGhlIGFtb3VudCBvZiBNSVAgbGV2ZWxzLiBPbmx5IGFwcGxpZXMgdG8gbWlwbWFwIGJsdXIuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLkxBUkdFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgbWlwbWFwQmx1ciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIG1pcG1hcEJsdXIgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSBtaXBtYXBCbHVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gRGVwcmVjYXRlZC4gVXNlIG1pcG1hcEJsdXIgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgbHVtaW5hbmNlVGhyZXNob2xkID0gMC45LFxuICAgIGx1bWluYW5jZVNtb290aGluZyA9IDAuMDI1LFxuICAgIG1pcG1hcEJsdXIgPSBmYWxzZSxcbiAgICBpbnRlbnNpdHkgPSAxLFxuICAgIHJhZGl1cyA9IDAuODUsXG4gICAgbGV2ZWxzID0gOCxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5MQVJHRSxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQmxvb21FZmZlY3RcIiwgYmxvb21fZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTI0KG51bGwpXSxcbiAgICAgICAgW1wiaW50ZW5zaXR5XCIsIG5ldyBVbmlmb3JtMjQoaW50ZW5zaXR5KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNSgxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkJsb29tLlRhcmdldFwiO1xuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgS2F3YXNlQmx1clBhc3MoeyBrZXJuZWxTaXplIH0pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcyA9IG5ldyBMdW1pbmFuY2VQYXNzKHsgY29sb3JPdXRwdXQ6IHRydWUgfSk7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC50aHJlc2hvbGQgPSBsdW1pbmFuY2VUaHJlc2hvbGQ7XG4gICAgdGhpcy5sdW1pbmFuY2VNYXRlcmlhbC5zbW9vdGhpbmcgPSBsdW1pbmFuY2VTbW9vdGhpbmc7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcyA9IG5ldyBNaXBtYXBCbHVyUGFzcygpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA9IG1pcG1hcEJsdXI7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5sZXZlbHMgPSBsZXZlbHM7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSBtaXBtYXBCbHVyID8gdGhpcy5taXBtYXBCbHVyUGFzcy50ZXh0dXJlIDogdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgfVxuICAvKipcbiAgICogQSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIGludGVybWVkaWF0ZSByZXN1bHQgb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCA/IHRoaXMubWlwbWFwQmx1clBhc3MudGV4dHVyZSA6IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBibG9vbSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbHVtaW5hbmNlIHBhc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0x1bWluYW5jZVBhc3N9IFRoZSBsdW1pbmFuY2UgcGFzcy5cbiAgICovXG4gIGdldEx1bWluYW5jZVBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcztcbiAgfVxuICAvKipcbiAgICogVGhlIGx1bWluYW5jZSBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0x1bWluYW5jZU1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsdW1pbmFuY2VNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtMdW1pbmFuY2VNYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0THVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubHVtaW5hbmNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBFZmZlY3RQYXNzLmRpdGhlcmluZyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpdGhlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZGl0aGVyaW5nID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0aW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4odGhpcy5uYW1lLCBcImRpc3RpbmN0aW9uIHdhcyByZW1vdmVkXCIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHNldCBkaXN0aW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImludGVuc2l0eVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgaW50ZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsb29tIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbnRlbnNpdHkuXG4gICAqL1xuICBnZXRJbnRlbnNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibG9vbSBpbnRlbnNpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnRlbnNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIHNldEludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFJlc29sdXRpb25TY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLnNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgbmV3IHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24uc2NhbGUgPSBzY2FsZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgY29uc3QgbHVtaW5hbmNlUGFzcyA9IHRoaXMubHVtaW5hbmNlUGFzcztcbiAgICBpZiAobHVtaW5hbmNlUGFzcy5lbmFibGVkKSB7XG4gICAgICBsdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgaWYgKHRoaXMubWlwbWFwQmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLm1pcG1hcEJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgbHVtaW5hbmNlUGFzcy5yZW5kZXJUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIGx1bWluYW5jZVBhc3MucmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5taXBtYXBCbHVyUGFzcy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMubWlwbWFwQmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldEJhc2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpO1xuICAgIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbi5jb3B5KHJlc29sdXRpb24pO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubWlwbWFwQmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmx1bWluYW5jZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5taXBtYXBCbHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQm9rZWhFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI1IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvYm9rZWguZnJhZ1xudmFyIGJva2VoX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgZm9jdXM7dW5pZm9ybSBmbG9hdCBkb2Y7dW5pZm9ybSBmbG9hdCBhcGVydHVyZTt1bmlmb3JtIGZsb2F0IG1heEJsdXI7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzIgYXNwZWN0Q29ycmVjdGlvbj12ZWMyKDEuMCxhc3BlY3QpO1xcbiNpZmRlZiBQRVJTUEVDVElWRV9DQU1FUkFcXG5mbG9hdCB2aWV3Wj1wZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihkZXB0aCxjYW1lcmFOZWFyLGNhbWVyYUZhcik7ZmxvYXQgbGluZWFyRGVwdGg9dmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKHZpZXdaLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtcXG4jZWxzZVxcbmZsb2F0IGxpbmVhckRlcHRoPWRlcHRoO1xcbiNlbmRpZlxcbmZsb2F0IGZvY3VzTmVhcj1jbGFtcChmb2N1cy1kb2YsMC4wLDEuMCk7ZmxvYXQgZm9jdXNGYXI9Y2xhbXAoZm9jdXMrZG9mLDAuMCwxLjApO2Zsb2F0IGxvdz1zdGVwKGxpbmVhckRlcHRoLGZvY3VzTmVhcik7ZmxvYXQgaGlnaD1zdGVwKGZvY3VzRmFyLGxpbmVhckRlcHRoKTtmbG9hdCBmYWN0b3I9KGxpbmVhckRlcHRoLWZvY3VzTmVhcikqbG93KyhsaW5lYXJEZXB0aC1mb2N1c0ZhcikqaGlnaDt2ZWMyIGRvZkJsdXI9dmVjMihjbGFtcChmYWN0b3IqYXBlcnR1cmUsLW1heEJsdXIsbWF4Qmx1cikpO3ZlYzIgZG9mYmx1cjk9ZG9mQmx1ciowLjk7dmVjMiBkb2ZibHVyNz1kb2ZCbHVyKjAuNzt2ZWMyIGRvZmJsdXI0PWRvZkJsdXIqMC40O3ZlYzQgY29sb3I9aW5wdXRDb2xvcjtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMCwwLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4xNSwwLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywwLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuNDAsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMzcsLTAuMTUpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4xNSwtMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsLTAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mQmx1cik7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4xNSwwLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4zNywwLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjM3LC0wLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LC0wLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZCbHVyKTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKDAuMTUsLTAuMzcpKmFzcGVjdENvcnJlY3Rpb24pKmRvZkJsdXIpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4xNSwwLjM3KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyOSk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywwLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyOSk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjM3LC0wLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyOSk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4xNSwtMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMTUsMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4zNywwLjE1KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyOSk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4zNywtMC4xNSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4xNSwtMC4zNykqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjkpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjQwLDAuMCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLC0wLjQpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LDAuMjkpKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI3KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNyk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigtMC4yOSwtMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4wLDAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjcpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoMC4yOSwwLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjQsMC4wKSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjI5LC0wLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsLTAuNCkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuMjksMC4yOSkqYXNwZWN0Q29ycmVjdGlvbikqZG9mYmx1cjQpO2NvbG9yKz10ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdXYrKHZlYzIoLTAuNCwwLjApKmFzcGVjdENvcnJlY3Rpb24pKmRvZmJsdXI0KTtjb2xvcis9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2Kyh2ZWMyKC0wLjI5LC0wLjI5KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7Y29sb3IrPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix1disodmVjMigwLjAsMC40KSphc3BlY3RDb3JyZWN0aW9uKSpkb2ZibHVyNCk7b3V0cHV0Q29sb3I9Y29sb3IvNDEuMDt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0Jva2VoRWZmZWN0LmpzXG52YXIgQm9rZWhFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGJva2VoIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXM9MC41XSAtIFRoZSBmb2N1cyBkaXN0YW5jZSByYXRpbywgcmFuZ2luZyBmcm9tIDAuMCB0byAxLjAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kb2Y9MC4wMl0gLSBEZXB0aCBvZiBmaWVsZC4gQW4gYXJlYSBpbiBmcm9udCBvZiBhbmQgYmVoaW5kIHRoZSBmb2NhbCBwb2ludCB0aGF0IHN0aWxsIGFwcGVhcnMgc2hhcnAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hcGVydHVyZT0wLjAxNV0gLSBDYW1lcmEgYXBlcnR1cmUgc2NhbGUuIEJpZ2dlciB2YWx1ZXMgZm9yIHN0cm9uZ2VyIGJsdXIgYW5kIHNoYWxsb3dlciBkZXB0aCBvZiBmaWVsZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIFRoZSBtYXhpbXVtIGJsdXIgc3RyZW5ndGguXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBmb2N1cyA9IDAuNSxcbiAgICBkb2YgPSAwLjAyLFxuICAgIGFwZXJ0dXJlID0gMC4wMTUsXG4gICAgbWF4Qmx1ciA9IDFcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJCb2tlaEVmZmVjdFwiLCBib2tlaF9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkNPTlZPTFVUSU9OIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZm9jdXNcIiwgbmV3IFVuaWZvcm0yNShmb2N1cyldLFxuICAgICAgICBbXCJkb2ZcIiwgbmV3IFVuaWZvcm0yNShkb2YpXSxcbiAgICAgICAgW1wiYXBlcnR1cmVcIiwgbmV3IFVuaWZvcm0yNShhcGVydHVyZSldLFxuICAgICAgICBbXCJtYXhCbHVyXCIsIG5ldyBVbmlmb3JtMjUobWF4Qmx1cildXG4gICAgICBdKVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9CcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTI2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvYnJpZ2h0bmVzcy1jb250cmFzdC5mcmFnXG52YXIgYnJpZ2h0bmVzc19jb250cmFzdF9kZWZhdWx0ID0gXCJ1bmlmb3JtIGZsb2F0IGJyaWdodG5lc3M7dW5pZm9ybSBmbG9hdCBjb250cmFzdDt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYit2ZWMzKGJyaWdodG5lc3MtMC41KTtpZihjb250cmFzdD4wLjApe2NvbG9yLz12ZWMzKDEuMC1jb250cmFzdCk7fWVsc2V7Y29sb3IqPXZlYzMoMS4wK2NvbnRyYXN0KTt9b3V0cHV0Q29sb3I9dmVjNChjb2xvcit2ZWMzKDAuNSksaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0JyaWdodG5lc3NDb250cmFzdEVmZmVjdC5qc1xudmFyIEJyaWdodG5lc3NDb250cmFzdEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYnJpZ2h0bmVzcy9jb250cmFzdCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJyaWdodG5lc3M9MC4wXSAtIFRoZSBicmlnaHRuZXNzIGZhY3RvciwgcmFuZ2luZyBmcm9tIC0xIHRvIDEsIHdoZXJlIDAgbWVhbnMgbm8gY2hhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udHJhc3Q9MC4wXSAtIFRoZSBjb250cmFzdCBmYWN0b3IsIHJhbmdpbmcgZnJvbSAtMSB0byAxLCB3aGVyZSAwIG1lYW5zIG5vIGNoYW5nZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLCBicmlnaHRuZXNzID0gMCwgY29udHJhc3QgPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0XCIsIGJyaWdodG5lc3NfY29udHJhc3RfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImJyaWdodG5lc3NcIiwgbmV3IFVuaWZvcm0yNihicmlnaHRuZXNzKV0sXG4gICAgICAgIFtcImNvbnRyYXN0XCIsIG5ldyBVbmlmb3JtMjYoY29udHJhc3QpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmlucHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBicmlnaHRuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJyaWdodG5lc3ModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImJyaWdodG5lc3NcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgYnJpZ2h0bmVzcy5cbiAgICovXG4gIGdldEJyaWdodG5lc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJpZ2h0bmVzcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYnJpZ2h0bmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJyaWdodG5lc3MgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJyaWdodG5lc3MuXG4gICAqL1xuICBzZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5icmlnaHRuZXNzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb250cmFzdC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb250cmFzdFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgY29udHJhc3QodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImNvbnRyYXN0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRyYXN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29udHJhc3QgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBnZXRDb250cmFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cmFzdDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29udHJhc3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb250cmFzdCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgY29udHJhc3QuXG4gICAqL1xuICBzZXRDb250cmFzdCh2YWx1ZSkge1xuICAgIHRoaXMuY29udHJhc3QgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jb2xvci1hdmVyYWdlLmZyYWdcbnZhciBjb2xvcl9hdmVyYWdlX2RlZmF1bHQgPSBcInZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtvdXRwdXRDb2xvcj12ZWM0KHZlYzMoYXZlcmFnZShpbnB1dENvbG9yLnJnYikpLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9Db2xvckF2ZXJhZ2VFZmZlY3QuanNcbnZhciBDb2xvckF2ZXJhZ2VFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbG9yIGF2ZXJhZ2UgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsZW5kRnVuY3Rpb24pIHtcbiAgICBzdXBlcihcIkNvbG9yQXZlcmFnZUVmZmVjdFwiLCBjb2xvcl9hdmVyYWdlX2RlZmF1bHQsIHsgYmxlbmRGdW5jdGlvbiB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvQ29sb3JEZXB0aEVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMjcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jb2xvci1kZXB0aC5mcmFnXG52YXIgY29sb3JfZGVwdGhfZGVmYXVsdCA9IFwidW5pZm9ybSBmbG9hdCBmYWN0b3I7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe291dHB1dENvbG9yPXZlYzQoZmxvb3IoaW5wdXRDb2xvci5yZ2IqZmFjdG9yKzAuNSkvZmFjdG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9Db2xvckRlcHRoRWZmZWN0LmpzXG52YXIgQ29sb3JEZXB0aEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29sb3IgZGVwdGggZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaXRzPTE2XSAtIFRoZSBjb2xvciBiaXQgZGVwdGguXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24sIGJpdHMgPSAxNiB9ID0ge30pIHtcbiAgICBzdXBlcihcIkNvbG9yRGVwdGhFZmZlY3RcIiwgY29sb3JfZGVwdGhfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImZhY3RvclwiLCBuZXcgVW5pZm9ybTI3KDEpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmJpdHMgPSAwO1xuICAgIHRoaXMuYml0RGVwdGggPSBiaXRzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdmlydHVhbCBhbW91bnQgb2YgY29sb3IgYml0cy5cbiAgICpcbiAgICogRWFjaCBjb2xvciBjaGFubmVsIGVmZmVjdGl2ZWx5IHVzZXMgYSBmb3VydGggb2YgdGhlIHRvdGFsIGFtb3VudCBvZiBiaXRzLiBBbHBoYSByZW1haW5zIHVuYWZmZWN0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYml0RGVwdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0cztcbiAgfVxuICBzZXQgYml0RGVwdGgodmFsdWUpIHtcbiAgICB0aGlzLmJpdHMgPSB2YWx1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImZhY3RvclwiKS52YWx1ZSA9IE1hdGgucG93KDIsIHZhbHVlIC8gMyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29sb3IgYml0IGRlcHRoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiaXQgZGVwdGguXG4gICAqL1xuICBnZXRCaXREZXB0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5iaXREZXB0aDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmlydHVhbCBhbW91bnQgb2YgY29sb3IgYml0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGJpdCBkZXB0aC5cbiAgICovXG4gIHNldEJpdERlcHRoKHZhbHVlKSB7XG4gICAgdGhpcy5iaXREZXB0aCA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9DaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0yOCwgVmVjdG9yMiBhcyBWZWN0b3IyMTggfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9jaHJvbWF0aWMtYWJlcnJhdGlvbi5mcmFnXG52YXIgY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdCA9IFwiI2lmZGVmIFJBRElBTF9NT0RVTEFUSU9OXFxudW5pZm9ybSBmbG9hdCBtb2R1bGF0aW9uT2Zmc2V0O1xcbiNlbmRpZlxcbnZhcnlpbmcgZmxvYXQgdkFjdGl2ZTt2YXJ5aW5nIHZlYzIgdlV2Ujt2YXJ5aW5nIHZlYzIgdlV2Qjt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMiByYT1pbnB1dENvbG9yLnJhO3ZlYzIgYmE9aW5wdXRDb2xvci5iYTtcXG4jaWZkZWYgUkFESUFMX01PRFVMQVRJT05cXG5jb25zdCB2ZWMyIGNlbnRlcj12ZWMyKDAuNSk7ZmxvYXQgZD1kaXN0YW5jZSh1dixjZW50ZXIpKjIuMDtkPW1heChkLW1vZHVsYXRpb25PZmZzZXQsMC4wKTtpZih2QWN0aXZlPjAuMCYmZD4wLjApe3JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcixtaXgodXYsdlV2UixkKSkucmE7YmE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLG1peCh1dix2VXZCLGQpKS5iYTt9XFxuI2Vsc2VcXG5pZih2QWN0aXZlPjAuMCl7cmE9dGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdlIpLnJhO2JhPXRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZCKS5iYTt9XFxuI2VuZGlmXFxub3V0cHV0Q29sb3I9dmVjNChyYS54LGlucHV0Q29sb3IuZyxiYS54LG1heChtYXgocmEueSxiYS55KSxpbnB1dENvbG9yLmEpKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvY2hyb21hdGljLWFiZXJyYXRpb24udmVydFxudmFyIGNocm9tYXRpY19hYmVycmF0aW9uX2RlZmF1bHQyID0gXCJ1bmlmb3JtIHZlYzIgb2Zmc2V0O3ZhcnlpbmcgZmxvYXQgdkFjdGl2ZTt2YXJ5aW5nIHZlYzIgdlV2Ujt2YXJ5aW5nIHZlYzIgdlV2Qjt2b2lkIG1haW5TdXBwb3J0KGNvbnN0IGluIHZlYzIgdXYpe3ZlYzIgc2hpZnQ9b2Zmc2V0KnZlYzIoMS4wLGFzcGVjdCk7dkFjdGl2ZT0oc2hpZnQueCE9MC4wfHxzaGlmdC55IT0wLjApPzEuMDowLjA7dlV2Uj11ditzaGlmdDt2VXZCPXV2LXNoaWZ0O31cIjtcblxuLy8gc3JjL2VmZmVjdHMvQ2hyb21hdGljQWJlcnJhdGlvbkVmZmVjdC5qc1xudmFyIENocm9tYXRpY0FiZXJyYXRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNocm9tYXRpYyBhYmVycmF0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY29sb3Igb2Zmc2V0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhZGlhbE1vZHVsYXRpb249ZmFsc2VdIC0gV2hldGhlciB0aGUgZWZmZWN0IHNob3VsZCBiZSBtb2R1bGF0ZWQgd2l0aCBhIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1vZHVsYXRpb25PZmZzZXQ9MC4xNV0gLSBUaGUgbW9kdWxhdGlvbiBvZmZzZXQuIE9ubHkgYXBwbGllcyBpZiBgcmFkaWFsTW9kdWxhdGlvbmAgaXMgZW5hYmxlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvZmZzZXQgPSBuZXcgVmVjdG9yMjE4KDFlLTMsIDVlLTQpLFxuICAgIHJhZGlhbE1vZHVsYXRpb24gPSBmYWxzZSxcbiAgICBtb2R1bGF0aW9uT2Zmc2V0ID0gMC4xNVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkNocm9tYXRpY0FiZXJyYXRpb25FZmZlY3RcIiwgY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0MixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm9mZnNldFwiLCBuZXcgVW5pZm9ybTI4KG9mZnNldCldLFxuICAgICAgICBbXCJtb2R1bGF0aW9uT2Zmc2V0XCIsIG5ldyBVbmlmb3JtMjgobW9kdWxhdGlvbk9mZnNldCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMucmFkaWFsTW9kdWxhdGlvbiA9IHJhZGlhbE1vZHVsYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZmZzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWU7XG4gIH1cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwib2Zmc2V0XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHJhZGlhbCBtb2R1bGF0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIFdoZW4gZW5hYmxlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIHdlYWtlciBpbiB0aGUgbWlkZGxlIGFuZCBzdHJvbmdlciB0b3dhcmRzIHRoZSBzY3JlZW4gZWRnZXMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHJhZGlhbE1vZHVsYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJSQURJQUxfTU9EVUxBVElPTlwiKTtcbiAgfVxuICBzZXQgcmFkaWFsTW9kdWxhdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlJBRElBTF9NT0RVTEFUSU9OXCIsIFwiMVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlJBRElBTF9NT0RVTEFUSU9OXCIpO1xuICAgIH1cbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1vZHVsYXRpb24gb2Zmc2V0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vZHVsYXRpb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibW9kdWxhdGlvbk9mZnNldFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbW9kdWxhdGlvbk9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibW9kdWxhdGlvbk9mZnNldFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2xvciBvZmZzZXQgdmVjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9IFRoZSBvZmZzZXQuXG4gICAqL1xuICBnZXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xvciBvZmZzZXQgdmVjdG9yLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kZXB0aC5mcmFnXG52YXIgZGVwdGhfZGVmYXVsdCA9IFwidm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe1xcbiNpZmRlZiBJTlZFUlRFRFxcbnZlYzMgY29sb3I9dmVjMygxLjAtZGVwdGgpO1xcbiNlbHNlXFxudmVjMyBjb2xvcj12ZWMzKGRlcHRoKTtcXG4jZW5kaWZcXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9EZXB0aEVmZmVjdC5qc1xudmFyIERlcHRoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnZlcnRlZD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBkZXB0aCBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQywgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRlcHRoRWZmZWN0XCIsIGRlcHRoX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuREVQVEhcbiAgICB9KTtcbiAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRlcHRoIHNob3VsZCBiZSBpbnZlcnRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJJTlZFUlRFRFwiKTtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pbnZlcnRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiSU5WRVJURURcIiwgXCIxXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIklOVkVSVEVEXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVuZGVyZWQgZGVwdGggaXMgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBkZXB0aCBpcyBpbnZlcnRlZC5cbiAgICovXG4gIGlzSW52ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52ZXJ0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZGVwdGggaW52ZXJzaW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW52ZXJ0ZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgZGVwdGggc2hvdWxkIGJlIGludmVydGVkLlxuICAgKi9cbiAgc2V0SW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLmludmVydGVkID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0RlcHRoT2ZGaWVsZEVmZmVjdC5qc1xuaW1wb3J0IHsgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxNCwgVW5pZm9ybSBhcyBVbmlmb3JtMjksIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTEyLCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZGVwdGgtb2YtZmllbGQuZnJhZ1xudmFyIGRlcHRoX29mX2ZpZWxkX2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbmVhckNvbG9yQnVmZmVyO3VuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgZmFyQ29sb3JCdWZmZXI7XFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG5lYXJDb2xvckJ1ZmZlcjt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGZhckNvbG9yQnVmZmVyO1xcbiNlbmRpZlxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbmVhckNvQ0J1ZmZlcjt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGZhckNvQ0J1ZmZlcjt1bmlmb3JtIGZsb2F0IHNjYWxlO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LGNvbnN0IGluIGZsb2F0IGRlcHRoLG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWM0IGNvbG9yTmVhcj10ZXh0dXJlMkQobmVhckNvbG9yQnVmZmVyLHV2KTt2ZWM0IGNvbG9yRmFyPXRleHR1cmUyRChmYXJDb2xvckJ1ZmZlcix1dik7XFxuI2lmIE1BU0tfRlVOQ1RJT04gPT0gMVxcbnZlYzIgY29jTmVhckZhcj12ZWMyKHRleHR1cmUyRChuZWFyQ29DQnVmZmVyLHV2KS5yLGNvbG9yRmFyLmEpO2NvY05lYXJGYXIueD1taW4oY29jTmVhckZhci54KnNjYWxlLDEuMCk7XFxuI2Vsc2VcXG52ZWMyIGNvY05lYXJGYXI9dmVjMih0ZXh0dXJlMkQobmVhckNvQ0J1ZmZlcix1dikucix0ZXh0dXJlMkQoZmFyQ29DQnVmZmVyLHV2KS5nKTtjb2NOZWFyRmFyPW1pbihjb2NOZWFyRmFyKnNjYWxlLDEuMCk7XFxuI2VuZGlmXFxudmVjNCByZXN1bHQ9aW5wdXRDb2xvciooMS4wLWNvY05lYXJGYXIueSkrY29sb3JGYXI7cmVzdWx0PW1peChyZXN1bHQsY29sb3JOZWFyLGNvY05lYXJGYXIueCk7b3V0cHV0Q29sb3I9cmVzdWx0O31cIjtcblxuLy8gc3JjL2VmZmVjdHMvRGVwdGhPZkZpZWxkRWZmZWN0LmpzXG52YXIgRGVwdGhPZkZpZWxkRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBkZXB0aCBvZiBmaWVsZCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkRm9jdXNEaXN0YW5jZV0gLSBUaGUgZm9jdXMgZGlzdGFuY2UgaW4gd29ybGQgdW5pdHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZEZvY3VzUmFuZ2VdIC0gVGhlIGZvY3VzIGRpc3RhbmNlIGluIHdvcmxkIHVuaXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXNEaXN0YW5jZT0wLjBdIC0gVGhlIG5vcm1hbGl6ZWQgZm9jdXMgZGlzdGFuY2UuIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1c1JhbmdlPTAuMV0gLSBUaGUgZm9jdXMgcmFuZ2UuIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2NhbExlbmd0aD0wLjFdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJva2VoU2NhbGU9MS4wXSAtIFRoZSBzY2FsZSBvZiB0aGUgYm9rZWggYmx1ci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwge1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgd29ybGRGb2N1c0Rpc3RhbmNlLFxuICAgIHdvcmxkRm9jdXNSYW5nZSxcbiAgICBmb2N1c0Rpc3RhbmNlID0gMCxcbiAgICBmb2NhbExlbmd0aCA9IDAuMSxcbiAgICBmb2N1c1JhbmdlID0gZm9jYWxMZW5ndGgsXG4gICAgYm9rZWhTY2FsZSA9IDEsXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMSxcbiAgICB3aWR0aCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIGhlaWdodCA9IFJlc29sdXRpb24uQVVUT19TSVpFLFxuICAgIHJlc29sdXRpb25YID0gd2lkdGgsXG4gICAgcmVzb2x1dGlvblkgPSBoZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJEZXB0aE9mRmllbGRFZmZlY3RcIiwgZGVwdGhfb2ZfZmllbGRfZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm5lYXJDb2xvckJ1ZmZlclwiLCBuZXcgVW5pZm9ybTI5KG51bGwpXSxcbiAgICAgICAgW1wiZmFyQ29sb3JCdWZmZXJcIiwgbmV3IFVuaWZvcm0yOShudWxsKV0sXG4gICAgICAgIFtcIm5lYXJDb0NCdWZmZXJcIiwgbmV3IFVuaWZvcm0yOShudWxsKV0sXG4gICAgICAgIFtcImZhckNvQ0J1ZmZlclwiLCBuZXcgVW5pZm9ybTI5KG51bGwpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm0yOSgxKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxNigxLCAxLCB7IGRlcHRoQnVmZmVyOiBmYWxzZSB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkRvRi5JbnRlcm1lZGlhdGVcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZCA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS5uYW1lID0gXCJEb0YuTWFza2VkLkZhclwiO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TmVhciA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXROZWFyLnRleHR1cmUubmFtZSA9IFwiRG9GLkJva2VoLk5lYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm5lYXJDb2xvckJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0TmVhci50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RmFyID0gdGhpcy5yZW5kZXJUYXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEZhci50ZXh0dXJlLm5hbWUgPSBcIkRvRi5Cb2tlaC5GYXJcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImZhckNvbG9yQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRGYXIudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQyA9IHRoaXMucmVuZGVyVGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZS5uYW1lID0gXCJEb0YuQ29DXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJmYXJDb0NCdWZmZXJcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLmNsb25lKCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmUubmFtZSA9IFwiRG9GLkNvQy5CbHVycmVkXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJuZWFyQ29DQnVmZmVyXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5jb2NQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IENpcmNsZU9mQ29uZnVzaW9uTWF0ZXJpYWwoY2FtZXJhKSk7XG4gICAgY29uc3QgY29jTWF0ZXJpYWwgPSB0aGlzLmNvY01hdGVyaWFsO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzRGlzdGFuY2UgPSBmb2N1c0Rpc3RhbmNlO1xuICAgIGNvY01hdGVyaWFsLmZvY3VzUmFuZ2UgPSBmb2N1c1JhbmdlO1xuICAgIGlmICh3b3JsZEZvY3VzRGlzdGFuY2UgIT09IHZvaWQgMCkge1xuICAgICAgY29jTWF0ZXJpYWwud29ybGRGb2N1c0Rpc3RhbmNlID0gd29ybGRGb2N1c0Rpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAod29ybGRGb2N1c1JhbmdlICE9PSB2b2lkIDApIHtcbiAgICAgIGNvY01hdGVyaWFsLndvcmxkRm9jdXNSYW5nZSA9IHdvcmxkRm9jdXNSYW5nZTtcbiAgICB9XG4gICAgdGhpcy5ibHVyUGFzcyA9IG5ldyBLYXdhc2VCbHVyUGFzcyh7IHJlc29sdXRpb25TY2FsZSwgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCBrZXJuZWxTaXplOiBLZXJuZWxTaXplLk1FRElVTSB9KTtcbiAgICB0aGlzLm1hc2tQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IE1hc2tNYXRlcmlhbCh0aGlzLnJlbmRlclRhcmdldENvQy50ZXh0dXJlKSk7XG4gICAgY29uc3QgbWFza01hdGVyaWFsID0gdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gICAgbWFza01hdGVyaWFsLmNvbG9yQ2hhbm5lbCA9IENvbG9yQ2hhbm5lbC5HUkVFTjtcbiAgICB0aGlzLm1hc2tGdW5jdGlvbiA9IE1hc2tGdW5jdGlvbi5NVUxUSVBMWV9SR0I7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKGZhbHNlLCB0cnVlKSk7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuY29jQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBCb2tlaE1hdGVyaWFsKHRydWUsIHRydWUpKTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5jb2NCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQudGV4dHVyZTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQm9rZWhNYXRlcmlhbChmYWxzZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyQmFzZVBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy5ib2tlaEZhckZpbGxQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IEJva2VoTWF0ZXJpYWwodHJ1ZSwgZmFsc2UpKTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLmNvY0J1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0Q29DLnRleHR1cmU7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24gPSBuZXcgUmVzb2x1dGlvbih0aGlzLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIHJlc29sdXRpb25TY2FsZSk7XG4gICAgcmVzb2x1dGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB0aGlzLnNldFNpemUocmVzb2x1dGlvbi5iYXNlV2lkdGgsIHJlc29sdXRpb24uYmFzZUhlaWdodCkpO1xuICAgIHRoaXMuYm9rZWhTY2FsZSA9IGJva2VoU2NhbGU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgY29jVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRDb0MudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIG1hc2sgZnVuY3Rpb24uIERlZmF1bHQgaXMgYE1VTFRJUExZX1JHQmAuXG4gICAqXG4gICAqIEB0eXBlIHtNYXNrRnVuY3Rpb259XG4gICAqL1xuICBnZXQgbWFza0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5tYXNrRnVuY3Rpb247XG4gIH1cbiAgc2V0IG1hc2tGdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hc2tGdW5jdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJNQVNLX0ZVTkNUSU9OXCIsIHZhbHVlLnRvRml4ZWQoMCkpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwubWFza0Z1bmN0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjb2NNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNpcmNsZSBvZiBjb25mdXNpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjb2NNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBjaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmNvY01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaXJjbGUgb2YgY29uZnVzaW9uIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29jTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2NNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFzcyB0aGF0IGJsdXJzIHRoZSBmb3JlZ3JvdW5kIENvQyBidWZmZXIgdG8gc29mdGVuIGVkZ2VzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MgaW5zdGVhZC5cbiAgICogQHJldHVybiB7S2F3YXNlQmx1clBhc3N9IFRoZSBibHVyIHBhc3MuXG4gICAqL1xuICBnZXRCbHVyUGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbiBzZXR0aW5ncy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7UmVzb2x1dGlvbn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJva2VoU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGJva2VoU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNjYWxlID0gdmFsdWU7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zY2FsZSA9IHZhbHVlO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2NhbGUgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zdHJlbmd0aCA9IHZhbHVlO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2NhbGVcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBib2tlaCBzY2FsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJva2VoU2NhbGUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc2NhbGUuXG4gICAqL1xuICBnZXRCb2tlaFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmJva2VoU2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJva2VoIHNjYWxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYm9rZWhTY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2NhbGUuXG4gICAqL1xuICBzZXRCb2tlaFNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5ib2tlaFNjYWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXV0byBmb2N1cyB0YXJnZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0YXJnZXQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yM30gVGhlIHRhcmdldC5cbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF1dG8gZm9jdXMgdGFyZ2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGFyZ2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdmFsdWUgLSBUaGUgdGFyZ2V0LlxuICAgKi9cbiAgc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgdGhpcy50YXJnZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZm9jdXMgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB0YXJnZXQgLSBUaGUgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBub3JtYWxpemVkIGZvY3VzIGRpc3RhbmNlLlxuICAgKi9cbiAgY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSh0YXJnZXQpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldCk7XG4gICAgcmV0dXJuIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCgtZGlzdGFuY2UsIGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTQpIHtcbiAgICB0aGlzLmNvY01hdGVyaWFsLmRlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuY29jTWF0ZXJpYWwuZGVwdGhQYWNraW5nID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRDb0MgPSB0aGlzLnJlbmRlclRhcmdldENvQztcbiAgICBjb25zdCByZW5kZXJUYXJnZXRDb0NCbHVycmVkID0gdGhpcy5yZW5kZXJUYXJnZXRDb0NCbHVycmVkO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldE1hc2tlZCA9IHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkO1xuICAgIGlmICh0aGlzLnRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZUZvY3VzRGlzdGFuY2UodGhpcy50YXJnZXQpO1xuICAgICAgdGhpcy5jb2NNYXRlcmlhbC5mb2N1c0Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfVxuICAgIHRoaXMuY29jUGFzcy5yZW5kZXIocmVuZGVyZXIsIG51bGwsIHJlbmRlclRhcmdldENvQyk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldENvQywgcmVuZGVyVGFyZ2V0Q29DQmx1cnJlZCk7XG4gICAgdGhpcy5tYXNrUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCByZW5kZXJUYXJnZXRNYXNrZWQpO1xuICAgIHRoaXMuYm9rZWhGYXJCYXNlUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldE1hc2tlZCwgcmVuZGVyVGFyZ2V0KTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIHRoaXMucmVuZGVyVGFyZ2V0RmFyKTtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldCk7XG4gICAgdGhpcy5ib2tlaE5lYXJGaWxsUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgdGhpcy5yZW5kZXJUYXJnZXROZWFyKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuY29jUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuYmx1clBhc3Muc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLm1hc2tQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRGYXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE5lYXIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldENvQ0JsdXJyZWQuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLmJva2VoTmVhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuYm9rZWhOZWFyRmlsbFBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5ib2tlaEZhckJhc2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuYm9rZWhGYXJGaWxsUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5jb2NQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMubWFza1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ib2tlaE5lYXJCYXNlUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJva2VoTmVhckZpbGxQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuYm9rZWhGYXJCYXNlUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICB0aGlzLmJva2VoRmFyRmlsbFBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgVW5zaWduZWRCeXRlVHlwZTEyKTtcbiAgICBpZiAocmVuZGVyZXIuY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpIHtcbiAgICAgIHRoaXMuY29jUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVmaW5lcy5MT0dfREVQVEggPSBcIjFcIjtcbiAgICB9XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgPSBmcmFtZUJ1ZmZlclR5cGU7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldE5lYXIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRGYXIudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0TmVhci50ZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMucmVuZGVyVGFyZ2V0RmFyLnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvRG90U2NyZWVuRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zMCwgVmVjdG9yMiBhcyBWZWN0b3IyMTkgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9kb3Qtc2NyZWVuLmZyYWdcbnZhciBkb3Rfc2NyZWVuX2RlZmF1bHQgPSBcInVuaWZvcm0gdmVjMiBhbmdsZTt1bmlmb3JtIGZsb2F0IHNjYWxlO2Zsb2F0IHBhdHRlcm4oY29uc3QgaW4gdmVjMiB1dil7dmVjMiBwb2ludD1zY2FsZSp2ZWMyKGRvdChhbmdsZS55eCx2ZWMyKHV2LngsLXV2LnkpKSxkb3QoYW5nbGUsdXYpKTtyZXR1cm4oc2luKHBvaW50LngpKnNpbihwb2ludC55KSkqNC4wO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7dmVjMyBjb2xvcj12ZWMzKGlucHV0Q29sb3IucmdiKjEwLjAtNS4wK3BhdHRlcm4odXYqcmVzb2x1dGlvbikpO291dHB1dENvbG9yPXZlYzQoY29sb3IsaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0RvdFNjcmVlbkVmZmVjdC5qc1xudmFyIERvdFNjcmVlbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZG90IHNjcmVlbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTEuNTddIC0gVGhlIGFuZ2xlIG9mIHRoZSBkb3QgcGF0dGVybi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIGRvdCBwYXR0ZXJuLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCBhbmdsZSA9IE1hdGguUEkgKiAwLjUsIHNjYWxlID0gMSB9ID0ge30pIHtcbiAgICBzdXBlcihcIkRvdFNjcmVlbkVmZmVjdFwiLCBkb3Rfc2NyZWVuX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJhbmdsZVwiLCBuZXcgVW5pZm9ybTMwKG5ldyBWZWN0b3IyMTkoKSldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTMwKHNjYWxlKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW5nbGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLnVuaWZvcm1zLmdldChcImFuZ2xlXCIpLnZhbHVlLnkpO1xuICB9XG4gIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW5nbGVcIikudmFsdWUuc2V0KE1hdGguc2luKHZhbHVlKSwgTWF0aC5jb3ModmFsdWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0dGVybiBhbmdsZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFuZ2xlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgc2V0QW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLmFuZ2xlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJzY2FsZVwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvZnhhYS5mcmFnXG52YXIgZnhhYV9kZWZhdWx0ID0gXCIjaWYgVEhSRUVfUkVWSVNJT04gPCAxNDNcXG4jZGVmaW5lIGx1bWluYW5jZSh2KSBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKHYpXFxuI2VuZGlmXFxuI2RlZmluZSBRVUFMSVRZKHEpICgocSkgPCA1ID8gMS4wIDogKChxKSA+IDUgPyAoKHEpIDwgMTAgPyAyLjAgOiAoKHEpIDwgMTEgPyA0LjAgOiA4LjApKSA6IDEuNSkpXFxuI2RlZmluZSBPTkVfT1ZFUl9UV0VMVkUgMC4wODMzMzMzMzMzMzMzMzMzM1xcbnZhcnlpbmcgdmVjMiB2VXZEb3duO3ZhcnlpbmcgdmVjMiB2VXZVcDt2YXJ5aW5nIHZlYzIgdlV2TGVmdDt2YXJ5aW5nIHZlYzIgdlV2UmlnaHQ7dmFyeWluZyB2ZWMyIHZVdkRvd25MZWZ0O3ZhcnlpbmcgdmVjMiB2VXZVcFJpZ2h0O3ZhcnlpbmcgdmVjMiB2VXZVcExlZnQ7dmFyeWluZyB2ZWMyIHZVdkRvd25SaWdodDt2ZWM0IGZ4YWEoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYpe2Zsb2F0IGx1bWFDZW50ZXI9bHVtaW5hbmNlKGlucHV0Q29sb3IucmdiKTtmbG9hdCBsdW1hRG93bj1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkRvd24pLnJnYik7ZmxvYXQgbHVtYVVwPWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2VXApLnJnYik7ZmxvYXQgbHVtYUxlZnQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZMZWZ0KS5yZ2IpO2Zsb2F0IGx1bWFSaWdodD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdlJpZ2h0KS5yZ2IpO2Zsb2F0IGx1bWFNaW49bWluKGx1bWFDZW50ZXIsbWluKG1pbihsdW1hRG93bixsdW1hVXApLG1pbihsdW1hTGVmdCxsdW1hUmlnaHQpKSk7ZmxvYXQgbHVtYU1heD1tYXgobHVtYUNlbnRlcixtYXgobWF4KGx1bWFEb3duLGx1bWFVcCksbWF4KGx1bWFMZWZ0LGx1bWFSaWdodCkpKTtmbG9hdCBsdW1hUmFuZ2U9bHVtYU1heC1sdW1hTWluO2lmKGx1bWFSYW5nZTxtYXgoRURHRV9USFJFU0hPTERfTUlOLGx1bWFNYXgqRURHRV9USFJFU0hPTERfTUFYKSl7cmV0dXJuIGlucHV0Q29sb3I7fWZsb2F0IGx1bWFEb3duTGVmdD1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHZVdkRvd25MZWZ0KS5yZ2IpO2Zsb2F0IGx1bWFVcFJpZ2h0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2VXBSaWdodCkucmdiKTtmbG9hdCBsdW1hVXBMZWZ0PWx1bWluYW5jZSh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsdlV2VXBMZWZ0KS5yZ2IpO2Zsb2F0IGx1bWFEb3duUmlnaHQ9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix2VXZEb3duUmlnaHQpLnJnYik7ZmxvYXQgbHVtYURvd25VcD1sdW1hRG93bitsdW1hVXA7ZmxvYXQgbHVtYUxlZnRSaWdodD1sdW1hTGVmdCtsdW1hUmlnaHQ7ZmxvYXQgbHVtYUxlZnRDb3JuZXJzPWx1bWFEb3duTGVmdCtsdW1hVXBMZWZ0O2Zsb2F0IGx1bWFEb3duQ29ybmVycz1sdW1hRG93bkxlZnQrbHVtYURvd25SaWdodDtmbG9hdCBsdW1hUmlnaHRDb3JuZXJzPWx1bWFEb3duUmlnaHQrbHVtYVVwUmlnaHQ7ZmxvYXQgbHVtYVVwQ29ybmVycz1sdW1hVXBSaWdodCtsdW1hVXBMZWZ0O2Zsb2F0IGVkZ2VIb3Jpem9udGFsPShhYnMoLTIuMCpsdW1hTGVmdCtsdW1hTGVmdENvcm5lcnMpK2FicygtMi4wKmx1bWFDZW50ZXIrbHVtYURvd25VcCkqMi4wK2FicygtMi4wKmx1bWFSaWdodCtsdW1hUmlnaHRDb3JuZXJzKSk7ZmxvYXQgZWRnZVZlcnRpY2FsPShhYnMoLTIuMCpsdW1hVXArbHVtYVVwQ29ybmVycykrYWJzKC0yLjAqbHVtYUNlbnRlcitsdW1hTGVmdFJpZ2h0KSoyLjArYWJzKC0yLjAqbHVtYURvd24rbHVtYURvd25Db3JuZXJzKSk7Ym9vbCBpc0hvcml6b250YWw9KGVkZ2VIb3Jpem9udGFsPj1lZGdlVmVydGljYWwpO2Zsb2F0IHN0ZXBMZW5ndGg9aXNIb3Jpem9udGFsP3RleGVsU2l6ZS55OnRleGVsU2l6ZS54O2Zsb2F0IGx1bWExPWlzSG9yaXpvbnRhbD9sdW1hRG93bjpsdW1hTGVmdDtmbG9hdCBsdW1hMj1pc0hvcml6b250YWw/bHVtYVVwOmx1bWFSaWdodDtmbG9hdCBncmFkaWVudDE9YWJzKGx1bWExLWx1bWFDZW50ZXIpO2Zsb2F0IGdyYWRpZW50Mj1hYnMobHVtYTItbHVtYUNlbnRlcik7Ym9vbCBpczFTdGVlcGVzdD1ncmFkaWVudDE+PWdyYWRpZW50MjtmbG9hdCBncmFkaWVudFNjYWxlZD0wLjI1Km1heChncmFkaWVudDEsZ3JhZGllbnQyKTtmbG9hdCBsdW1hTG9jYWxBdmVyYWdlPTAuMDtpZihpczFTdGVlcGVzdCl7c3RlcExlbmd0aD0tc3RlcExlbmd0aDtsdW1hTG9jYWxBdmVyYWdlPTAuNSoobHVtYTErbHVtYUNlbnRlcik7fWVsc2V7bHVtYUxvY2FsQXZlcmFnZT0wLjUqKGx1bWEyK2x1bWFDZW50ZXIpO312ZWMyIGN1cnJlbnRVdj11djtpZihpc0hvcml6b250YWwpe2N1cnJlbnRVdi55Kz1zdGVwTGVuZ3RoKjAuNTt9ZWxzZXtjdXJyZW50VXYueCs9c3RlcExlbmd0aCowLjU7fXZlYzIgb2Zmc2V0PWlzSG9yaXpvbnRhbD92ZWMyKHRleGVsU2l6ZS54LDAuMCk6dmVjMigwLjAsdGV4ZWxTaXplLnkpO3ZlYzIgdXYxPWN1cnJlbnRVdi1vZmZzZXQqUVVBTElUWSgwKTt2ZWMyIHV2Mj1jdXJyZW50VXYrb2Zmc2V0KlFVQUxJVFkoMCk7ZmxvYXQgbHVtYUVuZDE9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix1djEpLnJnYik7ZmxvYXQgbHVtYUVuZDI9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix1djIpLnJnYik7bHVtYUVuZDEtPWx1bWFMb2NhbEF2ZXJhZ2U7bHVtYUVuZDItPWx1bWFMb2NhbEF2ZXJhZ2U7Ym9vbCByZWFjaGVkMT1hYnMobHVtYUVuZDEpPj1ncmFkaWVudFNjYWxlZDtib29sIHJlYWNoZWQyPWFicyhsdW1hRW5kMik+PWdyYWRpZW50U2NhbGVkO2Jvb2wgcmVhY2hlZEJvdGg9cmVhY2hlZDEmJnJlYWNoZWQyO2lmKCFyZWFjaGVkMSl7dXYxLT1vZmZzZXQqUVVBTElUWSgxKTt9aWYoIXJlYWNoZWQyKXt1djIrPW9mZnNldCpRVUFMSVRZKDEpO31pZighcmVhY2hlZEJvdGgpe2ZvcihpbnQgaT0yO2k8U0FNUExFUzsrK2kpe2lmKCFyZWFjaGVkMSl7bHVtYUVuZDE9bHVtaW5hbmNlKHRleHR1cmUyRChpbnB1dEJ1ZmZlcix1djEpLnJnYik7bHVtYUVuZDE9bHVtYUVuZDEtbHVtYUxvY2FsQXZlcmFnZTt9aWYoIXJlYWNoZWQyKXtsdW1hRW5kMj1sdW1pbmFuY2UodGV4dHVyZTJEKGlucHV0QnVmZmVyLHV2MikucmdiKTtsdW1hRW5kMj1sdW1hRW5kMi1sdW1hTG9jYWxBdmVyYWdlO31yZWFjaGVkMT1hYnMobHVtYUVuZDEpPj1ncmFkaWVudFNjYWxlZDtyZWFjaGVkMj1hYnMobHVtYUVuZDIpPj1ncmFkaWVudFNjYWxlZDtyZWFjaGVkQm90aD1yZWFjaGVkMSYmcmVhY2hlZDI7aWYoIXJlYWNoZWQxKXt1djEtPW9mZnNldCpRVUFMSVRZKGkpO31pZighcmVhY2hlZDIpe3V2Mis9b2Zmc2V0KlFVQUxJVFkoaSk7fWlmKHJlYWNoZWRCb3RoKXticmVhazt9fX1mbG9hdCBkaXN0YW5jZTE9aXNIb3Jpem9udGFsPyh1di54LXV2MS54KToodXYueS11djEueSk7ZmxvYXQgZGlzdGFuY2UyPWlzSG9yaXpvbnRhbD8odXYyLngtdXYueCk6KHV2Mi55LXV2LnkpO2Jvb2wgaXNEaXJlY3Rpb24xPWRpc3RhbmNlMTxkaXN0YW5jZTI7ZmxvYXQgZGlzdGFuY2VGaW5hbD1taW4oZGlzdGFuY2UxLGRpc3RhbmNlMik7ZmxvYXQgZWRnZVRoaWNrbmVzcz0oZGlzdGFuY2UxK2Rpc3RhbmNlMik7Ym9vbCBpc0x1bWFDZW50ZXJTbWFsbGVyPWx1bWFDZW50ZXI8bHVtYUxvY2FsQXZlcmFnZTtib29sIGNvcnJlY3RWYXJpYXRpb24xPShsdW1hRW5kMTwwLjApIT1pc0x1bWFDZW50ZXJTbWFsbGVyO2Jvb2wgY29ycmVjdFZhcmlhdGlvbjI9KGx1bWFFbmQyPDAuMCkhPWlzTHVtYUNlbnRlclNtYWxsZXI7Ym9vbCBjb3JyZWN0VmFyaWF0aW9uPWlzRGlyZWN0aW9uMT9jb3JyZWN0VmFyaWF0aW9uMTpjb3JyZWN0VmFyaWF0aW9uMjtmbG9hdCBwaXhlbE9mZnNldD0tZGlzdGFuY2VGaW5hbC9lZGdlVGhpY2tuZXNzKzAuNTtmbG9hdCBmaW5hbE9mZnNldD1jb3JyZWN0VmFyaWF0aW9uP3BpeGVsT2Zmc2V0OjAuMDtmbG9hdCBsdW1hQXZlcmFnZT1PTkVfT1ZFUl9UV0VMVkUqKDIuMCoobHVtYURvd25VcCtsdW1hTGVmdFJpZ2h0KStsdW1hTGVmdENvcm5lcnMrbHVtYVJpZ2h0Q29ybmVycyk7ZmxvYXQgc3ViUGl4ZWxPZmZzZXQxPWNsYW1wKGFicyhsdW1hQXZlcmFnZS1sdW1hQ2VudGVyKS9sdW1hUmFuZ2UsMC4wLDEuMCk7ZmxvYXQgc3ViUGl4ZWxPZmZzZXQyPSgtMi4wKnN1YlBpeGVsT2Zmc2V0MSszLjApKnN1YlBpeGVsT2Zmc2V0MSpzdWJQaXhlbE9mZnNldDE7ZmxvYXQgc3ViUGl4ZWxPZmZzZXRGaW5hbD1zdWJQaXhlbE9mZnNldDIqc3ViUGl4ZWxPZmZzZXQyKlNVQlBJWEVMX1FVQUxJVFk7ZmluYWxPZmZzZXQ9bWF4KGZpbmFsT2Zmc2V0LHN1YlBpeGVsT2Zmc2V0RmluYWwpO3ZlYzIgZmluYWxVdj11djtpZihpc0hvcml6b250YWwpe2ZpbmFsVXYueSs9ZmluYWxPZmZzZXQqc3RlcExlbmd0aDt9ZWxzZXtmaW5hbFV2LngrPWZpbmFsT2Zmc2V0KnN0ZXBMZW5ndGg7fXJldHVybiB0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsZmluYWxVdik7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtvdXRwdXRDb2xvcj1meGFhKGlucHV0Q29sb3IsdXYpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9meGFhLnZlcnRcbnZhciBmeGFhX2RlZmF1bHQyID0gXCJ2YXJ5aW5nIHZlYzIgdlV2RG93bjt2YXJ5aW5nIHZlYzIgdlV2VXA7dmFyeWluZyB2ZWMyIHZVdkxlZnQ7dmFyeWluZyB2ZWMyIHZVdlJpZ2h0O3ZhcnlpbmcgdmVjMiB2VXZEb3duTGVmdDt2YXJ5aW5nIHZlYzIgdlV2VXBSaWdodDt2YXJ5aW5nIHZlYzIgdlV2VXBMZWZ0O3ZhcnlpbmcgdmVjMiB2VXZEb3duUmlnaHQ7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2VXZEb3duPXV2K3ZlYzIoMC4wLC0xLjApKnRleGVsU2l6ZTt2VXZVcD11dit2ZWMyKDAuMCwxLjApKnRleGVsU2l6ZTt2VXZSaWdodD11dit2ZWMyKDEuMCwwLjApKnRleGVsU2l6ZTt2VXZMZWZ0PXV2K3ZlYzIoLTEuMCwwLjApKnRleGVsU2l6ZTt2VXZEb3duTGVmdD11dit2ZWMyKC0xLjAsLTEuMCkqdGV4ZWxTaXplO3ZVdlVwUmlnaHQ9dXYrdmVjMigxLjAsMS4wKSp0ZXhlbFNpemU7dlV2VXBMZWZ0PXV2K3ZlYzIoLTEuMCwxLjApKnRleGVsU2l6ZTt2VXZEb3duUmlnaHQ9dXYrdmVjMigxLjAsLTEuMCkqdGV4ZWxTaXplO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvRlhBQUVmZmVjdC5qc1xudmFyIEZYQUFFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEZYQUEgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNSQyB9ID0ge30pIHtcbiAgICBzdXBlcihcIkZYQUFFZmZlY3RcIiwgZnhhYV9kZWZhdWx0LCB7XG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGZ4YWFfZGVmYXVsdDIsXG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJFREdFX1RIUkVTSE9MRF9NSU5cIiwgXCIwLjAzMTJcIl0sXG4gICAgICAgIFtcIkVER0VfVEhSRVNIT0xEX01BWFwiLCBcIjAuMTI1XCJdLFxuICAgICAgICBbXCJTVUJQSVhFTF9RVUFMSVRZXCIsIFwiMC43NVwiXSxcbiAgICAgICAgW1wiU0FNUExFU1wiLCBcIjEyXCJdXG4gICAgICBdKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBlZGdlIGRldGVjdGlvbiB0aHJlc2hvbGQuIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWluRWRnZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJFREdFX1RIUkVTSE9MRF9NSU5cIikpO1xuICB9XG4gIHNldCBtaW5FZGdlVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIkVER0VfVEhSRVNIT0xEX01JTlwiLCB2YWx1ZS50b0ZpeGVkKDEyKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGVkZ2UgZGV0ZWN0aW9uIHRocmVzaG9sZC4gUmFuZ2UgaXMgWzAuMCwgMS4wXS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtYXhFZGdlVGhyZXNob2xkKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIkVER0VfVEhSRVNIT0xEX01BWFwiKSk7XG4gIH1cbiAgc2V0IG1heEVkZ2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiRURHRV9USFJFU0hPTERfTUFYXCIsIHZhbHVlLnRvRml4ZWQoMTIpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN1YnBpeGVsIGJsZW5kIHF1YWxpdHkuIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc3VicGl4ZWxRdWFsaXR5KCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5kZWZpbmVzLmdldChcIlNVQlBJWEVMX1FVQUxJVFlcIikpO1xuICB9XG4gIHNldCBzdWJwaXhlbFF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiU1VCUElYRUxfUVVBTElUWVwiLCB2YWx1ZS50b0ZpeGVkKDEyKSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBlZGdlIGRldGVjdGlvbiBzYW1wbGVzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiU0FNUExFU1wiKSk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0FNUExFU1wiLCB2YWx1ZS50b0ZpeGVkKDApKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvR2FtbWFDb3JyZWN0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm0zMSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dhbW1hLWNvcnJlY3Rpb24uZnJhZ1xudmFyIGdhbW1hX2NvcnJlY3Rpb25fZGVmYXVsdCA9IFwidW5pZm9ybSBmbG9hdCBnYW1tYTt2b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9TGluZWFyVG9HYW1tYShtYXgoaW5wdXRDb2xvciwwLjApLGdhbW1hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0dhbW1hQ29ycmVjdGlvbkVmZmVjdC5qc1xudmFyIEdhbW1hQ29ycmVjdGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ2FtbWEgY29ycmVjdGlvbiBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU1JDXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhbW1hPTIuMF0gLSBUaGUgZ2FtbWEgZmFjdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsIGdhbW1hID0gMiB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdhbW1hQ29ycmVjdGlvbkVmZmVjdFwiLCBnYW1tYV9jb3JyZWN0aW9uX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJnYW1tYVwiLCBuZXcgVW5pZm9ybTMxKGdhbW1hKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dsaXRjaEVmZmVjdC5qc1xuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyNiwgUmVwZWF0V3JhcHBpbmcsIFJHQkFGb3JtYXQgYXMgUkdCQUZvcm1hdDMsIFVuaWZvcm0gYXMgVW5pZm9ybTMyLCBWZWN0b3IyIGFzIFZlY3RvcjIyMCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvdGV4dHVyZXMvbHV0L0xvb2t1cFRleHR1cmUuanNcbmltcG9ydCB7XG4gIENvbG9yIGFzIENvbG9yNCxcbiAgQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgRGF0YVRleHR1cmUsXG4gIERhdGEzRFRleHR1cmUsXG4gIEZsb2F0VHlwZSBhcyBGbG9hdFR5cGU0LFxuICBMaW5lYXJGaWx0ZXIgYXMgTGluZWFyRmlsdGVyMyxcbiAgUkdCQUZvcm1hdCxcbiAgVW5zaWduZWRCeXRlVHlwZSBhcyBVbnNpZ25lZEJ5dGVUeXBlMTMsXG4gIFZlY3RvcjNcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy90ZXh0dXJlcy9SYXdJbWFnZURhdGEuanNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGRhdGEsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGltYWdlRGF0YS5kYXRhLnNldChkYXRhKTtcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG52YXIgUmF3SW1hZ2VEYXRhID0gY2xhc3MgX1Jhd0ltYWdlRGF0YSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGltYWdlIGRhdGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIC0gVGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gW2RhdGE9bnVsbF0gLSBUaGUgaW1hZ2UgZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgZGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhcyBmcm9tIHRoaXMgaW1hZ2UgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7Q2FudmFzfSBUaGUgY2FudmFzLCBvciBudWxsIGlmIGl0IGNvdWxkbid0IGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0b0NhbnZhcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IGNyZWF0ZUNhbnZhcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbWFnZSBkYXRhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtJbWFnZURhdGF8SW1hZ2V9IGltYWdlIC0gQW4gaW1hZ2Ugb3IgcGxhaW4gaW1hZ2UgZGF0YS5cbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgaW1hZ2UgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGltYWdlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQsIGltYWdlKTtcbiAgICAgIGlmIChjYW52YXMgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfUmF3SW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEpO1xuICB9XG59O1xuXG4vLyB0bXAvbHV0L3dvcmtlci50eHRcbnZhciB3b3JrZXJfZGVmYXVsdCA9ICdcInVzZSBzdHJpY3RcIjsoKCk9Pnt2YXIgTz17U0NBTEVfVVA6XCJsdXQuc2NhbGV1cFwifTt2YXIgXz1bbmV3IEZsb2F0MzJBcnJheSgzKSxuZXcgRmxvYXQzMkFycmF5KDMpXSxuPVtuZXcgRmxvYXQzMkFycmF5KDMpLG5ldyBGbG9hdDMyQXJyYXkoMyksbmV3IEZsb2F0MzJBcnJheSgzKSxuZXcgRmxvYXQzMkFycmF5KDMpXSxaPVtbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxXSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXSxbbmV3IEZsb2F0MzJBcnJheShbMCwwLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwwXSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKV0sW25ldyBGbG9hdDMyQXJyYXkoWzAsMCwwXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDBdKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMV0pLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSldLFtuZXcgRmxvYXQzMkFycmF5KFswLDAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxXSksbmV3IEZsb2F0MzJBcnJheShbMCwxLDFdKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMV0pXV07ZnVuY3Rpb24gZChhLHQscixtKXtsZXQgaT1yWzBdLXRbMF0sZT1yWzFdLXRbMV0seT1yWzJdLXRbMl0saD1hWzBdLXRbMF0sQT1hWzFdLXRbMV0sdz1hWzJdLXRbMl0sYz1lKncteSpBLGw9eSpoLWkqdyx4PWkqQS1lKmgsdT1NYXRoLnNxcnQoYypjK2wqbCt4KngpLGI9dSouNSxzPWMvdSxGPWwvdSxmPXgvdSxwPS0oYVswXSpzK2FbMV0qRithWzJdKmYpLE09bVswXSpzK21bMV0qRittWzJdKmY7cmV0dXJuIE1hdGguYWJzKE0rcCkqYi8zfWZ1bmN0aW9uIFYoYSx0LHIsbSxpLGUpe2xldCB5PShyK20qdCtpKnQqdCkqNDtlWzBdPWFbeSswXSxlWzFdPWFbeSsxXSxlWzJdPWFbeSsyXX1mdW5jdGlvbiBrKGEsdCxyLG0saSxlKXtsZXQgeT1yKih0LTEpLGg9bSoodC0xKSxBPWkqKHQtMSksdz1NYXRoLmZsb29yKHkpLGM9TWF0aC5mbG9vcihoKSxsPU1hdGguZmxvb3IoQSkseD1NYXRoLmNlaWwoeSksdT1NYXRoLmNlaWwoaCksYj1NYXRoLmNlaWwoQSkscz15LXcsRj1oLWMsZj1BLWw7aWYodz09PXkmJmM9PT1oJiZsPT09QSlWKGEsdCx5LGgsQSxlKTtlbHNle2xldCBwO3M+PUYmJkY+PWY/cD1aWzBdOnM+PWYmJmY+PUY/cD1aWzFdOmY+PXMmJnM+PUY/cD1aWzJdOkY+PXMmJnM+PWY/cD1aWzNdOkY+PWYmJmY+PXM/cD1aWzRdOmY+PUYmJkY+PXMmJihwPVpbNV0pO2xldFtNLGcsWCxZXT1wLFA9X1swXTtQWzBdPXMsUFsxXT1GLFBbMl09ZjtsZXQgbz1fWzFdLEw9eC13LFM9dS1jLFU9Yi1sO29bMF09TCpNWzBdK3csb1sxXT1TKk1bMV0rYyxvWzJdPVUqTVsyXStsLFYoYSx0LG9bMF0sb1sxXSxvWzJdLG5bMF0pLG9bMF09TCpnWzBdK3csb1sxXT1TKmdbMV0rYyxvWzJdPVUqZ1syXStsLFYoYSx0LG9bMF0sb1sxXSxvWzJdLG5bMV0pLG9bMF09TCpYWzBdK3csb1sxXT1TKlhbMV0rYyxvWzJdPVUqWFsyXStsLFYoYSx0LG9bMF0sb1sxXSxvWzJdLG5bMl0pLG9bMF09TCpZWzBdK3csb1sxXT1TKllbMV0rYyxvWzJdPVUqWVsyXStsLFYoYSx0LG9bMF0sb1sxXSxvWzJdLG5bM10pO2xldCBUPWQoZyxYLFksUCkqNixxPWQoTSxYLFksUCkqNixDPWQoTSxnLFksUCkqNixFPWQoTSxnLFgsUCkqNjtuWzBdWzBdKj1ULG5bMF1bMV0qPVQsblswXVsyXSo9VCxuWzFdWzBdKj1xLG5bMV1bMV0qPXEsblsxXVsyXSo9cSxuWzJdWzBdKj1DLG5bMl1bMV0qPUMsblsyXVsyXSo9QyxuWzNdWzBdKj1FLG5bM11bMV0qPUUsblszXVsyXSo9RSxlWzBdPW5bMF1bMF0rblsxXVswXStuWzJdWzBdK25bM11bMF0sZVsxXT1uWzBdWzFdK25bMV1bMV0rblsyXVsxXStuWzNdWzFdLGVbMl09blswXVsyXStuWzFdWzJdK25bMl1bMl0rblszXVsyXX19dmFyIHY9Y2xhc3N7c3RhdGljIGV4cGFuZCh0LHIpe2xldCBtPU1hdGguY2JydCh0Lmxlbmd0aC80KSxpPW5ldyBGbG9hdDMyQXJyYXkoMyksZT1uZXcgdC5jb25zdHJ1Y3RvcihyKiozKjQpLHk9dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/MjU1OjEsaD1yKioyLEE9MS8oci0xKTtmb3IobGV0IHc9MDt3PHI7Kyt3KWZvcihsZXQgYz0wO2M8cjsrK2MpZm9yKGxldCBsPTA7bDxyOysrbCl7bGV0IHg9bCpBLHU9YypBLGI9dypBLHM9TWF0aC5yb3VuZChsK2Mqcit3KmgpKjQ7ayh0LG0seCx1LGIsaSksZVtzKzBdPWlbMF0sZVtzKzFdPWlbMV0sZVtzKzJdPWlbMl0sZVtzKzNdPXl9cmV0dXJuIGV9fTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsYT0+e2xldCB0PWEuZGF0YSxyPXQuZGF0YTtzd2l0Y2godC5vcGVyYXRpb24pe2Nhc2UgTy5TQ0FMRV9VUDpyPXYuZXhwYW5kKHIsdC5zaXplKTticmVha31wb3N0TWVzc2FnZShyLFtyLmJ1ZmZlcl0pLGNsb3NlKCl9KTt9KSgpO1xcbic7XG5cbi8vIHNyYy90ZXh0dXJlcy9sdXQvTG9va3VwVGV4dHVyZS5qc1xudmFyIGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IENvbG9yNCgpO1xudmFyIExvb2t1cFRleHR1cmUgPSBjbGFzcyBfTG9va3VwVGV4dHVyZSBleHRlbmRzIERhdGEzRFRleHR1cmUge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGN1YmljIDNEIGxvb2t1cCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBUaGUgcGl4ZWwgZGF0YS4gVGhlIGRlZmF1bHQgZm9ybWF0IGlzIFJHQkEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIHNpZGVsZW5ndGguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCBzaXplKSB7XG4gICAgc3VwZXIoZGF0YSwgc2l6ZSwgc2l6ZSwgc2l6ZSk7XG4gICAgdGhpcy50eXBlID0gRmxvYXRUeXBlNDtcbiAgICB0aGlzLmZvcm1hdCA9IFJHQkFGb3JtYXQ7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXIzO1xuICAgIHRoaXMubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0aGlzLndyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcywgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIHRoaXMuZG9tYWluTWluID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5kb21haW5NYXggPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBMb29rdXBUZXh0dXJlM0QuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGlzTG9va3VwVGV4dHVyZTNEKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTY2FsZXMgdGhpcyBMVVQgdXAgdG8gYSBnaXZlbiB0YXJnZXQgc2l6ZSB1c2luZyB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSB0YXJnZXQgc2lkZWxlbmd0aC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbdHJhbnNmZXJEYXRhPXRydWVdIC0gRXh0cmEgZmFzdCBtb2RlLiBTZXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgb3JpZ2luYWwgZGF0YSBpbnRhY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9va3VwVGV4dHVyZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBuZXcgTFVUIHVwb24gY29tcGxldGlvbi5cbiAgICovXG4gIHNjYWxlVXAoc2l6ZSwgdHJhbnNmZXJEYXRhID0gdHJ1ZSkge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoc2l6ZSA8PSBpbWFnZS53aWR0aCkge1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlRoZSB0YXJnZXQgc2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBzaXplXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd29ya2VyX2RlZmF1bHRdLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHJlamVjdChldmVudC5lcnJvcikpO1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgbHV0ID0gbmV3IF9Mb29rdXBUZXh0dXJlKGV2ZW50LmRhdGEsIHNpemUpO1xuICAgICAgICAgIGNvcHlUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLCBsdXQpO1xuICAgICAgICAgIGx1dC50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICAgIGx1dC5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgICAgICAgICByZXNvbHZlKGx1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2Zlckxpc3QgPSB0cmFuc2ZlckRhdGEgPyBbaW1hZ2UuZGF0YS5idWZmZXJdIDogW107XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgb3BlcmF0aW9uOiBMVVRPcGVyYXRpb24uU0NBTEVfVVAsXG4gICAgICAgICAgZGF0YTogaW1hZ2UuZGF0YSxcbiAgICAgICAgICBzaXplXG4gICAgICAgIH0sIHRyYW5zZmVyTGlzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIExVVCB0byB0aGlzIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtMb29rdXBUZXh0dXJlfSBsdXQgLSBBIExVVC4gTXVzdCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMsIHR5cGUgYW5kIGZvcm1hdCBhcyB0aGlzIExVVC5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgYXBwbHlMVVQobHV0KSB7XG4gICAgY29uc3QgaW1nMCA9IHRoaXMuaW1hZ2U7XG4gICAgY29uc3QgaW1nMSA9IGx1dC5pbWFnZTtcbiAgICBjb25zdCBzaXplMCA9IE1hdGgubWluKGltZzAud2lkdGgsIGltZzAuaGVpZ2h0LCBpbWcwLmRlcHRoKTtcbiAgICBjb25zdCBzaXplMSA9IE1hdGgubWluKGltZzEud2lkdGgsIGltZzEuaGVpZ2h0LCBpbWcxLmRlcHRoKTtcbiAgICBpZiAoc2l6ZTAgIT09IHNpemUxKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiU2l6ZSBtaXNtYXRjaFwiKTtcbiAgICB9IGVsc2UgaWYgKGx1dC50eXBlICE9PSBGbG9hdFR5cGU0IHx8IHRoaXMudHlwZSAhPT0gRmxvYXRUeXBlNCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkJvdGggTFVUcyBtdXN0IGJlIEZsb2F0VHlwZSB0ZXh0dXJlc1wiKTtcbiAgICB9IGVsc2UgaWYgKGx1dC5mb3JtYXQgIT09IFJHQkFGb3JtYXQgfHwgdGhpcy5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCb3RoIExVVHMgbXVzdCBiZSBSR0JBIHRleHR1cmVzXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkYXRhMCA9IGltZzAuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGExID0gaW1nMS5kYXRhO1xuICAgICAgY29uc3Qgc2l6ZSA9IHNpemUwO1xuICAgICAgY29uc3Qgc2l6ZVNxID0gc2l6ZSAqKiAyO1xuICAgICAgY29uc3QgcyA9IHNpemUgLSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzaXplICoqIDM7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgaTQgPSBpICogNDtcbiAgICAgICAgY29uc3QgciA9IGRhdGEwW2k0ICsgMF0gKiBzO1xuICAgICAgICBjb25zdCBnID0gZGF0YTBbaTQgKyAxXSAqIHM7XG4gICAgICAgIGNvbnN0IGIgPSBkYXRhMFtpNCArIDJdICogcztcbiAgICAgICAgY29uc3QgaVJHQiA9IE1hdGgucm91bmQociArIGcgKiBzaXplICsgYiAqIHNpemVTcSkgKiA0O1xuICAgICAgICBkYXRhMFtpNCArIDBdID0gZGF0YTFbaVJHQiArIDBdO1xuICAgICAgICBkYXRhMFtpNCArIDFdID0gZGF0YTFbaVJHQiArIDFdO1xuICAgICAgICBkYXRhMFtpNCArIDJdID0gZGF0YTFbaVJHQiArIDJdO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTFVUIGRhdGEgaW50byB1bnNpZ25lZCBieXRlIGRhdGEuXG4gICAqXG4gICAqIFRoaXMgaXMgYSBsb3NzeSBvcGVyYXRpb24gd2hpY2ggc2hvdWxkIG9ubHkgYmUgcGVyZm9ybWVkIGFmdGVyIGFsbCBvdGhlciB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRUb1VpbnQ4KCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IEZsb2F0VHlwZTQpIHtcbiAgICAgIGNvbnN0IGZsb2F0RGF0YSA9IHRoaXMuaW1hZ2UuZGF0YTtcbiAgICAgIGNvbnN0IHVpbnQ4RGF0YSA9IG5ldyBVaW50OEFycmF5KGZsb2F0RGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBmbG9hdERhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIHVpbnQ4RGF0YVtpXSA9IGZsb2F0RGF0YVtpXSAqIDI1NSArIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1hZ2UuZGF0YSA9IHVpbnQ4RGF0YTtcbiAgICAgIHRoaXMudHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGUxMztcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIExVVCBkYXRhIGludG8gZmxvYXQgZGF0YS5cbiAgICpcbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydFRvRmxvYXQoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gVW5zaWduZWRCeXRlVHlwZTEzKSB7XG4gICAgICBjb25zdCB1aW50OERhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgICBjb25zdCBmbG9hdERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHVpbnQ4RGF0YS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1aW50OERhdGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGZsb2F0RGF0YVtpXSA9IHVpbnQ4RGF0YVtpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1hZ2UuZGF0YSA9IGZsb2F0RGF0YTtcbiAgICAgIHRoaXMudHlwZSA9IEZsb2F0VHlwZTQ7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTFVUIGludG8gUkdCQSBkYXRhLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBMVVRzIGFyZSBSR0JBIGJ5IGRlZmF1bHQgc2luY2UgdGhyZWUgcjEzNy5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gVGhpcyB0ZXh0dXJlLlxuICAgKi9cbiAgY29udmVydFRvUkdCQSgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJMb29rdXBUZXh0dXJlXCIsIFwiY29udmVydFRvUkdCQSgpIGlzIGRlcHJlY2F0ZWQsIExVVHMgYXJlIG5vdyBSR0JBIGJ5IGRlZmF1bHRcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvdXRwdXQgb2YgdGhpcyBMVVQgaW50byBzUkdCIGNvbG9yIHNwYWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGlzIHRleHR1cmUuXG4gICAqL1xuICBjb252ZXJ0TGluZWFyVG9TUkdCKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmltYWdlLmRhdGE7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRmxvYXRUeXBlNCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICBjLmZyb21BcnJheShkYXRhLCBpKS5jb252ZXJ0TGluZWFyVG9TUkdCKCkudG9BcnJheShkYXRhLCBpKTtcbiAgICAgIH1cbiAgICAgIHNldFRleHR1cmVDb2xvclNwYWNlKHRoaXMsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ29sb3Igc3BhY2UgY29udmVyc2lvbiByZXF1aXJlcyBGbG9hdFR5cGUgZGF0YVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBvdXRwdXQgb2YgdGhpcyBMVVQgaW50byBsaW5lYXIgY29sb3Igc3BhY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIGNvbnZlcnRTUkdCVG9MaW5lYXIoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaW1hZ2UuZGF0YTtcbiAgICBpZiAodGhpcy50eXBlID09PSBGbG9hdFR5cGU0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIGMuZnJvbUFycmF5KGRhdGEsIGkpLmNvbnZlcnRTUkdCVG9MaW5lYXIoKS50b0FycmF5KGRhdGEsIGkpO1xuICAgICAgfVxuICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcywgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb2xvciBzcGFjZSBjb252ZXJzaW9uIHJlcXVpcmVzIEZsb2F0VHlwZSBkYXRhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMVVQgaW50byBhIDJEIGRhdGEgdGV4dHVyZS5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCBjdXN0b20gaW5wdXQgZG9tYWlucyBhcmUgbm90IGNhcnJpZWQgb3ZlciB0byAyRCB0ZXh0dXJlcy5cbiAgICpcbiAgICogQHJldHVybiB7RGF0YVRleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgdG9EYXRhVGV4dHVyZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQgKiB0aGlzLmltYWdlLmRlcHRoO1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUodGhpcy5pbWFnZS5kYXRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0ZXh0dXJlLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGV4dHVyZS50eXBlID0gdGhpcy50eXBlO1xuICAgIHRleHR1cmUuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXIzO1xuICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyMztcbiAgICB0ZXh0dXJlLndyYXBTID0gdGhpcy53cmFwUztcbiAgICB0ZXh0dXJlLndyYXBUID0gdGhpcy53cmFwVDtcbiAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGNvcHlUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLCB0ZXh0dXJlKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyAzRCBMVVQgYnkgY29weWluZyBhIGdpdmVuIExVVC5cbiAgICpcbiAgICogQ29tbW9uIGltYWdlLWJhc2VkIHRleHR1cmVzIHdpbGwgYmUgY29udmVydGVkIGludG8gM0QgZGF0YSB0ZXh0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIExVVC4gQXNzdW1lZCB0byBiZSBjdWJpYy5cbiAgICogQHJldHVybiB7TG9va3VwVGV4dHVyZX0gQSBuZXcgM0QgTFVULlxuICAgKi9cbiAgc3RhdGljIGZyb20odGV4dHVyZSkge1xuICAgIGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgY29uc3QgcmF3SW1hZ2VEYXRhID0gUmF3SW1hZ2VEYXRhLmZyb20oaW1hZ2UpO1xuICAgICAgY29uc3Qgc3JjID0gcmF3SW1hZ2VEYXRhLmRhdGE7XG4gICAgICBpZiAod2lkdGggPiBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNyYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHNpemU7ICsreikge1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgKyt5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemU7ICsreCkge1xuICAgICAgICAgICAgICBjb25zdCBpNCA9ICh4ICsgeiAqIHNpemUgKyB5ICogc2l6ZSAqIHNpemUpICogNDtcbiAgICAgICAgICAgICAgY29uc3QgajQgPSAoeCArIHkgKiBzaXplICsgeiAqIHNpemUgKiBzaXplKSAqIDQ7XG4gICAgICAgICAgICAgIGRhdGFbajQgKyAwXSA9IHNyY1tpNCArIDBdO1xuICAgICAgICAgICAgICBkYXRhW2o0ICsgMV0gPSBzcmNbaTQgKyAxXTtcbiAgICAgICAgICAgICAgZGF0YVtqNCArIDJdID0gc3JjW2k0ICsgMl07XG4gICAgICAgICAgICAgIGRhdGFbajQgKyAzXSA9IHNyY1tpNCArIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBjb25zdCBsdXQgPSBuZXcgX0xvb2t1cFRleHR1cmUoZGF0YSwgc2l6ZSk7XG4gICAgbHV0LnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG4gICAgbHV0Lm5hbWUgPSB0ZXh0dXJlLm5hbWU7XG4gICAgY29weVRleHR1cmVDb2xvclNwYWNlKHRleHR1cmUsIGx1dCk7XG4gICAgcmV0dXJuIGx1dDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldXRyYWwgM0QgTFVULlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSBzaWRlbGVuZ3RoLlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBBIG5ldXRyYWwgM0QgTFVULlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZU5ldXRyYWwoc2l6ZSkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiogMyAqIDQpO1xuICAgIGNvbnN0IHNpemVTcSA9IHNpemUgKiogMjtcbiAgICBjb25zdCBzID0gMSAvIChzaXplIC0gMSk7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBzaXplOyArK3IpIHtcbiAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgc2l6ZTsgKytnKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgc2l6ZTsgKytiKSB7XG4gICAgICAgICAgY29uc3QgaTQgPSAociArIGcgKiBzaXplICsgYiAqIHNpemVTcSkgKiA0O1xuICAgICAgICAgIGRhdGFbaTQgKyAwXSA9IHIgKiBzO1xuICAgICAgICAgIGRhdGFbaTQgKyAxXSA9IGcgKiBzO1xuICAgICAgICAgIGRhdGFbaTQgKyAyXSA9IGIgKiBzO1xuICAgICAgICAgIGRhdGFbaTQgKyAzXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbHV0ID0gbmV3IF9Mb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICAgIGx1dC5uYW1lID0gXCJuZXV0cmFsXCI7XG4gICAgcmV0dXJuIGx1dDtcbiAgfVxufTtcblxuLy8gc3JjL3RleHR1cmVzL2x1dC9UZXRyYWhlZHJhbFVwc2NhbGVyLmpzXG52YXIgUCA9IFtcbiAgbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgbmV3IEZsb2F0MzJBcnJheSgzKVxuXTtcbnZhciBDID0gW1xuICBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICBuZXcgRmxvYXQzMkFycmF5KDMpXG5dO1xudmFyIFQgPSBbXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF0sXG4gIFtcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSlcbiAgXSxcbiAgW1xuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDBdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMV0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKVxuICBdLFxuICBbXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pLFxuICAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDFdKSxcbiAgICBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxXSksXG4gICAgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pXG4gIF1cbl07XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShhLCBiLCBjMiwgZCkge1xuICBjb25zdCBiY1ggPSBjMlswXSAtIGJbMF07XG4gIGNvbnN0IGJjWSA9IGMyWzFdIC0gYlsxXTtcbiAgY29uc3QgYmNaID0gYzJbMl0gLSBiWzJdO1xuICBjb25zdCBiYVggPSBhWzBdIC0gYlswXTtcbiAgY29uc3QgYmFZID0gYVsxXSAtIGJbMV07XG4gIGNvbnN0IGJhWiA9IGFbMl0gLSBiWzJdO1xuICBjb25zdCBjcm9zc1ggPSBiY1kgKiBiYVogLSBiY1ogKiBiYVk7XG4gIGNvbnN0IGNyb3NzWSA9IGJjWiAqIGJhWCAtIGJjWCAqIGJhWjtcbiAgY29uc3QgY3Jvc3NaID0gYmNYICogYmFZIC0gYmNZICogYmFYO1xuICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoY3Jvc3NYICogY3Jvc3NYICsgY3Jvc3NZICogY3Jvc3NZICsgY3Jvc3NaICogY3Jvc3NaKTtcbiAgY29uc3QgdHJpYW5nbGVBcmVhID0gbGVuZ3RoICogMC41O1xuICBjb25zdCBub3JtYWxYID0gY3Jvc3NYIC8gbGVuZ3RoO1xuICBjb25zdCBub3JtYWxZID0gY3Jvc3NZIC8gbGVuZ3RoO1xuICBjb25zdCBub3JtYWxaID0gY3Jvc3NaIC8gbGVuZ3RoO1xuICBjb25zdCBjb25zdGFudCA9IC0oYVswXSAqIG5vcm1hbFggKyBhWzFdICogbm9ybWFsWSArIGFbMl0gKiBub3JtYWxaKTtcbiAgY29uc3QgZG90ID0gZFswXSAqIG5vcm1hbFggKyBkWzFdICogbm9ybWFsWSArIGRbMl0gKiBub3JtYWxaO1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyhkb3QgKyBjb25zdGFudCk7XG4gIHJldHVybiBoZWlnaHQgKiB0cmlhbmdsZUFyZWEgLyAzO1xufVxuZnVuY3Rpb24gc2FtcGxlKGRhdGEsIHNpemUsIHgsIHksIHosIGNvbG9yMikge1xuICBjb25zdCBpNCA9ICh4ICsgeSAqIHNpemUgKyB6ICogc2l6ZSAqIHNpemUpICogNDtcbiAgY29sb3IyWzBdID0gZGF0YVtpNCArIDBdO1xuICBjb2xvcjJbMV0gPSBkYXRhW2k0ICsgMV07XG4gIGNvbG9yMlsyXSA9IGRhdGFbaTQgKyAyXTtcbn1cbmZ1bmN0aW9uIHRldHJhaGVkcmFsU2FtcGxlKGRhdGEsIHNpemUsIHUsIHYzLCB3LCBjb2xvcjIpIHtcbiAgY29uc3QgcHggPSB1ICogKHNpemUgLSAxKTtcbiAgY29uc3QgcHkgPSB2MyAqIChzaXplIC0gMSk7XG4gIGNvbnN0IHB6ID0gdyAqIChzaXplIC0gMSk7XG4gIGNvbnN0IG1pblggPSBNYXRoLmZsb29yKHB4KTtcbiAgY29uc3QgbWluWSA9IE1hdGguZmxvb3IocHkpO1xuICBjb25zdCBtaW5aID0gTWF0aC5mbG9vcihweik7XG4gIGNvbnN0IG1heFggPSBNYXRoLmNlaWwocHgpO1xuICBjb25zdCBtYXhZID0gTWF0aC5jZWlsKHB5KTtcbiAgY29uc3QgbWF4WiA9IE1hdGguY2VpbChweik7XG4gIGNvbnN0IHN1ID0gcHggLSBtaW5YO1xuICBjb25zdCBzdiA9IHB5IC0gbWluWTtcbiAgY29uc3Qgc3cgPSBweiAtIG1pblo7XG4gIGlmIChtaW5YID09PSBweCAmJiBtaW5ZID09PSBweSAmJiBtaW5aID09PSBweikge1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCBweCwgcHksIHB6LCBjb2xvcjIpO1xuICB9IGVsc2Uge1xuICAgIGxldCB2ZXJ0aWNlcztcbiAgICBpZiAoc3UgPj0gc3YgJiYgc3YgPj0gc3cpIHtcbiAgICAgIHZlcnRpY2VzID0gVFswXTtcbiAgICB9IGVsc2UgaWYgKHN1ID49IHN3ICYmIHN3ID49IHN2KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbMV07XG4gICAgfSBlbHNlIGlmIChzdyA+PSBzdSAmJiBzdSA+PSBzdikge1xuICAgICAgdmVydGljZXMgPSBUWzJdO1xuICAgIH0gZWxzZSBpZiAoc3YgPj0gc3UgJiYgc3UgPj0gc3cpIHtcbiAgICAgIHZlcnRpY2VzID0gVFszXTtcbiAgICB9IGVsc2UgaWYgKHN2ID49IHN3ICYmIHN3ID49IHN1KSB7XG4gICAgICB2ZXJ0aWNlcyA9IFRbNF07XG4gICAgfSBlbHNlIGlmIChzdyA+PSBzdiAmJiBzdiA+PSBzdSkge1xuICAgICAgdmVydGljZXMgPSBUWzVdO1xuICAgIH1cbiAgICBjb25zdCBbUDAsIFAxLCBQMiwgUDNdID0gdmVydGljZXM7XG4gICAgY29uc3QgY29vcmRzID0gUFswXTtcbiAgICBjb29yZHNbMF0gPSBzdTtcbiAgICBjb29yZHNbMV0gPSBzdjtcbiAgICBjb29yZHNbMl0gPSBzdztcbiAgICBjb25zdCB0bXAgPSBQWzFdO1xuICAgIGNvbnN0IGRpZmZYID0gbWF4WCAtIG1pblg7XG4gICAgY29uc3QgZGlmZlkgPSBtYXhZIC0gbWluWTtcbiAgICBjb25zdCBkaWZmWiA9IG1heFogLSBtaW5aO1xuICAgIHRtcFswXSA9IGRpZmZYICogUDBbMF0gKyBtaW5YO1xuICAgIHRtcFsxXSA9IGRpZmZZICogUDBbMV0gKyBtaW5ZO1xuICAgIHRtcFsyXSA9IGRpZmZaICogUDBbMl0gKyBtaW5aO1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCB0bXBbMF0sIHRtcFsxXSwgdG1wWzJdLCBDWzBdKTtcbiAgICB0bXBbMF0gPSBkaWZmWCAqIFAxWzBdICsgbWluWDtcbiAgICB0bXBbMV0gPSBkaWZmWSAqIFAxWzFdICsgbWluWTtcbiAgICB0bXBbMl0gPSBkaWZmWiAqIFAxWzJdICsgbWluWjtcbiAgICBzYW1wbGUoZGF0YSwgc2l6ZSwgdG1wWzBdLCB0bXBbMV0sIHRtcFsyXSwgQ1sxXSk7XG4gICAgdG1wWzBdID0gZGlmZlggKiBQMlswXSArIG1pblg7XG4gICAgdG1wWzFdID0gZGlmZlkgKiBQMlsxXSArIG1pblk7XG4gICAgdG1wWzJdID0gZGlmZlogKiBQMlsyXSArIG1pblo7XG4gICAgc2FtcGxlKGRhdGEsIHNpemUsIHRtcFswXSwgdG1wWzFdLCB0bXBbMl0sIENbMl0pO1xuICAgIHRtcFswXSA9IGRpZmZYICogUDNbMF0gKyBtaW5YO1xuICAgIHRtcFsxXSA9IGRpZmZZICogUDNbMV0gKyBtaW5ZO1xuICAgIHRtcFsyXSA9IGRpZmZaICogUDNbMl0gKyBtaW5aO1xuICAgIHNhbXBsZShkYXRhLCBzaXplLCB0bXBbMF0sIHRtcFsxXSwgdG1wWzJdLCBDWzNdKTtcbiAgICBjb25zdCBWMCA9IGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKFAxLCBQMiwgUDMsIGNvb3JkcykgKiA2O1xuICAgIGNvbnN0IFYxID0gY2FsY3VsYXRlVGV0cmFoZWRyb25Wb2x1bWUoUDAsIFAyLCBQMywgY29vcmRzKSAqIDY7XG4gICAgY29uc3QgVjIgPSBjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZShQMCwgUDEsIFAzLCBjb29yZHMpICogNjtcbiAgICBjb25zdCBWMyA9IGNhbGN1bGF0ZVRldHJhaGVkcm9uVm9sdW1lKFAwLCBQMSwgUDIsIGNvb3JkcykgKiA2O1xuICAgIENbMF1bMF0gKj0gVjA7XG4gICAgQ1swXVsxXSAqPSBWMDtcbiAgICBDWzBdWzJdICo9IFYwO1xuICAgIENbMV1bMF0gKj0gVjE7XG4gICAgQ1sxXVsxXSAqPSBWMTtcbiAgICBDWzFdWzJdICo9IFYxO1xuICAgIENbMl1bMF0gKj0gVjI7XG4gICAgQ1syXVsxXSAqPSBWMjtcbiAgICBDWzJdWzJdICo9IFYyO1xuICAgIENbM11bMF0gKj0gVjM7XG4gICAgQ1szXVsxXSAqPSBWMztcbiAgICBDWzNdWzJdICo9IFYzO1xuICAgIGNvbG9yMlswXSA9IENbMF1bMF0gKyBDWzFdWzBdICsgQ1syXVswXSArIENbM11bMF07XG4gICAgY29sb3IyWzFdID0gQ1swXVsxXSArIENbMV1bMV0gKyBDWzJdWzFdICsgQ1szXVsxXTtcbiAgICBjb2xvcjJbMl0gPSBDWzBdWzJdICsgQ1sxXVsyXSArIENbMl1bMl0gKyBDWzNdWzJdO1xuICB9XG59XG52YXIgVGV0cmFoZWRyYWxVcHNjYWxlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEV4cGFuZHMgdGhlIGdpdmVuIGRhdGEgdG8gdGhlIHRhcmdldCBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBUaGUgaW5wdXQgUkdCQSBkYXRhLiBBc3N1bWVkIHRvIGJlIGN1YmljLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIFRoZSB0YXJnZXQgc2l6ZS5cbiAgICogQHJldHVybiB7VHlwZWRBcnJheX0gVGhlIG5ldyBkYXRhLlxuICAgKi9cbiAgc3RhdGljIGV4cGFuZChkYXRhLCBzaXplKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTaXplID0gTWF0aC5jYnJ0KGRhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3QgcmdiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKHNpemUgKiogMyAqIDQpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyAyNTUgOiAxO1xuICAgIGNvbnN0IHNpemVTcSA9IHNpemUgKiogMjtcbiAgICBjb25zdCBzID0gMSAvIChzaXplIC0gMSk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBzaXplOyArK3opIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgKyt5KSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgKyt4KSB7XG4gICAgICAgICAgY29uc3QgdSA9IHggKiBzO1xuICAgICAgICAgIGNvbnN0IHYzID0geSAqIHM7XG4gICAgICAgICAgY29uc3QgdyA9IHogKiBzO1xuICAgICAgICAgIGNvbnN0IGk0ID0gTWF0aC5yb3VuZCh4ICsgeSAqIHNpemUgKyB6ICogc2l6ZVNxKSAqIDQ7XG4gICAgICAgICAgdGV0cmFoZWRyYWxTYW1wbGUoZGF0YSwgb3JpZ2luYWxTaXplLCB1LCB2MywgdywgcmdiKTtcbiAgICAgICAgICBhcnJheVtpNCArIDBdID0gcmdiWzBdO1xuICAgICAgICAgIGFycmF5W2k0ICsgMV0gPSByZ2JbMV07XG4gICAgICAgICAgYXJyYXlbaTQgKyAyXSA9IHJnYlsyXTtcbiAgICAgICAgICBhcnJheVtpNCArIDNdID0gbWF4VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9TTUFBQXJlYUltYWdlRGF0YS5qc1xudmFyIGFyZWEgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoMiksXG4gIG5ldyBGbG9hdDMyQXJyYXkoMilcbl07XG52YXIgT1JUSE9HT05BTF9TSVpFID0gMTY7XG52YXIgRElBR09OQUxfU0laRSA9IDIwO1xudmFyIERJQUdPTkFMX1NBTVBMRVMgPSAzMDtcbnZhciBTTU9PVEhfTUFYX0RJU1RBTkNFID0gMzI7XG52YXIgb3J0aG9nb25hbFN1YnNhbXBsaW5nT2Zmc2V0cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAwLFxuICAtMC4yNSxcbiAgMC4yNSxcbiAgLTAuMTI1LFxuICAwLjEyNSxcbiAgLTAuMzc1LFxuICAwLjM3NVxuXSk7XG52YXIgZGlhZ29uYWxTdWJzYW1wbGluZ09mZnNldHMgPSBbXG4gIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMC4yNSwgLTAuMjVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbLTAuMjUsIDAuMjVdKSxcbiAgbmV3IEZsb2F0MzJBcnJheShbMC4xMjUsIC0wLjEyNV0pLFxuICBuZXcgRmxvYXQzMkFycmF5KFstMC4xMjUsIDAuMTI1XSlcbl07XG52YXIgb3J0aG9nb25hbEVkZ2VzID0gW1xuICBuZXcgVWludDhBcnJheShbMCwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMywgMF0pLFxuICBuZXcgVWludDhBcnJheShbMCwgM10pLFxuICBuZXcgVWludDhBcnJheShbMywgM10pLFxuICBuZXcgVWludDhBcnJheShbMSwgMF0pLFxuICBuZXcgVWludDhBcnJheShbNCwgMF0pLFxuICBuZXcgVWludDhBcnJheShbMSwgM10pLFxuICBuZXcgVWludDhBcnJheShbNCwgM10pLFxuICBuZXcgVWludDhBcnJheShbMCwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMywgMV0pLFxuICBuZXcgVWludDhBcnJheShbMCwgNF0pLFxuICBuZXcgVWludDhBcnJheShbMywgNF0pLFxuICBuZXcgVWludDhBcnJheShbMSwgMV0pLFxuICBuZXcgVWludDhBcnJheShbNCwgMV0pLFxuICBuZXcgVWludDhBcnJheShbMSwgNF0pLFxuICBuZXcgVWludDhBcnJheShbNCwgNF0pXG5dO1xudmFyIGRpYWdvbmFsRWRnZXMgPSBbXG4gIG5ldyBVaW50OEFycmF5KFswLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCAyXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAyXSksXG4gIG5ldyBVaW50OEFycmF5KFsyLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAwXSksXG4gIG5ldyBVaW50OEFycmF5KFsyLCAyXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAyXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFswLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFsxLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFsyLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAxXSksXG4gIG5ldyBVaW50OEFycmF5KFsyLCAzXSksXG4gIG5ldyBVaW50OEFycmF5KFszLCAzXSlcbl07XG5mdW5jdGlvbiBsZXJwKGEsIGIsIHApIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbn1cbmZ1bmN0aW9uIHNhdHVyYXRlKGEpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGEsIDApLCAxKTtcbn1cbmZ1bmN0aW9uIHNtb290aEFyZWEoZCkge1xuICBjb25zdCBhMSA9IGFyZWFbMF07XG4gIGNvbnN0IGEyID0gYXJlYVsxXTtcbiAgY29uc3QgYjFYID0gTWF0aC5zcXJ0KGExWzBdICogMikgKiAwLjU7XG4gIGNvbnN0IGIxWSA9IE1hdGguc3FydChhMVsxXSAqIDIpICogMC41O1xuICBjb25zdCBiMlggPSBNYXRoLnNxcnQoYTJbMF0gKiAyKSAqIDAuNTtcbiAgY29uc3QgYjJZID0gTWF0aC5zcXJ0KGEyWzFdICogMikgKiAwLjU7XG4gIGNvbnN0IHAgPSBzYXR1cmF0ZShkIC8gU01PT1RIX01BWF9ESVNUQU5DRSk7XG4gIGExWzBdID0gbGVycChiMVgsIGExWzBdLCBwKTtcbiAgYTFbMV0gPSBsZXJwKGIxWSwgYTFbMV0sIHApO1xuICBhMlswXSA9IGxlcnAoYjJYLCBhMlswXSwgcCk7XG4gIGEyWzFdID0gbGVycChiMlksIGEyWzFdLCBwKTtcbn1cbmZ1bmN0aW9uIGdldE9ydGhBcmVhKHAxWCwgcDFZLCBwMlgsIHAyWSwgeCwgcmVzdWx0KSB7XG4gIGNvbnN0IGRYID0gcDJYIC0gcDFYO1xuICBjb25zdCBkWSA9IHAyWSAtIHAxWTtcbiAgY29uc3QgeDEgPSB4O1xuICBjb25zdCB4MiA9IHggKyAxO1xuICBjb25zdCB5MSA9IHAxWSArIGRZICogKHgxIC0gcDFYKSAvIGRYO1xuICBjb25zdCB5MiA9IHAxWSArIGRZICogKHgyIC0gcDFYKSAvIGRYO1xuICBpZiAoeDEgPj0gcDFYICYmIHgxIDwgcDJYIHx8IHgyID4gcDFYICYmIHgyIDw9IHAyWCkge1xuICAgIGlmIChNYXRoLnNpZ24oeTEpID09PSBNYXRoLnNpZ24oeTIpIHx8IE1hdGguYWJzKHkxKSA8IDFlLTQgfHwgTWF0aC5hYnMoeTIpIDwgMWUtNCkge1xuICAgICAgY29uc3QgYSA9ICh5MSArIHkyKSAvIDI7XG4gICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5hYnMoYSk7XG4gICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgICByZXN1bHRbMV0gPSBNYXRoLmFicyhhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdCA9IC1wMVkgKiBkWCAvIGRZICsgcDFYO1xuICAgICAgY29uc3QgdEludCA9IE1hdGgudHJ1bmModCk7XG4gICAgICBjb25zdCBhMSA9IHQgPiBwMVggPyB5MSAqICh0IC0gdEludCkgLyAyIDogMDtcbiAgICAgIGNvbnN0IGEyID0gdCA8IHAyWCA/IHkyICogKDEgLSAodCAtIHRJbnQpKSAvIDIgOiAwO1xuICAgICAgY29uc3QgYSA9IE1hdGguYWJzKGExKSA+IE1hdGguYWJzKGEyKSA/IGExIDogLWEyO1xuICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgIHJlc3VsdFswXSA9IE1hdGguYWJzKGExKTtcbiAgICAgICAgcmVzdWx0WzFdID0gTWF0aC5hYnMoYTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gTWF0aC5hYnMoYTIpO1xuICAgICAgICByZXN1bHRbMV0gPSBNYXRoLmFicyhhMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdFswXSA9IDA7XG4gICAgcmVzdWx0WzFdID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0T3J0aEFyZWFGb3JQYXR0ZXJuKHBhdHRlcm4sIGxlZnQsIHJpZ2h0LCBvZmZzZXQsIHJlc3VsdCkge1xuICBjb25zdCBhMSA9IGFyZWFbMF07XG4gIGNvbnN0IGEyID0gYXJlYVsxXTtcbiAgY29uc3QgbzEgPSAwLjUgKyBvZmZzZXQ7XG4gIGNvbnN0IG8yID0gMC41ICsgb2Zmc2V0IC0gMTtcbiAgY29uc3QgZCA9IGxlZnQgKyByaWdodCArIDE7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgMDoge1xuICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICBpZiAobGVmdCA8PSByaWdodCkge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCAvIDIsIDAsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgaWYgKGxlZnQgPj0gcmlnaHQpIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8yLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDM6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkIC8gMiwgMCwgbGVmdCwgYTEpO1xuICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8yLCBsZWZ0LCBhMik7XG4gICAgICBzbW9vdGhBcmVhKGQsIGFyZWEpO1xuICAgICAgcmVzdWx0WzBdID0gYTFbMF0gKyBhMlswXTtcbiAgICAgIHJlc3VsdFsxXSA9IGExWzFdICsgYTJbMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA0OiB7XG4gICAgICBpZiAobGVmdCA8PSByaWdodCkge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCAvIDIsIDAsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNToge1xuICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA2OiB7XG4gICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0KSA+IDApIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzEsIGQsIG8yLCBsZWZ0LCBhMSk7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8xLCBkIC8gMiwgMCwgbGVmdCwgYTIpO1xuICAgICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzIsIGxlZnQsIHJlc3VsdCk7XG4gICAgICAgIGEyWzBdID0gYTJbMF0gKyByZXN1bHRbMF07XG4gICAgICAgIGEyWzFdID0gYTJbMV0gKyByZXN1bHRbMV07XG4gICAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCwgbzIsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA3OiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCwgbzIsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA4OiB7XG4gICAgICBpZiAobGVmdCA+PSByaWdodCkge1xuICAgICAgICBnZXRPcnRoQXJlYShkIC8gMiwgMCwgZCwgbzEsIGxlZnQsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbMF0gPSAwO1xuICAgICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgOToge1xuICAgICAgaWYgKE1hdGguYWJzKG9mZnNldCkgPiAwKSB7XG4gICAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkLCBvMSwgbGVmdCwgYTEpO1xuICAgICAgICBnZXRPcnRoQXJlYSgwLCBvMiwgZCAvIDIsIDAsIGxlZnQsIGEyKTtcbiAgICAgICAgZ2V0T3J0aEFyZWEoZCAvIDIsIDAsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgICBhMlswXSA9IGEyWzBdICsgcmVzdWx0WzBdO1xuICAgICAgICBhMlsxXSA9IGEyWzFdICsgcmVzdWx0WzFdO1xuICAgICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0T3J0aEFyZWEoMCwgbzIsIGQsIG8xLCBsZWZ0LCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTA6IHtcbiAgICAgIHJlc3VsdFswXSA9IDA7XG4gICAgICByZXN1bHRbMV0gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTE6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEyOiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCAvIDIsIDAsIGxlZnQsIGExKTtcbiAgICAgIGdldE9ydGhBcmVhKGQgLyAyLCAwLCBkLCBvMSwgbGVmdCwgYTIpO1xuICAgICAgc21vb3RoQXJlYShkLCBhcmVhKTtcbiAgICAgIHJlc3VsdFswXSA9IGExWzBdICsgYTJbMF07XG4gICAgICByZXN1bHRbMV0gPSBhMVsxXSArIGEyWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTM6IHtcbiAgICAgIGdldE9ydGhBcmVhKDAsIG8yLCBkLCBvMSwgbGVmdCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE0OiB7XG4gICAgICBnZXRPcnRoQXJlYSgwLCBvMSwgZCwgbzIsIGxlZnQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxNToge1xuICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlQXJlYShhMVgsIGExWSwgYTJYLCBhMlksIHgsIHkpIHtcbiAgbGV0IHJlc3VsdCA9IGExWCA9PT0gYTJYICYmIGExWSA9PT0gYTJZO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIGNvbnN0IHhtID0gKGExWCArIGEyWCkgLyAyO1xuICAgIGNvbnN0IHltID0gKGExWSArIGEyWSkgLyAyO1xuICAgIGNvbnN0IGEgPSBhMlkgLSBhMVk7XG4gICAgY29uc3QgYiA9IGExWCAtIGEyWDtcbiAgICBjb25zdCBjMiA9IGEgKiAoeCAtIHhtKSArIGIgKiAoeSAtIHltKTtcbiAgICByZXN1bHQgPSBjMiA+IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERpYWdBcmVhRm9yUGl4ZWwoYTFYLCBhMVksIGEyWCwgYTJZLCBwWCwgcFkpIHtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IERJQUdPTkFMX1NBTVBMRVM7ICsreSkge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgRElBR09OQUxfU0FNUExFUzsgKyt4KSB7XG4gICAgICBjb25zdCBvZmZzZXRYID0geCAvIChESUFHT05BTF9TQU1QTEVTIC0gMSk7XG4gICAgICBjb25zdCBvZmZzZXRZID0geSAvIChESUFHT05BTF9TQU1QTEVTIC0gMSk7XG4gICAgICBpZiAoaXNJbnNpZGVBcmVhKGExWCwgYTFZLCBhMlgsIGEyWSwgcFggKyBvZmZzZXRYLCBwWSArIG9mZnNldFkpKSB7XG4gICAgICAgICsrbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4gLyAoRElBR09OQUxfU0FNUExFUyAqIERJQUdPTkFMX1NBTVBMRVMpO1xufVxuZnVuY3Rpb24gZ2V0RGlhZ0FyZWEocGF0dGVybiwgYTFYLCBhMVksIGEyWCwgYTJZLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCkge1xuICBjb25zdCBlID0gZGlhZ29uYWxFZGdlc1twYXR0ZXJuXTtcbiAgY29uc3QgZTEgPSBlWzBdO1xuICBjb25zdCBlMiA9IGVbMV07XG4gIGlmIChlMSA+IDApIHtcbiAgICBhMVggKz0gb2Zmc2V0WzBdO1xuICAgIGExWSArPSBvZmZzZXRbMV07XG4gIH1cbiAgaWYgKGUyID4gMCkge1xuICAgIGEyWCArPSBvZmZzZXRbMF07XG4gICAgYTJZICs9IG9mZnNldFsxXTtcbiAgfVxuICByZXN1bHRbMF0gPSAxIC0gZ2V0RGlhZ0FyZWFGb3JQaXhlbChhMVgsIGExWSwgYTJYLCBhMlksIDEgKyBsZWZ0LCAwICsgbGVmdCk7XG4gIHJlc3VsdFsxXSA9IGdldERpYWdBcmVhRm9yUGl4ZWwoYTFYLCBhMVksIGEyWCwgYTJZLCAxICsgbGVmdCwgMSArIGxlZnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RGlhZ0FyZWFGb3JQYXR0ZXJuKHBhdHRlcm4sIGxlZnQsIHJpZ2h0LCBvZmZzZXQsIHJlc3VsdCkge1xuICBjb25zdCBhMSA9IGFyZWFbMF07XG4gIGNvbnN0IGEyID0gYXJlYVsxXTtcbiAgY29uc3QgZCA9IGxlZnQgKyByaWdodCArIDE7XG4gIHN3aXRjaCAocGF0dGVybikge1xuICAgIGNhc2UgMDoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDAgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAwLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMzoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA0OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAwICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMCArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDY6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgNzoge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDAgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDg6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDAsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSA5OiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTA6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDAsIDAsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAwLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxMToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEyOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDEzOiB7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMSArIGQsIGxlZnQsIG9mZnNldCwgYTEpO1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMCwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGEyKTtcbiAgICAgIHJlc3VsdFswXSA9IChhMVswXSArIGEyWzBdKSAvIDI7XG4gICAgICByZXN1bHRbMV0gPSAoYTFbMV0gKyBhMlsxXSkgLyAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMTQ6IHtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDEsIDEgKyBkLCAxICsgZCwgbGVmdCwgb2Zmc2V0LCBhMSk7XG4gICAgICBnZXREaWFnQXJlYShwYXR0ZXJuLCAxLCAxLCAxICsgZCwgMCArIGQsIGxlZnQsIG9mZnNldCwgYTIpO1xuICAgICAgcmVzdWx0WzBdID0gKGExWzBdICsgYTJbMF0pIC8gMjtcbiAgICAgIHJlc3VsdFsxXSA9IChhMVsxXSArIGEyWzFdKSAvIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAxNToge1xuICAgICAgZ2V0RGlhZ0FyZWEocGF0dGVybiwgMSwgMSwgMSArIGQsIDEgKyBkLCBsZWZ0LCBvZmZzZXQsIGExKTtcbiAgICAgIGdldERpYWdBcmVhKHBhdHRlcm4sIDEsIDAsIDEgKyBkLCAwICsgZCwgbGVmdCwgb2Zmc2V0LCBhMik7XG4gICAgICByZXN1bHRbMF0gPSAoYTFbMF0gKyBhMlswXSkgLyAyO1xuICAgICAgcmVzdWx0WzFdID0gKGExWzFdICsgYTJbMV0pIC8gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVQYXR0ZXJucyhwYXR0ZXJucywgb2Zmc2V0LCBvcnRob2dvbmFsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgIGNvbnN0IGRhdGEgPSBwYXR0ZXJuLmRhdGE7XG4gICAgY29uc3Qgc2l6ZSA9IHBhdHRlcm4ud2lkdGg7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgKyt4KSB7XG4gICAgICAgIGlmIChvcnRob2dvbmFsKSB7XG4gICAgICAgICAgZ2V0T3J0aEFyZWFGb3JQYXR0ZXJuKGksIHgsIHksIG9mZnNldCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZXREaWFnQXJlYUZvclBhdHRlcm4oaSwgeCwgeSwgb2Zmc2V0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMyID0gKHkgKiBzaXplICsgeCkgKiAyO1xuICAgICAgICBkYXRhW2MyXSA9IHJlc3VsdFswXSAqIDI1NTtcbiAgICAgICAgZGF0YVtjMiArIDFdID0gcmVzdWx0WzFdICogMjU1O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzZW1ibGUoYmFzZVgsIGJhc2VZLCBwYXR0ZXJucywgZWRnZXMyLCBzaXplLCBvcnRob2dvbmFsLCB0YXJnZXQpIHtcbiAgY29uc3QgZHN0RGF0YSA9IHRhcmdldC5kYXRhO1xuICBjb25zdCBkc3RXaWR0aCA9IHRhcmdldC53aWR0aDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCBlZGdlID0gZWRnZXMyW2ldO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICBjb25zdCBzcmNEYXRhID0gcGF0dGVybi5kYXRhO1xuICAgIGNvbnN0IHNyY1dpZHRoID0gcGF0dGVybi53aWR0aDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemU7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyArK3gpIHtcbiAgICAgICAgY29uc3QgcFggPSBlZGdlWzBdICogc2l6ZSArIGJhc2VYICsgeDtcbiAgICAgICAgY29uc3QgcFkgPSBlZGdlWzFdICogc2l6ZSArIGJhc2VZICsgeTtcbiAgICAgICAgY29uc3QgYzIgPSAocFkgKiBkc3RXaWR0aCArIHBYKSAqIDQ7XG4gICAgICAgIGNvbnN0IGQgPSBvcnRob2dvbmFsID8gKHkgKiB5ICogc3JjV2lkdGggKyB4ICogeCkgKiAyIDogKHkgKiBzcmNXaWR0aCArIHgpICogMjtcbiAgICAgICAgZHN0RGF0YVtjMl0gPSBzcmNEYXRhW2RdO1xuICAgICAgICBkc3REYXRhW2MyICsgMV0gPSBzcmNEYXRhW2QgKyAxXTtcbiAgICAgICAgZHN0RGF0YVtjMiArIDJdID0gMDtcbiAgICAgICAgZHN0RGF0YVtjMiArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIFNNQUFBcmVhSW1hZ2VEYXRhID0gY2xhc3Mge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhcmVhIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSYXdJbWFnZURhdGF9IFRoZSBnZW5lcmF0ZWQgaW1hZ2UgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IDIgKiA1ICogT1JUSE9HT05BTF9TSVpFO1xuICAgIGNvbnN0IGhlaWdodCA9IG9ydGhvZ29uYWxTdWJzYW1wbGluZ09mZnNldHMubGVuZ3RoICogNSAqIE9SVEhPR09OQUxfU0laRTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFJhd0ltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0LCBkYXRhKTtcbiAgICBjb25zdCBvcnRoUGF0dGVyblNpemUgPSBNYXRoLnBvdyhPUlRIT0dPTkFMX1NJWkUgLSAxLCAyKSArIDE7XG4gICAgY29uc3QgZGlhZ1BhdHRlcm5TaXplID0gRElBR09OQUxfU0laRTtcbiAgICBjb25zdCBvcnRob2dvbmFsUGF0dGVybnMgPSBbXTtcbiAgICBjb25zdCBkaWFnb25hbFBhdHRlcm5zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDMsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgZGF0YVtpXSA9IDI1NTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBvcnRob2dvbmFsUGF0dGVybnMucHVzaChuZXcgUmF3SW1hZ2VEYXRhKFxuICAgICAgICBvcnRoUGF0dGVyblNpemUsXG4gICAgICAgIG9ydGhQYXR0ZXJuU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG9ydGhQYXR0ZXJuU2l6ZSAqIG9ydGhQYXR0ZXJuU2l6ZSAqIDIpLFxuICAgICAgICAyXG4gICAgICApKTtcbiAgICAgIGRpYWdvbmFsUGF0dGVybnMucHVzaChuZXcgUmF3SW1hZ2VEYXRhKFxuICAgICAgICBkaWFnUGF0dGVyblNpemUsXG4gICAgICAgIGRpYWdQYXR0ZXJuU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRpYWdQYXR0ZXJuU2l6ZSAqIGRpYWdQYXR0ZXJuU2l6ZSAqIDIpLFxuICAgICAgICAyXG4gICAgICApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgZ2VuZXJhdGVQYXR0ZXJucyhvcnRob2dvbmFsUGF0dGVybnMsIG9ydGhvZ29uYWxTdWJzYW1wbGluZ09mZnNldHNbaV0sIHRydWUpO1xuICAgICAgYXNzZW1ibGUoXG4gICAgICAgIDAsXG4gICAgICAgIDUgKiBPUlRIT0dPTkFMX1NJWkUgKiBpLFxuICAgICAgICBvcnRob2dvbmFsUGF0dGVybnMsXG4gICAgICAgIG9ydGhvZ29uYWxFZGdlcyxcbiAgICAgICAgT1JUSE9HT05BTF9TSVpFLFxuICAgICAgICB0cnVlLFxuICAgICAgICByZXN1bHRcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGlhZ29uYWxTdWJzYW1wbGluZ09mZnNldHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBnZW5lcmF0ZVBhdHRlcm5zKGRpYWdvbmFsUGF0dGVybnMsIGRpYWdvbmFsU3Vic2FtcGxpbmdPZmZzZXRzW2ldLCBmYWxzZSk7XG4gICAgICBhc3NlbWJsZShcbiAgICAgICAgNSAqIE9SVEhPR09OQUxfU0laRSxcbiAgICAgICAgNCAqIERJQUdPTkFMX1NJWkUgKiBpLFxuICAgICAgICBkaWFnb25hbFBhdHRlcm5zLFxuICAgICAgICBkaWFnb25hbEVkZ2VzLFxuICAgICAgICBESUFHT05BTF9TSVpFLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgcmVzdWx0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9TTUFBSW1hZ2VHZW5lcmF0b3IuanNcbmltcG9ydCB7IExvYWRpbmdNYW5hZ2VyIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHRtcC9zbWFhL3dvcmtlci50eHRcbnZhciB3b3JrZXJfZGVmYXVsdDIgPSAnXCJ1c2Ugc3RyaWN0XCI7KCgpPT57ZnVuY3Rpb24gcSh0LGEscyl7bGV0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxuPWUuZ2V0Q29udGV4dChcIjJkXCIpO2lmKGUud2lkdGg9dCxlLmhlaWdodD1hLHMgaW5zdGFuY2VvZiBJbWFnZSluLmRyYXdJbWFnZShzLDAsMCk7ZWxzZXtsZXQgcj1uLmNyZWF0ZUltYWdlRGF0YSh0LGEpO3IuZGF0YS5zZXQocyksbi5wdXRJbWFnZURhdGEociwwLDApfXJldHVybiBlfXZhciBGPWNsYXNzIHR7Y29uc3RydWN0b3IoYT0wLHM9MCxlPW51bGwpe3RoaXMud2lkdGg9YSx0aGlzLmhlaWdodD1zLHRoaXMuZGF0YT1lfXRvQ2FudmFzKCl7cmV0dXJuIHR5cGVvZiBkb2N1bWVudD09XCJ1bmRlZmluZWRcIj9udWxsOnEodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLmRhdGEpfXN0YXRpYyBmcm9tKGEpe2xldHt3aWR0aDpzLGhlaWdodDplfT1hLG47aWYoYSBpbnN0YW5jZW9mIEltYWdlKXtsZXQgcj1xKHMsZSxhKTtyIT09bnVsbCYmKG49ci5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsMCxzLGUpLmRhdGEpfWVsc2Ugbj1hLmRhdGE7cmV0dXJuIG5ldyB0KHMsZSxuKX19O3ZhciBNPVtuZXcgRmxvYXQzMkFycmF5KDIpLG5ldyBGbG9hdDMyQXJyYXkoMildLEQ9MTYsVz0yMCxJPTMwLGo9MzIsdj1uZXcgRmxvYXQzMkFycmF5KFswLC0uMjUsLjI1LC0uMTI1LC4xMjUsLS4zNzUsLjM3NV0pLE49W25ldyBGbG9hdDMyQXJyYXkoWzAsMF0pLG5ldyBGbG9hdDMyQXJyYXkoWy4yNSwtLjI1XSksbmV3IEZsb2F0MzJBcnJheShbLS4yNSwuMjVdKSxuZXcgRmxvYXQzMkFycmF5KFsuMTI1LC0uMTI1XSksbmV3IEZsb2F0MzJBcnJheShbLS4xMjUsLjEyNV0pXSx6PVtuZXcgVWludDhBcnJheShbMCwwXSksbmV3IFVpbnQ4QXJyYXkoWzMsMF0pLG5ldyBVaW50OEFycmF5KFswLDNdKSxuZXcgVWludDhBcnJheShbMywzXSksbmV3IFVpbnQ4QXJyYXkoWzEsMF0pLG5ldyBVaW50OEFycmF5KFs0LDBdKSxuZXcgVWludDhBcnJheShbMSwzXSksbmV3IFVpbnQ4QXJyYXkoWzQsM10pLG5ldyBVaW50OEFycmF5KFswLDFdKSxuZXcgVWludDhBcnJheShbMywxXSksbmV3IFVpbnQ4QXJyYXkoWzAsNF0pLG5ldyBVaW50OEFycmF5KFszLDRdKSxuZXcgVWludDhBcnJheShbMSwxXSksbmV3IFVpbnQ4QXJyYXkoWzQsMV0pLG5ldyBVaW50OEFycmF5KFsxLDRdKSxuZXcgVWludDhBcnJheShbNCw0XSldLHA9W25ldyBVaW50OEFycmF5KFswLDBdKSxuZXcgVWludDhBcnJheShbMSwwXSksbmV3IFVpbnQ4QXJyYXkoWzAsMl0pLG5ldyBVaW50OEFycmF5KFsxLDJdKSxuZXcgVWludDhBcnJheShbMiwwXSksbmV3IFVpbnQ4QXJyYXkoWzMsMF0pLG5ldyBVaW50OEFycmF5KFsyLDJdKSxuZXcgVWludDhBcnJheShbMywyXSksbmV3IFVpbnQ4QXJyYXkoWzAsMV0pLG5ldyBVaW50OEFycmF5KFsxLDFdKSxuZXcgVWludDhBcnJheShbMCwzXSksbmV3IFVpbnQ4QXJyYXkoWzEsM10pLG5ldyBVaW50OEFycmF5KFsyLDFdKSxuZXcgVWludDhBcnJheShbMywxXSksbmV3IFVpbnQ4QXJyYXkoWzIsM10pLG5ldyBVaW50OEFycmF5KFszLDNdKV07ZnVuY3Rpb24gQyh0LGEscyl7cmV0dXJuIHQrKGEtdCkqc31mdW5jdGlvbiBCKHQpe3JldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LDApLDEpfWZ1bmN0aW9uIF8odCl7bGV0IGE9TVswXSxzPU1bMV0sZT1NYXRoLnNxcnQoYVswXSoyKSouNSxuPU1hdGguc3FydChhWzFdKjIpKi41LHI9TWF0aC5zcXJ0KHNbMF0qMikqLjUsbz1NYXRoLnNxcnQoc1sxXSoyKSouNSxjPUIodC9qKTthWzBdPUMoZSxhWzBdLGMpLGFbMV09QyhuLGFbMV0sYyksc1swXT1DKHIsc1swXSxjKSxzWzFdPUMobyxzWzFdLGMpfWZ1bmN0aW9uIGQodCxhLHMsZSxuLHIpe2xldCBvPXMtdCxjPWUtYSxoPW4saT1uKzEsdz1hK2MqKGgtdCkvbyxiPWErYyooaS10KS9vO2lmKGg+PXQmJmg8c3x8aT50JiZpPD1zKWlmKE1hdGguc2lnbih3KT09PU1hdGguc2lnbihiKXx8TWF0aC5hYnModyk8MWUtNHx8TWF0aC5hYnMoYik8MWUtNCl7bGV0IGc9KHcrYikvMjtnPDA/KHJbMF09TWF0aC5hYnMoZyksclsxXT0wKTooclswXT0wLHJbMV09TWF0aC5hYnMoZykpfWVsc2V7bGV0IGc9LWEqby9jK3Qsaz1NYXRoLnRydW5jKGcpLG09Zz50P3cqKGctaykvMjowLFU9ZzxzP2IqKDEtKGctaykpLzI6MDsoTWF0aC5hYnMobSk+TWF0aC5hYnMoVSk/bTotVSk8MD8oclswXT1NYXRoLmFicyhtKSxyWzFdPU1hdGguYWJzKFUpKTooclswXT1NYXRoLmFicyhVKSxyWzFdPU1hdGguYWJzKG0pKX1lbHNlIHJbMF09MCxyWzFdPTA7cmV0dXJuIHJ9ZnVuY3Rpb24gSih0LGEscyxlLG4pe2xldCByPU1bMF0sbz1NWzFdLGM9LjUrZSxoPS41K2UtMSxpPWErcysxO3N3aXRjaCh0KXtjYXNlIDA6e25bMF09MCxuWzFdPTA7YnJlYWt9Y2FzZSAxOnthPD1zP2QoMCxoLGkvMiwwLGEsbik6KG5bMF09MCxuWzFdPTApO2JyZWFrfWNhc2UgMjp7YT49cz9kKGkvMiwwLGksaCxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDM6e2QoMCxoLGkvMiwwLGEsciksZChpLzIsMCxpLGgsYSxvKSxfKGksTSksblswXT1yWzBdK29bMF0sblsxXT1yWzFdK29bMV07YnJlYWt9Y2FzZSA0OnthPD1zP2QoMCxjLGkvMiwwLGEsbik6KG5bMF09MCxuWzFdPTApO2JyZWFrfWNhc2UgNTp7blswXT0wLG5bMV09MDticmVha31jYXNlIDY6e01hdGguYWJzKGUpPjA/KGQoMCxjLGksaCxhLHIpLGQoMCxjLGkvMiwwLGEsbyksZChpLzIsMCxpLGgsYSxuKSxvWzBdPW9bMF0rblswXSxvWzFdPW9bMV0rblsxXSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yKTpkKDAsYyxpLGgsYSxuKTticmVha31jYXNlIDc6e2QoMCxjLGksaCxhLG4pO2JyZWFrfWNhc2UgODp7YT49cz9kKGkvMiwwLGksYyxhLG4pOihuWzBdPTAsblsxXT0wKTticmVha31jYXNlIDk6e01hdGguYWJzKGUpPjA/KGQoMCxoLGksYyxhLHIpLGQoMCxoLGkvMiwwLGEsbyksZChpLzIsMCxpLGMsYSxuKSxvWzBdPW9bMF0rblswXSxvWzFdPW9bMV0rblsxXSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yKTpkKDAsaCxpLGMsYSxuKTticmVha31jYXNlIDEwOntuWzBdPTAsblsxXT0wO2JyZWFrfWNhc2UgMTE6e2QoMCxoLGksYyxhLG4pO2JyZWFrfWNhc2UgMTI6e2QoMCxjLGkvMiwwLGEsciksZChpLzIsMCxpLGMsYSxvKSxfKGksTSksblswXT1yWzBdK29bMF0sblsxXT1yWzFdK29bMV07YnJlYWt9Y2FzZSAxMzp7ZCgwLGgsaSxjLGEsbik7YnJlYWt9Y2FzZSAxNDp7ZCgwLGMsaSxoLGEsbik7YnJlYWt9Y2FzZSAxNTp7blswXT0wLG5bMV09MDticmVha319cmV0dXJuIG59ZnVuY3Rpb24gSyh0LGEscyxlLG4scil7bGV0IG89dD09PXMmJmE9PT1lO2lmKCFvKXtsZXQgYz0odCtzKS8yLGg9KGErZSkvMixpPWUtYSx3PXQtcztvPWkqKG4tYykrdyooci1oKT4wfXJldHVybiBvfWZ1bmN0aW9uIEcodCxhLHMsZSxuLHIpe2xldCBvPTA7Zm9yKGxldCBjPTA7YzxJOysrYylmb3IobGV0IGg9MDtoPEk7KytoKXtsZXQgaT1oLyhJLTEpLHc9Yy8oSS0xKTtLKHQsYSxzLGUsbitpLHIrdykmJisrb31yZXR1cm4gby8oSSpJKX1mdW5jdGlvbiBBKHQsYSxzLGUsbixyLG8sYyl7bGV0IGg9cFt0XSxpPWhbMF0sdz1oWzFdO3JldHVybiBpPjAmJihhKz1vWzBdLHMrPW9bMV0pLHc+MCYmKGUrPW9bMF0sbis9b1sxXSksY1swXT0xLUcoYSxzLGUsbiwxK3IsMCtyKSxjWzFdPUcoYSxzLGUsbiwxK3IsMStyKSxjfWZ1bmN0aW9uIFEodCxhLHMsZSxuKXtsZXQgcj1NWzBdLG89TVsxXSxjPWErcysxO3N3aXRjaCh0KXtjYXNlIDA6e0EodCwxLDEsMStjLDErYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgMTp7QSh0LDEsMCwwK2MsMCtjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAyOntBKHQsMCwwLDErYywwK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDM6e0EodCwxLDAsMStjLDArYyxhLGUsbik7YnJlYWt9Y2FzZSA0OntBKHQsMSwxLDArYywwK2MsYSxlLHIpLEEodCwxLDEsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDU6e0EodCwxLDEsMCtjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgNjp7QSh0LDEsMSwxK2MsMCtjLGEsZSxuKTticmVha31jYXNlIDc6e0EodCwxLDEsMStjLDArYyxhLGUsciksQSh0LDEsMCwxK2MsMCtjLGEsZSxvKSxuWzBdPShyWzBdK29bMF0pLzIsblsxXT0oclsxXStvWzFdKS8yO2JyZWFrfWNhc2UgODp7QSh0LDAsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywxK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSA5OntBKHQsMSwwLDErYywxK2MsYSxlLG4pLEEodCwxLDAsMStjLDErYyxhLGUsbik7YnJlYWt9Y2FzZSAxMDp7QSh0LDAsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxMTp7QSh0LDEsMCwxK2MsMStjLGEsZSxyKSxBKHQsMSwwLDErYywwK2MsYSxlLG8pLG5bMF09KHJbMF0rb1swXSkvMixuWzFdPShyWzFdK29bMV0pLzI7YnJlYWt9Y2FzZSAxMjp7QSh0LDEsMSwxK2MsMStjLGEsZSxuKTticmVha31jYXNlIDEzOntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDErYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE0OntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDEsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha31jYXNlIDE1OntBKHQsMSwxLDErYywxK2MsYSxlLHIpLEEodCwxLDAsMStjLDArYyxhLGUsbyksblswXT0oclswXStvWzBdKS8yLG5bMV09KHJbMV0rb1sxXSkvMjticmVha319cmV0dXJuIG59ZnVuY3Rpb24gUih0LGEscyl7bGV0IGU9bmV3IEZsb2F0MzJBcnJheSgyKTtmb3IobGV0IG49MCxyPXQubGVuZ3RoO248cjsrK24pe2xldCBvPXRbbl0sYz1vLmRhdGEsaD1vLndpZHRoO2ZvcihsZXQgaT0wO2k8aDsrK2kpZm9yKGxldCB3PTA7dzxoOysrdyl7cz9KKG4sdyxpLGEsZSk6UShuLHcsaSxhLGUpO2xldCBiPShpKmgrdykqMjtjW2JdPWVbMF0qMjU1LGNbYisxXT1lWzFdKjI1NX19fWZ1bmN0aW9uIFQodCxhLHMsZSxuLHIsbyl7bGV0IGM9by5kYXRhLGg9by53aWR0aDtmb3IobGV0IGk9MCx3PXMubGVuZ3RoO2k8dzsrK2kpe2xldCBiPWVbaV0sZz1zW2ldLGs9Zy5kYXRhLG09Zy53aWR0aDtmb3IobGV0IFU9MDtVPG47KytVKWZvcihsZXQgeD0wO3g8bjsrK3gpe2xldCBaPWJbMF0qbit0K3gsTz0oKGJbMV0qbithK1UpKmgrWikqNCxMPXI/KFUqVSptK3gqeCkqMjooVSptK3gpKjI7Y1tPXT1rW0xdLGNbTysxXT1rW0wrMV0sY1tPKzJdPTAsY1tPKzNdPTI1NX19fXZhciBTPWNsYXNze3N0YXRpYyBnZW5lcmF0ZSgpe2xldCBhPTEwKkQscz12Lmxlbmd0aCo1KkQsZT1uZXcgVWludDhDbGFtcGVkQXJyYXkoYSpzKjQpLG49bmV3IEYoYSxzLGUpLHI9TWF0aC5wb3coRC0xLDIpKzEsbz1XLGM9W10saD1bXTtmb3IobGV0IGk9Myx3PWUubGVuZ3RoO2k8dztpKz00KWVbaV09MjU1O2ZvcihsZXQgaT0wO2k8MTY7KytpKWMucHVzaChuZXcgRihyLHIsbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHIqcioyKSwyKSksaC5wdXNoKG5ldyBGKG8sbyxuZXcgVWludDhDbGFtcGVkQXJyYXkobypvKjIpLDIpKTtmb3IobGV0IGk9MCx3PXYubGVuZ3RoO2k8dzsrK2kpUihjLHZbaV0sITApLFQoMCw1KkQqaSxjLHosRCwhMCxuKTtmb3IobGV0IGk9MCx3PU4ubGVuZ3RoO2k8dzsrK2kpUihoLE5baV0sITEpLFQoNSpELDQqVyppLGgscCxXLCExLG4pO3JldHVybiBufX07dmFyIFA9bmV3IE1hcChbW3koMCwwLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMF0pXSxbeSgwLDAsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDAsMCwxXSldLFt5KDAsMCwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwxLDBdKV0sW3koMCwwLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMCwwLDEsMV0pXSxbeSgwLDEsMCwwKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMCwwXSldLFt5KDAsMSwwLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzAsMSwwLDFdKV0sW3koMCwxLDEsMCksbmV3IEZsb2F0MzJBcnJheShbMCwxLDEsMF0pXSxbeSgwLDEsMSwxKSxuZXcgRmxvYXQzMkFycmF5KFswLDEsMSwxXSldLFt5KDEsMCwwLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDBdKV0sW3koMSwwLDAsMSksbmV3IEZsb2F0MzJBcnJheShbMSwwLDAsMV0pXSxbeSgxLDAsMSwwKSxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMSwwXSldLFt5KDEsMCwxLDEpLG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwxLDFdKV0sW3koMSwxLDAsMCksbmV3IEZsb2F0MzJBcnJheShbMSwxLDAsMF0pXSxbeSgxLDEsMCwxKSxuZXcgRmxvYXQzMkFycmF5KFsxLDEsMCwxXSldLFt5KDEsMSwxLDApLG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxLDBdKV0sW3koMSwxLDEsMSksbmV3IEZsb2F0MzJBcnJheShbMSwxLDEsMV0pXV0pO2Z1bmN0aW9uIEgodCxhLHMpe3JldHVybiB0KyhhLXQpKnN9ZnVuY3Rpb24geSh0LGEscyxlKXtsZXQgbj1IKHQsYSwuNzUpLHI9SChzLGUsMS0uMjUpO3JldHVybiBIKG4sciwxLS4xMjUpfWZ1bmN0aW9uIFYodCxhKXtsZXQgcz0wO3JldHVybiBhWzNdPT09MSYmKHMrPTEpLHM9PT0xJiZhWzJdPT09MSYmdFsxXSE9PTEmJnRbM10hPT0xJiYocys9MSksc31mdW5jdGlvbiAkKHQsYSl7bGV0IHM9MDtyZXR1cm4gYVszXT09PTEmJnRbMV0hPT0xJiZ0WzNdIT09MSYmKHMrPTEpLHM9PT0xJiZhWzJdPT09MSYmdFswXSE9PTEmJnRbMl0hPT0xJiYocys9MSksc312YXIgRT1jbGFzc3tzdGF0aWMgZ2VuZXJhdGUoKXtsZXQgbz1uZXcgVWludDhDbGFtcGVkQXJyYXkoMjE3OCksYz1uZXcgVWludDhDbGFtcGVkQXJyYXkoNjQqMTYqNCk7Zm9yKGxldCBoPTA7aDwzMzsrK2gpZm9yKGxldCBpPTA7aTw2NjsrK2kpe2xldCB3PS4wMzEyNSppLGI9LjAzMTI1Kmg7aWYoUC5oYXModykmJlAuaGFzKGIpKXtsZXQgZz1QLmdldCh3KSxrPVAuZ2V0KGIpLG09aCo2NitpO29bbV09MTI3KlYoZyxrKSxvW20rMzNdPTEyNyokKGcsayl9fWZvcihsZXQgaD0wLGk9MTc7aTwzMzsrK2kpZm9yKGxldCB3PTA7dzw2NDsrK3csaCs9NCljW2hdPW9baSo2Nit3XSxjW2grM109MjU1O3JldHVybiBuZXcgRig2NCwxNixjKX19O3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0PT57bGV0IGE9Uy5nZW5lcmF0ZSgpLHM9RS5nZW5lcmF0ZSgpO3Bvc3RNZXNzYWdlKHthcmVhSW1hZ2VEYXRhOmEsc2VhcmNoSW1hZ2VEYXRhOnN9LFthLmRhdGEuYnVmZmVyLHMuZGF0YS5idWZmZXJdKSxjbG9zZSgpfSk7fSkoKTtcXG4nO1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9TTUFBSW1hZ2VHZW5lcmF0b3IuanNcbmZ1bmN0aW9uIGdlbmVyYXRlKHVzZUNhY2hlID0gdHJ1ZSkge1xuICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJfZGVmYXVsdDJdLCB7XG4gICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIlxuICB9KSk7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbiAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiByZWplY3QoZXZlbnQuZXJyb3IpKTtcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hJbWFnZURhdGEgPSBSYXdJbWFnZURhdGEuZnJvbShldmVudC5kYXRhLnNlYXJjaEltYWdlRGF0YSk7XG4gICAgICBjb25zdCBhcmVhSW1hZ2VEYXRhID0gUmF3SW1hZ2VEYXRhLmZyb20oZXZlbnQuZGF0YS5hcmVhSW1hZ2VEYXRhKTtcbiAgICAgIGNvbnN0IHVybHMgPSBbXG4gICAgICAgIHNlYXJjaEltYWdlRGF0YS50b0NhbnZhcygpLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiLCAxKSxcbiAgICAgICAgYXJlYUltYWdlRGF0YS50b0NhbnZhcygpLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiLCAxKVxuICAgICAgXTtcbiAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNtYWEtc2VhcmNoXCIsIHVybHNbMF0pO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNtYWEtYXJlYVwiLCB1cmxzWzFdKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUodXJscyk7XG4gICAgfSk7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKG51bGwpO1xuICB9KTtcbn1cbnZhciBTTUFBSW1hZ2VHZW5lcmF0b3IgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNNQUEgaW1hZ2UgZ2VuZXJhdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaXNhYmxlQ2FjaGUgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBjYWNoaW5nIHZpYSBsb2NhbFN0b3JhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgLSBXaGV0aGVyIHRoZSBjYWNoZSBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldENhY2hlRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuZGlzYWJsZUNhY2hlID0gIXZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFNNQUEgZGF0YSBpbWFnZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFNNQUFJbWFnZUdlbmVyYXRvci5nZW5lcmF0ZSgpLnRoZW4oKFtzZWFyY2gsIGFyZWFdKSA9PiB7XG4gICAqICAgY29uc3Qgc21hYUVmZmVjdCA9IG5ldyBTTUFBRWZmZWN0KHNlYXJjaCwgYXJlYSk7XG4gICAqIH0pO1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEltYWdlW10+fSBBIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBzZWFyY2ggaW1hZ2UgYW5kIGFyZWEgaW1hZ2UgYXMgYSBwYWlyLlxuICAgKi9cbiAgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgdXNlQ2FjaGUgPSAhdGhpcy5kaXNhYmxlQ2FjaGUgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IGNhY2hlZFVSTHMgPSB1c2VDYWNoZSA/IFtcbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic21hYS1zZWFyY2hcIiksXG4gICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNtYWEtYXJlYVwiKVxuICAgIF0gOiBbbnVsbCwgbnVsbF07XG4gICAgY29uc3QgcHJvbWlzZSA9IGNhY2hlZFVSTHNbMF0gIT09IG51bGwgJiYgY2FjaGVkVVJMc1sxXSAhPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZShjYWNoZWRVUkxzKSA6IGdlbmVyYXRlKHVzZUNhY2hlKTtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKCh1cmxzKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBzZWFyY2hJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBhcmVhSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuICAgICAgICBtYW5hZ2VyLm9uTG9hZCA9ICgpID0+IHJlc29sdmUoW3NlYXJjaEltYWdlLCBhcmVhSW1hZ2VdKTtcbiAgICAgICAgbWFuYWdlci5vbkVycm9yID0gcmVqZWN0O1xuICAgICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IG1hbmFnZXIuaXRlbUVycm9yKFwic21hYS1zZWFyY2hcIikpO1xuICAgICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiBtYW5hZ2VyLml0ZW1FcnJvcihcInNtYWEtYXJlYVwiKSk7XG4gICAgICAgIHNlYXJjaEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IG1hbmFnZXIuaXRlbUVuZChcInNtYWEtc2VhcmNoXCIpKTtcbiAgICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IG1hbmFnZXIuaXRlbUVuZChcInNtYWEtYXJlYVwiKSk7XG4gICAgICAgIG1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1zZWFyY2hcIik7XG4gICAgICAgIG1hbmFnZXIuaXRlbVN0YXJ0KFwic21hYS1hcmVhXCIpO1xuICAgICAgICBzZWFyY2hJbWFnZS5zcmMgPSB1cmxzWzBdO1xuICAgICAgICBhcmVhSW1hZ2Uuc3JjID0gdXJsc1sxXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdGV4dHVyZXMvc21hYS9TTUFBU2VhcmNoSW1hZ2VEYXRhLmpzXG52YXIgZWRnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtiaWxpbmVhcigwLCAwLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDAsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMCwgMCwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigwLCAwLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMV0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDAsIDApLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAwLCAwXSldLFxuICBbYmlsaW5lYXIoMCwgMSwgMCwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDAsIDFdKV0sXG4gIFtiaWxpbmVhcigwLCAxLCAxLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMSwgMF0pXSxcbiAgW2JpbGluZWFyKDAsIDEsIDEsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMCwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAwLCAwLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pXSxcbiAgW2JpbGluZWFyKDEsIDAsIDEsIDApLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAxLCAwXSldLFxuICBbYmlsaW5lYXIoMSwgMCwgMSwgMSksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDEsIDFdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAwLCAwKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMCwgMF0pXSxcbiAgW2JpbGluZWFyKDEsIDEsIDAsIDEpLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLCAxXSldLFxuICBbYmlsaW5lYXIoMSwgMSwgMSwgMCksIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDBdKV0sXG4gIFtiaWxpbmVhcigxLCAxLCAxLCAxKSwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pXVxuXSk7XG5mdW5jdGlvbiBsZXJwMihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5mdW5jdGlvbiBiaWxpbmVhcihlMCwgZTEsIGUyLCBlMykge1xuICBjb25zdCBhID0gbGVycDIoZTAsIGUxLCAxIC0gMC4yNSk7XG4gIGNvbnN0IGIgPSBsZXJwMihlMiwgZTMsIDEgLSAwLjI1KTtcbiAgcmV0dXJuIGxlcnAyKGEsIGIsIDEgLSAwLjEyNSk7XG59XG5mdW5jdGlvbiBkZWx0YUxlZnQobGVmdCwgdG9wKSB7XG4gIGxldCBkID0gMDtcbiAgaWYgKHRvcFszXSA9PT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICBpZiAoZCA9PT0gMSAmJiB0b3BbMl0gPT09IDEgJiYgbGVmdFsxXSAhPT0gMSAmJiBsZWZ0WzNdICE9PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gZGVsdGFSaWdodChsZWZ0LCB0b3ApIHtcbiAgbGV0IGQgPSAwO1xuICBpZiAodG9wWzNdID09PSAxICYmIGxlZnRbMV0gIT09IDEgJiYgbGVmdFszXSAhPT0gMSkge1xuICAgIGQgKz0gMTtcbiAgfVxuICBpZiAoZCA9PT0gMSAmJiB0b3BbMl0gPT09IDEgJiYgbGVmdFswXSAhPT0gMSAmJiBsZWZ0WzJdICE9PSAxKSB7XG4gICAgZCArPSAxO1xuICB9XG4gIHJldHVybiBkO1xufVxudmFyIFNNQUFTZWFyY2hJbWFnZURhdGEgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHNlYXJjaCBpbWFnZS5cbiAgICpcbiAgICogQHJldHVybiB7UmF3SW1hZ2VEYXRhfSBUaGUgZ2VuZXJhdGVkIGltYWdlIGRhdGEuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSA2NjtcbiAgICBjb25zdCBoZWlnaHQgPSAzMztcbiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgY29uc3QgY3JvcHBlZFdpZHRoID0gNjQ7XG4gICAgY29uc3QgY3JvcHBlZEhlaWdodCA9IDE2O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgIGNvbnN0IGNyb3BwZWREYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGNyb3BwZWRXaWR0aCAqIGNyb3BwZWRIZWlnaHQgKiA0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcyA9IDAuMDMxMjUgKiB4O1xuICAgICAgICBjb25zdCB0ID0gMC4wMzEyNSAqIHk7XG4gICAgICAgIGlmIChlZGdlcy5oYXMocykgJiYgZWRnZXMuaGFzKHQpKSB7XG4gICAgICAgICAgY29uc3QgZTEgPSBlZGdlcy5nZXQocyk7XG4gICAgICAgICAgY29uc3QgZTIgPSBlZGdlcy5nZXQodCk7XG4gICAgICAgICAgY29uc3QgaSA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgZGF0YVtpXSA9IDEyNyAqIGRlbHRhTGVmdChlMSwgZTIpO1xuICAgICAgICAgIGRhdGFbaSArIGhhbGZXaWR0aF0gPSAxMjcgKiBkZWx0YVJpZ2h0KGUxLCBlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIHkgPSBoZWlnaHQgLSBjcm9wcGVkSGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY3JvcHBlZFdpZHRoOyArK3gsIGkgKz0gNCkge1xuICAgICAgICBjcm9wcGVkRGF0YVtpXSA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgIGNyb3BwZWREYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYXdJbWFnZURhdGEoY3JvcHBlZFdpZHRoLCBjcm9wcGVkSGVpZ2h0LCBjcm9wcGVkRGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy90ZXh0dXJlcy9Ob2lzZVRleHR1cmUuanNcbmltcG9ydCB7XG4gIERhdGFUZXh0dXJlIGFzIERhdGFUZXh0dXJlMixcbiAgTHVtaW5hbmNlRm9ybWF0LFxuICBSZWRGb3JtYXQsXG4gIFJHRm9ybWF0LFxuICBSR0JBRm9ybWF0IGFzIFJHQkFGb3JtYXQyLFxuICBVbnNpZ25lZEJ5dGVUeXBlIGFzIFVuc2lnbmVkQnl0ZVR5cGUxNFxufSBmcm9tIFwidGhyZWVcIjtcbmZ1bmN0aW9uIGdldE5vaXNlKHNpemUsIGZvcm1hdCwgdHlwZSkge1xuICBjb25zdCBjaGFubmVscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbTHVtaW5hbmNlRm9ybWF0LCAxXSxcbiAgICBbUmVkRm9ybWF0LCAxXSxcbiAgICBbUkdGb3JtYXQsIDJdLFxuICAgIFtSR0JBRm9ybWF0MiwgNF1cbiAgXSk7XG4gIGxldCBkYXRhO1xuICBpZiAoIWNoYW5uZWxzLmhhcyhmb3JtYXQpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgbm9pc2UgdGV4dHVyZSBmb3JtYXRcIik7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUxNCkge1xuICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1ICsgMC41O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogY2hhbm5lbHMuZ2V0KGZvcm1hdCkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbnZhciBOb2lzZVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIERhdGFUZXh0dXJlMiB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vaXNlIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSB0ZXh0dXJlIGZvcm1hdCBjYW4gYmUgZWl0aGVyIGBMdW1pbmFuY2VGb3JtYXRgIG9yIGBSR0JBRm9ybWF0YC4gQWRkaXRpb25hbGx5LCB0aGUgZm9ybWF0cyBgUmVkRm9ybWF0YCBhbmRcbiAgICogYFJHRm9ybWF0YCBjYW4gYmUgdXNlZCBpbiBhIFdlYkdMIDIgY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmb3JtYXQ9THVtaW5hbmNlRm9ybWF0XSAtIFRoZSB0ZXh0dXJlIGZvcm1hdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0eXBlPVVuc2lnbmVkQnl0ZVR5cGVdIC0gVGhlIHRleHR1cmUgdHlwZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCA9IEx1bWluYW5jZUZvcm1hdCwgdHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGUxNCkge1xuICAgIHN1cGVyKGdldE5vaXNlKHdpZHRoICogaGVpZ2h0LCBmb3JtYXQsIHR5cGUpLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dsaXRjaC5mcmFnXG52YXIgZ2xpdGNoX2RlZmF1bHQgPSBcInVuaWZvcm0gbG93cCBzYW1wbGVyMkQgcGVydHVyYmF0aW9uTWFwO3VuaWZvcm0gYm9vbCBhY3RpdmU7dW5pZm9ybSBmbG9hdCBjb2x1bW5zO3VuaWZvcm0gZmxvYXQgcmFuZG9tO3VuaWZvcm0gdmVjMiBzZWVkczt1bmlmb3JtIHZlYzIgZGlzdG9ydGlvbjt2b2lkIG1haW5Vdihpbm91dCB2ZWMyIHV2KXtpZihhY3RpdmUpe2lmKHV2Lnk8ZGlzdG9ydGlvbi54K2NvbHVtbnMmJnV2Lnk+ZGlzdG9ydGlvbi54LWNvbHVtbnMqcmFuZG9tKXtmbG9hdCBzeD1jbGFtcChjZWlsKHNlZWRzLngpLDAuMCwxLjApO3V2Lnk9c3gqKDEuMC0odXYueStkaXN0b3J0aW9uLnkpKSsoMS4wLXN4KSpkaXN0b3J0aW9uLnk7fWlmKHV2Lng8ZGlzdG9ydGlvbi55K2NvbHVtbnMmJnV2Lng+ZGlzdG9ydGlvbi55LWNvbHVtbnMqcmFuZG9tKXtmbG9hdCBzeT1jbGFtcChjZWlsKHNlZWRzLnkpLDAuMCwxLjApO3V2Lng9c3kqZGlzdG9ydGlvbi54KygxLjAtc3kpKigxLjAtKHV2LngrZGlzdG9ydGlvbi54KSk7fXZlYzIgbm9ybWFsPXRleHR1cmUyRChwZXJ0dXJiYXRpb25NYXAsdXYqcmFuZG9tKnJhbmRvbSkucmc7dXYrPW5vcm1hbCpzZWVkcyoocmFuZG9tKjAuMik7fX1cIjtcblxuLy8gc3JjL2VmZmVjdHMvR2xpdGNoRWZmZWN0LmpzXG52YXIgdGV4dHVyZVRhZyA9IFwiR2xpdGNoLkdlbmVyYXRlZFwiO1xuZnVuY3Rpb24gcmFuZG9tRmxvYXQobG93LCBoaWdoKSB7XG4gIHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpO1xufVxudmFyIEdsaXRjaEVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ2xpdGNoIGVmZmVjdC5cbiAgICpcbiAgICogVE9ETyBDaGFuZ2UgcmF0aW8gdG8gMC4xNS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXRdIC0gQSBjaHJvbWF0aWMgYWJlcnJhdGlvbiBvZmZzZXQuIElmIHByb3ZpZGVkLCB0aGUgZ2xpdGNoIGVmZmVjdCB3aWxsIGluZmx1ZW5jZSB0aGlzIG9mZnNldC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5kZWxheV0gLSBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucyBpbiBzZWNvbmRzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLmR1cmF0aW9uXSAtIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGR1cmF0aW9uIG9mIGEgZ2xpdGNoIGluIHNlY29uZHMuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMuc3RyZW5ndGhdIC0gVGhlIHN0cmVuZ3RoIG9mIHdlYWsgYW5kIHN0cm9uZyBnbGl0Y2hlcy5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy5wZXJ0dXJiYXRpb25NYXBdIC0gQSBwZXJ0dXJiYXRpb24gbWFwLiBJZiBub25lIGlzIHByb3ZpZGVkLCBhIG5vaXNlIHRleHR1cmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHRTaXplPTY0XSAtIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgbm9pc2UgbWFwLiBXaWxsIGJlIGlnbm9yZWQgaWYgYSBwZXJ0dXJiYXRpb24gbWFwIGlzIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sdW1ucz0wLjA1XSAtIFRoZSBzY2FsZSBvZiB0aGUgYmxvY2t5IGdsaXRjaCBjb2x1bW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmF0aW89MC44NV0gLSBUaGUgdGhyZXNob2xkIGZvciBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCA9IG51bGwsXG4gICAgZGVsYXkgPSBuZXcgVmVjdG9yMjIwKDEuNSwgMy41KSxcbiAgICBkdXJhdGlvbiA9IG5ldyBWZWN0b3IyMjAoMC42LCAxKSxcbiAgICBzdHJlbmd0aCA9IG5ldyBWZWN0b3IyMjAoMC4zLCAxKSxcbiAgICBjb2x1bW5zID0gMC4wNSxcbiAgICByYXRpbyA9IDAuODUsXG4gICAgcGVydHVyYmF0aW9uTWFwID0gbnVsbCxcbiAgICBkdFNpemUgPSA2NFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIkdsaXRjaEVmZmVjdFwiLCBnbGl0Y2hfZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wicGVydHVyYmF0aW9uTWFwXCIsIG5ldyBVbmlmb3JtMzIobnVsbCldLFxuICAgICAgICBbXCJjb2x1bW5zXCIsIG5ldyBVbmlmb3JtMzIoY29sdW1ucyldLFxuICAgICAgICBbXCJhY3RpdmVcIiwgbmV3IFVuaWZvcm0zMihmYWxzZSldLFxuICAgICAgICBbXCJyYW5kb21cIiwgbmV3IFVuaWZvcm0zMigxKV0sXG4gICAgICAgIFtcInNlZWRzXCIsIG5ldyBVbmlmb3JtMzIobmV3IFZlY3RvcjIyMCgpKV0sXG4gICAgICAgIFtcImRpc3RvcnRpb25cIiwgbmV3IFVuaWZvcm0zMihuZXcgVmVjdG9yMjIwKCkpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICBpZiAocGVydHVyYmF0aW9uTWFwID09PSBudWxsKSB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgTm9pc2VUZXh0dXJlKGR0U2l6ZSwgZHRTaXplLCBSR0JBRm9ybWF0Myk7XG4gICAgICBtYXAubmFtZSA9IHRleHR1cmVUYWc7XG4gICAgICB0aGlzLnBlcnR1cmJhdGlvbk1hcCA9IG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wZXJ0dXJiYXRpb25NYXAgPSBwZXJ0dXJiYXRpb25NYXA7XG4gICAgfVxuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5kaXN0b3J0aW9uID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJkaXN0b3J0aW9uXCIpLnZhbHVlO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5icmVha1BvaW50ID0gbmV3IFZlY3RvcjIyMChcbiAgICAgIHJhbmRvbUZsb2F0KHRoaXMuZGVsYXkueCwgdGhpcy5kZWxheS55KSxcbiAgICAgIHJhbmRvbUZsb2F0KHRoaXMuZHVyYXRpb24ueCwgdGhpcy5kdXJhdGlvbi55KVxuICAgICk7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHN0cmVuZ3RoO1xuICAgIHRoaXMubW9kZSA9IEdsaXRjaE1vZGUuU1BPUkFESUM7XG4gICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xuICAgIHRoaXMuY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCA9IGNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJhbmRvbSBudW1iZXIgc2VlZHMuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IHNlZWRzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInNlZWRzXCIpLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZ2xpdGNoIGVmZmVjdCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZ2xpdGNoIGVmZmVjdCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWN0aXZlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGdsaXRjaCBlZmZlY3QgaXMgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5EZWxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxheS54O1xuICB9XG4gIHNldCBtaW5EZWxheSh2YWx1ZSkge1xuICAgIHRoaXMuZGVsYXkueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIGRlbGF5IGJldHdlZW4gZ2xpdGNoIGFjdGl2YXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluRGVsYXkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWluaW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZ2V0TWluRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkRlbGF5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIGRlbGF5IGluIHNlY29uZHMuXG4gICAqL1xuICBzZXRNaW5EZWxheSh2YWx1ZSkge1xuICAgIHRoaXMuZGVsYXkueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtYXhEZWxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxheS55O1xuICB9XG4gIHNldCBtYXhEZWxheSh2YWx1ZSkge1xuICAgIHRoaXMuZGVsYXkueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gZ2xpdGNoIGFjdGl2YXRpb25zLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4RGVsYXkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWF4aW11bSBkZWxheSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZ2V0TWF4RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXkueTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIGdsaXRjaCBhY3RpdmF0aW9ucy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heERlbGF5IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtYXhpbXVtIGRlbGF5IGluIHNlY29uZHMuXG4gICAqL1xuICBzZXRNYXhEZWxheSh2YWx1ZSkge1xuICAgIHRoaXMuZGVsYXkueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5EdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbi54O1xuICB9XG4gIHNldCBtaW5EdXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuZHVyYXRpb24ueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIGR1cmF0aW9uIG9mIHNwb3JhZGljIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluRHVyYXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWluaW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZ2V0TWluRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1pbkR1cmF0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAqL1xuICBzZXRNaW5EdXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuZHVyYXRpb24ueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtYXhEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbi55O1xuICB9XG4gIHNldCBtYXhEdXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuZHVyYXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGR1cmF0aW9uIG9mIHNwb3JhZGljIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF4RHVyYXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWF4aW11bSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgZ2V0TWF4RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24ueTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBkdXJhdGlvbiBvZiBzcG9yYWRpYyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heER1cmF0aW9uIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBtYXhpbXVtIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAqL1xuICBzZXRNYXhEdXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuZHVyYXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RyZW5ndGggb2Ygd2VhayBnbGl0Y2hlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaW5TdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC54O1xuICB9XG4gIHNldCBtaW5TdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuc3RyZW5ndGgueCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJlbmd0aCBvZiB3ZWFrIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluU3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3RyZW5ndGguXG4gICAqL1xuICBnZXRNaW5TdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC54O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB3ZWFrIGdsaXRjaGVzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWluU3RyZW5ndGggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHN0cmVuZ3RoLlxuICAgKi9cbiAgc2V0TWluU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnN0cmVuZ3RoLnggPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cmVuZ3RoIG9mIHN0cm9uZyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtYXhTdHJlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlbmd0aC55O1xuICB9XG4gIHNldCBtYXhTdHJlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMuc3RyZW5ndGgueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJlbmd0aCBvZiBzdHJvbmcgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXhTdHJlbmd0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIGdldE1heFN0cmVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHN0cm9uZyBnbGl0Y2hlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1heFN0cmVuZ3RoIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBzdHJlbmd0aC5cbiAgICovXG4gIHNldE1heFN0cmVuZ3RoKHZhbHVlKSB7XG4gICAgdGhpcy5zdHJlbmd0aC55ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZ2xpdGNoIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0dsaXRjaE1vZGV9IFRoZSBtb2RlLlxuICAgKi9cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGdsaXRjaCBtb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbW9kZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0dsaXRjaE1vZGV9IHZhbHVlIC0gVGhlIG1vZGUuXG4gICAqL1xuICBzZXRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdsaXRjaCByYXRpby5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJhdGlvIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJhdGlvLlxuICAgKi9cbiAgZ2V0R2xpdGNoUmF0aW8oKSB7XG4gICAgcmV0dXJuIDEgLSB0aGlzLnJhdGlvO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYXRpbyBvZiB3ZWFrICgwLjApIGFuZCBzdHJvbmcgKDEuMCkgZ2xpdGNoZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByYXRpbyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgcmF0aW8uIFJhbmdlIGlzIFswLjAsIDEuMF0uXG4gICAqL1xuICBzZXRHbGl0Y2hSYXRpbyh2YWx1ZSkge1xuICAgIHRoaXMucmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgxIC0gdmFsdWUsIDApLCAxKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImNvbHVtbnNcIikudmFsdWU7XG4gIH1cbiAgc2V0IGNvbHVtbnModmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImNvbHVtbnNcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2xpdGNoIGNvbHVtbiBzaXplLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sdW1ucyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBnbGl0Y2ggY29sdW1uIHNpemUuXG4gICAqL1xuICBnZXRHbGl0Y2hDb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbnM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbHVtbnMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGdsaXRjaCBjb2x1bW4gc2l6ZS5cbiAgICovXG4gIHNldEdsaXRjaENvbHVtbnModmFsdWUpIHtcbiAgICB0aGlzLmNvbHVtbnMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hyb21hdGljIGFiZXJyYXRpb24gb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgZ2V0Q2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjaHJvbWF0aWMgYWJlcnJhdGlvbiBvZmZzZXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjaHJvbWF0aWNBYmVycmF0aW9uT2Zmc2V0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdmFsdWUgLSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgc2V0Q2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuY2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGVydHVyYmF0aW9uIG1hcC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgcGVydHVyYmF0aW9uTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInBlcnR1cmJhdGlvbk1hcFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgcGVydHVyYmF0aW9uTWFwKHZhbHVlKSB7XG4gICAgY29uc3QgY3VycmVudE1hcCA9IHRoaXMucGVydHVyYmF0aW9uTWFwO1xuICAgIGlmIChjdXJyZW50TWFwICE9PSBudWxsICYmIGN1cnJlbnRNYXAubmFtZSA9PT0gdGV4dHVyZVRhZykge1xuICAgICAgY3VycmVudE1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHZhbHVlLm1pbkZpbHRlciA9IHZhbHVlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI2O1xuICAgIHZhbHVlLndyYXBTID0gdmFsdWUud3JhcFQgPSBSZXBlYXRXcmFwcGluZztcbiAgICB2YWx1ZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInBlcnR1cmJhdGlvbk1hcFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwZXJ0dXJiYXRpb25NYXAgaW5zdGVhZC5cbiAgICogQHJldHVybiB7VGV4dHVyZX0gVGhlIGN1cnJlbnQgcGVydHVyYmF0aW9uIG1hcC5cbiAgICovXG4gIGdldFBlcnR1cmJhdGlvbk1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJ0dXJiYXRpb25NYXA7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHBlcnR1cmJhdGlvbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuICAgKlxuICAgKiBUaGUgY3VycmVudCBtYXAgd2lsbCBiZSBkaXNwb3NlZCBpZiBpdCB3YXMgZ2VuZXJhdGVkIGJ5IHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGVydHVyYmF0aW9uTWFwIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgbmV3IHBlcnR1cmJhdGlvbiBtYXAuXG4gICAqL1xuICBzZXRQZXJ0dXJiYXRpb25NYXAodmFsdWUpIHtcbiAgICB0aGlzLnBlcnR1cmJhdGlvbk1hcCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgTm9pc2VUZXh0dXJlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdmFsdWU9NjRdIC0gVGhlIHRleHR1cmUgc2l6ZS5cbiAgICogQHJldHVybiB7RGF0YVRleHR1cmV9IFRoZSBwZXJ0dXJiYXRpb24gbWFwLlxuICAgKi9cbiAgZ2VuZXJhdGVQZXJ0dXJiYXRpb25NYXAodmFsdWUgPSA2NCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBOb2lzZVRleHR1cmUodmFsdWUsIHZhbHVlLCBSR0JBRm9ybWF0Myk7XG4gICAgbWFwLm5hbWUgPSB0ZXh0dXJlVGFnO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgY29uc3QgYnJlYWtQb2ludCA9IHRoaXMuYnJlYWtQb2ludDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQ7XG4gICAgY29uc3QgcyA9IHRoaXMuc3RyZW5ndGg7XG4gICAgbGV0IHRpbWUgPSB0aGlzLnRpbWU7XG4gICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuICAgIGxldCByID0gMCwgYSA9IDA7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKG1vZGUgIT09IEdsaXRjaE1vZGUuRElTQUJMRUQpIHtcbiAgICAgIGlmIChtb2RlID09PSBHbGl0Y2hNb2RlLlNQT1JBRElDKSB7XG4gICAgICAgIHRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICB0cmlnZ2VyID0gdGltZSA+IGJyZWFrUG9pbnQueDtcbiAgICAgICAgaWYgKHRpbWUgPj0gYnJlYWtQb2ludC54ICsgYnJlYWtQb2ludC55KSB7XG4gICAgICAgICAgYnJlYWtQb2ludC5zZXQoXG4gICAgICAgICAgICByYW5kb21GbG9hdCh0aGlzLmRlbGF5LngsIHRoaXMuZGVsYXkueSksXG4gICAgICAgICAgICByYW5kb21GbG9hdCh0aGlzLmR1cmF0aW9uLngsIHRoaXMuZHVyYXRpb24ueSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicmFuZG9tXCIpLnZhbHVlID0gcjtcbiAgICAgIGlmICh0cmlnZ2VyICYmIHIgPiB0aGlzLnJhdGlvIHx8IG1vZGUgPT09IEdsaXRjaE1vZGUuQ09OU1RBTlRfV0lMRCkge1xuICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICByICo9IHMueSAqIDAuMDM7XG4gICAgICAgIGEgPSByYW5kb21GbG9hdCgtTWF0aC5QSSwgTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuc2VlZHMuc2V0KHJhbmRvbUZsb2F0KC1zLnksIHMueSksIHJhbmRvbUZsb2F0KC1zLnksIHMueSkpO1xuICAgICAgICB0aGlzLmRpc3RvcnRpb24uc2V0KHJhbmRvbUZsb2F0KDAsIDEpLCByYW5kb21GbG9hdCgwLCAxKSk7XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgfHwgbW9kZSA9PT0gR2xpdGNoTW9kZS5DT05TVEFOVF9NSUxEKSB7XG4gICAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHIgKj0gcy54ICogMC4wMztcbiAgICAgICAgYSA9IHJhbmRvbUZsb2F0KC1NYXRoLlBJLCBNYXRoLlBJKTtcbiAgICAgICAgdGhpcy5zZWVkcy5zZXQocmFuZG9tRmxvYXQoLXMueCwgcy54KSwgcmFuZG9tRmxvYXQoLXMueCwgcy54KSk7XG4gICAgICAgIHRoaXMuZGlzdG9ydGlvbi5zZXQocmFuZG9tRmxvYXQoMCwgMSksIHJhbmRvbUZsb2F0KDAsIDEpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IG51bGwpIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgb2Zmc2V0LnNldChNYXRoLmNvcyhhKSwgTWF0aC5zaW4oYSkpLm11bHRpcGx5U2NhbGFyKHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0LnNldCgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhY3RpdmVcIikudmFsdWUgPSBhY3RpdmU7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgZ2VuZXJhdGVkIHJlc291cmNlcy5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5wZXJ0dXJiYXRpb25NYXA7XG4gICAgaWYgKG1hcCAhPT0gbnVsbCAmJiBtYXAubmFtZSA9PT0gdGV4dHVyZVRhZykge1xuICAgICAgbWFwLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dvZFJheXNFZmZlY3QuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTUsXG4gIENvbG9yIGFzIENvbG9yNSxcbiAgRGVwdGhUZXh0dXJlIGFzIERlcHRoVGV4dHVyZTIsXG4gIE1hdHJpeDQgYXMgTWF0cml4NDIsXG4gIFNjZW5lIGFzIFNjZW5lMixcbiAgVW5pZm9ybSBhcyBVbmlmb3JtMzMsXG4gIFZlY3RvcjIgYXMgVmVjdG9yMjIxLFxuICBWZWN0b3IzIGFzIFZlY3RvcjMyLFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE3XG59IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dvZC1yYXlzLmZyYWdcbnZhciBnb2RfcmF5c19kZWZhdWx0ID0gXCIjaWZkZWYgRlJBTUVCVUZGRVJfUFJFQ0lTSU9OX0hJR0hcXG51bmlmb3JtIG1lZGl1bXAgc2FtcGxlcjJEIG1hcDtcXG4jZWxzZVxcbnVuaWZvcm0gbG93cCBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtvdXRwdXRDb2xvcj10ZXh0dXJlMkQobWFwLHV2KTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0dvZFJheXNFZmZlY3QuanNcbnZhciB2ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzMigpO1xudmFyIG0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQyKCk7XG52YXIgR29kUmF5c0VmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgZ29kIHJheXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gW2NhbWVyYV0gLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7TWVzaHxQb2ludHN9IFtsaWdodFNvdXJjZV0gLSBUaGUgbGlnaHQgc291cmNlLiBNdXN0IG5vdCB3cml0ZSBkZXB0aCBhbmQgaGFzIHRvIGJlIGZsYWdnZWQgYXMgdHJhbnNwYXJlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uPUJsZW5kRnVuY3Rpb24uU0NSRUVOXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZXM9NjAuMF0gLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVuc2l0eT0wLjk2XSAtIFRoZSBkZW5zaXR5IG9mIHRoZSBsaWdodCByYXlzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVjYXk9MC45XSAtIEFuIGlsbHVtaW5hdGlvbiBkZWNheSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53ZWlnaHQ9MC40XSAtIEEgbGlnaHQgcmF5IHdlaWdodCBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5leHBvc3VyZT0wLjZdIC0gQSBjb25zdGFudCBhdHRlbnVhdGlvbiBjb2VmZmljaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsYW1wTWF4PTEuMF0gLSBBbiB1cHBlciBib3VuZCBmb3IgdGhlIHNhdHVyYXRpb24gb2YgdGhlIG92ZXJhbGwgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblNjYWxlPTAuNV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25YPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIFRoZSBob3Jpem9udGFsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWT1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgdmVydGljYWwgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0PVJlc29sdXRpb24uQVVUT19TSVpFXSAtIERlcHJlY2F0ZWQuIFVzZSByZXNvbHV0aW9uWSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0tlcm5lbFNpemV9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5TTUFMTF0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS4gSGFzIG5vIGVmZmVjdCBpZiBibHVyIGlzIGRpc2FibGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJsdXI9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBnb2QgcmF5cyBzaG91bGQgYmUgYmx1cnJlZCB0byByZWR1Y2UgYXJ0aWZhY3RzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FtZXJhLCBsaWdodFNvdXJjZSwge1xuICAgIGJsZW5kRnVuY3Rpb24gPSBCbGVuZEZ1bmN0aW9uLlNDUkVFTixcbiAgICBzYW1wbGVzID0gNjAsXG4gICAgZGVuc2l0eSA9IDAuOTYsXG4gICAgZGVjYXkgPSAwLjksXG4gICAgd2VpZ2h0ID0gMC40LFxuICAgIGV4cG9zdXJlID0gMC42LFxuICAgIGNsYW1wTWF4ID0gMSxcbiAgICBibHVyID0gdHJ1ZSxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5TTUFMTCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiR29kUmF5c0VmZmVjdFwiLCBnb2RfcmF5c19kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgYXR0cmlidXRlczogRWZmZWN0QXR0cmlidXRlLkRFUFRILFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wibWFwXCIsIG5ldyBVbmlmb3JtMzMobnVsbCldXG4gICAgICBdKVxuICAgIH0pO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuX2xpZ2h0U291cmNlID0gbGlnaHRTb3VyY2U7XG4gICAgdGhpcy5saWdodFNvdXJjZSA9IGxpZ2h0U291cmNlO1xuICAgIHRoaXMubGlnaHRTY2VuZSA9IG5ldyBTY2VuZTIoKTtcbiAgICB0aGlzLnNjcmVlblBvc2l0aW9uID0gbmV3IFZlY3RvcjIyMSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE3KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0QS50ZXh0dXJlLm5hbWUgPSBcIkdvZFJheXMuVGFyZ2V0LkFcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIgPSB0aGlzLnJlbmRlclRhcmdldEEuY2xvbmUoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLlRhcmdldC5CXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTcoMSwgMSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMaWdodC50ZXh0dXJlLm5hbWUgPSBcIkdvZFJheXMuTGlnaHRcIjtcbiAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUyKCk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQgPSBuZXcgUmVuZGVyUGFzcyh0aGlzLmxpZ2h0U2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQuY2xlYXJQYXNzLm92ZXJyaWRlQ2xlYXJDb2xvciA9IG5ldyBDb2xvcjUoMCk7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNSgwKTtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IEthd2FzZUJsdXJQYXNzKHsga2VybmVsU2l6ZSB9KTtcbiAgICB0aGlzLmJsdXJQYXNzLmVuYWJsZWQgPSBibHVyO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBEZXB0aE1hc2tNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBkZXB0aE1hc2tNYXRlcmlhbCA9IHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWw7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhCdWZmZXIxID0gdGhpcy5yZW5kZXJUYXJnZXRMaWdodC5kZXB0aFRleHR1cmU7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKGNhbWVyYSk7XG4gICAgdGhpcy5nb2RSYXlzUGFzcyA9IG5ldyBTaGFkZXJQYXNzKG5ldyBHb2RSYXlzTWF0ZXJpYWwodGhpcy5zY3JlZW5Qb3NpdGlvbikpO1xuICAgIGNvbnN0IGdvZFJheXNNYXRlcmlhbCA9IHRoaXMuZ29kUmF5c01hdGVyaWFsO1xuICAgIGdvZFJheXNNYXRlcmlhbC5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuZGVjYXkgPSBkZWNheTtcbiAgICBnb2RSYXlzTWF0ZXJpYWwud2VpZ2h0ID0gd2VpZ2h0O1xuICAgIGdvZFJheXNNYXRlcmlhbC5leHBvc3VyZSA9IGV4cG9zdXJlO1xuICAgIGdvZFJheXNNYXRlcmlhbC5tYXhJbnRlbnNpdHkgPSBjbGFtcE1heDtcbiAgICBnb2RSYXlzTWF0ZXJpYWwuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMucmVuZGVyUGFzc0xpZ2h0Lm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpZ2h0IHNvdXJjZS5cbiAgICpcbiAgICogQHR5cGUge01lc2h8UG9pbnRzfVxuICAgKi9cbiAgZ2V0IGxpZ2h0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9saWdodFNvdXJjZTtcbiAgfVxuICBzZXQgbGlnaHRTb3VyY2UodmFsdWUpIHtcbiAgICB0aGlzLl9saWdodFNvdXJjZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgICAgdmFsdWUubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmx1ciBwYXNzIHRoYXQgcmVkdWNlcyBhbGlhc2luZyBhcnRpZmFjdHMgYW5kIG1ha2VzIHRoZSBsaWdodCBzb2Z0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtLYXdhc2VCbHVyUGFzc30gVGhlIGJsdXIgcGFzcy5cbiAgICovXG4gIGdldEJsdXJQYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzO1xuICB9XG4gIC8qKlxuICAgKiBBIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdCBvZiB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdvZCByYXlzIHRleHR1cmUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVwdGggbWFzayBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0RlcHRoTWFza01hdGVyaWFsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGRlcHRoTWFza01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoTWFza1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW50ZXJuYWwgZ29kIHJheXMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtHb2RSYXlzTWF0ZXJpYWx9XG4gICAqL1xuICBnZXQgZ29kUmF5c01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ29kIHJheXMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBnb2RSYXlzTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICogQHJldHVybiB7R29kUmF5c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRHb2RSYXlzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ29kUmF5c01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHV0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtHb2RSYXlzTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi53aWR0aCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnByZWZlcnJlZFdpZHRoID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uLmhlaWdodCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnByZWZlcnJlZEhlaWdodCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGl0aGVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNNYXRlcmlhbC5kaXRoZXJpbmc7XG4gIH1cbiAgc2V0IGRpdGhlcmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5nb2RSYXlzTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwuZGl0aGVyaW5nID0gdmFsdWU7XG4gICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZ29kIHJheXMgc2hvdWxkIGJlIGJsdXJyZWQgdG8gcmVkdWNlIGFydGlmYWN0cy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBibHVyUGFzcy5lbmFibGVkIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYmx1cigpIHtcbiAgICByZXR1cm4gdGhpcy5ibHVyUGFzcy5lbmFibGVkO1xuICB9XG4gIHNldCBibHVyKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibHVyIGtlcm5lbCBzaXplLlxuICAgKlxuICAgKiBAdHlwZSB7S2VybmVsU2l6ZX1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzLmtlcm5lbFNpemUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBrZXJuZWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7XG4gIH1cbiAgc2V0IGtlcm5lbFNpemUodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uIHNjYWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvblNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24uc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICovXG4gIHNldFJlc29sdXRpb25TY2FsZShzY2FsZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zY2FsZSA9IHNjYWxlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29kUmF5c01hdGVyaWFsLnNhbXBsZXMgaW5zdGVhZC5cbiAgICovXG4gIGdldCBzYW1wbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdvZFJheXNNYXRlcmlhbC5zYW1wbGVzO1xuICB9XG4gIC8qKlxuICAgKiBBIGhpZ2hlciBzYW1wbGUgY291bnQgaW1wcm92ZXMgcXVhbGl0eSBhdCB0aGUgY29zdCBvZiBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvZFJheXNNYXRlcmlhbC5zYW1wbGVzIGluc3RlYWQuXG4gICAqL1xuICBzZXQgc2FtcGxlcyh2YWx1ZSkge1xuICAgIHRoaXMuZ29kUmF5c01hdGVyaWFsLnNhbXBsZXMgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVwdGhQYWNraW5nPUJhc2ljRGVwdGhQYWNraW5nXSAtIFRoZSBkZXB0aCBwYWNraW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmcxNSkge1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhCdWZmZXIwID0gZGVwdGhUZXh0dXJlO1xuICAgIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuZGVwdGhQYWNraW5nMCA9IGRlcHRoUGFja2luZztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gaW5wdXRCdWZmZXIgLSBBIGZyYW1lIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIHBhc3MuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsdGFUaW1lXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGFUaW1lKSB7XG4gICAgY29uc3QgbGlnaHRTb3VyY2UgPSB0aGlzLmxpZ2h0U291cmNlO1xuICAgIGNvbnN0IHBhcmVudCA9IGxpZ2h0U291cmNlLnBhcmVudDtcbiAgICBjb25zdCBtYXRyaXhBdXRvVXBkYXRlID0gbGlnaHRTb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRBID0gdGhpcy5yZW5kZXJUYXJnZXRBO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldExpZ2h0ID0gdGhpcy5yZW5kZXJUYXJnZXRMaWdodDtcbiAgICBsaWdodFNvdXJjZS5tYXRlcmlhbC5kZXB0aFdyaXRlID0gdHJ1ZTtcbiAgICBsaWdodFNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgbGlnaHRTb3VyY2UudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBtLmNvcHkobGlnaHRTb3VyY2UubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGxpZ2h0U291cmNlLm1hdHJpeC5jb3B5KGxpZ2h0U291cmNlLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgdGhpcy5saWdodFNjZW5lLmFkZChsaWdodFNvdXJjZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCk7XG4gICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBKTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRMaWdodCwgcmVuZGVyVGFyZ2V0QSk7XG4gICAgbGlnaHRTb3VyY2UubWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIGxpZ2h0U291cmNlLm1hdHJpeEF1dG9VcGRhdGUgPSBtYXRyaXhBdXRvVXBkYXRlO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghbWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgICBsaWdodFNvdXJjZS5tYXRyaXguY29weShtKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hZGQobGlnaHRTb3VyY2UpO1xuICAgIH1cbiAgICB2LnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodFNvdXJjZS5tYXRyaXhXb3JsZCkucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5zY3JlZW5Qb3NpdGlvbi5zZXQoXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi54ICsgMSkgKiAwLjUsIC0xKSwgMiksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heCgodi55ICsgMSkgKiAwLjUsIC0xKSwgMilcbiAgICApO1xuICAgIGlmICh0aGlzLmJsdXJQYXNzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuYmx1clBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXRBLCByZW5kZXJUYXJnZXRBKTtcbiAgICB9XG4gICAgdGhpcy5nb2RSYXlzUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldEEsIHRoaXMucmVuZGVyVGFyZ2V0Qik7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uc2V0QmFzZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IHJlc29sdXRpb24ud2lkdGgsIGggPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlclRhcmdldEEuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEIuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldExpZ2h0LnNldFNpemUodywgaCk7XG4gICAgdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uLmNvcHkocmVzb2x1dGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRoaXMuYmx1clBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzTGlnaHQuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIHRoaXMuZ29kUmF5c1Bhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgaWYgKGZyYW1lQnVmZmVyVHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXRCLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TGlnaHQudGV4dHVyZS50eXBlID0gZnJhbWVCdWZmZXJUeXBlO1xuICAgICAgaWYgKGdldE91dHB1dENvbG9yU3BhY2UocmVuZGVyZXIpID09PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEEudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldEIudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZXRUZXh0dXJlQ29sb3JTcGFjZSh0aGlzLnJlbmRlclRhcmdldExpZ2h0LnRleHR1cmUsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0dyaWRFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTM0LCBWZWN0b3IyIGFzIFZlY3RvcjIyMiB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL2dyaWQuZnJhZ1xudmFyIGdyaWRfZGVmYXVsdCA9IFwidW5pZm9ybSB2ZWMyIHNjYWxlO3VuaWZvcm0gZmxvYXQgbGluZVdpZHRoO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtmbG9hdCBncmlkPTAuNS1tYXgoYWJzKG1vZCh1di54KnNjYWxlLngsMS4wKS0wLjUpLGFicyhtb2QodXYueSpzY2FsZS55LDEuMCktMC41KSk7b3V0cHV0Q29sb3I9dmVjNCh2ZWMzKHNtb290aHN0ZXAoMC4wLGxpbmVXaWR0aCxncmlkKSksaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0dyaWRFZmZlY3QuanNcbnZhciBHcmlkRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBncmlkIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5PVkVSTEFZXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIGdyaWQgcGF0dGVybi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbmVXaWR0aD0wLjBdIC0gVGhlIGxpbmUgd2lkdGggb2YgdGhlIGdyaWQgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uT1ZFUkxBWSwgc2NhbGUgPSAxLCBsaW5lV2lkdGggPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiR3JpZEVmZmVjdFwiLCBncmlkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTM0KG5ldyBWZWN0b3IyMjIoKSldLFxuICAgICAgICBbXCJsaW5lV2lkdGhcIiwgbmV3IFVuaWZvcm0zNChsaW5lV2lkdGgpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjIyKCk7XG4gICAgdGhpcy5zID0gMDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5sID0gMDtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYWxlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnM7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy5zID0gTWF0aC5tYXgodmFsdWUsIDFlLTYpO1xuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdyaWQgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBncmlkIHNjYWxlLlxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdyaWQgc2NhbGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzY2FsZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGdyaWQgc2NhbGUuXG4gICAqL1xuICBzZXRTY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxpbmUgd2lkdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbGluZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmw7XG4gIH1cbiAgc2V0IGxpbmVXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMubCA9IHZhbHVlO1xuICAgIHRoaXMuc2V0U2l6ZSh0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdyaWQgbGluZSB3aWR0aC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGxpbmVXaWR0aCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBncmlkIGxpbmUgd2lkdGguXG4gICAqL1xuICBnZXRMaW5lV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZVdpZHRoO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBncmlkIGxpbmUgd2lkdGguXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBsaW5lV2lkdGggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBncmlkIGxpbmUgd2lkdGguXG4gICAqL1xuICBzZXRMaW5lV2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlICogKGhlaWdodCAqIDAuMTI1KTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlLnNldChhc3BlY3QgKiBzY2FsZSwgc2NhbGUpO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibGluZVdpZHRoXCIpLnZhbHVlID0gc2NhbGUgLyBoZWlnaHQgKyB0aGlzLmxpbmVXaWR0aDtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvSHVlU2F0dXJhdGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzUsIFZlY3RvcjMgYXMgVmVjdG9yMzMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9odWUtc2F0dXJhdGlvbi5mcmFnXG52YXIgaHVlX3NhdHVyYXRpb25fZGVmYXVsdCA9IFwidW5pZm9ybSB2ZWMzIGh1ZTt1bmlmb3JtIGZsb2F0IHNhdHVyYXRpb247dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe3ZlYzMgY29sb3I9dmVjMyhkb3QoaW5wdXRDb2xvci5yZ2IsaHVlLnh5eiksZG90KGlucHV0Q29sb3IucmdiLGh1ZS56eHkpLGRvdChpbnB1dENvbG9yLnJnYixodWUueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDt2ZWMzIGRpZmY9YXZlcmFnZS1jb2xvcjtpZihzYXR1cmF0aW9uPjAuMCl7Y29sb3IrPWRpZmYqKDEuMC0xLjAvKDEuMDAxLXNhdHVyYXRpb24pKTt9ZWxzZXtjb2xvcis9ZGlmZiotc2F0dXJhdGlvbjt9b3V0cHV0Q29sb3I9dmVjNChtaW4oY29sb3IsMS4wKSxpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvSHVlU2F0dXJhdGlvbkVmZmVjdC5qc1xudmFyIEh1ZVNhdHVyYXRpb25FZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGh1ZS9zYXR1cmF0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaHVlPTAuMF0gLSBUaGUgaHVlIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0aW9uPTAuMF0gLSBUaGUgc2F0dXJhdGlvbiBmYWN0b3IsIHJhbmdpbmcgZnJvbSAtMSB0byAxLCB3aGVyZSAwIG1lYW5zIG5vIGNoYW5nZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDLCBodWUgPSAwLCBzYXR1cmF0aW9uID0gMCB9ID0ge30pIHtcbiAgICBzdXBlcihcIkh1ZVNhdHVyYXRpb25FZmZlY3RcIiwgaHVlX3NhdHVyYXRpb25fZGVmYXVsdCwge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcImh1ZVwiLCBuZXcgVW5pZm9ybTM1KG5ldyBWZWN0b3IzMygpKV0sXG4gICAgICAgIFtcInNhdHVyYXRpb25cIiwgbmV3IFVuaWZvcm0zNShzYXR1cmF0aW9uKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5odWUgPSBodWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzYXR1cmF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNhdHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwic2F0dXJhdGlvblwiKS52YWx1ZTtcbiAgfVxuICBzZXQgc2F0dXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2F0dXJhdGlvblwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzYXR1cmF0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2F0dXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzYXR1cmF0aW9uLlxuICAgKi9cbiAgZ2V0U2F0dXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzYXR1cmF0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2F0dXJhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc2F0dXJhdGlvbi5cbiAgICovXG4gIHNldFNhdHVyYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnNhdHVyYXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGh1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBodWUoKSB7XG4gICAgY29uc3QgaHVlID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJodWVcIikudmFsdWU7XG4gICAgcmV0dXJuIE1hdGguYWNvcygoaHVlLnggKiAzIC0gMSkgLyAyKTtcbiAgfVxuICBzZXQgaHVlKHZhbHVlKSB7XG4gICAgY29uc3QgcyA9IE1hdGguc2luKHZhbHVlKSwgYzIgPSBNYXRoLmNvcyh2YWx1ZSk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJodWVcIikudmFsdWUuc2V0KFxuICAgICAgKDIgKiBjMiArIDEpIC8gMyxcbiAgICAgICgtTWF0aC5zcXJ0KDMpICogcyAtIGMyICsgMSkgLyAzLFxuICAgICAgKE1hdGguc3FydCgzKSAqIHMgLSBjMiArIDEpIC8gM1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGh1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGh1ZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBodWUgaW4gcmFkaWFucy5cbiAgICovXG4gIGdldEh1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5odWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGh1ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGh1ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgaHVlIGluIHJhZGlhbnMuXG4gICAqL1xuICBzZXRIdWUodmFsdWUpIHtcbiAgICB0aGlzLmh1ZSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9MZW5zRGlzdG9ydGlvbkVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtMzYsIFZlY3RvcjIgYXMgVmVjdG9yMjIzIH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbGVucy1kaXN0b3J0aW9uLmZyYWdcbnZhciBsZW5zX2Rpc3RvcnRpb25fZGVmYXVsdCA9IFwidW5pZm9ybSB2ZWMyIGRpc3RvcnRpb247dW5pZm9ybSB2ZWMyIHByaW5jaXBhbFBvaW50O3VuaWZvcm0gdmVjMiBmb2NhbExlbmd0aDt1bmlmb3JtIGZsb2F0IHNrZXc7ZmxvYXQgbWFzayhjb25zdCBpbiB2ZWMyIHV2KXtyZXR1cm4gZmxvYXQodXYucz49MC4wJiZ1di5zPD0xLjAmJnV2LnQ+PTAuMCYmdXYudDw9MS4wKTt9dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7dmVjMiB4bj0yLjAqKHV2LnN0LTAuNSk7dmVjMyB4RGlzdG9ydGVkPXZlYzMoKDEuMCtkaXN0b3J0aW9uKmRvdCh4bix4bikpKnhuLDEuMCk7bWF0MyBraz1tYXQzKHZlYzMoZm9jYWxMZW5ndGgueCwwLjAsMC4wKSx2ZWMzKHNrZXcqZm9jYWxMZW5ndGgueCxmb2NhbExlbmd0aC55LDAuMCksdmVjMyhwcmluY2lwYWxQb2ludC54LHByaW5jaXBhbFBvaW50LnksMS4wKSk7dXY9KGtrKnhEaXN0b3J0ZWQpLnh5KjAuNSswLjU7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtvdXRwdXRDb2xvcj1tYXNrKHV2KSppbnB1dENvbG9yO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvTGVuc0Rpc3RvcnRpb25FZmZlY3QuanNcbnZhciBMZW5zRGlzdG9ydGlvbkVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbGVucyBkaXN0b3J0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLmRpc3RvcnRpb25dIC0gVGhlIGRpc3RvcnRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gW29wdGlvbnMucHJpbmNpcGFsUG9pbnRdIC0gVGhlIGNlbnRlciBwb2ludC5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9ucy5mb2NhbExlbmd0aF0gLSBUaGUgZm9jYWwgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2tldz0wXSAtIFRoZSBza2V3IHZhbHVlLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpc3RvcnRpb24gPSBuZXcgVmVjdG9yMjIzKDAsIDApLFxuICAgIHByaW5jaXBhbFBvaW50ID0gbmV3IFZlY3RvcjIyMygwLCAwKSxcbiAgICBmb2NhbExlbmd0aCA9IG5ldyBWZWN0b3IyMjMoMSwgMSksXG4gICAgc2tldyA9IDBcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJMZW5zRGlzdG9ydGlvbkVmZmVjdFwiLCBsZW5zX2Rpc3RvcnRpb25fZGVmYXVsdCwge1xuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiZGlzdG9ydGlvblwiLCBuZXcgVW5pZm9ybTM2KGRpc3RvcnRpb24pXSxcbiAgICAgICAgW1wicHJpbmNpcGFsUG9pbnRcIiwgbmV3IFVuaWZvcm0zNihwcmluY2lwYWxQb2ludCldLFxuICAgICAgICBbXCJmb2NhbExlbmd0aFwiLCBuZXcgVW5pZm9ybTM2KGZvY2FsTGVuZ3RoKV0sXG4gICAgICAgIFtcInNrZXdcIiwgbmV3IFVuaWZvcm0zNihza2V3KV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByYWRpYWwgZGlzdG9ydGlvbiBjb2VmZmljaWVudHMuIERlZmF1bHQgaXMgKDAsIDApLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yMn1cbiAgICovXG4gIGdldCBkaXN0b3J0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWU7XG4gIH1cbiAgc2V0IGRpc3RvcnRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImRpc3RvcnRpb25cIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW5jaXBhbCBwb2ludC4gRGVmYXVsdCBpcyAoMCwgMCkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IHByaW5jaXBhbFBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInByaW5jaXBhbFBvaW50XCIpLnZhbHVlO1xuICB9XG4gIHNldCBwcmluY2lwYWxQb2ludCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicHJpbmNpcGFsUG9pbnRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aC4gRGVmYXVsdCBpcyAoMSwgMSkuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0IGZvY2FsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImZvY2FsTGVuZ3RoXCIpLnZhbHVlO1xuICB9XG4gIHNldCBmb2NhbExlbmd0aCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZm9jYWxMZW5ndGhcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGluIHJhZGlhbnMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlO1xuICB9XG4gIHNldCBza2V3KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJza2V3XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDFERWZmZWN0LmpzXG5pbXBvcnQgeyBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNSwgSGFsZkZsb2F0VHlwZSwgVW5pZm9ybSBhcyBVbmlmb3JtMzcgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9sdXQtMWQuZnJhZ1xudmFyIGx1dF8xZF9kZWZhdWx0ID0gXCIjaWZkZWYgTFVUX1BSRUNJU0lPTl9ISUdIXFxuI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgbHV0O1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBsdXQ7XFxuI2VuZGlmXFxuI2Vsc2VcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1dDtcXG4jZW5kaWZcXG52b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixvdXQgdmVjNCBvdXRwdXRDb2xvcil7b3V0cHV0Q29sb3I9dmVjNCh0ZXh0dXJlMkQobHV0LHZlYzIoaW5wdXRDb2xvci5yLDAuNSkpLnIsdGV4dHVyZTJEKGx1dCx2ZWMyKGlucHV0Q29sb3IuZywwLjUpKS5yLHRleHR1cmUyRChsdXQsdmVjMihpbnB1dENvbG9yLmIsMC41KSkucixpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvTFVUMURFZmZlY3QuanNcbnZhciBMVVQxREVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgY29sb3IgZ3JhZGluZyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gbHV0IC0gVGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsdXQsIHsgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uU1JDIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTFVUMURFZmZlY3RcIiwgbHV0XzFkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tcImx1dFwiLCBuZXcgVW5pZm9ybTM3KG51bGwpXV0pXG4gICAgfSk7XG4gICAgdGhpcy5sdXQgPSBsdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBMVVQuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IGx1dCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJsdXRcIikudmFsdWU7XG4gIH1cbiAgc2V0IGx1dCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibHV0XCIpLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmICh2YWx1ZS50eXBlID09PSBGbG9hdFR5cGU1IHx8IHZhbHVlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUpKSB7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTFVUX1BSRUNJU0lPTl9ISUdIXCIsIFwiMVwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDNERWZmZWN0LmpzXG5pbXBvcnQge1xuICBEYXRhM0RUZXh0dXJlIGFzIERhdGEzRFRleHR1cmUyLFxuICBGbG9hdFR5cGUgYXMgRmxvYXRUeXBlNixcbiAgSGFsZkZsb2F0VHlwZSBhcyBIYWxmRmxvYXRUeXBlMixcbiAgTGluZWFyRmlsdGVyIGFzIExpbmVhckZpbHRlcjQsXG4gIE5lYXJlc3RGaWx0ZXIgYXMgTmVhcmVzdEZpbHRlcjcsXG4gIHNSR0JFbmNvZGluZyBhcyBzUkdCRW5jb2RpbmcyLFxuICBVbmlmb3JtIGFzIFVuaWZvcm0zOCxcbiAgVmVjdG9yMyBhcyBWZWN0b3IzNFxufSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9sdXQtM2QuZnJhZ1xudmFyIGx1dF8zZF9kZWZhdWx0ID0gXCJ1bmlmb3JtIHZlYzMgc2NhbGU7dW5pZm9ybSB2ZWMzIG9mZnNldDtcXG4jaWZkZWYgQ1VTVE9NX0lOUFVUX0RPTUFJTlxcbnVuaWZvcm0gdmVjMyBkb21haW5NaW47dW5pZm9ybSB2ZWMzIGRvbWFpbk1heDtcXG4jZW5kaWZcXG4jaWZkZWYgTFVUXzNEXFxuI2lmZGVmIExVVF9QUkVDSVNJT05fSElHSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjNEIGx1dDtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyM0QgbHV0O1xcbiNlbmRpZlxcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIzRCBsdXQ7XFxuI2VuZGlmXFxudmVjNCBhcHBseUxVVChjb25zdCBpbiB2ZWMzIHJnYil7XFxuI2lmZGVmIFRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cXG52ZWMzIHA9Zmxvb3IocmdiKTt2ZWMzIGY9cmdiLXA7dmVjMyB2MT0ocCswLjUpKkxVVF9URVhFTF9XSURUSDt2ZWMzIHY0PShwKzEuNSkqTFVUX1RFWEVMX1dJRFRIO3ZlYzMgdjIsdjM7dmVjMyBmcmFjO2lmKGYucj49Zi5nKXtpZihmLmc+Zi5iKXtmcmFjPWYucmdiO3YyPXZlYzModjQueCx2MS55LHYxLnopO3YzPXZlYzModjQueCx2NC55LHYxLnopO31lbHNlIGlmKGYucj49Zi5iKXtmcmFjPWYucmJnO3YyPXZlYzModjQueCx2MS55LHYxLnopO3YzPXZlYzModjQueCx2MS55LHY0LnopO31lbHNle2ZyYWM9Zi5icmc7djI9dmVjMyh2MS54LHYxLnksdjQueik7djM9dmVjMyh2NC54LHYxLnksdjQueik7fX1lbHNle2lmKGYuYj5mLmcpe2ZyYWM9Zi5iZ3I7djI9dmVjMyh2MS54LHYxLnksdjQueik7djM9dmVjMyh2MS54LHY0LnksdjQueik7fWVsc2UgaWYoZi5yPj1mLmIpe2ZyYWM9Zi5ncmI7djI9dmVjMyh2MS54LHY0LnksdjEueik7djM9dmVjMyh2NC54LHY0LnksdjEueik7fWVsc2V7ZnJhYz1mLmdicjt2Mj12ZWMzKHYxLngsdjQueSx2MS56KTt2Mz12ZWMzKHYxLngsdjQueSx2NC56KTt9fXZlYzQgbjE9dGV4dHVyZShsdXQsdjEpO3ZlYzQgbjI9dGV4dHVyZShsdXQsdjIpO3ZlYzQgbjM9dGV4dHVyZShsdXQsdjMpO3ZlYzQgbjQ9dGV4dHVyZShsdXQsdjQpO3ZlYzQgd2VpZ2h0cz12ZWM0KDEuMC1mcmFjLngsZnJhYy54LWZyYWMueSxmcmFjLnktZnJhYy56LGZyYWMueik7dmVjNCByZXN1bHQ9d2VpZ2h0cyptYXQ0KHZlYzQobjEucixuMi5yLG4zLnIsbjQuciksdmVjNChuMS5nLG4yLmcsbjMuZyxuNC5nKSx2ZWM0KG4xLmIsbjIuYixuMy5iLG40LmIpLHZlYzQoMS4wKSk7cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwxLjApO1xcbiNlbHNlXFxucmV0dXJuIHRleHR1cmUobHV0LHJnYik7XFxuI2VuZGlmXFxufVxcbiNlbHNlXFxuI2lmZGVmIExVVF9QUkVDSVNJT05fSElHSFxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGx1dDtcXG4jZWxzZVxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbHV0O1xcbiNlbmRpZlxcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBsdXQ7XFxuI2VuZGlmXFxudmVjNCBhcHBseUxVVChjb25zdCBpbiB2ZWMzIHJnYil7ZmxvYXQgc2xpY2U9cmdiLmIqTFVUX1NJWkU7ZmxvYXQgc2xpY2UwPWZsb29yKHNsaWNlKTtmbG9hdCBpbnRlcnA9c2xpY2Utc2xpY2UwO2Zsb2F0IGNlbnRlcmVkSW50ZXJwPWludGVycC0wLjU7ZmxvYXQgc2xpY2UxPXNsaWNlMCtzaWduKGNlbnRlcmVkSW50ZXJwKTtcXG4jaWZkZWYgTFVUX1NUUklQX0hPUklaT05UQUxcXG5mbG9hdCB4T2Zmc2V0PWNsYW1wKHJnYi5yKkxVVF9URVhFTF9IRUlHSFQsTFVUX1RFWEVMX1dJRFRIKjAuNSxMVVRfVEVYRUxfSEVJR0hULUxVVF9URVhFTF9XSURUSCowLjUpO3ZlYzIgdXYwPXZlYzIoc2xpY2UwKkxVVF9URVhFTF9IRUlHSFQreE9mZnNldCxyZ2IuZyk7dmVjMiB1djE9dmVjMihzbGljZTEqTFVUX1RFWEVMX0hFSUdIVCt4T2Zmc2V0LHJnYi5nKTtcXG4jZWxzZVxcbmZsb2F0IHlPZmZzZXQ9Y2xhbXAocmdiLmcqTFVUX1RFWEVMX1dJRFRILExVVF9URVhFTF9IRUlHSFQqMC41LExVVF9URVhFTF9XSURUSC1MVVRfVEVYRUxfSEVJR0hUKjAuNSk7dmVjMiB1djA9dmVjMihyZ2IucixzbGljZTAqTFVUX1RFWEVMX1dJRFRIK3lPZmZzZXQpO3ZlYzIgdXYxPXZlYzIocmdiLnIsc2xpY2UxKkxVVF9URVhFTF9XSURUSCt5T2Zmc2V0KTtcXG4jZW5kaWZcXG52ZWM0IHNhbXBsZTA9dGV4dHVyZTJEKGx1dCx1djApO3ZlYzQgc2FtcGxlMT10ZXh0dXJlMkQobHV0LHV2MSk7cmV0dXJuIG1peChzYW1wbGUwLHNhbXBsZTEsYWJzKGNlbnRlcmVkSW50ZXJwKSk7fVxcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGM9aW5wdXRDb2xvci5yZ2I7XFxuI2lmZGVmIENVU1RPTV9JTlBVVF9ET01BSU5cXG5pZihjLnI+PWRvbWFpbk1pbi5yJiZjLmc+PWRvbWFpbk1pbi5nJiZjLmI+PWRvbWFpbk1pbi5iJiZjLnI8PWRvbWFpbk1heC5yJiZjLmc8PWRvbWFpbk1heC5nJiZjLmI8PWRvbWFpbk1heC5iKXtjPWFwcGx5TFVUKHNjYWxlKmMrb2Zmc2V0KS5yZ2I7fWVsc2V7Yz1pbnB1dENvbG9yLnJnYjt9XFxuI2Vsc2VcXG4jaWYgIWRlZmluZWQoTFVUXzNEKSB8fCBkZWZpbmVkKFRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT04pXFxuYz1jbGFtcChjLDAuMCwxLjApO1xcbiNlbmRpZlxcbmM9YXBwbHlMVVQoc2NhbGUqYytvZmZzZXQpLnJnYjtcXG4jZW5kaWZcXG5vdXRwdXRDb2xvcj12ZWM0KGMsaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL0xVVDNERWZmZWN0LmpzXG52YXIgTFVUM0RFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbG9yIGdyYWRpbmcgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IGx1dCAtIFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbj1mYWxzZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24uXG4gICAqIEBwYXJhbSB7VGV4dHVyZUVuY29kaW5nfSBbb3B0aW9ucy5pbnB1dEVuY29kaW5nPXNSR0JFbmNvZGluZ10gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge0NvbG9yU3BhY2V9IFtvcHRpb25zLmlucHV0Q29sb3JTcGFjZT1TUkdCQ29sb3JTcGFjZV0gLSBUaGUgaW5wdXQgY29sb3Igc3BhY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsdXQsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gZmFsc2UsXG4gICAgaW5wdXRFbmNvZGluZyA9IHNSR0JFbmNvZGluZzIsXG4gICAgaW5wdXRDb2xvclNwYWNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiTFVUM0RFZmZlY3RcIiwgbHV0XzNkX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJsdXRcIiwgbmV3IFVuaWZvcm0zOChudWxsKV0sXG4gICAgICAgIFtcInNjYWxlXCIsIG5ldyBVbmlmb3JtMzgobmV3IFZlY3RvcjM0KCkpXSxcbiAgICAgICAgW1wib2Zmc2V0XCIsIG5ldyBVbmlmb3JtMzgobmV3IFZlY3RvcjM0KCkpXSxcbiAgICAgICAgW1wiZG9tYWluTWluXCIsIG5ldyBVbmlmb3JtMzgobnVsbCldLFxuICAgICAgICBbXCJkb21haW5NYXhcIiwgbmV3IFVuaWZvcm0zOChudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgdGhpcy5pbnB1dENvbG9yU3BhY2UgPSBpbnB1dENvbG9yU3BhY2UgfHwgZW5jb2RpbmdUb0NvbG9yU3BhY2UuZ2V0KGlucHV0RW5jb2RpbmcpO1xuICAgIHRoaXMubHV0ID0gbHV0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgZW5jb2RpbmcuIERlZmF1bHQgaXMgYHNSR0JFbmNvZGluZ2AuXG4gICAqXG4gICAqIFNldCB0aGlzIHRvIGBMaW5lYXJFbmNvZGluZ2AgaWYgeW91ciBMVVQgZXhwZWN0cyBsaW5lYXIgY29sb3IgaW5wdXQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnB1dENvbG9yU3BhY2UgaW5zdGVhZC5cbiAgICogQHR5cGUge1RleHR1cmVFbmNvZGluZ31cbiAgICovXG4gIGdldCBpbnB1dEVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0Q29sb3JTcGFjZTtcbiAgfVxuICBzZXQgaW5wdXRFbmNvZGluZyh2YWx1ZSkge1xuICAgIHRoaXMuaW5wdXRDb2xvclNwYWNlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlucHV0IGVuY29kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRDb2xvclNwYWNlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmVFbmNvZGluZ30gVGhlIGVuY29kaW5nLlxuICAgKi9cbiAgZ2V0SW5wdXRFbmNvZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dENvbG9yU3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IGVuY29kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaW5wdXRDb2xvclNwYWNlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZUVuY29kaW5nfSB2YWx1ZSAtIFRoZSBlbmNvZGluZy5cbiAgICovXG4gIHNldElucHV0RW5jb2RpbmcodmFsdWUpIHtcbiAgICB0aGlzLmlucHV0Q29sb3JTcGFjZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRwdXQgZW5jb2RpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvdXRwdXRDb2xvclNwYWNlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmVFbmNvZGluZ30gVGhlIGVuY29kaW5nLlxuICAgKi9cbiAgZ2V0T3V0cHV0RW5jb2RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0Q29sb3JTcGFjZTtcbiAgfVxuICAvKipcbiAgICogVGhlIExVVC5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgbHV0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImx1dFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgbHV0KHZhbHVlKSB7XG4gICAgY29uc3QgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgaWYgKHRoaXMubHV0ICE9PSB2YWx1ZSkge1xuICAgICAgdW5pZm9ybXMuZ2V0KFwibHV0XCIpLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB2YWx1ZS5pbWFnZTtcbiAgICAgICAgY29uc3QgdGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgICAgIGRlZmluZXMuY2xlYXIoKTtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfU0laRVwiLCBNYXRoLm1pbihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1RFWEVMX1dJRFRIXCIsICgxIC8gaW1hZ2Uud2lkdGgpLnRvRml4ZWQoMTYpKTtcbiAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfVEVYRUxfSEVJR0hUXCIsICgxIC8gaW1hZ2UuaGVpZ2h0KS50b0ZpeGVkKDE2KSk7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1pblwiKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImRvbWFpbk1heFwiKS52YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBGbG9hdFR5cGU2IHx8IHZhbHVlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUyKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJMVVRfUFJFQ0lTSU9OX0hJR0hcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZS53aWR0aCA+IGltYWdlLmhlaWdodCkge1xuICAgICAgICAgIGRlZmluZXMuc2V0KFwiTFVUX1NUUklQX0hPUklaT05UQUxcIiwgXCIxXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIkxVVF8zRFwiLCBcIjFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9va3VwVGV4dHVyZSkge1xuICAgICAgICAgIGNvbnN0IG1pbiA9IHZhbHVlLmRvbWFpbk1pbjtcbiAgICAgICAgICBjb25zdCBtYXggPSB2YWx1ZS5kb21haW5NYXg7XG4gICAgICAgICAgaWYgKG1pbi54ICE9PSAwIHx8IG1pbi55ICE9PSAwIHx8IG1pbi56ICE9PSAwIHx8IG1heC54ICE9PSAxIHx8IG1heC55ICE9PSAxIHx8IG1heC56ICE9PSAxKSB7XG4gICAgICAgICAgICBkZWZpbmVzLnNldChcIkNVU1RPTV9JTlBVVF9ET01BSU5cIiwgXCIxXCIpO1xuICAgICAgICAgICAgdW5pZm9ybXMuZ2V0KFwiZG9tYWluTWluXCIpLnZhbHVlID0gbWluLmNsb25lKCk7XG4gICAgICAgICAgICB1bmlmb3Jtcy5nZXQoXCJkb21haW5NYXhcIikudmFsdWUgPSBtYXguY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gPSB0ZXRyYWhlZHJhbEludGVycG9sYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IExVVC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGx1dCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgTFVULlxuICAgKi9cbiAgZ2V0TFVUKCkge1xuICAgIHJldHVybiB0aGlzLmx1dDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTFVULlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbHV0IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgTFVULlxuICAgKi9cbiAgc2V0TFVUKHZhbHVlKSB7XG4gICAgdGhpcy5sdXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2NhbGUgYW5kIG9mZnNldCBmb3IgdGhlIExVVCBzYW1wbGluZyBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVNjYWxlT2Zmc2V0KCkge1xuICAgIGNvbnN0IGx1dCA9IHRoaXMubHV0O1xuICAgIGlmIChsdXQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihsdXQuaW1hZ2Uud2lkdGgsIGx1dC5pbWFnZS5oZWlnaHQpO1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnVuaWZvcm1zLmdldChcInNjYWxlXCIpLnZhbHVlO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWU7XG4gICAgICBpZiAodGhpcy50ZXRyYWhlZHJhbEludGVycG9sYXRpb24gJiYgbHV0IGluc3RhbmNlb2YgRGF0YTNEVGV4dHVyZTIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lcy5oYXMoXCJDVVNUT01fSU5QVVRfRE9NQUlOXCIpKSB7XG4gICAgICAgICAgY29uc3QgZG9tYWluU2NhbGUgPSBsdXQuZG9tYWluTWF4LmNsb25lKCkuc3ViKGx1dC5kb21haW5NaW4pO1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcihzaXplIC0gMSkuZGl2aWRlKGRvbWFpblNjYWxlKTtcbiAgICAgICAgICBvZmZzZXQuY29weShsdXQuZG9tYWluTWluKS5uZWdhdGUoKS5tdWx0aXBseShzY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGUuc2V0U2NhbGFyKHNpemUgLSAxKTtcbiAgICAgICAgICBvZmZzZXQuc2V0U2NhbGFyKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kZWZpbmVzLmhhcyhcIkNVU1RPTV9JTlBVVF9ET01BSU5cIikpIHtcbiAgICAgICAgICBjb25zdCBkb21haW5TY2FsZSA9IGx1dC5kb21haW5NYXguY2xvbmUoKS5zdWIobHV0LmRvbWFpbk1pbikubXVsdGlwbHlTY2FsYXIoc2l6ZSk7XG4gICAgICAgICAgc2NhbGUuc2V0U2NhbGFyKHNpemUgLSAxKS5kaXZpZGUoZG9tYWluU2NhbGUpO1xuICAgICAgICAgIG9mZnNldC5jb3B5KGx1dC5kb21haW5NaW4pLm5lZ2F0ZSgpLm11bHRpcGx5KHNjYWxlKS5hZGRTY2FsYXIoMSAvICgyICogc2l6ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlLnNldFNjYWxhcigoc2l6ZSAtIDEpIC8gc2l6ZSk7XG4gICAgICAgICAgb2Zmc2V0LnNldFNjYWxhcigxIC8gKDIgKiBzaXplKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgcGFyYW1ldGVycyBmb3IgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ3VyZVRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbigpIHtcbiAgICBjb25zdCBsdXQgPSB0aGlzLmx1dDtcbiAgICBpZiAobHV0ICE9PSBudWxsKSB7XG4gICAgICBsdXQubWluRmlsdGVyID0gTGluZWFyRmlsdGVyNDtcbiAgICAgIGx1dC5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI0O1xuICAgICAgaWYgKHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGlmIChsdXQgaW5zdGFuY2VvZiBEYXRhM0RUZXh0dXJlMikge1xuICAgICAgICAgIGx1dC5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyNztcbiAgICAgICAgICBsdXQubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIDNEIHRleHR1cmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsdXQuc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgbHV0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRldHJhaGVkcmFsIGludGVycG9sYXRpb24gaXMgZW5hYmxlZC4gUmVxdWlyZXMgYSAzRCBMVVQsIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIFRldHJhaGVkcmFsIGludGVycG9sYXRpb24gcHJvZHVjZXMgaGlnaGx5IGFjY3VyYXRlIHJlc3VsdHMgYnV0IGlzIHNsb3dlciB0aGFuIGhhcmR3YXJlIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cIik7XG4gIH1cbiAgc2V0IHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlRFVFJBSEVEUkFMX0lOVEVSUE9MQVRJT05cIiwgXCIxXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiVEVUUkFIRURSQUxfSU5URVJQT0xBVElPTlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWd1cmVUZXRyYWhlZHJhbEludGVycG9sYXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVNjYWxlT2Zmc2V0KCk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGV0cmFoZWRyYWwgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0ZXRyYWhlZHJhbCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0VGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uRW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMudGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uID0gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvbm9pc2UuZnJhZ1xudmFyIG5vaXNlX2RlZmF1bHQgPSBcInZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIG5vaXNlPXZlYzMocmFuZCh1diooMS4wK3RpbWUpKSk7XFxuI2lmZGVmIFBSRU1VTFRJUExZXFxub3V0cHV0Q29sb3I9dmVjNChtaW4oaW5wdXRDb2xvci5yZ2Iqbm9pc2UsdmVjMygxLjApKSxpbnB1dENvbG9yLmEpO1xcbiNlbHNlXFxub3V0cHV0Q29sb3I9dmVjNChub2lzZSxpbnB1dENvbG9yLmEpO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL2VmZmVjdHMvTm9pc2VFZmZlY3QuanNcbnZhciBOb2lzZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgbm9pc2UgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNDUkVFTl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucHJlbXVsdGlwbHk9ZmFsc2VdIC0gV2hldGhlciB0aGUgbm9pc2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sIHByZW11bHRpcGx5ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJOb2lzZUVmZmVjdFwiLCBub2lzZV9kZWZhdWx0LCB7IGJsZW5kRnVuY3Rpb24gfSk7XG4gICAgdGhpcy5wcmVtdWx0aXBseSA9IHByZW11bHRpcGx5O1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBub2lzZSB3aWxsIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBwcmVtdWx0aXBseSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlBSRU1VTFRJUExZXCIpO1xuICB9XG4gIHNldCBwcmVtdWx0aXBseSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZW11bHRpcGx5ICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJQUkVNVUxUSVBMWVwiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiUFJFTVVMVElQTFlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG5vaXNlIHdpbGwgYmUgbXVsdGlwbGllZCB3aXRoIHRoZSBpbnB1dCBjb2xvcnMgcHJpb3IgdG8gYmxlbmRpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcmVtdWx0aXBseSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG5vaXNlIGlzIHByZW11bHRpcGxpZWQuXG4gICAqL1xuICBpc1ByZW11bHRpcGxpZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlbXVsdGlwbHk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIHdoZXRoZXIgbm9pc2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQgY29sb3JzIHByaW9yIHRvIGJsZW5kaW5nLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJlbXVsdGlwbHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgbm9pc2Ugc2hvdWxkIGJlIHByZW11bHRpcGxpZWQuXG4gICAqL1xuICBzZXRQcmVtdWx0aXBsaWVkKHZhbHVlKSB7XG4gICAgdGhpcy5wcmVtdWx0aXBseSA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9PdXRsaW5lRWZmZWN0LmpzXG5pbXBvcnQgeyBDb2xvciBhcyBDb2xvcjYsIFJlcGVhdFdyYXBwaW5nIGFzIFJlcGVhdFdyYXBwaW5nMiwgVW5pZm9ybSBhcyBVbmlmb3JtMzksIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTE1LCBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE4IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvb3V0bGluZS5mcmFnXG52YXIgb3V0bGluZV9kZWZhdWx0MyA9IFwidW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBlZGdlVGV4dHVyZTt1bmlmb3JtIGxvd3Agc2FtcGxlcjJEIG1hc2tUZXh0dXJlO3VuaWZvcm0gdmVjMyB2aXNpYmxlRWRnZUNvbG9yO3VuaWZvcm0gdmVjMyBoaWRkZW5FZGdlQ29sb3I7dW5pZm9ybSBmbG9hdCBwdWxzZTt1bmlmb3JtIGZsb2F0IGVkZ2VTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1BBVFRFUk5cXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIHBhdHRlcm5UZXh0dXJlO3ZhcnlpbmcgdmVjMiB2VXZQYXR0ZXJuO1xcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMyIGVkZ2U9dGV4dHVyZTJEKGVkZ2VUZXh0dXJlLHV2KS5yZzt2ZWMyIG1hc2s9dGV4dHVyZTJEKG1hc2tUZXh0dXJlLHV2KS5yZztcXG4jaWZuZGVmIFhfUkFZXFxuZWRnZS55PTAuMDtcXG4jZW5kaWZcXG5lZGdlKj0oZWRnZVN0cmVuZ3RoKm1hc2sueCpwdWxzZSk7dmVjMyBjb2xvcj1lZGdlLngqdmlzaWJsZUVkZ2VDb2xvcitlZGdlLnkqaGlkZGVuRWRnZUNvbG9yO2Zsb2F0IHZpc2liaWxpdHlGYWN0b3I9MC4wO1xcbiNpZmRlZiBVU0VfUEFUVEVSTlxcbnZlYzQgcGF0dGVybkNvbG9yPXRleHR1cmUyRChwYXR0ZXJuVGV4dHVyZSx2VXZQYXR0ZXJuKTtcXG4jaWZkZWYgWF9SQVlcXG5mbG9hdCBoaWRkZW5GYWN0b3I9MC41O1xcbiNlbHNlXFxuZmxvYXQgaGlkZGVuRmFjdG9yPTAuMDtcXG4jZW5kaWZcXG52aXNpYmlsaXR5RmFjdG9yPSgxLjAtbWFzay55PjAuMCk/MS4wOmhpZGRlbkZhY3Rvcjt2aXNpYmlsaXR5RmFjdG9yKj0oMS4wLW1hc2sueCkqcGF0dGVybkNvbG9yLmE7Y29sb3IrPXZpc2liaWxpdHlGYWN0b3IqcGF0dGVybkNvbG9yLnJnYjtcXG4jZW5kaWZcXG5mbG9hdCBhbHBoYT1tYXgobWF4KGVkZ2UueCxlZGdlLnkpLHZpc2liaWxpdHlGYWN0b3IpO1xcbiNpZmRlZiBBTFBIQVxcbm91dHB1dENvbG9yPXZlYzQoY29sb3IsYWxwaGEpO1xcbiNlbHNlXFxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixtYXgoYWxwaGEsaW5wdXRDb2xvci5hKSk7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL291dGxpbmUudmVydFxudmFyIG91dGxpbmVfZGVmYXVsdDQgPSBcInVuaWZvcm0gZmxvYXQgcGF0dGVyblNjYWxlO3ZhcnlpbmcgdmVjMiB2VXZQYXR0ZXJuO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dlV2UGF0dGVybj11dip2ZWMyKGFzcGVjdCwxLjApKnBhdHRlcm5TY2FsZTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL091dGxpbmVFZmZlY3QuanNcbnZhciBPdXRsaW5lRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBvdXRsaW5lIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgbWFpbiBzY2VuZS5cbiAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TQ1JFRU5dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uLiBVc2UgYEJsZW5kRnVuY3Rpb24uQUxQSEFgIGZvciBkYXJrIG91dGxpbmVzLlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLnBhdHRlcm5UZXh0dXJlPW51bGxdIC0gQSBwYXR0ZXJuIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXR0ZXJuU2NhbGU9MS4wXSAtIFRoZSBwYXR0ZXJuIHNjYWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWRnZVN0cmVuZ3RoPTEuMF0gLSBUaGUgZWRnZSBzdHJlbmd0aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnB1bHNlU3BlZWQ9MC4wXSAtIFRoZSBwdWxzZSBzcGVlZC4gQSB2YWx1ZSBvZiB6ZXJvIGRpc2FibGVzIHRoZSBwdWxzZSBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aXNpYmxlRWRnZUNvbG9yPTB4ZmZmZmZmXSAtIFRoZSBjb2xvciBvZiB2aXNpYmxlIGVkZ2VzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGlkZGVuRWRnZUNvbG9yPTB4MjIwOTBhXSAtIFRoZSBjb2xvciBvZiBoaWRkZW4gZWRnZXMuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLlZFUllfU01BTExdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmx1cj1mYWxzZV0gLSBXaGV0aGVyIHRoZSBvdXRsaW5lIHNob3VsZCBiZSBibHVycmVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnhSYXk9dHJ1ZV0gLSBXaGV0aGVyIG9jY2x1ZGVkIHBhcnRzIG9mIHNlbGVjdGVkIG9iamVjdHMgc2hvdWxkIGJlIHZpc2libGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXNhbXBsaW5nPTBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHVzZWQgZm9yIG11bHRpc2FtcGxlIGFudGlhbGlhc2luZy4gUmVxdWlyZXMgV2ViR0wgMi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjZW5lLCBjYW1lcmEsIHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TQ1JFRU4sXG4gICAgcGF0dGVyblRleHR1cmUgPSBudWxsLFxuICAgIHBhdHRlcm5TY2FsZSA9IDEsXG4gICAgZWRnZVN0cmVuZ3RoID0gMSxcbiAgICBwdWxzZVNwZWVkID0gMCxcbiAgICB2aXNpYmxlRWRnZUNvbG9yID0gMTY3NzcyMTUsXG4gICAgaGlkZGVuRWRnZUNvbG9yID0gMjIzMDUzOCxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5WRVJZX1NNQUxMLFxuICAgIGJsdXIgPSBmYWxzZSxcbiAgICB4UmF5ID0gdHJ1ZSxcbiAgICBtdWx0aXNhbXBsaW5nID0gMCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAwLjUsXG4gICAgd2lkdGggPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICBoZWlnaHQgPSBSZXNvbHV0aW9uLkFVVE9fU0laRSxcbiAgICByZXNvbHV0aW9uWCA9IHdpZHRoLFxuICAgIHJlc29sdXRpb25ZID0gaGVpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiT3V0bGluZUVmZmVjdFwiLCBvdXRsaW5lX2RlZmF1bHQzLCB7XG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJtYXNrVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTM5KG51bGwpXSxcbiAgICAgICAgW1wiZWRnZVRleHR1cmVcIiwgbmV3IFVuaWZvcm0zOShudWxsKV0sXG4gICAgICAgIFtcImVkZ2VTdHJlbmd0aFwiLCBuZXcgVW5pZm9ybTM5KGVkZ2VTdHJlbmd0aCldLFxuICAgICAgICBbXCJ2aXNpYmxlRWRnZUNvbG9yXCIsIG5ldyBVbmlmb3JtMzkobmV3IENvbG9yNih2aXNpYmxlRWRnZUNvbG9yKSldLFxuICAgICAgICBbXCJoaWRkZW5FZGdlQ29sb3JcIiwgbmV3IFVuaWZvcm0zOShuZXcgQ29sb3I2KGhpZGRlbkVkZ2VDb2xvcikpXSxcbiAgICAgICAgW1wicHVsc2VcIiwgbmV3IFVuaWZvcm0zOSgxKV0sXG4gICAgICAgIFtcInBhdHRlcm5TY2FsZVwiLCBuZXcgVW5pZm9ybTM5KHBhdHRlcm5TY2FsZSldLFxuICAgICAgICBbXCJwYXR0ZXJuVGV4dHVyZVwiLCBuZXcgVW5pZm9ybTM5KG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLmJsZW5kTW9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24gPT09IEJsZW5kRnVuY3Rpb24uQUxQSEEpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkFMUEhBXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJBTFBIQVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH0pO1xuICAgIHRoaXMuYmxlbmRNb2RlLmJsZW5kRnVuY3Rpb24gPSBibGVuZEZ1bmN0aW9uO1xuICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSBwYXR0ZXJuVGV4dHVyZTtcbiAgICB0aGlzLnhSYXkgPSB4UmF5O1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2sgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQxOCgxLCAxKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suc2FtcGxlcyA9IG11bHRpc2FtcGxpbmc7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmUubmFtZSA9IFwiT3V0bGluZS5NYXNrXCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXNrVGV4dHVyZVwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0TWFzay50ZXh0dXJlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDE4KDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0T3V0bGluZS50ZXh0dXJlLm5hbWUgPSBcIk91dGxpbmUuRWRnZXNcIjtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VUZXh0dXJlXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLnRleHR1cmU7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKCk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNigwKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMuZGVwdGhQYXNzID0gbmV3IERlcHRoUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLm1hc2tQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgbmV3IERlcHRoQ29tcGFyaXNvbk1hdGVyaWFsKHRoaXMuZGVwdGhQYXNzLnRleHR1cmUsIGNhbWVyYSkpO1xuICAgIGNvbnN0IGNsZWFyUGFzcyA9IHRoaXMubWFza1Bhc3MuY2xlYXJQYXNzO1xuICAgIGNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQ29sb3IgPSBuZXcgQ29sb3I2KDE2Nzc3MjE1KTtcbiAgICBjbGVhclBhc3Mub3ZlcnJpZGVDbGVhckFscGhhID0gMTtcbiAgICB0aGlzLmJsdXJQYXNzID0gbmV3IEthd2FzZUJsdXJQYXNzKHsgcmVzb2x1dGlvblNjYWxlLCByZXNvbHV0aW9uWCwgcmVzb2x1dGlvblksIGtlcm5lbFNpemUgfSk7XG4gICAgdGhpcy5ibHVyUGFzcy5lbmFibGVkID0gYmx1cjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5ibHVyUGFzcy5yZXNvbHV0aW9uO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLm91dGxpbmVQYXNzID0gbmV3IFNoYWRlclBhc3MobmV3IE91dGxpbmVNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBvdXRsaW5lTWF0ZXJpYWwgPSB0aGlzLm91dGxpbmVQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgICBvdXRsaW5lTWF0ZXJpYWwuaW5wdXRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbigpO1xuICAgIHRoaXMuc2VsZWN0aW9uLmxheWVyID0gMTA7XG4gICAgdGhpcy5wdWxzZVNwZWVkID0gcHVsc2VTcGVlZDtcbiAgfVxuICBzZXQgbWFpblNjZW5lKHZhbHVlKSB7XG4gICAgdGhpcy5zY2VuZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5TY2VuZSA9IHZhbHVlO1xuICAgIHRoaXMubWFza1Bhc3MubWFpblNjZW5lID0gdmFsdWU7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm1haW5DYW1lcmEgPSB2YWx1ZTtcbiAgICB0aGlzLm1hc2tQYXNzLm92ZXJyaWRlTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlc29sdXRpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEB0eXBlIHtSZXNvbHV0aW9ufVxuICAgKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MucmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x1dGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UmVzaXplcn0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmdldFJlc29sdXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBNU0FBIHNhbXBsZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIFdlYkdMIDIuIFNldCB0byB6ZXJvIHRvIGRpc2FibGUgbXVsdGlzYW1wbGluZy5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbCBSZXF1aXJlcyB0aHJlZSA+PSByMTM4LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG11bHRpc2FtcGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zYW1wbGVzO1xuICB9XG4gIHNldCBtdWx0aXNhbXBsaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrLnNhbXBsZXMgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2suZGlzcG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiBzY2FsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBwYXR0ZXJuU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwicGF0dGVyblNjYWxlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBwYXR0ZXJuU2NhbGUodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5TY2FsZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSBzdHJlbmd0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBlZGdlU3RyZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwiZWRnZVN0cmVuZ3RoXCIpLnZhbHVlO1xuICB9XG4gIHNldCBlZGdlU3RyZW5ndGgodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImVkZ2VTdHJlbmd0aFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdmlzaWJsZSBlZGdlIGNvbG9yLlxuICAgKlxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqL1xuICBnZXQgdmlzaWJsZUVkZ2VDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJ2aXNpYmxlRWRnZUNvbG9yXCIpLnZhbHVlO1xuICB9XG4gIHNldCB2aXNpYmxlRWRnZUNvbG9yKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJ2aXNpYmxlRWRnZUNvbG9yXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoaWRkZW4gZWRnZSBjb2xvci5cbiAgICpcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKi9cbiAgZ2V0IGhpZGRlbkVkZ2VDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJoaWRkZW5FZGdlQ29sb3JcIikudmFsdWU7XG4gIH1cbiAgc2V0IGhpZGRlbkVkZ2VDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiaGlkZGVuRWRnZUNvbG9yXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJsdXIgcGFzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsdXJQYXNzIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0thd2FzZUJsdXJQYXNzfSBUaGUgYmx1ciBwYXNzLlxuICAgKi9cbiAgZ2V0Qmx1clBhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFRoZSBzZWxlY3Rpb24uXG4gICAqL1xuICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwdWxzZSBzcGVlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHB1bHNlU3BlZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3BlZWQuXG4gICAqL1xuICBnZXRQdWxzZVNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnB1bHNlU3BlZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHB1bHNlIHNwZWVkLiBTZXQgdG8gemVybyB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHVsc2VTcGVlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgc3BlZWQuXG4gICAqL1xuICBzZXRQdWxzZVNwZWVkKHZhbHVlKSB7XG4gICAgdGhpcy5wdWxzZVNwZWVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24ud2lkdGggaW5zdGVhZC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRXaWR0aCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbi5oZWlnaHQgaW5zdGVhZC5cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5wcmVmZXJyZWRIZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBsYXllci5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNlbGVjdGlvbi5sYXllciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNlbGVjdGlvbkxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5sYXllcjtcbiAgfVxuICBzZXQgc2VsZWN0aW9uTGF5ZXIodmFsdWUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5sYXllciA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXRoZXJpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgZGl0aGVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJQYXNzLmRpdGhlcmluZztcbiAgfVxuICBzZXQgZGl0aGVyaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5kaXRoZXJpbmcgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJsdXIga2VybmVsIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtLZXJuZWxTaXplfVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3Mua2VybmVsU2l6ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGtlcm5lbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZTtcbiAgfVxuICBzZXQga2VybmVsU2l6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb3V0bGluZXMgc2hvdWxkIGJlIGJsdXJyZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmx1clBhc3MuZW5hYmxlZCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clBhc3MuZW5hYmxlZDtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clBhc3MuZW5hYmxlZCA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBYLXJheSBtb2RlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHhSYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJYX1JBWVwiKTtcbiAgfVxuICBzZXQgeFJheSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnhSYXkgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlhfUkFZXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJYX1JBWVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgWC1yYXkgbW9kZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgeFJheSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIFgtcmF5IG1vZGUgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzWFJheUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMueFJheTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBYLXJheSBvdXRsaW5lcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHhSYXkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgWC1yYXkgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRYUmF5RW5hYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMueFJheSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0ZXh0dXJlLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IHBhdHRlcm5UZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInBhdHRlcm5UZXh0dXJlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBwYXR0ZXJuVGV4dHVyZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUud3JhcFMgPSB2YWx1ZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nMjtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJVU0VfUEFUVEVSTlwiLCBcIjFcIik7XG4gICAgICB0aGlzLnNldFZlcnRleFNoYWRlcihvdXRsaW5lX2RlZmF1bHQ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIlVTRV9QQVRURVJOXCIpO1xuICAgICAgdGhpcy5zZXRWZXJ0ZXhTaGFkZXIobnVsbCk7XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwicGF0dGVyblRleHR1cmVcIikudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGF0dGVybiB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcGF0dGVyblRleHR1cmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBuZXcgdGV4dHVyZS5cbiAgICovXG4gIHNldFBhdHRlcm5UZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5wYXR0ZXJuVGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlc29sdXRpb24gc2NhbGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5zY2FsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIG5ldyByZXNvbHV0aW9uIHNjYWxlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvblNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uLnNjYWxlID0gc2NhbGU7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgYSBsaXN0IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0RbXX0gb2JqZWN0cyAtIFRoZSBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIG91dGxpbmVkLiBUaGlzIGFycmF5IHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPdXRsaW5lUGFzc30gVGhpcyBwYXNzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uLnNldCgpIGluc3RlYWQuXG4gICAqL1xuICBzZXRTZWxlY3Rpb24ob2JqZWN0cykge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNldChvYmplY3RzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBsaXN0IG9mIHNlbGVjdGVkIG9iamVjdHMuXG4gICAqXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uY2xlYXIoKSBpbnN0ZWFkLlxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2VsZWN0cyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgb3V0bGluZWQuXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uYWRkKCkgaW5zdGVhZC5cbiAgICovXG4gIHNlbGVjdE9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5hZGQob2JqZWN0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVzZWxlY3RzIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QzRH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0aGF0IHNob3VsZCBubyBsb25nZXIgYmUgb3V0bGluZWQuXG4gICAqIEByZXR1cm4ge091dGxpbmVQYXNzfSBUaGlzIHBhc3MuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZWxlY3Rpb24uZGVsZXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGRlc2VsZWN0T2JqZWN0KG9iamVjdCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLmRlbGV0ZShvYmplY3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IHB1bHNlID0gdW5pZm9ybXMuZ2V0KFwicHVsc2VcIik7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgY29uc3QgbWFzayA9IGNhbWVyYS5sYXllcnMubWFzaztcbiAgICBpZiAodGhpcy5mb3JjZVVwZGF0ZSB8fCBzZWxlY3Rpb24uc2l6ZSA+IDApIHtcbiAgICAgIHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgcHVsc2UudmFsdWUgPSAxO1xuICAgICAgaWYgKHRoaXMucHVsc2VTcGVlZCA+IDApIHtcbiAgICAgICAgcHVsc2UudmFsdWUgPSBNYXRoLmNvcyh0aGlzLnRpbWUgKiB0aGlzLnB1bHNlU3BlZWQgKiAxMCkgKiAwLjM3NSArIDAuNjI1O1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lICs9IGRlbHRhVGltZTtcbiAgICAgIHNlbGVjdGlvbi5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgIHRoaXMuZGVwdGhQYXNzLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICBzZWxlY3Rpb24uc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgIGNhbWVyYS5sYXllcnMuc2V0KHNlbGVjdGlvbi5sYXllcik7XG4gICAgICB0aGlzLm1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRNYXNrKTtcbiAgICAgIGNhbWVyYS5sYXllcnMubWFzayA9IG1hc2s7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICAgIHRoaXMub3V0bGluZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUpO1xuICAgICAgaWYgKHRoaXMuYmx1clBhc3MuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLCB0aGlzLnJlbmRlclRhcmdldE91dGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZvcmNlVXBkYXRlID0gc2VsZWN0aW9uLnNpemUgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFzay5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuZGVwdGhQYXNzLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRPdXRsaW5lLnNldFNpemUodywgaCk7XG4gICAgdGhpcy5vdXRsaW5lUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwuc2V0U2l6ZSh3LCBoKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgVW5zaWduZWRCeXRlVHlwZTE1KTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVwdGhQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgICAgdGhpcy5tYXNrUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICAgIHRoaXMub3V0bGluZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9QaXhlbGF0aW9uRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MCwgVmVjdG9yMiBhcyBWZWN0b3IyMjQsIFZlY3RvcjQgYXMgVmVjdG9yNDMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9waXhlbGF0aW9uLmZyYWdcbnZhciBwaXhlbGF0aW9uX2RlZmF1bHQgPSBcInVuaWZvcm0gYm9vbCBhY3RpdmU7dW5pZm9ybSB2ZWM0IGQ7dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7aWYoYWN0aXZlKXt1dj1kLnh5KihmbG9vcih1dipkLnp3KSswLjUpO319XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1BpeGVsYXRpb25FZmZlY3QuanNcbnZhciBQaXhlbGF0aW9uRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBwaXhlbGF0aW9uIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtncmFudWxhcml0eT0zMC4wXSAtIFRoZSBwaXhlbCBncmFudWxhcml0eS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdyYW51bGFyaXR5ID0gMzApIHtcbiAgICBzdXBlcihcIlBpeGVsYXRpb25FZmZlY3RcIiwgcGl4ZWxhdGlvbl9kZWZhdWx0LCB7XG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJhY3RpdmVcIiwgbmV3IFVuaWZvcm00MChmYWxzZSldLFxuICAgICAgICBbXCJkXCIsIG5ldyBVbmlmb3JtNDAobmV3IFZlY3RvcjQzKCkpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgVmVjdG9yMjI0KCk7XG4gICAgdGhpcy5fZ3JhbnVsYXJpdHkgPSAwO1xuICAgIHRoaXMuZ3JhbnVsYXJpdHkgPSBncmFudWxhcml0eTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBpeGVsIGdyYW51bGFyaXR5LlxuICAgKlxuICAgKiBBIGhpZ2hlciB2YWx1ZSB5aWVsZHMgY29hcnNlciB2aXN1YWxzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGdyYW51bGFyaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFudWxhcml0eTtcbiAgfVxuICBzZXQgZ3JhbnVsYXJpdHkodmFsdWUpIHtcbiAgICBsZXQgZCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIGlmIChkICUgMiA+IDApIHtcbiAgICAgIGQgKz0gMTtcbiAgICB9XG4gICAgdGhpcy5fZ3JhbnVsYXJpdHkgPSBkO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYWN0aXZlXCIpLnZhbHVlID0gZCA+IDA7XG4gICAgdGhpcy5zZXRTaXplKHRoaXMucmVzb2x1dGlvbi53aWR0aCwgdGhpcy5yZXNvbHV0aW9uLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpeGVsIGdyYW51bGFyaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ3JhbnVsYXJpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZ3JhbnVsYXJpdHkuXG4gICAqL1xuICBnZXRHcmFudWxhcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFudWxhcml0eTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBncmFudWxhcml0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGdyYW51bGFyaXR5LlxuICAgKi9cbiAgc2V0R3JhbnVsYXJpdHkodmFsdWUpIHtcbiAgICB0aGlzLmdyYW51bGFyaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGdyYW51bGFyaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXNvbHV0aW9uLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBkID0gdGhpcy5ncmFudWxhcml0eTtcbiAgICBjb25zdCB4ID0gZCAvIHJlc29sdXRpb24ueDtcbiAgICBjb25zdCB5ID0gZCAvIHJlc29sdXRpb24ueTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImRcIikudmFsdWUuc2V0KHgsIHksIDEgLyB4LCAxIC8geSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1JlYWxpc3RpY0Jva2VoRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MSwgVmVjdG9yNCBhcyBWZWN0b3I0NCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3JlYWxpc3RpYy1ib2tlaC5mcmFnXG52YXIgcmVhbGlzdGljX2Jva2VoX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgZm9jdXM7dW5pZm9ybSBmbG9hdCBmb2NhbExlbmd0aDt1bmlmb3JtIGZsb2F0IGZTdG9wO3VuaWZvcm0gZmxvYXQgbWF4Qmx1cjt1bmlmb3JtIGZsb2F0IGx1bWluYW5jZVRocmVzaG9sZDt1bmlmb3JtIGZsb2F0IGx1bWluYW5jZUdhaW47dW5pZm9ybSBmbG9hdCBiaWFzO3VuaWZvcm0gZmxvYXQgZnJpbmdlO1xcbiNpZmRlZiBNQU5VQUxfRE9GXFxudW5pZm9ybSB2ZWM0IGRvZjtcXG4jZW5kaWZcXG4jaWZkZWYgUEVOVEFHT05cXG5mbG9hdCBwZW50YWdvbihjb25zdCBpbiB2ZWMyIGNvb3Jkcyl7Y29uc3QgdmVjNCBIUzA9dmVjNCgxLjAsMC4wLDAuMCwxLjApO2NvbnN0IHZlYzQgSFMxPXZlYzQoMC4zMDkwMTY5OTQsMC45NTEwNTY1MTYsMC4wLDEuMCk7Y29uc3QgdmVjNCBIUzI9dmVjNCgtMC44MDkwMTY5OTQsMC41ODc3ODUyNTIsMC4wLDEuMCk7Y29uc3QgdmVjNCBIUzM9dmVjNCgtMC44MDkwMTY5OTQsLTAuNTg3Nzg1MjUyLDAuMCwxLjApO2NvbnN0IHZlYzQgSFM0PXZlYzQoMC4zMDkwMTY5OTQsLTAuOTUxMDU2NTE2LDAuMCwxLjApO2NvbnN0IHZlYzQgSFM1PXZlYzQoMC4wLDAuMCwxLjAsMS4wKTtjb25zdCB2ZWM0IE9ORT12ZWM0KDEuMCk7Y29uc3QgZmxvYXQgUF9GRUFUSEVSPTAuNDtjb25zdCBmbG9hdCBOX0ZFQVRIRVI9LVBfRkVBVEhFUjtmbG9hdCBpbk9yT3V0PS00LjA7dmVjNCBQPXZlYzQoY29vcmRzLHZlYzIoUklOR1NfRkxPQVQtMS4zKSk7dmVjNCBkaXN0PXZlYzQoZG90KFAsSFMwKSxkb3QoUCxIUzEpLGRvdChQLEhTMiksZG90KFAsSFMzKSk7ZGlzdD1zbW9vdGhzdGVwKE5fRkVBVEhFUixQX0ZFQVRIRVIsZGlzdCk7aW5Pck91dCs9ZG90KGRpc3QsT05FKTtkaXN0Lng9ZG90KFAsSFM0KTtkaXN0Lnk9SFM1LnctYWJzKFAueik7ZGlzdD1zbW9vdGhzdGVwKE5fRkVBVEhFUixQX0ZFQVRIRVIsZGlzdCk7aW5Pck91dCs9ZGlzdC54O3JldHVybiBjbGFtcChpbk9yT3V0LDAuMCwxLjApO31cXG4jZW5kaWZcXG52ZWMzIHByb2Nlc3NUZXhlbChjb25zdCBpbiB2ZWMyIGNvb3Jkcyxjb25zdCBpbiBmbG9hdCBibHVyKXt2ZWMyIHNjYWxlPXRleGVsU2l6ZSpmcmluZ2UqYmx1cjt2ZWMzIGM9dmVjMyh0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzK3ZlYzIoMC4wLDEuMCkqc2NhbGUpLnIsdGV4dHVyZTJEKGlucHV0QnVmZmVyLGNvb3Jkcyt2ZWMyKC0wLjg2NiwtMC41KSpzY2FsZSkuZyx0ZXh0dXJlMkQoaW5wdXRCdWZmZXIsY29vcmRzK3ZlYzIoMC44NjYsLTAuNSkqc2NhbGUpLmIpO2Zsb2F0IGx1bWluYW5jZT1saW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKGMpO2Zsb2F0IHRocmVzaG9sZD1tYXgoKGx1bWluYW5jZS1sdW1pbmFuY2VUaHJlc2hvbGQpKmx1bWluYW5jZUdhaW4sMC4wKTtyZXR1cm4gYyttaXgodmVjMygwLjApLGMsdGhyZXNob2xkKmJsdXIpO31mbG9hdCBnYXRoZXIoY29uc3QgaW4gZmxvYXQgaSxjb25zdCBpbiBmbG9hdCBqLGNvbnN0IGluIGZsb2F0IHJpbmdTYW1wbGVzLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gdmVjMiBibHVyRmFjdG9yLGNvbnN0IGluIGZsb2F0IGJsdXIsaW5vdXQgdmVjMyBjb2xvcil7ZmxvYXQgc3RlcD1QSTIvcmluZ1NhbXBsZXM7dmVjMiB3aD12ZWMyKGNvcyhqKnN0ZXApKmksc2luKGoqc3RlcCkqaSk7XFxuI2lmZGVmIFBFTlRBR09OXFxuZmxvYXQgcD1wZW50YWdvbih3aCk7XFxuI2Vsc2VcXG5mbG9hdCBwPTEuMDtcXG4jZW5kaWZcXG5jb2xvcis9cHJvY2Vzc1RleGVsKHdoKmJsdXJGYWN0b3IrdXYsYmx1cikqbWl4KDEuMCxpL1JJTkdTX0ZMT0FULGJpYXMpKnA7cmV0dXJuIG1peCgxLjAsaS9SSU5HU19GTE9BVCxiaWFzKSpwO312b2lkIG1haW5JbWFnZShjb25zdCBpbiB2ZWM0IGlucHV0Q29sb3IsY29uc3QgaW4gdmVjMiB1dixjb25zdCBpbiBmbG9hdCBkZXB0aCxvdXQgdmVjNCBvdXRwdXRDb2xvcil7XFxuI2lmZGVmIFBFUlNQRUNUSVZFX0NBTUVSQVxcbmZsb2F0IHZpZXdaPXBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGRlcHRoLGNhbWVyYU5lYXIsY2FtZXJhRmFyKTtmbG9hdCBsaW5lYXJEZXB0aD12aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osY2FtZXJhTmVhcixjYW1lcmFGYXIpO1xcbiNlbHNlXFxuZmxvYXQgbGluZWFyRGVwdGg9ZGVwdGg7XFxuI2VuZGlmXFxuI2lmZGVmIE1BTlVBTF9ET0ZcXG5mbG9hdCBmb2NhbFBsYW5lPWxpbmVhckRlcHRoLWZvY3VzO2Zsb2F0IGZhckRvRj0oZm9jYWxQbGFuZS1kb2YueikvZG9mLnc7ZmxvYXQgbmVhckRvRj0oLWZvY2FsUGxhbmUtZG9mLngpL2RvZi55O2Zsb2F0IGJsdXI9KGZvY2FsUGxhbmU+MC4wKT9mYXJEb0Y6bmVhckRvRjtcXG4jZWxzZVxcbmNvbnN0IGZsb2F0IENJUkNMRV9PRl9DT05GVVNJT049MC4wMztmbG9hdCBmb2NhbFBsYW5lTU09Zm9jdXMqMTAwMC4wO2Zsb2F0IGRlcHRoTU09bGluZWFyRGVwdGgqMTAwMC4wO2Zsb2F0IGZvY2FsUGxhbmU9KGRlcHRoTU0qZm9jYWxMZW5ndGgpLyhkZXB0aE1NLWZvY2FsTGVuZ3RoKTtmbG9hdCBmYXJEb0Y9KGZvY2FsUGxhbmVNTSpmb2NhbExlbmd0aCkvKGZvY2FsUGxhbmVNTS1mb2NhbExlbmd0aCk7ZmxvYXQgbmVhckRvRj0oZm9jYWxQbGFuZU1NLWZvY2FsTGVuZ3RoKS8oZm9jYWxQbGFuZU1NKmZTdG9wKkNJUkNMRV9PRl9DT05GVVNJT04pO2Zsb2F0IGJsdXI9YWJzKGZvY2FsUGxhbmUtZmFyRG9GKSpuZWFyRG9GO1xcbiNlbmRpZlxcbmNvbnN0IGludCBNQVhfUklOR19TQU1QTEVTPVJJTkdTX0lOVCpTQU1QTEVTX0lOVDtibHVyPWNsYW1wKGJsdXIsMC4wLDEuMCk7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYjtpZihibHVyPj0wLjA1KXt2ZWMyIGJsdXJGYWN0b3I9Ymx1ciptYXhCbHVyKnRleGVsU2l6ZTtmbG9hdCBzPTEuMDtpbnQgcmluZ1NhbXBsZXM7Zm9yKGludCBpPTE7aTw9UklOR1NfSU5UO2krKyl7cmluZ1NhbXBsZXM9aSpTQU1QTEVTX0lOVDtmb3IoaW50IGo9MDtqPE1BWF9SSU5HX1NBTVBMRVM7aisrKXtpZihqPj1yaW5nU2FtcGxlcyl7YnJlYWs7fXMrPWdhdGhlcihmbG9hdChpKSxmbG9hdChqKSxmbG9hdChyaW5nU2FtcGxlcyksdXYsYmx1ckZhY3RvcixibHVyLGNvbG9yKTt9fWNvbG9yLz1zO31cXG4jaWZkZWYgU0hPV19GT0NVU1xcbmZsb2F0IGVkZ2U9MC4wMDIqbGluZWFyRGVwdGg7ZmxvYXQgbT1jbGFtcChzbW9vdGhzdGVwKDAuMCxlZGdlLGJsdXIpLDAuMCwxLjApO2Zsb2F0IGU9Y2xhbXAoc21vb3Roc3RlcCgxLjAtZWRnZSwxLjAsYmx1ciksMC4wLDEuMCk7Y29sb3I9bWl4KGNvbG9yLHZlYzMoMS4wLDAuNSwwLjApLCgxLjAtbSkqMC42KTtjb2xvcj1taXgoY29sb3IsdmVjMygwLjAsMC41LDEuMCksKCgxLjAtZSktKDEuMC1tKSkqMC4yKTtcXG4jZW5kaWZcXG5vdXRwdXRDb2xvcj12ZWM0KGNvbG9yLGlucHV0Q29sb3IuYSk7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9SZWFsaXN0aWNCb2tlaEVmZmVjdC5qc1xudmFyIFJlYWxpc3RpY0Jva2VoRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBib2tlaCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCbGVuZEZ1bmN0aW9ufSBbb3B0aW9ucy5ibGVuZEZ1bmN0aW9uXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzPTEuMF0gLSBUaGUgZm9jdXMgZGlzdGFuY2UgaW4gd29ybGQgdW5pdHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2NhbExlbmd0aD0yNC4wXSAtIFRoZSBmb2NhbCBsZW5ndGggb2YgdGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZlN0b3A9MC45XSAtIFRoZSByYXRpbyBvZiB0aGUgbGVucyBmb2NhbCBsZW5ndGggdG8gdGhlIGRpYW1ldGVyIG9mIHRoZSBlbnRyYW5jZSBwdXBpbCAoYXBlcnR1cmUpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubHVtaW5hbmNlVGhyZXNob2xkPTAuNV0gLSBBIGx1bWluYW5jZSB0aHJlc2hvbGQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sdW1pbmFuY2VHYWluPTIuMF0gLSBBIGx1bWluYW5jZSBnYWluIGZhY3Rvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJpYXM9MC41XSAtIEEgYmx1ciBiaWFzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpbmdlPTAuN10gLSBBIGJsdXIgb2Zmc2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Qmx1cj0xLjBdIC0gVGhlIG1heGltdW0gYmx1ciBzdHJlbmd0aC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yaW5ncz0zXSAtIFRoZSBudW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNhbXBsZXM9Ml0gLSBUaGUgYW1vdW50IG9mIHNhbXBsZXMgdGFrZW4gcGVyIHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hvd0ZvY3VzPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGZvY2FsIHBvaW50IHNob3VsZCBiZSBoaWdobGlnaHRlZC4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFudWFsRG9GPWZhbHNlXSAtIEVuYWJsZXMgbWFudWFsIGNvbnRyb2wgb3ZlciB0aGUgZGVwdGggb2YgZmllbGQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucGVudGFnb249ZmFsc2VdIC0gRW5hYmxlcyBwZW50YWdvbmFsIGJsdXIgc2hhcGVzLiBSZXF1aXJlcyBhIGhpZ2ggbnVtYmVyIG9mIHJpbmdzIGFuZCBzYW1wbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgZm9jdXMgPSAxLFxuICAgIGZvY2FsTGVuZ3RoID0gMjQsXG4gICAgZlN0b3AgPSAwLjksXG4gICAgbHVtaW5hbmNlVGhyZXNob2xkID0gMC41LFxuICAgIGx1bWluYW5jZUdhaW4gPSAyLFxuICAgIGJpYXMgPSAwLjUsXG4gICAgZnJpbmdlID0gMC43LFxuICAgIG1heEJsdXIgPSAxLFxuICAgIHJpbmdzID0gMyxcbiAgICBzYW1wbGVzID0gMixcbiAgICBzaG93Rm9jdXMgPSBmYWxzZSxcbiAgICBtYW51YWxEb0YgPSBmYWxzZSxcbiAgICBwZW50YWdvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiUmVhbGlzdGljQm9rZWhFZmZlY3RcIiwgcmVhbGlzdGljX2Jva2VoX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBhdHRyaWJ1dGVzOiBFZmZlY3RBdHRyaWJ1dGUuQ09OVk9MVVRJT04gfCBFZmZlY3RBdHRyaWJ1dGUuREVQVEgsXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJmb2N1c1wiLCBuZXcgVW5pZm9ybTQxKGZvY3VzKV0sXG4gICAgICAgIFtcImZvY2FsTGVuZ3RoXCIsIG5ldyBVbmlmb3JtNDEoZm9jYWxMZW5ndGgpXSxcbiAgICAgICAgW1wiZlN0b3BcIiwgbmV3IFVuaWZvcm00MShmU3RvcCldLFxuICAgICAgICBbXCJsdW1pbmFuY2VUaHJlc2hvbGRcIiwgbmV3IFVuaWZvcm00MShsdW1pbmFuY2VUaHJlc2hvbGQpXSxcbiAgICAgICAgW1wibHVtaW5hbmNlR2FpblwiLCBuZXcgVW5pZm9ybTQxKGx1bWluYW5jZUdhaW4pXSxcbiAgICAgICAgW1wiYmlhc1wiLCBuZXcgVW5pZm9ybTQxKGJpYXMpXSxcbiAgICAgICAgW1wiZnJpbmdlXCIsIG5ldyBVbmlmb3JtNDEoZnJpbmdlKV0sXG4gICAgICAgIFtcIm1heEJsdXJcIiwgbmV3IFVuaWZvcm00MShtYXhCbHVyKV0sXG4gICAgICAgIFtcImRvZlwiLCBuZXcgVW5pZm9ybTQxKG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJpbmdzID0gcmluZ3M7XG4gICAgdGhpcy5zYW1wbGVzID0gc2FtcGxlcztcbiAgICB0aGlzLnNob3dGb2N1cyA9IHNob3dGb2N1cztcbiAgICB0aGlzLm1hbnVhbERvRiA9IG1hbnVhbERvRjtcbiAgICB0aGlzLnBlbnRhZ29uID0gcGVudGFnb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgYmx1ciBpdGVyYXRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJpbmdzKCkge1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGhpcy5kZWZpbmVzLmdldChcIlJJTkdTX0lOVFwiKSk7XG4gIH1cbiAgc2V0IHJpbmdzKHZhbHVlKSB7XG4gICAgY29uc3QgciA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJSSU5HU19JTlRcIiwgci50b0ZpeGVkKDApKTtcbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiUklOR1NfRkxPQVRcIiwgci50b0ZpeGVkKDEpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBibHVyIHNhbXBsZXMgcGVyIHJpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2FtcGxlcygpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRoaXMuZGVmaW5lcy5nZXQoXCJTQU1QTEVTX0lOVFwiKSk7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlNBTVBMRVNfSU5UXCIsIHMudG9GaXhlZCgwKSk7XG4gICAgdGhpcy5kZWZpbmVzLnNldChcIlNBTVBMRVNfRkxPQVRcIiwgcy50b0ZpeGVkKDEpKTtcbiAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGZvY2FsIHBvaW50IHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHNob3dGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbmVzLmhhcyhcIlNIT1dfRk9DVVNcIik7XG4gIH1cbiAgc2V0IHNob3dGb2N1cyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNob3dGb2N1cyAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwiU0hPV19GT0NVU1wiLCBcIjFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlZmluZXMuZGVsZXRlKFwiU0hPV19GT0NVU1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERlcHRoIG9mIEZpZWxkIHNob3VsZCBiZSBjYWxjdWxhdGVkIG1hbnVhbGx5LlxuICAgKlxuICAgKiBJZiBlbmFibGVkLCB0aGUgRGVwdGggb2YgRmllbGQgY2FuIGJlIGFkanVzdGVkIHZpYSB0aGUgYGRvZmAgdW5pZm9ybS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbWFudWFsRG9GKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiTUFOVUFMX0RPRlwiKTtcbiAgfVxuICBzZXQgbWFudWFsRG9GKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubWFudWFsRG9GICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJNQU5VQUxfRE9GXCIsIFwiMVwiKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJkb2ZcIikudmFsdWUgPSBuZXcgVmVjdG9yNDQoMC4yLCAxLCAwLjIsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLmRlbGV0ZShcIk1BTlVBTF9ET0ZcIik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZG9mXCIpLnZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJsdXIgc2hhcGUgc2hvdWxkIGJlIHBlbnRhZ29uYWwuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHBlbnRhZ29uKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXMuaGFzKFwiUEVOVEFHT05cIik7XG4gIH1cbiAgc2V0IHBlbnRhZ29uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucGVudGFnb24gIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlBFTlRBR09OXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJQRU5UQUdPTlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2NhbmxpbmVFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTQyLCBWZWN0b3IyIGFzIFZlY3RvcjIyNSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NjYW5saW5lcy5mcmFnXG52YXIgc2NhbmxpbmVzX2RlZmF1bHQgPSBcInVuaWZvcm0gZmxvYXQgY291bnQ7XFxuI2lmZGVmIFNDUk9MTFxcbnVuaWZvcm0gZmxvYXQgc2Nyb2xsU3BlZWQ7XFxuI2VuZGlmXFxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IHk9dXYueTtcXG4jaWZkZWYgU0NST0xMXFxueSs9dGltZSpzY3JvbGxTcGVlZDtcXG4jZW5kaWZcXG52ZWMyIHNsPXZlYzIoc2luKHkqY291bnQpLGNvcyh5KmNvdW50KSk7b3V0cHV0Q29sb3I9dmVjNChzbC54eXgsaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1NjYW5saW5lRWZmZWN0LmpzXG52YXIgU2NhbmxpbmVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNjYW5saW5lIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5PVkVSTEFZXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbnNpdHk9MS4yNV0gLSBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjcm9sbFNwZWVkPTAuMF0gLSBUaGUgc2NhbmxpbmUgc2Nyb2xsIHNwZWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5PVkVSTEFZLCBkZW5zaXR5ID0gMS4yNSwgc2Nyb2xsU3BlZWQgPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2NhbmxpbmVFZmZlY3RcIiwgc2NhbmxpbmVzX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJjb3VudFwiLCBuZXcgVW5pZm9ybTQyKDApXSxcbiAgICAgICAgW1wic2Nyb2xsU3BlZWRcIiwgbmV3IFVuaWZvcm00MigwKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIyNSgpO1xuICAgIHRoaXMuZCA9IGRlbnNpdHk7XG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2NhbmxpbmUgZGVuc2l0eS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBkZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmQ7XG4gIH1cbiAgc2V0IGRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmQgPSB2YWx1ZTtcbiAgICB0aGlzLnNldFNpemUodGhpcy5yZXNvbHV0aW9uLndpZHRoLCB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY2FubGluZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzY2FubGluZSBkZW5zaXR5LlxuICAgKi9cbiAgZ2V0RGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZW5zaXR5O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY2FubGluZSBkZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVuc2l0eSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHNjYW5saW5lIGRlbnNpdHkuXG4gICAqL1xuICBzZXREZW5zaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5kZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FubGluZSBzY3JvbGwgc3BlZWQuIERlZmF1bHQgaXMgMCAoZGlzYWJsZWQpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNjcm9sbFNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcInNjcm9sbFNwZWVkXCIpLnZhbHVlO1xuICB9XG4gIHNldCBzY3JvbGxTcGVlZCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwic2Nyb2xsU3BlZWRcIikudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmRlZmluZXMuZGVsZXRlKFwiU0NST0xMXCIpKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGVmaW5lcy5oYXMoXCJTQ1JPTExcIikpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJTQ1JPTExcIiwgXCIxXCIpO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoaXMgcGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMucmVzb2x1dGlvbi5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJjb3VudFwiKS52YWx1ZSA9IE1hdGgucm91bmQoaGVpZ2h0ICogdGhpcy5kZW5zaXR5KTtcbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2hvY2tXYXZlRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00MywgVmVjdG9yMiBhcyBWZWN0b3IyMjYsIFZlY3RvcjMgYXMgVmVjdG9yMzUgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC9zaG9jay13YXZlLmZyYWdcbnZhciBzaG9ja193YXZlX2RlZmF1bHQgPSBcInVuaWZvcm0gYm9vbCBhY3RpdmU7dW5pZm9ybSB2ZWMyIGNlbnRlcjt1bmlmb3JtIGZsb2F0IHdhdmVTaXplO3VuaWZvcm0gZmxvYXQgcmFkaXVzO3VuaWZvcm0gZmxvYXQgbWF4UmFkaXVzO3VuaWZvcm0gZmxvYXQgYW1wbGl0dWRlO3ZhcnlpbmcgZmxvYXQgdlNpemU7dm9pZCBtYWluVXYoaW5vdXQgdmVjMiB1dil7aWYoYWN0aXZlKXt2ZWMyIGFzcGVjdENvcnJlY3Rpb249dmVjMihhc3BlY3QsMS4wKTt2ZWMyIGRpZmZlcmVuY2U9dXYqYXNwZWN0Q29ycmVjdGlvbi1jZW50ZXIqYXNwZWN0Q29ycmVjdGlvbjtmbG9hdCBkaXN0YW5jZT1zcXJ0KGRvdChkaWZmZXJlbmNlLGRpZmZlcmVuY2UpKSp2U2l6ZTtpZihkaXN0YW5jZT5yYWRpdXMpe2lmKGRpc3RhbmNlPHJhZGl1cyt3YXZlU2l6ZSl7ZmxvYXQgYW5nbGU9KGRpc3RhbmNlLXJhZGl1cykqUEkyL3dhdmVTaXplO2Zsb2F0IGNvc1Npbj0oMS4wLWNvcyhhbmdsZSkpKjAuNTtmbG9hdCBleHRlbnQ9bWF4UmFkaXVzK3dhdmVTaXplO2Zsb2F0IGRlY2F5PW1heChleHRlbnQtZGlzdGFuY2UqZGlzdGFuY2UsMC4wKS9leHRlbnQ7dXYtPSgoY29zU2luKmFtcGxpdHVkZSpkaWZmZXJlbmNlKS9kaXN0YW5jZSkqZGVjYXk7fX19fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3Nob2NrLXdhdmUudmVydFxudmFyIHNob2NrX3dhdmVfZGVmYXVsdDIgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTt1bmlmb3JtIGZsb2F0IGNhbWVyYURpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdlNpemU7dm9pZCBtYWluU3VwcG9ydCgpe3ZTaXplPSgwLjEqY2FtZXJhRGlzdGFuY2UpL3NpemU7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9TaG9ja1dhdmVFZmZlY3QuanNcbnZhciBIQUxGX1BJID0gTWF0aC5QSSAqIDAuNTtcbnZhciB2MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMzUoKTtcbnZhciBhYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMzUoKTtcbnZhciBTaG9ja1dhdmVFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNob2NrIHdhdmUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IFtwb3NpdGlvbl0gLSBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwZWVkPTIuMF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmFkaXVzPTEuMF0gLSBUaGUgZXh0ZW50IG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2F2ZVNpemU9MC4yXSAtIFRoZSB3YXZlIHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbXBsaXR1ZGU9MC4wNV0gLSBUaGUgZGlzdG9ydGlvbiBhbXBsaXR1ZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIHBvc2l0aW9uID0gbmV3IFZlY3RvcjM1KCksIHtcbiAgICBzcGVlZCA9IDIsXG4gICAgbWF4UmFkaXVzID0gMSxcbiAgICB3YXZlU2l6ZSA9IDAuMixcbiAgICBhbXBsaXR1ZGUgPSAwLjA1XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiU2hvY2tXYXZlRWZmZWN0XCIsIHNob2NrX3dhdmVfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBzaG9ja193YXZlX2RlZmF1bHQyLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYWN0aXZlXCIsIG5ldyBVbmlmb3JtNDMoZmFsc2UpXSxcbiAgICAgICAgW1wiY2VudGVyXCIsIG5ldyBVbmlmb3JtNDMobmV3IFZlY3RvcjIyNigwLjUsIDAuNSkpXSxcbiAgICAgICAgW1wiY2FtZXJhRGlzdGFuY2VcIiwgbmV3IFVuaWZvcm00MygxKV0sXG4gICAgICAgIFtcInNpemVcIiwgbmV3IFVuaWZvcm00MygxKV0sXG4gICAgICAgIFtcInJhZGl1c1wiLCBuZXcgVW5pZm9ybTQzKC13YXZlU2l6ZSldLFxuICAgICAgICBbXCJtYXhSYWRpdXNcIiwgbmV3IFVuaWZvcm00MyhtYXhSYWRpdXMpXSxcbiAgICAgICAgW1wid2F2ZVNpemVcIiwgbmV3IFVuaWZvcm00Myh3YXZlU2l6ZSldLFxuICAgICAgICBbXCJhbXBsaXR1ZGVcIiwgbmV3IFVuaWZvcm00MyhhbXBsaXR1ZGUpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuc2NyZWVuUG9zaXRpb24gPSB0aGlzLnVuaWZvcm1zLmdldChcImNlbnRlclwiKS52YWx1ZTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYW1wbGl0dWRlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGFtcGxpdHVkZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJhbXBsaXR1ZGVcIikudmFsdWU7XG4gIH1cbiAgc2V0IGFtcGxpdHVkZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiYW1wbGl0dWRlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3YXZlIHNpemUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgd2F2ZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2F2ZVNpemVcIikudmFsdWU7XG4gIH1cbiAgc2V0IHdhdmVTaXplKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJ3YXZlU2l6ZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSByYWRpdXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWF4UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm1heFJhZGl1c1wiKS52YWx1ZTtcbiAgfVxuICBzZXQgbWF4UmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXhSYWRpdXNcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAdHlwZSB7VmVjdG9yM31cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHBvc2l0aW9uIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZXBpY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICB9XG4gIHNldCBlcGljZW50ZXIodmFsdWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHJldHVybiB7VmVjdG9yM30gVGhlIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcG9zaXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2YWx1ZSAtIFRoZSBwb3NpdGlvbi5cbiAgICovXG4gIHNldFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcGVlZCBvZiB0aGUgc2hvY2sgd2F2ZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNwZWVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHNwZWVkLlxuICAgKi9cbiAgZ2V0U3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNwZWVkIG9mIHRoZSBzaG9jayB3YXZlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3BlZWQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHNwZWVkLlxuICAgKi9cbiAgc2V0U3BlZWQodmFsdWUpIHtcbiAgICB0aGlzLnNwZWVkID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBzaG9jayB3YXZlLlxuICAgKi9cbiAgZXhwbG9kZSgpIHtcbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImFjdGl2ZVwiKS52YWx1ZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhXSAtIFRoZSB0aW1lIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IG9uZSBpbiBzZWNvbmRzLlxuICAgKi9cbiAgdXBkYXRlKHJlbmRlcmVyLCBpbnB1dEJ1ZmZlciwgZGVsdGEpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICAgIGNvbnN0IHVBY3RpdmUgPSB1bmlmb3Jtcy5nZXQoXCJhY3RpdmVcIik7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBjb25zdCB3YXZlU2l6ZSA9IHVuaWZvcm1zLmdldChcIndhdmVTaXplXCIpLnZhbHVlO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHYyKTtcbiAgICAgIGFiLmNvcHkoY2FtZXJhLnBvc2l0aW9uKS5zdWIocG9zaXRpb24pO1xuICAgICAgdUFjdGl2ZS52YWx1ZSA9IHYyLmFuZ2xlVG8oYWIpID4gSEFMRl9QSTtcbiAgICAgIGlmICh1QWN0aXZlLnZhbHVlKSB7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImNhbWVyYURpc3RhbmNlXCIpLnZhbHVlID0gY2FtZXJhLnBvc2l0aW9uLmRpc3RhbmNlVG8ocG9zaXRpb24pO1xuICAgICAgICB2Mi5jb3B5KHBvc2l0aW9uKS5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgIHRoaXMuc2NyZWVuUG9zaXRpb24uc2V0KCh2Mi54ICsgMSkgKiAwLjUsICh2Mi55ICsgMSkgKiAwLjUpO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lICs9IGRlbHRhICogdGhpcy5zcGVlZDtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMudGltZSAtIHdhdmVTaXplO1xuICAgICAgdW5pZm9ybXMuZ2V0KFwicmFkaXVzXCIpLnZhbHVlID0gcmFkaXVzO1xuICAgICAgaWYgKHJhZGl1cyA+PSAodW5pZm9ybXMuZ2V0KFwibWF4UmFkaXVzXCIpLnZhbHVlICsgd2F2ZVNpemUpICogMikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB1QWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZWZmZWN0cy9TZWxlY3RpdmVCbG9vbUVmZmVjdC5qc1xuaW1wb3J0IHtcbiAgQmFzaWNEZXB0aFBhY2tpbmcgYXMgQmFzaWNEZXB0aFBhY2tpbmcxNixcbiAgQ29sb3IgYXMgQ29sb3I3LFxuICBOb3RFcXVhbERlcHRoIGFzIE5vdEVxdWFsRGVwdGgyLFxuICBFcXVhbERlcHRoIGFzIEVxdWFsRGVwdGgyLFxuICBSR0JBRGVwdGhQYWNraW5nIGFzIFJHQkFEZXB0aFBhY2tpbmc1LFxuICBXZWJHTFJlbmRlclRhcmdldCBhcyBXZWJHTFJlbmRlclRhcmdldDE5XG59IGZyb20gXCJ0aHJlZVwiO1xudmFyIFNlbGVjdGl2ZUJsb29tRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBCbG9vbUVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNlbGVjdGl2ZSBibG9vbSBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIG1haW4gc2NlbmUuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy4gU2VlIHtAbGluayBCbG9vbUVmZmVjdH0gZm9yIGRldGFpbHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhLCBvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHRoaXMuZ2V0QXR0cmlidXRlcygpIHwgRWZmZWN0QXR0cmlidXRlLkRFUFRIKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmRlcHRoUGFzcyA9IG5ldyBEZXB0aFBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yNygwKTtcbiAgICB0aGlzLmRlcHRoTWFza1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRGVwdGhNYXNrTWF0ZXJpYWwoKSk7XG4gICAgY29uc3QgZGVwdGhNYXNrTWF0ZXJpYWwgPSB0aGlzLmRlcHRoTWFza01hdGVyaWFsO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyhjYW1lcmEpO1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoQnVmZmVyMSA9IHRoaXMuZGVwdGhQYXNzLnRleHR1cmU7XG4gICAgZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhQYWNraW5nMSA9IFJHQkFEZXB0aFBhY2tpbmc1O1xuICAgIGRlcHRoTWFza01hdGVyaWFsLmRlcHRoTW9kZSA9IEVxdWFsRGVwdGgyO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MTkoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZS5uYW1lID0gXCJCbG9vbS5NYXNrZWRcIjtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnNlbGVjdGlvbi5sYXllciA9IDExO1xuICAgIHRoaXMuX2ludmVydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faWdub3JlQmFja2dyb3VuZCA9IGZhbHNlO1xuICB9XG4gIHNldCBtYWluU2NlbmUodmFsdWUpIHtcbiAgICB0aGlzLmRlcHRoUGFzcy5tYWluU2NlbmUgPSB2YWx1ZTtcbiAgfVxuICBzZXQgbWFpbkNhbWVyYSh2YWx1ZSkge1xuICAgIHRoaXMuY2FtZXJhID0gdmFsdWU7XG4gICAgdGhpcy5kZXB0aFBhc3MubWFpbkNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuY29weUNhbWVyYVNldHRpbmdzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2VsZWN0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gVGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBtYXNrIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAdHlwZSB7RGVwdGhNYXNrTWF0ZXJpYWx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGVwdGhNYXNrTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGhNYXNrUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZlcnRlZDtcbiAgfVxuICBzZXQgaW52ZXJ0ZWQodmFsdWUpIHtcbiAgICB0aGlzLl9pbnZlcnRlZCA9IHZhbHVlO1xuICAgIHRoaXMuZGVwdGhNYXNrTWF0ZXJpYWwuZGVwdGhNb2RlID0gdmFsdWUgPyBOb3RFcXVhbERlcHRoMiA6IEVxdWFsRGVwdGgyO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFzayBpcyBpbnZlcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGludmVydGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG1hc2sgaXMgaW52ZXJ0ZWQuXG4gICAqL1xuICBpc0ludmVydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmludmVydGVkO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGUgbWFzayBpbnZlcnNpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpbnZlcnRlZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciB0aGUgbWFzayBzaG91bGQgYmUgaW52ZXJ0ZWQuXG4gICAqL1xuICBzZXRJbnZlcnRlZCh2YWx1ZSkge1xuICAgIHRoaXMuaW52ZXJ0ZWQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJhY2tncm91bmQgY29sb3JzIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaWdub3JlQmFja2dyb3VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICBzZXQgaWdub3JlQmFja2dyb3VuZCh2YWx1ZSkge1xuICAgIHRoaXMuX2lnbm9yZUJhY2tncm91bmQgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoTWFza01hdGVyaWFsLm1heERlcHRoU3RyYXRlZ3kgPSB2YWx1ZSA/IERlcHRoVGVzdFN0cmF0ZWd5LkRJU0NBUkRfTUFYX0RFUFRIIDogRGVwdGhUZXN0U3RyYXRlZ3kuS0VFUF9NQVhfREVQVEg7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaWdub3JlQmFja2dyb3VuZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBiYWNrZ3JvdW5kIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNCYWNrZ3JvdW5kRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWdub3JlQmFja2dyb3VuZDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYmFja2dyb3VuZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlnbm9yZUJhY2tncm91bmQgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAtIFdoZXRoZXIgdGhlIGJhY2tncm91bmQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0QmFja2dyb3VuZERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5pZ25vcmVCYWNrZ3JvdW5kID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE2KSB7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5kZXB0aEJ1ZmZlcjAgPSBkZXB0aFRleHR1cmU7XG4gICAgdGhpcy5kZXB0aE1hc2tNYXRlcmlhbC5kZXB0aFBhY2tpbmcwID0gZGVwdGhQYWNraW5nO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICBjb25zdCBpbnZlcnRlZCA9IHRoaXMuaW52ZXJ0ZWQ7XG4gICAgbGV0IHJlbmRlclRhcmdldCA9IGlucHV0QnVmZmVyO1xuICAgIGlmICh0aGlzLmlnbm9yZUJhY2tncm91bmQgfHwgIWludmVydGVkIHx8IHNlbGVjdGlvbi5zaXplID4gMCkge1xuICAgICAgY29uc3QgbWFzayA9IGNhbWVyYS5sYXllcnMubWFzaztcbiAgICAgIGNhbWVyYS5sYXllcnMuc2V0KHNlbGVjdGlvbi5sYXllcik7XG4gICAgICB0aGlzLmRlcHRoUGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgY2FtZXJhLmxheWVycy5tYXNrID0gbWFzaztcbiAgICAgIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkO1xuICAgICAgdGhpcy5jbGVhclBhc3MucmVuZGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQpO1xuICAgICAgdGhpcy5kZXB0aE1hc2tQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHJlbmRlclRhcmdldCk7XG4gICAgfVxuICAgIHN1cGVyLnVwZGF0ZShyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBkZWx0YVRpbWUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgc3VwZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldE1hc2tlZC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGVwdGhQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5jbGVhclBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5kZXB0aFBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5kZXB0aE1hc2tQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgIGlmIChyZW5kZXJlci5jYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcikge1xuICAgICAgdGhpcy5kZXB0aE1hc2tQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbC5kZWZpbmVzLkxPR19ERVBUSCA9IFwiMVwiO1xuICAgIH1cbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0TWFza2VkLnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXRNYXNrZWQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvU2VwaWFFZmZlY3QuanNcbmltcG9ydCB7IFVuaWZvcm0gYXMgVW5pZm9ybTQ0LCBWZWN0b3IzIGFzIFZlY3RvcjM2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvc2VwaWEuZnJhZ1xudmFyIHNlcGlhX2RlZmF1bHQgPSBcInVuaWZvcm0gdmVjMyB3ZWlnaHRzUjt1bmlmb3JtIHZlYzMgd2VpZ2h0c0c7dW5pZm9ybSB2ZWMzIHdlaWdodHNCO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWMzIGNvbG9yPXZlYzMoZG90KGlucHV0Q29sb3IucmdiLHdlaWdodHNSKSxkb3QoaW5wdXRDb2xvci5yZ2Isd2VpZ2h0c0cpLGRvdChpbnB1dENvbG9yLnJnYix3ZWlnaHRzQikpO291dHB1dENvbG9yPXZlYzQoY29sb3IsaW5wdXRDb2xvci5hKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1NlcGlhRWZmZWN0LmpzXG52YXIgU2VwaWFFZmZlY3QgPSBjbGFzcyBleHRlbmRzIEVmZmVjdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNlcGlhIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGJsZW5kRnVuY3Rpb24sIGludGVuc2l0eSA9IDEgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTZXBpYUVmZmVjdFwiLCBzZXBpYV9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wid2VpZ2h0c1JcIiwgbmV3IFVuaWZvcm00NChuZXcgVmVjdG9yMzYoMC4zOTMsIDAuNzY5LCAwLjE4OSkpXSxcbiAgICAgICAgW1wid2VpZ2h0c0dcIiwgbmV3IFVuaWZvcm00NChuZXcgVmVjdG9yMzYoMC4zNDksIDAuNjg2LCAwLjE2OCkpXSxcbiAgICAgICAgW1wid2VpZ2h0c0JcIiwgbmV3IFVuaWZvcm00NChuZXcgVmVjdG9yMzYoMC4yNzIsIDAuNTM0LCAwLjEzMSkpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGludGVuc2l0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGJsZW5kTW9kZS5vcGFjaXR5IGluc3RlYWQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmJsZW5kTW9kZS5vcGFjaXR5LnZhbHVlO1xuICB9XG4gIHNldCBpbnRlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kTW9kZS5vcGFjaXR5LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2VwaWEgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRNb2RlLm9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW50ZW5zaXR5LlxuICAgKi9cbiAgZ2V0SW50ZW5zaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmludGVuc2l0eTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2VwaWEgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYmxlbmRNb2RlLm9wYWNpdHkgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGludGVuc2l0eS5cbiAgICovXG4gIHNldEludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMuaW50ZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB3ZWlnaHRzIGZvciB0aGUgcmVkIGNoYW5uZWwuIERlZmF1bHQgaXMgYCgwLjM5MywgMC43NjksIDAuMTg5KWAuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IzfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNSKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodHNSXCIpLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0cyBmb3IgdGhlIGdyZWVuIGNoYW5uZWwuIERlZmF1bHQgaXMgYCgwLjM0OSwgMC42ODYsIDAuMTY4KWAuXG4gICAqXG4gICAqIEB0eXBlIHtWZWN0b3IzfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNHKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIndlaWdodHNHXCIpLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2VpZ2h0cyBmb3IgdGhlIGJsdWUgY2hhbm5lbC4gRGVmYXVsdCBpcyBgKDAuMjcyLCAwLjUzNCwgMC4xMzEpYC5cbiAgICpcbiAgICogQHR5cGUge1ZlY3RvcjN9XG4gICAqL1xuICBnZXQgd2VpZ2h0c0IoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2VpZ2h0c0JcIikudmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NNQUFFZmZlY3QuanNcbmltcG9ydCB7XG4gIEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTcsXG4gIENvbG9yIGFzIENvbG9yOCxcbiAgTGluZWFyRmlsdGVyIGFzIExpbmVhckZpbHRlcjUsXG4gIExvYWRpbmdNYW5hZ2VyIGFzIExvYWRpbmdNYW5hZ2VyMixcbiAgTmVhcmVzdEZpbHRlciBhcyBOZWFyZXN0RmlsdGVyOCxcbiAgVGV4dHVyZSBhcyBUZXh0dXJlMyxcbiAgVW5pZm9ybSBhcyBVbmlmb3JtNDUsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjBcbn0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy90ZXh0dXJlcy9zbWFhL3NlYXJjaEltYWdlRGF0YVVSTC5qc1xudmFyIHNlYXJjaEltYWdlRGF0YVVSTF9kZWZhdWx0ID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUVBQUFBQVFDQVlBQUFDbTUza3BBQUFBZUVsRVFWUllSKzJYU3dxQU1BeEVKMTY4ZVBFcXdSU0toSUlpdUhqSnFpVTBnV0UrMUNRZEFwY1ZBTVVBdUFSYU1HQ1gxTUlML093MTMrKzlsVzJzM21XOU1XdnNuV2MvMmZ2R3lnd1BBTjRFOFF6QUE0Q1hBQjZBSGpHNEpUSFlJMWV5M3BjeDZGSG5FZmhMRE9JQktBbVVCSzYvQU5VRFRsUk9YQUhkOUVDMUFBQUFBRWxGVGtTdVFtQ0NcIjtcblxuLy8gc3JjL3RleHR1cmVzL3NtYWEvYXJlYUltYWdlRGF0YVVSTC5qc1xudmFyIGFyZWFJbWFnZURhdGFVUkxfZGVmYXVsdCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFLQUFBQUl3Q0FZQUFBQUJObUJIQUFBZ0FFbEVRVlI0WHV5OUNiaGxWMWt0T3ZicHEwOURraUlrVUJJNmt4QVNJSDBEbEFRaUlLMXdSZlNKVHgraTRKWDd2S0lpZ3M4SFhwWHZxVmN2cmNDOWFnUTdJRFRTU1dncUNRUWxpRFJCSktra2hEU2txVlBOcVZPblArOGIvL3JIM1ArZVorMTk5dGx6blZUbHZWcmZ0NysxVDdPYXVlWlk0Mi9tMzdRQUxLTmsyd0hnMXBJVGxCMTdtQytQcDExVzNYL0xIeVQzMnZoZzQ4LzVTT3YrUG53cHNIQTcwSm9HbHVlQjFpS0FwZXF6dk96bjQ0R2F0VEI3Nlh6aGQ3c3VCUjcrV1dBRGdERUF3d0NHL0w1NGIvcG9ETHJIdXZ2bTcwWjJBdmhzYytQVmN4c2NCVThGOEM4QURnNStpcElqRC9QbEd3ZmdqdThCOTI0RTVzZUFSVWZMc2lObXFRVzBJakw4KzdMMk5ZRC83Q09CemZjQ20rYUI4U1ZnZEFrWUlSQ1hLeURheDRFZEFhbkw1UHVOUGxsTnZYRGxBSHdGZ1A4QWNDMkFoUklvRFhic1liNDhkbDVXa1ZGVEUzTEdEY0M5bTRDWkNXQnVGRmdlQVphR0FZSlFRQ1JxREhUK01jSnJWYjh6d0FUVVhIMDJNSFlmTUhFSUdGc0F4Z2pBcFFxQUNZUU9SanRkL0I3QXh0L3o3OXNDMCtjTVBnampsd1B3VndIY0ErRGZBSHpUeGNWZ1dCcm9xTU44K2NZQmVNNzF3SDBUd0tFeFlIWVVXQ0lBSFlSTFRsa0NZZ2NJQmNBZ1UvbjNxeThHUnU0SFJnbkFPV0JrRVJoZGRQQUpoR0pEQnhrdnc3Y3FpbXIrekZNL1pMblpGNjRjZ0w4QllEK0FXd0I4eC9kbFd1V2FnSGlZTDk4NEFKLzBSV0J5MUFFNEFpenlNMXl4WUFjVGlnVzU1eE1iQWt4RWl3RWRrSi9aQ1F4UEFpT0hnQkVDY0tFQzRUQlpjS2tTdittVGllTmNOUE5DMjZtTE5zajQ1UUQ4TFFEVEFPNEdjSnQvN2l3MmJmb0c0V0crdkFHd205RXhpRWc2OXpwZy93Z3dQUUxNamdBTHpuNEU0YUl6b0pqUTlnNDAyNHV5Z2tqK3B5dUFvWDBWQUlmbmdPSDVOZ0NITWhBbThTdjJ5M1hEWmVCaE5JcDhPekpFOE9zQnpBS1lCSEFYZ0R0OC80TytNVlQwajRmNThvMEQ4UHhyZ2YzRHdNd0lNRVBRRVlSa053ZmdzdXVEWkxza2lwME5vMGdXTUQvOUhHRG9BREFrQUM0QXcvd3NBZ1pBZ3MyWjBBQkkwR1U2SVZtS3YrZjI4S0RuSHhrQS9HMEE4eTZHNzNOOWtPQ2pYbmgvRWJiNk92Z3dYNzV4QUY1d0xUQTFWSUhQQURnTUxEajR5SUE1QUFtNmFDVW52NG96NDZlZUR3eE5BVU16d0pBejRCQUJTTkRGVHdTZmc3RERLSEUyM01HNVBxSVk4QTF1L2RJTnM5ZEJkeThBZ25HUE0yTmZVQnJzbnc3ejVSc0g0SVhYQUFjSnZpRmdsdUFieWdCSU5uU0xXT0FqR3hKNHBnT0tEVjB2L09TTEtwOGlHWEJvdmhMQkJPQ1FNMkFDb1RPaG5ZckFkSXRZYkNpajVKRnpSeUlBcVJjY0FuREFRVWpnNlVOUTdoc01YUDBjUlFBZXhzczNEc0NMQ0VDQ0x3Q1F6TWNQd1VpMk13QVNjQUtiZm5ZL1lSTEZROERIWCtJQUpBTVNmRGtBRjEza0x2bGVJamhqUVFIeFVWUzNqamdHcEtlZU56WVZRRWpnVVM4aytQZ2hPTmRoSXdBUDQrWFhCWUNIS0lKYndKeURUZ2FJQWRDQkp4M1EyTTh0WUFIUDltNGRmL3lsUU9zUTBKcXRSTEN4MzBLMXd0TEJnZ1NjUU9nc0tCR2NXSEFKZU93UkMwQlNNMW1RSUtSYmhoK0JqOThKUVA2dDRVMEFQRXlYWHhjQUVueGtRQUZ3b1ZVeElEOWt2UWcrYzFDN3ZpZFJiSURrYzI0Qi8vaFRRR3VtRGNDV0E1RGdNeEFTZE5JRkJVSTVwQ01MOHY4QVBJNXpmRVF4NEJ1ZGdxaWN6dmlTbkpoUXdDUDRCTUNHbCt3TzgrVTdBSmkvVzRPNFlTNitwbUsvMmNpQURzQU9CaFRJSWlBSm5QQjdBdk5qUCswQW5BTmFZa0FIWDJKQkFjK3RZYUpYT3FCWnYyNFZjMzg2WFc1ZHRrSEdXKzRIRkFKb25wT2UrWVlRWkFTaGdLanYzUE52UFFheFZvSTh6SmRmRndBU2ZQek1Vd1MzS3QxdjBVRklsb3M2b0RGZEFHRmNsaU1BUC9yeUFFQUdOd1FSbkRPZ0xiZGxJRXdySXM2QVovUWdrTU1IUUY2WkFLUWNKQXNTWVB3SWVBSWs5d0pnb1BLMWdpNytQd0Y0R0MvZk9BQXZJUVBTczBVUlRQQkovUHAzR1NFR1JIZkJDSVEweG93QnRVYmNBajd5czVYNEpmdTFISUFHUXJJZ1FSWEVzQUZRSU9SREZoaURZL3JNSG1yVTRRVWdSMDhBa2dVakNBVzZDRDZDa3dCc0FJUUM0R0c2ZlBNQTNPWGlOekNnMkk5Z05DTWtzbUFBb2VtRHpvaW1Gd0w0OE04NUFLa2l1UVZNQUFwOENZUlJEQXQ4R1FpSjY3TjZHSk9EQVhBSGxzR2d1c2NBMkFKZzFJUEdZbXhPcEJ4RldrUk45THNBVGdJd1huTnMvdi81ei85WENmOEJPM1lBdHhiYy80Ni9LRHQrNStlYTFZa3UyVlV4SHovejB2MjRGd01HSzFnV3NLMk9VVXhISGRDQmVSVUI2T3hIQUJyNFpJQ0lCZDBRV1NGK1hSZE1UQWpnQ2RUckc5Y0JOd0U0RjhDcERrSUN5WUxHc3VoRnQ2enMrZ0lTd1Vlbjh6RUFqZ013NGNmeDJINk8vOTB5QUZvODRDYmc0SUQzLzlUZkxUdCs1K2ViblJBQmtPRGp4MFN3UGk1ZWMvRnJZcG1xU0F4TThEbjYwQ3NxQUZJNkdmaHFBTWlERS9nb2ttdkVyMEM0UGdEa0JRbTQwd0U4ek1GRVVES0VWb3hJTUxsL0tTNzNtRTdIOWQrdmNLSFFRY2p3VzBZdTluUDhtOHNBbU9JQnVXWTZ3UDIvNHMwZXpqamc4VHV2YVI2QUJKNzB2eFVBcEdybTdFYkdFK2k0NzJCQUIrV0hmcUhTL2VvQWFFd1kyRTkrd0xTWFRxaEk3Q1hnbkI2TENvT0o0QmlTVCtoVG5HMEhjQ3dBZ2xDeDNBUm9aRVZGWG5CUHAvTy9BL2hYQUNjN0NQczkvaTFsQU95SUIrUkRYK1A5LytwYlFqampBTWZ2L1BMNkFGRHMxd0ZBZ3MvOWZnS2ZnZEUvWkVwdWlRbGJ3QWRlNlFBTUJnaVJtc1N3QTlCWTBKZmpvdkdSREJNSDRUbGNYR2hjQk9jNkhrRjBnalBoWmdjaHhUTFpNQWNpLzA0Vy9CNkFiM3QwOUVQWGNQeWZsZ0Z3UlR3Z0oyTU45LzhiZjVxRk02N3grQi9hVzRYUXo0MkZlTDBZclJ5aWt6dFVGdzA3MDRtZjlrWGd4aE9BcWMzQUFzUHlSeHhRQ3MvUGRYT0ZZMFcxS0h5M1FJVUd0eCs2dmRueDF2c0IrZHNUbmNtMkFvZ2dsRmdWRUFsVVdyT01CMlJ5RW1NQ0dRL1k3L0h2S25zNnRmR0FuSlErci85Yjc2b0paMXpEOFdkeVFqWUJoOGFCaFZFSGpFTG91UTh1a1E3VlJTQ0pBQUx3a3Irc0FMaG5HekREM0pBSllKSGc5dWhvaTRieDh5dGtXVXR2SFQvNytaYzRkdzF1WjM2MTJmSDJka1FmN3l4SUVFb2Nrd2tKUW40SVFvcTh1bmhBaG1QUktLRngwdXY0Szh1ZVRzOTR3RDd1Ly9WWDlnaG43T1A0Yys0RzdoOEhwc2VCK2RGMkFLbEZMd3VBSVo4akQ2TlByT2hBZmZtZkE5L1pCdXpaQ2t5UldTZXFCQ1d5b1lHUTV5UXJCcERidW0vTUUxSG9QbzBYRWtTRDJ6bGZibmE4cTYrRVVKY1RDeEtFdEhMNUVRalA2QkVQeUlnWUFaQnZZdDN4SHl4N09xdkdBNjV5LzcvOXdWWENHVmM1L3NsN3F4RDY2ZEVxaVlnUnpBcWhOMUE0Q0JOQUFsRHlBRkkraVo5L04zRExKdUMramNEVUJtQ1d5VW5Pcm1UWUNNSU9rTmNsTGcwQjgvUnNOTGc5K1V2TmpuZDFBUExtbVFwRkh5RUJST3VXQUNRVDhuTitIL0dBdlk3L1ZOblQ2U3Nlc01mMTMvQ3BhaEduWnpoamorUFBtd1gyTVlkRElmUWV4V3lCQXdFVU9RRHJSRE4vOThwM0E3ZHZBTzZmQUE1c3FISkRCRUF5b1VWR2t3RWQ2SFIxMlhVNGt3emZsNmZDWFRaemp5NTd2dm5SNTEzWDdIajdBeUR2Z2dBVWk5RXlGZ2lacU54UFFGNjM0NW5PV2JEMUhRL1k1ZnB2dUxhLzIrODIvdk5IZ0FQREZRRG5ob0Y1ajJDMnFCV0NJOGJ3MWVSdzVDTDVsOTRMM0RFT1RJNERCOFk5T1dtc0V1L3pCSjNyZ3NheWJxQm9iLzdBNEM3anRXY29vUnJjenIrdTJmSDJEMEFPUWdBVUN4S0VQN2FHZ0x5NjQrbTZLZGpXRkE5WWMvMDMvT3NhNGdscmpyK0F1cHFIejFzRXMwY3hHMEJDOUhJZVBMb2l0OWVOa1ZmOUwrRHVVV0J5REpnYXE0eWJHWUxQQVdnaVhtTGVkVUU3ZHdDN3NhTDdDcWZQS1hpNE5ZZGF5a0NENDEwYkFIbERFc05pd1o5d0FQWWJrSmNmejZUMmdtM044WURaOWQvd0h4VUErNzM5ZlB3WFByU0tZR2IrQnVQM2pBRkRFbEZIOUhJV3diekNJR2tCci9vcjRKNFJZTzhvTU9XNlpWY0F1dmkxQ2dvaGEwNEJDd1Q1Z2ZNS0htN05vUmRlMit4NDF3NUEzaFFaa0FEazUrY0dpQWVNeDMrLzdBRU5GQThZcnYvRzcxY0FYRk00WXpqK290T0FhUUxRQTBnWnhhSUladE1ERlRpZ0tKVjhIOUlxNmFaNTlaWEF2U1BBdnBFS2dCVHRCT0RjU0NXQ1plUll0cHpybUx5ZUdOQ0F5RmwxditIZWk4cWViMzcwUmRjMk85N0JBTWk3RWdCLzJRRzQxbmhBSFU5THVXQWJPQjdRci8vR1BSVUExM3I3R3Y5Rlp3SU1vVmNFc3dFd2ZEb2ltRVAwc2hLS3RJcGhhWlFBWHYxK1lNK3dBM0RFZGN2UktrR0pBRFFRRXNRdWhpMVRqdDk1dkJzaDVueDJJTzU5U3NIRHJUbVVPU3ROam5kd0FBcUVyeTBJeUNNSUNrT3lpdUlCTndCdlBGUVFUN2dCdVBqYzlvUllBSUh5T0VMNHZJRkVZVk5hT291NXZDR0UvdFYvQTB3T1ZjbnB6STQ3Tk9yaTNRRklCcFNlYVNEVWRZTE9TV3ZZSW1TR2dmdHBKRGE0TVdKYkFHeGl2R1VBNU1BT2MwQmU2ZVZMajcvNE1rK2h6Q09ZUFlwWkRCaU5rTGgrRy9NM3lGeXYvbHRnTDNXM1lRZmdjRlVoZ1JZMlB3WStaNy9FaEFSMVNGeVhDT2I1N3IyOFFmUUJzSlFCTW41RDR5MEhZTFBqZTlDZDdSSUMwUE0zRWlNb2ZGNGdWQ0JwMVA4NDBpeC9neXo1NnIrdkFNams5R2wzNzVpQjQrQ3p2ZXVaZExra0VQSjhaRWZYLzZSNzN2T2p6VDVTaTlodWNMeEhBVmc0UHdKZ1J3aDlDS09YSzhZQTRaRXFLWlhTUVdoNVArNUFmdFhmQS91R0t2WWpDS243MmNjdGJGclpORUNrYTVMNUNQd0lQdE1IM1RWejE3TUxCNWdkTGdBMk5kNmpBQ3ljSHdMUXhGRVVTUjVBU3ZBUkRCMGg5QVFiOWJYSWdDR2s2bFVmQVBZVGdFUEFJVEtnZzFCT2JrNThzclRKZ0c1OFdNa1dNYUFiUVFUMW5jOHJIR0FOQUpzYzcxRUFGczRQQWFnUWVzdGdDMWxzQko0Qk1DU09LNmREVWN3cXFhRmlRci8wUWVBQUFkankrakJpUVFlZU1TQlpUM25DUFVESWE5eisvTUlCMWdDd3lmRWVCV0RoL0JDQWVRU3pna2pGZkdMQkJENW54UTREeE4wd3YzaFZ4WDVUQkdEd0w1b2J4dlZBNVlxWUw1QmVNTGQ2NllZeEpwUkIwZ0srOTZMQ0FkWUFzTW54SGdWZzRmd0lnTXJoVVBLUTJDK0J6MFBtQlRxQk1RZWhBYkRsSWpqNEY4MEtKZ3VTVlowRnVYcGpvQ09nWGF3TGpBTGhiVDllT01BdUFHeHF2RWNCV0RnL2wxSUUwNUVkMHlnWm55SGR6MFZ3Q3FFUElmTnl4MFFRdnZMREZRQ3ArOG5mWms1dW5kOHRYd0lnV2NIU05YME4yQ0ptbkFsM3Y2UndnTm5obDE3VDdIaVBBckJ3ZmdoQVM3bVYvaGV5MkpTOUZ2TTNCTHBVVWkxWXdEUk1YdmtSWUpvQWxBaDJsMGRjWjA0czZKVVRESWp5QmNybDR5RGMvZExDQWRZQXNNbnhIZ1ZnNGZ4d0tWd0pnR0VKTm1XdHhwUU1wWDlvbjJlUmhWQStPNTZBak1mblArZTNYdmYzTndHNHhJUFRsZWlZNTVicEdoNlViYWZOVTBsMHowcCs1Smg1SHFZSjZiNTFuUDZYUDhjeDEyWE5IUVZnSVFCL2JGUFZnMk9DN1ErV2dWRlduZy9GdnRXTEkwNnVXaDVvZ3VLRWNYVlMvOXNFQUYvL1ZHRDd0NEVURGdKYkY0Q05pOENHWldCczJmUEwvSDZWd3AyS0V0Vms0Zkordi9FSVlQTjl3S2E1cXUrSW5jZlB3WEhWWmUvYU9MM0Vid1M3eHY4QTFyUXZuTzBqOFBBclRnVEdaNEJ4RnY5bUl4aE9DR3N2KzBPUFlEUmdoY0xma1drRXVxMCtHMDB4NE90ZkRHeitkMkRiSG1ETGpMOHNpOEFZUC83Q0dJQWlFRU1URzkyelhxU2JIK2Q5UjJhQTBYbnZPK0pqdGhpSXJPVkRISFBPa0JyelVRQVdBUHNacDNvUERwYS9YYWc2RVZrTEJLKzVyQW5KQzMvbllrL0FQRDcwNFdpRUFWOE9USHdYMkxRSDJEZ0ZiSmdGTnJCaGpkOHI3OWRlR29Fd3NsbGdOQk96eThDZGp3ZUc5d0JqMDhBSUFjaTJENkhhZm15QWs0L1o3U0o3MmhHWVJ3RllBTURMVHdPR3A0RlJGZ0QzSGh6cVJHUWl5ZXVycU9kRzZyMFJtOElFWmp6UmxraXFDV29FZ0s4QXhtNEJKdTRISmh5QWJGaER4bWJER25aTzRqMFNnTEdEa3BpYmdFcTY2VEp3LzFuQTBGNWdkTHBxK3pEcUZmZDVMTWVXcXU1SE5TVDB1Sk9JbGxnK3FnTVdnSStIUHYweHdMQTNnV0hwVzJzQzQ0MWdDRUNibUt6aWFHcm5VZE1PNGFIZWg2TXhBUDRTTUhJN01MNEhHRDhBakh2SEpHTkFncERnWS9jazNzdGlwUmVtdlZoYyt1QVNNUFVFWUdoLzlkSVJnR3g4WStNTmJSLzAwdVZ0SDB3RXg5NGovdjBvQXhhQThFZCtHQmllQVlaWmc1a0FEQzBRV0dPRnpHSmxjR1B6bDFCeE5MWEQ4c2s0eGZ0d05BYkEvd3dNM3dHTVVteE9PUUJuSFh6ZXRJWXZpYm9ubVNpdVlUTmpyaVZnN2dsQWl3QmswZk5aSDYrUG1YOVA2a2ZObUNYR3BmdEo3VGdLd0JJQW5sbjE0QkFBWXhNWW01QzZSakN5Q29PeXIwcWtEL2MrSEkwQjhEWEE4TjNBeUNRd2VzRDFWUUtIN0VjQVNtMVEreTRDa045cFVLaVZGNW5MdnkrZkJiVFVkOFFCYUgxSHZOQlJPaVp2ZnNObnJGNGtjdlB3cGRzQkxCZVUxOE5mN0FCMjNEcDRlY0hDOG9CZ1VsSkplY0xTKzcrV09wRTNnYkUrSEt3K3lvZXZDWWtNR0txUEpyZEVLQVJ1dGFGWVJzMWZpRVowd1A4Q0ROOExETzhGUnFZcTNXMTBwZ0tnZllMYVlDem9vdGdBNktYYVRBOTB5Mzc0VEtCMXNCb3p5Nzd4SEZaNTM2dXRSZ0FtRWF3Nmc1a1VTRlp3U1huQTMzMHFzT2xmZ0hNUERsWmVzTEE4SU9qb0x5cFBXSGovMTFFbkNpVndrejdrQUV4dHNHcmFZVVdkU0RYNVRtc2FnTDhLREJHQTdCZDMwSnNXMG9XaXZuRU9RTlA3eUdUU0JSMTAxQWxaU1V0R3lmZ1pEa0NXWTFIbkpkY0JWZTYzMjVoVHZlbGcyQ1FqWk5EeWdHLzJBbjBqMXdLbkw2eTl2R0JoZVVDOHByUThZZUg5WDM5T1ZRU2M3TWM2ZkNhS3ZBZUhkQ0lWZjR5TVlDeW5UcFgrbmI5N05KbWxTUWI4cjhEUUhtOVlPRlVaVEtPem9YR2hzNkF4RjBISWV4Y0xCdldCdWlITjhzMm5lOThSM3FjNkw0VnliMm9CVmpmbTlNSUZIYmpEQ2g2a1BPQmJRb0crb1c4Q081YldWbDZ3c0R3Z2ZyMjBQR0hoL1gvMWlhRUl1RGNDVElXLzFRNHJGdjhPbllpVzNjK1cyaUt3VWpLYnlqUU53TDF1dVI2c0FFZ0RncTFiclhPbVY4MVB4aE5CNkRVREJTWXpRSndGdHo2MjNYY2t0WDFRMVZXS2FURi96WmhWYXpCVllBMXRYNU1henNHdm9id2UvalFyME5lNkJUaDV1Zi95Z29YbEFmRzYwdktFaGZmL3JTZTFpNERuVFdEVUFDWTFndUZURHFMWWRDQnZmNkRKWVNNWUFUQmZPeDFrTGZqMXYxYXhIMTBuUTNTZDBHVWtCblRmcGVtdEJKZ3NlSUtRQUhMUWNWeGEyVG51TVcwQXF1aTVlczh4QkllZ1ZkVlZFOFZoekhuTGg2NVdNQjlBbitYMThLNmFBbjJ0TzRFVGw2dnFiS3VWRnl3c0R3aGV2cWc4WWVIOTMvUms3MEpFOTBub3d4WmJJSmp2UzNXWU5TR1V3R0hKVHBQeHd3Y2JCdUJyZ1JZQmVLQUNuN1Z0cGRVdS9jME5KeE85Qkl4Y0t1NFRUT0R6YmtvblBMb2FMMHZ5VVFSYjJ5OEhzTDFja2ZXek1ldUZpNDBRZXpxaSt5aVBoeXQ3Rk9qcjYvZ0NGd2dQN1hiNXZzc1RGdDcvblFSZzZNR1JXbURSb2V5VGxwZ3c2OEdSVHdnWmdvMWdHbVhBWDYvOGR0YXlsU0tZL2tveUlEOUJoek1MM3ExZ0FvczJBY09yWllTb3EvcEpwMVZ0T0RSbTlaM0xTLzdXalZrdlhPekV0T3BLeUdybEFUKzRTb0crVlk4dkJHQ3Z5L2RWbnJEdy92ZWU2NU5CSmlBakJJVmNBSlFqT20rRGtDWkVlaUdBTXc2c0F3RFpzSnJBZGhGTTlyUEdoZDQ5MDRDbzVvVnVDWlBWNmtENDBFYzYrOVc4ZEJUQnNmZGMzbmtwdm5CODJmcDJSUGNzNzlkSGdiNTFMQTlvZnNEVjZ2dXQ1LzNQbnhjQW1MVkJpRHFnZXZEYUpMa1lycHVReHpjTndOOEFXZ0lnUmJCOGxvRUJ6WER3bDRjR2lER2Z0NThTQ09XR2VkZ2p2T0orYlB2Z1JraXVBK1pqemhuUVFPaUZOVmJsb2E3bC9mb3MwTGRPNVFFTmdFWGxDZnM4UWJmN0h5TUEzUVZqWWloWWhMRU5nalg5eS9xd3hRbVJVL2FzZmQwWmNMVTJDSFZHeXVzSlFMS2ZWaTk4Q1MxMlQ1ZjdpRUNrSHBzTWtBaENGOCtuc2hXSDJJL2pYc09ZTzE0NEdWLzlBcEFJclMzdnQ0WUNmZXRRSHRBQTJHKy80UFc0LzJQUGJ6TWdtVU1pMk5vZVNDUnhJdDIvRnZ1eFdVUklXQ1hnMzU3Z2ZUakVETklIblRSWFJDcEg1dWdLd0dsM0hwTUJYUWMwdjZXTFlWbS81bGltajA0ckc3NjJLMnVZWTlqQmtyOStySTAzTkw1WmJjelMvZEorTFF5b2dhNG83N2ZHQW4wTmx3ZE1BT3kzdmwvVDkzOEtBY2oxMjF6OEJuK1k5ZVdRSlJ6OFk2a05hZ0RoMmV5NUV2eGp4UUQ4VFdkQXVuZUNDTzRBbjF2dzV2ZHpRTW1ka3R3cTdwTFpRUitkTTM0K1p1bUF4dlkxWTA0dXFPQUo2RnNFeHpldG83emZBQVg2R2l3UGFMV1IxbHJmcjhuN2YvUmwzUUd6bXNpcysvdU83MVY5T0ZnUDJncFBoZ3I3VEdScVJVVDZkeXZyNGFJcy9wbS8yelZVTmJCU3Y2RzhlNXBFdjBDdmVjN1BvNytiVHRqbEJSbGt2QU1Ca0RlUXl2c05XS0N2b2ZLQUNZQnJyZS9YMVAwL29XRUFubkZEMVlkamh0WHhSNzNtWDEwRmZDSEhFOXBWV2NHQUkvUzBnS3NmQTJ5K3R3ckZadzZIeGYvRjBQazhSaS9rcEdTbk11RHg1VDBpQUNnUUhpb28wTmRBZWNCVUhXNlFkc1YyL2NMN3YvQ3lxcjVnbmM0MkNDT2NmWDFWSVovVjhXZTlJRG1UelZYd1BESmlYdUtYUHh0REJtYTgrbHpQNFdBZ0trUHhDVUFQRTR2NUd6RXVNWDBQWUpQTGhCNkZKc2M3TUFNbWtWeGFZQy9LOWdHK0YxKys4QVE3R3diZ2s3OEk3R0ZwWGdJd0ZpUlhPd2FKWlBVYmlSMHlDVURSaytjSGYrWXB3TWo5SGdmSThDbEdQeXZzU2lIMFdTS1J1WWxpdExiL3pITS9KT1NzNUMvWUlDOWNNUURaci9kd3hnT1c5Z3RHWVVCaTB3QThsMzA0dkRRdkFjaGlsRmJwSUJRaFo3RWpxNlpRMC9ZaGlsOHk0ajg5QXhpZTlEQXNENkZYOUhPSzNRdFJPVEZrdmlOODNrRzRmZWxJWThEQ2VMclNlTURTZnNFb3ZBRUNVRnNUakhEK3RjQit0a0ZnY1hLdkJSaXI3cXRGbDlvd21PNFh5LzFHM2JBRmZQclpIb3JGTldCRndIalFBRmN0SWdoajJrQmFydzA2SWYvK01NOVpxVE42RGdzRG9qQ2VyalFlc0xSZk1BcHZvR2tBV2g4T2IvdGdBUFNLV0NwOG5nTlF0YWRqbVRkbHR2TnZuM3BlRlloZ1FRZ2graVVtRWFVQVVvWE0xeVJMbVd1RkxhRTlaK1hJQVdCaFBGMXBQR0JwdjJBVTNrRFRBTHp3bXFvNnF0Vmg5a0pFckF1ZEFCaWEzOFRDNXdKZ1MyeEloQXdCbjN5aEJ5TDRFaHpYZlJYeFlzRFRKNEl2ck5OMkpGTXhaY0J6Vm80Y0FCYkcwNVhHQTViMkMwYmhEVFFOUUxaQllIMUFWc1FTQUFVK2ltSTFvYkh5Ymxuakcva0prM1U4Qkh6OHhWVVFBaG5RSWw1Q3lOZ0tBR3A1TEtTU0NvQXlTaDVKajc5dlRhZ2N4VWFJQmVSTmU3OWc5Z3ErRFhpZzR3R3p5K1BPTmZUN1JXRkE0bm9Ba0dYWlZBaGNCY2tKUWdOZ3JMaWFOYjNwYUlEbzF2SEhYK29BOUxRQmk0RHhKY09VUEpVblRnVTJOSlV5Uk9zOGlyR0FSeFFBQytQcEN0c0ZkNDBIL0FFZjBnTVFrTGdlQUNUNDFQaUdvTE9LcXlySnEzSy9ZYTltTnlyNUZ1c04vdVBMUEllRGE4QmMrdzNydHlsNFZGSGFNWmMzaTlSV0JNOWpqemdBRnNiVEZiWUxSbW0vWUJUZVFOTUF0RDRjQktEWEJUUUdkQUIyTUdCbzhTQ0xtRXVTMUFGVkFKM0EvTmhQdDBQb0NjQThiU0RHNzZYSTdheVNnNkpZdUdmS3dKSEZnSDBFNUIzdWVNQ2UvWTRMK3hWSEFPWis5RUhjRWdRZ3diZWlFWXg2andUZHo0cWZ1N0VoRUpxeEdxcnVmL1JuSElBRW54Z3dCTTBhQzhhVUFZV05CUkNtb0lsbDRIVHFPMTIyUWNaYnJnTVd4dE1WdGd2dU94NndhNy9qd2h0b0dvRFdoNE1CSjE2V040bGZyOEFxSTBUVlYxTzFmYTlCYlF6b3ZrQXk0RWQrTmdDUVVTeFpDRld2Q09hT0ZSRVh5VXdaT1BJQTJHZEEzdUdPQjZ3UGFPeitRUHY1UytNQTNPWGlOOWFjbGdoVytkM0lndXBCRjJwUHF4Y3hHZW5EUHhmU1JoMkFTaUtLaVZQMlBhWlNjdkFLb0EwVkRjNmNPbElCMkdkQTN1R09CMXpSNzdpd1gvRjZBRkI5T05TT1FXMGZyQTUwc0lMVmNja1dKeUlEU2d3UEFWY0pnRmJZdVozRkp2QWxFSGJKM0lzZ0pMR2VkZUJJQStBQUFYbUhPeDZ3bzk5eFliL2k5UUtnMmlBSWZESkVKSHFqNFNFeGJFdHkwZ2tkaEIvNlA5b1piQlpJR2lLWVZiOUdLYU41MGxSSEJMT3ZoRHhoLzVFS3dEVUc1QjN1ZU1CMlFHTS9ncmI3LzZ3SEFQTkdNQVkrR1NHVWpDNTJWWDJmMkNENCtITzBncWtaZmVnWEtnQmFIa2NXdFMwQVdpaTl4RzFJbXJMbE41WFI4TDhmbVFEMDVCVnJtRUVObXBZU1A5UVgrS0hpcWoyLzgyK0hxcURXd25iQlJmR0FUZHpBZWdHd3J1MkRwUnE3TXpxMmZwQWYwTnEwUmwyd0JYemdsWjR5VUFQQW1EU1ZXREJQSFFqTGNnVHFPWjZ6VXZkS0hoNHJ1RENlcm94L0RudTdZcXdYQUMxTkkvUWNFUXVLNldLL2tkZ0NUR0MwUFlBUC9LSURNQmdnbHEraElrck9mc2FDdmlMU29mY0pnSjVBZE03a2tTYUNqL0hxUUtWSUd2RDRzd0Y4YmNCam16anNhUTJINUQvNmFjQmQ5d0FMQjRERldXQjVBVmhlck1wNEdLSVlFT3A3KzI2VUYwYVNmVC94WXVERzd3RGpySXBBRVJ5dFhmMnZhamo3dWVyeVFYU0ZsMTBLL09OM2dJV0R3Q0x2amZHQjhaNTRPK0VlNHZlNjUxM3VCMlIxeXpzcUMrdHdiQzhIY05WaGZBZWFCdURQL1R2d3RTM0EvZVBBSWZZRlZsUHEySEhUdXl1bFpDVGxoYmpoRVRGNXl4VFFHZ1BHaG9IaElXQzRWU1hHRDNuMHRMa01IWEh4dStZeUIrTWxQd0R1WnM1SzZGbHNiQ3pkVk85RHVLZmtITThBRWtQN0I4Zk9rd0RjRCtCN25wNDIrSmtHT3ZLZEFMNEU0SzhQMHp2UWRFVDBiMTREM0RnQjNEMEI3QjhIWmthOVd6ckQ4OE42c0ZtK1ljVWpybjdFMVpEdk10RjlEQmdlQVlhSGdTR0IwUE5IQ0Q0Qkx3TFJzQnlBeVgvaWowL2REVXh1cWxJRzVoaXg3ZUZodkxjT1ZVQXR5UFN5ZEFGbU9RTmU2RVlHVi85WkVTaUtnSUVndGJhRC9nSEFMUUM0b3ZZNXI1S3d0ak9VL1hmVEFIenpMdUNtSWVEdU1XRHZLSEJ3cE1vTjBXUXpOdEFhWVNzMEs0WmxPU0FqR0c5a1BqQ0JSd1owQUJLRUJKZXhZQVpFQVUzQTdPaTFCZUR5bTRFRG5qUTFUd0NHV01XOE1YY0trczBZT3laTmxRT1FqY2dZSVVIbGxFellRMGt0bStyNm96OEc0RjRBWHdYd1JkOC9rTzlBMHdCOHk2NUttUHhnR0pnY3FZSlRLWXBUdjJDQ3p5ZGRRSlJET2pLaXZuK0RlaDhCRjhCbndCdGFDVUErWVlFeUFVOGgrYzZBejlnTkhIUm1yZ09nbURBM2pIUStpV3VwQ2VVQXZOU3JBOUhOd3F4K211azluSlZOZy9DVGZybWJBUHdiZ0s4RCtQY0hrSWliam9iNW8xM0EzWHlwV3NBa0cxY1BBOVBERlFEWk0xaWQwaTFLeHNXZk9yS25BRlhsaWZDRkZNTVJjQVNpZ09jczJNR0FJZkU5aVdYcGxTNk9uN1VibVBhVVVUWFFyZ3NWTXpjUmo1Rm9sZzJWNWF5VUE1QldZS3dPeEtVYWZub3NXamNKd2srN1c1RjJFS3ZsRTN4Y1hhTllmaUNZc0drQS9zbXVxdWc2aGNsZUFuQUltUGJPNll3UnBNZ2pDQVZBbS95UW1LVHY1aE5zQWYvaTdTeU5CU2wyYThRdi80L00xeUYrQlpTWWxOUUNublZycGJDK21Ub0FBQ0FBU1VSQlZKY2FJN3NPU0VZMk5wYURYTHFwUit2RS9PVmtzRGdJbWdHZ2doSG9ZSmJUV2M3b0p0RldjNjUvY2cyQVl2aDJBTHNCM0F6Z1Z2OTVuUy9mNFFkc0lrVDlUM2NCckd0SVRXWmZDNWhxdFFISW5zRUdRbjNVRER2RURFWS9JQ2Y3U3hNT3JBZzhUK2MwMEpHa3ZIR2QyREFCVVlaSUFPTnpDVURwcENGaFN1a0NCc0xRckZ0WmUvSWl4WVFwU3lFb0pvcW51UFdyVlJBdWJRaDgzSE5sWkIyM3o3ajF5d21qNkNJSXFVUHh3MlhldTlieDJqeDEwd3o0WjdzcVRZWmFERDhFSUR1b0UzaE1WRXBoV2c2NkpJcDkwazBzQnhCY3kraVBJSWFUMVJ0RXNIUy95SUFxdytWU05QV1FmZTV0bFZFazhhdVhnVmE1QlVzRUp1VDV1b2xpQWJFNUFHb3RtSUFqQ1BuUjl4REczVFFlcm5ZQVV1cFRkQkdFRk1mODNPa0FwSEcrWGx2VEFQd2Z1eXJnU1pPaGFzM3U2Y3dUc1VCVm4yZ1R3eUZNaTh3akhaQUExTTlmWUdIRFVMSkQxbThDcGE4ZlJ4RGFkK2wrWWtmLzNYTnZkMTFVK3FpTDM5U3hYZXZTc3NoZERGdmdiSTFPMkF3QXRSWk1aelRCUnVERmp4ZTFYZzhRRUlCOHl5ajV5WUlVeGZRSWtma0lSbm1IQ003MTJKb0c0RnNkZ0hIcDNBQ29NSDJHNmpNNGxXem9RYXJTdndRNk1TQi92cG9yVmFGa2grbUNMbHBWUjhaK2RxRFpMb0RPcEhTaVFlQUZEa0JqUHJsZ0NIZ0NVYUZpZmc2N0gvOXVZam40QWkxdnBURVJUQUFTQmFvUUpCQUtlTnFIbEw2bXdQRFpZQU9ST2FnL0VZUmtQWDM0TXdISXZ6VzlyUWNBK1RMcEkyMkc3RWNRS2xKR3NZSUpoQzZDbFVNaVhmQlRiRlVRQWVqNm5QUy9PdUFsOXBPT3FJYzJCTHpnKyszVm1XZ0lFVXo4MmNSdUNBdExJSFFRbTBnTzUydU9BYjIyc0MzSkVXZ1JmUHBaZjJzUUJRSWdMeWRQRUlGR3dQRWo4TWxGMmJTYnN1bGdoTGZ0cXNDWHE5SEdnSHlzem5yR2dpNXF6VFVURkg4RkxoQVVuM2hJSndDTjBITG5jdzM3cWFGMnpvWXZ1S05pdm1RSXVVTmM3R3ZXdDZzSE5zMjZ0d0E2dmh5cThORU1BSGx5bnRGckRDY1FlaHlhUFRsK0Z3QWJYRGNtQUtNUlRoYWtFazhROGtQZzhTUEwwcXpMQmwrQTlRQ2dSNnVaR3MzdmZIejhUdEJadmtnR1FyRVBCVkFVZzJTaWo1MFFBT2ppVktJM3NhQURKUm03ZFNMWVdmU0ZEa0NlbS9kaFplTXk5cFBZNVF2U0RZUXlVSm9ESUs4cU1lemgzd1k2ZlNMNDlQY0dnQ0FBOHBTY0pMSWdBVVlRRW16OFJQQTE3U3R2R29CdjM5VzI0ZVJFaUJvTlFTZ1dOSTFIQmtkZ3hKU3cxQUkrZEZJYmdPWW1ramltUTFyNlhYQzNyQWJDSHljQWd5dG9oZjh2c0IvcjJLUmFScTd6cForRDM3SE1YMHMzRERjQ1VHTFlhdzUzTUo0WVVPRHp1c3FsR0NRQU9RQ2VqdXhBOFVVTFVreEl3QW1NQXA4V2EzcWtOL1I5VytzQndPaElFUGprNVNMcjhIZUtGYlRRZmI3N2NzUElNSEdsLzRNUGJSZXNsUGhOZTQrTWlUcGk5QUZHVjRuSTdNZnZhZ05RTGgvcGZyWW5EQVM4YUpRNDJBMnc0ZW0yY0F5V1FVdUpWUVRHV0xzMXVMN0RHOUoxUmpoQStqdllrNHQzS1hlTXFpanB6cnVkNEF0OXozWHRQMTZ5R2ZqS1ptQ0dvb1loMXRaenZ2OHhYUEZsNFBvSllDOTdrOUZsd1pXRCtBemkvZGVNWldlUDEzZVFDR0V5b0VSdWRDaElqYmIzbUpZd0g3VjBRSUt1Q3dqL2dmTWowYXNuMkkwRlhSU0hYZkwvaVJrTmdMeWVWajhjY01ZLy9KMWZ5eHpUQVhUMit4b1FWaUtZRC8xaERxTHhQaVl4VGdTdlFycGhwaEc5N3R6NFNscWFmbmo3dWsxa0lRRFpydldUdzhCM2p3RVcrUkx4UGdTaUNFUmRQd1BSNyt3Q1BnL2d1bEZnZnJ1RGtPTVFrRmM1eDg0ZTcwOEpBTW1DdVJOQlhpNFRJZzVDR1J6R2lCR0UvRDRFL0MycjJ2Y0FZSm9pZnk2MmkwYUpTTWhCKzJJSG9Od3UwZmtjalE4NXB1M2FjazVuSUJSRXFuZVlGeVdMa0FYSUpIRVNlMDBDeXg1UXllTDZGL3R5RWNEY3JPVzJuN2ZYOGRmMG1NRSsvdlEvUFFqaG95M2d6bzNBSVNZZjgwTVFhUXgxcGVIOXdiN3YybXJ0bUNCa0lNTWVqcDNqSUpEMU1zYXhhTVo4djVOLzY3SU5Bc0IzQkFZVTRKTDREU28xSjE1QUZQQUV3dVFIWkp6a0tmVUF0T0hMSlNPUVJXbmRCWVF2Q1FBMDFjZm5Ob3Bmc2FDSmFEMmJhQm43OVFqU1RpT0VQMUVjYXdJcGtxMmtlZ0JUTmdIV0VwT0tGOFV3cTJOUkZQTTRBcUNmNDYvckEyVTkvdVZEdnVyQjAxenZBSnBpaXdPbDNmRWVjaUNHRitJajExZitRa2JTZk1QZkl6cXc1N21FRlo5RGwzUHM1SFhXQVlCeUhKQUpLVjdOK3MwY0NRUWh3U2xmbTRsR1owS0I4Qy9yQUJnWlVTNlpISVRCU0VoQ293VVlBQWtzRjdjU3RXUkV5eFJ3dHVQcE9sZ3crNXM5c3E2T2FJSklJbFVnRWhBMWVkb1RnSHhhOUhWdzVqaWJaTkYrai85eUdRQS83cGJ1alo0Ynd2MitjV0I2dEZvME56WW5reEZBK2N2RUFvNDNWQm9FbzJlKzQ4RU1YRU9tRDlGNnhoQ0U4UndaRUo4MFZibEt2RGxtendpY2ZxeTkzL28rOEs4VHdCMmpWU2dXMTM4RnJKUVRYQk5sbkpnbXJqWndhbm93OUNCUC9yTDl3RjBqd0FHV0R0RnlvTjlQSHV0bklIVDA1bVBYejkzZE1HUUFQbmlKc2ppQlhpVGJ4RFpGTUY5TkxVUFF4S1I1cWV6ejFZNi9ZWkRIMEQ2R2tkQWtZSkl2UmFsQWRIQU1tUFpvWWhiNk5oRFd2RXlmL21hNzM3Q1hON1IxWkM3aFViUGdjRmdxdC9aWmpBRG5NMXhxRVZoWUJwYjRDVWs1VXNMN2pRdmovLy81YnVEckxlQ09FZUQrWVFjaFl3RzlWSWZ5ZzFOYVpzekZpQ0g2RGtSR0x6ZTUvZGdrOElNV2NNQ2pkQ2lDelI4b2QxQjhPVHd2Sk04SkVTaEZ1dDFmek1oaStlUkpyNkxJN2hZUDJNL3hWTHdLTm9aalVUd1JNQVFRbVl5aFdHUXhzU0FET2ZsWjRrdWtqN1BoWjc1YkVUakJwa0FHYWhNa2NyR2d3aHNYZUN5QkhCajF3bU9CUXd2QXdxS3pvRmVSVjhaYWVyaktZQXVpcm1QWS9vOVg3cTVDeXI3ZkF2WU1BZnRDUEdBRW9ZbEJpVnRGd0xqdHAyVTRpcmo3eU9BTmJpK2NySHlyZkNiVHF1SlY0NE8wRjFGcndRR0lNWkZxZFFEeVAvZ0dTWjhUQzBaUlJzT2xWenpnYXNkL3UrenBNQnlMZWhBZkNnTVFDRHlHWkpIRkNDZ0xaMmY4bWdJNXFhdUVjVng5ZTV2QUNUZ0NUd0VNV3I1VGRJcFdLSmI1TXZybm9vY0Rzd3ZBUEFHNFZMR2c2VUtlcW1pNGl1RHo0ZXIzMG9YMEZQN3U1bW9NdklmN1c4Qitqd2xVTkF6Rm5sWkNJaHZHRlJDZVd6cmdYU1NJQnJlWFRGWlNnVkxIQXA0VUhPRnVvY2lFRXNuMlBKd2wvWEVrMGR6ZlNvamVlckZnMUlPbzVCS0F2ZUlCZXgxUDY3bGdVemdXUWFKd0xBS1JIMDRpMTRJdGdES0V0R3NSbld4NDliMlZrazl3VWVmVEdyS0NGN1IwSnhaTXF4TjhjbVBBeFdjQWN4R0FCS0VBS1BBNXU5bEVhQWJDbUtNSStzRE4xWDN6K3JvMjR3RVpGYzBWRUU2NEFCZ1QxODBQRjlaZEJjRGI2SnBxY1B0UGsrMUFDYm1LakpubGx3eXVJTHVuRUFXalpIa0JzcnNSVW5mRDBxRWlDNUlKZnlpc2dNaHpXaGNQMk8xNFJvNFdiQVNnQU1RSjQ4U0p3Y2htQkNERmE4cXB5QmJTUDdPdlU0UFEwcDJXNytMU25TSlVGT3JJNFY3dzVJb0JUUVFUZko2b1RTWWsybVFjcEdSeUgyc3lHaklGNkVNM1YvZk0rK0MxQ2Z3VUV4aENzbXpDYVFUNDNsWkMzZTFoQnBFSGgzNlhFcXJCN1NjbXE1ZFYwWFp4bVY4V3VERnpBRjlpd2hvdzlzZUFHb0JjR3RLanFBYysxbDlyTGIvMWlnZXNPNTV5c21DckM4ZWk2SXhSTUFLVFdOQmk2WHc5OHhOVEZVaTBqRWNtcFlnUkFQaGRkcFZpOU9JRVBQNWNZRDRDY0xrQ29vSFB3YVc5a1YraXdXclFIVDh1QTFmZDNGN0RGdmdVSFVQMms4alRpb2dBcUxveEZwRGdiTWo5alhTdU43aTlkTElkYXh6QnA1WFZCTUlNZ0ZFbkZBUEtUOXFQZDZBOUJJR0k3TWZQbWY0VSs0MEh6SThuV2dxMlBCeEw0RkVraktKaXhHUlJGeVFRUHp6ZDFpQVV6Q0FRYXMxWU9tQUVvRmp3a2VjREMvUEF3aEt3NkN4SWtDWHdPZFZKTHhUb2JNakJkeUlnZnZpbU52Tko3RXZmNGpXdGRuUllEMVlOR1Z1RzkzVld1V3M0SmYrbWxaQ0NaeHdQL2NuSjZtWFZLazIrdEs4bFFRVkhSVEdjNjRTREFaQjNFeTNKY3h5QUNrVG9KeDR3SGwrWXdxbG9HRElDbVltVEZnTVFGQkVUOHl5WXp5QUcvQWZXWDhtQ0dRZzBCVFJvSHd0OUtWYVBFL0hRODkwQUlmZ1dLK0NSQWFNUlluVmR4SGJoZFk4V3NsdzFWOTNVRHNtUElqOUd4Z2lBaW9SUk1JSk52b3RpK1NXL0lrZDBnd0FVOCtYeEpjYkdJVEpQRHZJNlhkQ0ZSRUZTa25UQjgzeGthNDBIMVBHRjlkbnljQ3hGd3lna0swYkFTSlFTVkFiQVllRDk4eFVBZTVVM2pLSXdCb3NTZ05zdUFCWW9nbDMvSXdnRlByT0lnMVhjNFpycEFzU3J2cnV5a2wydWN5a2Fwa01NaDRDRXhENUR3SmZXQVlBeHdrNE1LUEFKZ09JakdTRUd3dUNha1JoZW13Nll2MFVVd1JmN0wwMEw5cG5zTng2UXg0ZmVZNE84cERFY2l4T2pzb1RLS3BNWWpTRllZak9DOEVxM1dubnIwWVlTKzBUbWkySHlzclBHTHF3QVNOWXpCblQyTXoyUUQ5MWxheExCMGdzMTJHQWg4MWNmL28vT2NIeUorcWowUy96eG5oVVpiU3lZV2FMOCtScTJTMjl3b3dpV2tKUGFuNE12Z3JEREdBbFJlN0tJeXdESWdSM21lRURXZzlIYkpnQXBOVGtYbzhvMGk3b1ZneG5FZ0ZyOEY3akVkblU1R3ZxZkpRS1FLeUVPUGxzTklRdnl2dXBBR0hTL09rdjRxdjlvaCtQSHhNTGs4Z2dCQ1J4dkFtRU4rQWlFenoyaVFmUUJlTm1raDRLNTJoSkJLT2FOZS9GU0xvYkxSWEN6NDNyUW51MnlpOW9NU01EeHMyam84MzAzRVJ6MXdzQ0daRUNGNGtkM0R3RVlZd0pqaG9ObFFyZ0lqbFlvZGJCUHJ3TUFaZkVteXpjSXYyN2dzNlhEekMvSVIxRE9nQTlhNkRSejR3WkFzWitMWVh2UVlzSG9ENHppT0ZrbG5hNllEMytublU2ZFo3YkdEQWNCVUltSUFtRVV3L3piSjFpL3NjR05ESmlMWG1sZTNSaFErbC9hcTU3Z1VRQ1d6d3dCS1BlTHNaL0xGckdnL1NoUlhBZTY0QWprdjMwa0FMQWpGOFIxMUR5M0s3S1J3SmNzVVRhcVdTY0FSb3Uzdy9JTlZuQ0grQTM2bjhSdk0zbkI1WFA0b0Q2REFUQll3R2I1YWpsT0xPaDZYOEphQktSRzc3Kzd5Z0dZcDFibitWMjUvMDFBekJud1ExeXBhbkQ3S1dmQTFRRFlDM3pKSWo3S2dPVXpjOW5GYmV0WC9yK081Yml3Tmh5WDV1U0VEcjVvMHhzSndMcDgvbTRBN0dhSlV2L2ozLzUrSFFGWUozb0ZQUGtoby9oTmVxQmNNa2NCMkJBQTZYcnhtTUJrZkZBY2kvbTBKcHd6WHcwVFh2WHR6cnorUEtjL01sL3Vnek05TURxQ0Fiei9rZVZqakdjUUEvWUx2am9ndW8xbVJzbFJJNlJ3ZnNpQTVucWhMNUQ2bnNjRjhnZlRkZnhwUysvaEx6dldmek1RQ29CMUZxLzhiM1ZXYVBJRFpxc1JWNjREQUxzWkhWSHMxZ0V2c3FGQWVCU0FwUUM4cEhLOTBPcWw0VUVBeXZDd05lR2NCWE5MT1BNTGZ0Z1pzSTc1b3VVcjlvdXNwMlRFeUlKL3NVNEF6QzFlK1dJRnNoeUFIUFpSRVZ3SXRyckQzd0dBaGliVFlCaHhWcGUveGVQeXJOQnVXYW9OcDNEZ0Z3QzgxTytSQWVwSy9hNUxmZTUxanhyN0p3QTgzblBYWWdxMWFzbDB5WDVONDgrZjRWRUdMQVRsSzF2QW81WUIxZ0JTUm1zTStORkU1N2xjZlBENXBQRldDSkltdHl2R2dHZk9BYWNCWU81OXpGZ2xnSGdQZWZac1hWNi9nUFhCWWVDMFJWZ3lKTk9HWXVKalBrYTllSFdnakw5Yld6aFdrMC9uL3dQbitrOGJnRk5tZ1ljc1ZmbFpuQlJtSVNodEpNL203SkdpYkdCb09JSWV6OXdLUFA0QWNOcHlsZmJObEdmZEkrOU5qQmp6OEpWenBwY2tadUorZEJ3NGFRNDRkcms2ajFMSVk5SmtQRDdQNHMybHdWRUdMSHdKbm5jc2NOSWg0Tmg1WU1zU3NIbTVuZE91MUJHRlRoSjgvSzZKclp0b3NsU1QyK1hIQTZmdEIwNVpBRTVjcmdBdXBzNVRmYUw2RUYrVXlJaWYzZ0FjT3d0c1hlcDgyZUlZWTlKa1hwTWdNcC9BZVpRQkMyYjhPZHVCWXc4QzIrYUFMUXZBUmdKd0daaFk3c3dFemJOYTg4SVJ2QVZPMXFrRjkxSjM2RE5PQkU3ZUQyeWZCNDVmcXBoTG5ldnpkR2VCS0JmTDhVWDUvQ1pneXl5d2VSSFlzRnd4WUh6Uk5LNm9ldFNCTURMalVRQVdUUHFQbmdwc25RSzJ6Z0tiQ01BbFlNTVNNRTRBTHJjblI2SllRSXdzb1VuanBEUnN0T0x5N2NCSkI0Q0hVR3d1QXR1VzJuVURWSDFFRlVoeWNTd1dqR0Q2NG1aZzB4eXdjYUVDb0kwejVQM1g1UDZuV2xIZGdIZ1VnQVVBZk9ZT1lNdEJZTk1zc0hFZTJMZ0lUQkNBRGtJelNKWlhwQ09uSWcyNXVQcmhnbnVwTy9UeWh3TEhId1NPbXdXMkxWU2lrMnBDckRzUXNrek5JQkdJcEJkR0krVmZOZ01iNW9FTkN4WDR5UFJqUGo0eGFKMCtXR2VFSFJYQkRVejJNeDRGYkRvSWJKeXBBRGl4VUFGd3pBRkk4S1VKQ2hNVjJTVWFBR2MxY0UveEZKZWYzRllSdGk2NG5rcVdEcnFxRWhicnNtNXp2WkNkUENkOG5IekpPTFp1QUJSejloVEhad1BMN0xuTG5vTk1JWTJWeWFLY2p0WkxIT0FiTmdOUG5nS2U0QmFjZkdGMXBueWREK2hwaFEvOFhWNVVpRXVlTEduRE4xdFdYai8zLzRjVHdBVXp3R1BjUmNGSmlEcFB0M0ZMbWY1dmp3RTJIQVEyelByRXpEdjdPUWc1T1NNK1NjWVF5NVhibzg0NjV1L1pmTFRKN2ZLSEFkdW1LeFZoOHdLd2VhbFNFNmluRW9TeTJNV0NkYlVISWdodjNBcU16d0hqaTlWTFp1RHpEOGNYeHhXWnM1YzdhcG1XMGZNQm5JSEtuNVg3ZDZJNW5wdlJ6OTRPN0xnWHVHSVJlSlNiK1hsMXR6cWZseWJ3UndxZjlpOTdCUVJXb21XSlE3b1pWRnRKb3FEWC9iL29HT0RzdmNCVEFUQjlnc2ZHcW16ZGp0VnorRytQQXlhbWdZbVpDb0RqRkUyYW5DVmcxQ2VKd09NblRSQi9EbVVJTlZra2dpYTN5MDhCdGt3RFcrWXFBRkpGTUQxVkFBdzZYRzYxUjMxTzkvZmRyY0RZUEREbVkwempjMVVqaXZCdUFNeDFRZE1CK1dBWVhVOGRoRVUxNmRPU2twcGJjSEZTcm5nOE1Id25zR01QY041eXBVUkhwMnhNSWE3ekR6Mno4R24va1ZlMFlvbU8wd0V3QllLdWpMN3YvekhBNkMzQXhmT1ZoNThnNUFzWnh4NGZaTTdzZjNoNkJjRHhXV2VHQlorY01FRml3R0VISFJuRHp1bjdPTkhzL2Rqa1JnQnVucWwwVkRPU0hJRFUzY3hTRDRhRWFqaEZYUzRINFMxYmdWR04wVjh3ZTdFMEZoOWpWREc2T2JyMUxKTVJ3bitrT0NhVEVZVDBkc2ZxWkhYbC9wN1ByTGk5d0lZN2dPMEgyeUFnQ0FXQ1dDb3dLcllFOG5NTG4vYTdQUW45WDd6SUpQUGtDY0srNzU4eTd4N2d1TnNCNmw5OGdaakxMWWV0M0F5NW4wc3Y0UitmQ1l4UEEyTU93TEVBUUxJRFB5UDh1QmcyY1JZbXpGd2VBWWlsS2tuK09DOC9GZGgwQ05oRUE0bkdBNDBrZDZGRVMxM1dMTzh2MXFIS0FmaDlCK0RvWWpVMkFrL2pzLzhOQUl3ZzdPVWI3TENDK1dBZkI0Q3BCSm9JaVRSTlJtUzFsMTNrcVdoM0FkdjJBOGNkcXFwMU1CK2FJT1N4V3Y2cHE1RDJra0lBdnQ4ckY3QkxKa3NOL2pNcWZhN3YrNy9BazRCM0E2Y2VxcGFzS01xNWFrQW1sTFdZMzd0OFpXOTdQREIycUFMZzJCeGdBRndBTkVHY25JNUpjckRaUlBsa2FYTDR1MUtKVUFmQWpiVFE1OXg2ZFN2ZExQWEFnR1lzaFpXUjZKSVJhWEIvTndGSThDMVd3TE1Yek1lU3dMZmNYdUtyQTJHK3dyTENEY04vSUlnNEVSUm4wcXZ5eVNBUVg2bUcxWHVBNGZ1QWJUT1Z3a3RSUnIyTUxDb1F5dkVaL1VZL1d3akFqM2p0Rkpaa1U3OWcxZ2hrZ0VCZjk4KzBVbWIvM0EyTTNsa0JsL2ZPY2RNb2syRWprWnl2ODc3M0xBZmdIRERLandOd3hFVXc5eWFpbHB3ZHhCQUVZaEJiQXVHekczYUtrUUVKd0FrQ2tPQ2psYjdZNlNZeWYyVXdsQVMrdktZbkFYamZObURFWDdERWZBNUNqVWNzbnp2YnUxbkR0VU1tQ0RrUlpFRXlHZGxBazZHNmxRVFNhNm0wTVA2SHVZNzNBeE5UbGNKTFo2V09KWUM1L0NOeExwSE1nZEtJS05sNjlRdnU2Lzc1QWpIT2lUVTg3Z0tPT1ZpSmI3NDhCS0NXcm5LL21hVEErNThBak0wQW83UEE2THgveEJBdXBvWURDOW9rQlJBbVBkQlo0N2xOQS9EaHdNUnN4WDdtUGdsK1NybUs1RWFSTlJzbFhGUTlDS0I5RGtBRG43OWNadGtIRmt5c0oxMDNlQmJxbGg5N0RwbVRRVFlnazlWTnh1K3hZYlhLVTNsaEZvSlBPZ2RGR1krbFBrZ1F4b2trZ0Y5WGdqNEF2Zm9Gczg0ZVg0S2U5eDlmSUMrdFJmRHh2dm5paWYzNThzU2lyMkxDajV3TmpCS0FjOENJaTJBeHhMQ3pJQUdZOUw3QWhHSUtncEFUdzRsOHdUb0IwSmpQcmZUa3ArU0xRYkhyT3FtNWpOeWFqUzZWQ01JcEFwREFXd1E0THJHZ1hxeklmbnE1Y3Ywdk4wWlhIVEluTUU1R0JOTGIxREdkT1lRc0k3QWZHS0ZqbGdxdmU4d0p3RzRUK2Z1RkFGeXRYekNMYitWZ1duSC9mSUdZZmM0NkhzN2lIQzhaa1BjZFh4NFZmVlhKdzgrY0E0d0lnTTZBSFNMS1daQ1RFU2ZMZmc3V3NJeVJGM2NraVJRK0hBQ1hrd0hwdHlQNEtIcnBKdktWR25PaFJGOWVCRjl3RTBtVUVvZ3oyd0MrV0dJL3ZWeGlRUUl4QXM5K3JtSEE2RTFZRllCOERKd1FNWmwwT3JMWisraTdzZlQ4enJvWUhMUzlkZjRSQUNXS3hTWnZMWHpHL2ZRTFpxazJncW4yL3ZVQ1VROVVaYU05d0RhUGVTUHJDNEE1QzFLVitOSVRLd0NTL1NpQ1IvalJCRGxMbVA3bkh5bnN4bm8xSVB3SlN5UnBiaU1BRFh6dVBEWWZaZkJURW9BbWN1VlFkaWFXMHp3WHdRc0NZRFltTWFEQTF3RzhUQlN2YW9SMEc3N0VjR1NFVDZoak92VkFwZlJQQVVOMHpqcjQ1SnpWY1NxaVR4RCtWZUd6WGt1LzROcjdKd0RKT2t4Rkl3dDZqNitScVVybGtPNGJYenAxZ0NBQXYwNEF6Z0xERHNCaEt1Z0xGVXZRVWhUd0NFS2JuS0N3MTRId0o5Y0RnR1E5V2VnUmdESThYRWNWRUR2QWw3bFZsZ2xBZ2krSTRDUitaZjFtTEdnTW1ERmhCR0ZmRENpY1JKRkVSdmlTQUJqTFM3RkMwTUZLTVUrMDd3T1BFMGtHdmFvUWdHdnRGOXoxL2lPRGt3bjNWV29FWHhyZXM1aWI5eHgxd1p1ZkJBd0xnQVFleGJBRDBKaVF3Sk91SkJBNjgvSDNaaGs2KzNDaWZxcXdXTk1LTjh3aktnYms2Z1dKZ0MrRk1hQmI1dkpWbXNVYlYydkNxbzNjUldaY0NJQUNvYXg1Myt1bGtxTmQ3aXFPY1UxV2NDOWN4RW01a1FCVWRaK3NUblNML2pFdFRXbmdpMjFqaEpOSkJpdlpCdWtYdk9MK3lZQmtjT3F4S2pKNEFHZ3h6TXJCVndkQU1tSHJaT0FZRjJsNnkvbXdWNnhEMTd6bVdvNk1iUnllV3RPSHd4SjkxSUlocjZycVpTNzBEUFBMWERWVXJmQnd6SEtyMUVVcDYvaDBULzZML0djQ3FzbHQ0SWhvVGN3ZEFxRFNzN0k2MFdRSDZSMzI5cEh1Rnl1WERKbUVqdU9TYmRCK3dTdnVQNWJHVWptc0E1WG9VdmN2QlhLS0FRbkFwVWRYd2FoMGI4alhSMll6SlRzQzBaSEIzM0ZMKzJ5aVgzaC8xWWVEMWZGWkdUODFnL0g2eXFrVmE5WUVwcU1oVEFEbGU4ZXJIQTZ0N01oNmo0WkJYZEJHakZ5TzRDU0ltOXdHQmlCdmdxeHdJQUpRbFhJeUVKTHlJL2kwU2tBRy9GYmhhRXI2QlhmY3YrNWRMS2hDZzR6MUMxSEVCSjgrQk9EUUdaWGZrL3F1QVpDNmtldEFaRVFDVFdBVThQSUp0MGZnd0h6WnZWV05hS3FpN0pMT210RFdGeTQyZzFGeEgvWGZxR2tJSTBDK2EwdG5Ea2ZzR3hRam4zVlBzazd0WG11eStYcDBKaHRvSm9zQWFGY1VBSlVZS2lZSnhjcUhxS0FIOXJQbEcyY01ybUNVYk1YOWd1TUxwR1RjQ01LRGxaR2hNSzhJUG5QSW4xWDVQQTJBd2Vnd0VFWW1ER0JNak9JNXdoR1FQM05QQlQ3VkpsUk5hS3ZGNHQySVdIYkRFcnREbFNrMXA0bEo3L3pkMjQ2dGdsR1pyeUlmckZoUTdwVThXQ0FYMFpFTkcrNTdVMTRaNFlyQ2VMclN4WGRldjZUZkx3cmJ4VDd6bk1yZktRWGZITFFDbnl2bVJJdjBRMzQzMGV6TW1MOThQMzkzRzN3cXo2YW0xTll6em9HbitzdnFSbVRBVTJjaXRjdHFBWC8yRUk4RjlBQ0VtTEhYTFpHb0Z4dFNsMnh5SzJiQVl3cmo2WHIxMisxbm9ML2pVVENEOXZ2RnJuNnUwdjEvbnZHa2FvVkJBUWkwZXVtbU1BdVhRSE1XSkFBN2dDaXhHOFUwZ0ZmY1hkbEJLazRaNnpFTGdBSmZaRUtyeHBDMXhPSWwvK1NrN2prY2RZbFNjbzkweTkrZ0s2dkpyUmlBREQwcGlhZDdSdUZvM3VkTkNnZnQ5NHZDZHJHWG4rdHVqZ1YzUUFjSExjRm5yb2VsaXZIa2NoRUw4dWUwdVE3NFMzZXViQUlUUzNJUWhLa01SakJNb2tnV0czTC8vMnozVlNuUDRWRGdRV3hVRUVVeEFaRkhMMGVSM0hEZm0zSVJiREhrQmZGMHp5NEVJS05oU3ZyOWdvR0VCZHZUei9NSVlRTFFkVnNUd1JURkRqNWpRbWRBclJEWUpRTkRTczk2MVIzdFBoeDVOWG9WZ294bGVIbmFyam9oZ0xlYzNEMkhJNDkyeVFOdkl3dnFPOWZKbTl6S0diQXdudTZGaGFQNXBGdU1nL2I3dFRicEJkdlR6Njhjei96SThhelZqOGlBSFRxZ21GSFhEVUI4OVIyZHRhQzd0VUd3NGtET2dGYjBSMndZUkRHWjhnOU84YVU0WHdQT2N6aGl3R2xNanFxTFdpRllHdTU3MHdBREZzYlR2YXhnOG5rb3c3RThuTS9hdGZLemxuNi8xbVM0WUh2NkJRNCtaMEJicUhjZDBOd3dZYlZEMysxeVdoWEp4UEJyYnE4QXFFL1hBcFNxQXhpQlYyTVovNTRETU9ad0tFMDBybkRVV2NSNUtpVi9icmp0U0FNQUxJeW4rL21DeWVlaGpJWXA2ZmRydlZFTHRoOFJBQ2x5SFh4bWhQaTZyMW04Rk0wdWNnazgreTRSSEMxa0FLLzVYZ1crMmhaWW9mYWZXY1BxMUI1QXFEcUVZc1EzbmVwUjJncWhWMnlpb2wxQ09rRDBDK2FPYW9HeDRhTDdEUUN3TUo3dVZ3b21uNGZtN1ZyWDJ1L1hBbEVMdGgrNXNIUHROK2wvQXA2c1gyZENzWi9waFprSUpndjlsKysxd2JjcSsyV0Z2Mk5YSWpOS0FQenV3N01VQVY4RFR1eW5GSUVzUXk4M1JnVEFoaXYrTmdCQUJhUU9HRS8zbXdXVEx3QXFIbmFRZnI5R253VWJBUmdETkJVbGtwelFib3lZQ3lZRFlkSUxkZjBsNE5kdVc5a0dvYTRnZU5kYXpMRWxLb0EzUHJ4N0RvZmlFVHRDNlh2RTdoR0V6SmxwY2lzM1Fncmo2ZDVVT0pvWURjTWdsclgyK3kwTlB0bDVVWlVqa2Z4L0hxYmVjb2UwT1p6ZEYxZ0hRcmxuOUJoZWU0czNmM1p4bTRNdkFrOVZTRmRVSXcwaStRMlBhQnRJU2lCU1NGZ0NZTWpNVzAwTVA3cHd2dkxEbXdGZ1FUemRIeGNPU0d2QmcvYjdaUlpCeVdZQWxPRVJsdUtNM1JhOUNLV2MwcTczZFRCaE1GVDRad0l3OWw1THJwZXMrSGplQmlHQ1VPS1hldUJ2UGNLVGlFSU9SMGYrUmhEQk1ZaTBMaGVhNEdUYWE1TmJPUUFWRHpoZ1BCMUxhNVJzc1YzcklQMSs3eXk1T0FBRG9BY2hFSEJrRmJLZkdScGl3ZUFQdE1zNUlGTm9reU9Hay83ckFZQzlPaEJGd05YVlkxYXQ1dGZ0Q0JIYVdWUzJBSmRFY0VpbnJETkMrTHVtaXljMUI4QUI0K211TEFSQVhURENXdnI5M2xSNC9aMFh0Nk9ERlFrajhXdHVtRXdIVEtETFFlakFmTjN1ZHMvZGZqb1FkYXRHTHhiOGpRQkFZejYvYm94aUZnQVZ1ZHpOSWMyL3MzeExrMXN6QU9Sb0I0eW4rMkRoYUFUQUdKQ3RicGtDWXE5K3Y0VithQmdBUTRpNjZYdGFDODVZa0RvZy96ZFp2elVnZk4xTjdhNjMzWHF2NmZlOW1zRElIZk5hQjZBeTJKUkUxQUhBRURJZkk1bnpaQ0xlTjROYm05eWFBK0NBOFhTc3VsNnlxVjBySjJXUWZyK3NwbEN5Q1lCUi9ISnlLWDRwaHMwUEtCWjBscU9ZVHB2bmlBaVVBbUFkK0hLam8xY3ZEakhnciszd1BKUXNWQ3ltVVpyUE11UnNSQkRHNEFRQ3N1bnlKdEZHSHdBQUlBQkpSRUZVY2MwQlVKbHhRb0g2MnE4U1Q4Y2dncEtOQUZSR3dDRDlma3V2YndBa3lHZ0pFM0MrTnoxUDFxOS9UM0YxRVpCeHZaaDUwczZBRVlDNXl5VUhYdDUvUTh6STUvS3JBbUFJa2tpcGt5R1BZd1h6MWFSVDh2NVpPNmpKclJ5QXZLT3ZOWGxMYXpzWHM5Ym8venRjMjlQb2hnb3RwNUo0OVJjai9wemZJd0dTLy8zT000Q05kMWRwbnRRcEZVbWpFSDRMWUlnbnluL09Makw4RmVER2h3SmJOZ0ZqSThESUVEQThCQXkxUEZLN0ZTS2Y0M2NOS3J2SHgrOEMvdm14d01nbVlIZ0VhQTM1SjBTdHB2dnpML25QOFJiTEFmaHlUMjA3VENoZ0RSaXUvWkw5RHNmV05BQnZZemJoQ0RCS29CQWsvcEVvYkdXVHFwODE5aHpRMS8wazBQb2FNREVKYkpqeFZaRmdEYWQwU2FVTzVMa3NXVmorWFNjRG13NVVFVURKNlU0ZDBuVmJDOTFTM292ZlZIcDVhbDY0Y2dDK2s3bVpBUDc2OEtDQTBXRDNBL2llTHowOTBDRGNlVm1sQXVoQmxqTGdyZmNBdzZQQXlEQXdQRndCa0NBYkl0TTRhL0ZpTnRFUmpCbDc2VzlmZkQyQWJ3SkRkd0ZqKzZzeUltUlhyZDVZMkZqSVljbnpXUExFcW5zZkMwenNyNnFCTVFtZklEUi9weUo2eE1oS3lNclNEaUtEMnhqYTZUQURUdDAvQUdBczFLY0FVQ0ZyT0xGNnRidGlSVkZhdlQvd3VNQ2E3TWZWVGxIMDk4WUJlQmN3TkFJTUVZQVVsUzR1QlVMT21LM0xDbndPUEFObEVJT1NvRjkrQzREdlZvV1hodmRXWlZPWXFXZ2kzdk9YRFVRaGdpZUIwRUVsVmlNWUowOEh4cWVxbkc4RDRJSURrQXpvNTFES1FRSnZCS1VtS0FDemJNNCs1aFVpdndyZ2l3QzRMenZqbWdDaDZuQmNnaU1UY3Y5QWJvMEQ4RTZnNWVDamZwVUE2QXhvUUl6Z2k4QUxtV3dDNHovL0R4Y1BQd0JhazhEUUZEQjh5SlBwUFpIZUdDeUMwS041REZDQnlmaDkvK09Bc2VrS2dFekNUd0QwNDdYMFNDUE0xSVlRakN2MkUvTUpvR1Z3VVVRb1Bib3EwTWRxa1dWbjdSdERETWFoQjRnK1A2cWhYRnBqVnRrRHRSR0Eybktqb3M3SXlPeUhGVWJJclhlMEZYc1R1eklZZk5iNE8yTTNBVEdJWVFPbVBuNmhHNmdpM2VVa1FRQWVBSVlPQVVPekFMTVZoMnBBbEVTcUdGQkFYQVlPTVFWanhsbDAzaU8veVlLUkFUMEZRWGt3WmtqcDFwejUxTE8yWEFUM0t0RDNBSUF3ajRXZzA1a2ZpdVVIWWxzWEFKTFZuUDBJTkxNME9ZRng3OEF6Y1J5U2VUc3cyQUp1ZUkrRGoyRm5lNEVXS3o1TUEwTXpEa0NDa0FCeVVXcXNKemFyRWFuemoyelh3akVHRkh1R1krcFlzTW9qelpMMUc5RUJleFhvdTMzOUlSQnJDM2xKR21ORHVTSFgrdzdXQzRDbTZ3V3htOERuZ0xUSW1nQzhwQmNHQnVUWGYvMWZYbnlUdWduRnd4VFFPZ2kwQ0VDeUlGbHN2dkpmRW5oMG1oc1lJL3M1dXhGWWkxeFpvZjdvT3FTQWF3d1lqUkdCellHWGJ0V1hhQ0lybHZIVWFnWDZTUC9ydU1WWUNFYkVxRUNYQU1qZnJlZTJIZ0EwRVN1cjEvMHZ0bk53R1NzRzBSc1pNRTIwLysvWFdINk11Z2sveW5nUEFHeTVHRFlBTGppSUhJZ1JVSXJzWmpNN0F4K0JTeDFTNHBmZmZRVkllcDhkTDdkTURzVEdqSkIrQ3ZReFRIbWR0cnc0bDBDb3ZGcnVDMk5PZTk3NWVnRFFzQ1hSSy9lSzYzNEpoQks5MHEyQzdJMWkrR3QwanhGNDBrMWNQSkFCN1VQMm0zTUdKQUFGUXJHZWk5aVVUSDl5QlVEVEhmVTNCNStCT0lLUTQzQld0TnRQY1dJT3pFWkU4Rm9LOUswRENHTnhMaTNGcWFLQTlnVGdlb0Z3UFFBb0kwT3VsV1QxMW9Fd2lGejdjd2JFcnpOeFd0RVlCQitWWTc2Vmg0RFdySDhJT29HUTdPY2cxQ3FNUkxQbHRteHZzMS9TSGFQNGRjQUplUFl5eVVDUkl6clRCOHRFOEZvTDlEVU13bDYxa1FRODdSbXkyUFMycmdCMGExY2kxOFJ1ZEVKSDU3T3NZMDJ5Lys4My9zWmRCS3I0RlhRVEFwQnZwckdnUUNnOVVFQU0raDlGNnVnSkRrQzNnSlBCRXZSR3JZb1lDQlg5SXhFY1M1SzRpNmNaQUhJdzhvWFE0bUxCYjM1WUg1ZDdPZWthZHRUVjFVWlNqYUVJUEg0blF6WU53Z2pBSE53RHVXR1lwWmM3bHpQZlgxY1F1cjVvQm9yZnpEZit6aTB5VlR1U2t1eEJJMlErUGhRRElVRW5NTG8xVEJDWkx1Zkd3L2l4YlFhMEtCOENUT0RqUG9oZFk3OElRbWZEam1XN1lvL2RvQVg2R3FJaUF0REhhWXN3U21lTXViVjgxa3AxMUw2aHkyUGRBY2dibGZzbE9LQzFJaUtSbXlSeFpnVi84KytEUzhCRnJ4WGk1SGQvVTZNZVNLZHFFc0VLaHBCUnNnUk1iQXR1RzRLVS8rOXJ5NWJyelAvbFBWTXYxRVBPUWVnaGFyclZjZ1pVaFZIRnhOUGNwOVZGdGxPV2tMNDM3QzBXQUJXeXBGUkdzVjBzYjVIbjJ6WUJ3dlVHb0tsMTB2MWtuRGdvMHk3WEE4UGZ2MFVBQ25qYUszM0NvOWdKUUFPZTY0RmtOdnRaQUhRZGp6OXYyTnoyR1NhM2pZZWoyVzNLR3VaOWl4R2RJVlNvS1QxM0IyczVBSGtHaGVTVDZxbjBlckh2NUFJZ0FBVStMVmZ3L3dxM0NFQVY3Y2xCS0RER1pHOS81b1ZYeC9veVlBUmN6Y3FINUd5SDhlRnBsVGF3RnZBdHJ0WExHcE5yUURHYmVqdXBCM29tbElIUUdjL0Vyek9jR1NSczh6cmhBYmJ1TDFUY28vSmZiTGxOd0hPbWkya0ljczNvd2Jkd05wWXR5bkRRaHNGY2d2dUc5L1lhcEdGdllYMjJ6WmNBVTAvR3dBMkxKLzRBbUdGOW13RWJCdTk4WTNjTUYrdUFHUUNqMkhWcDNCYlB1bzNJbHF4QXk1d0hBcTRPZkFSbUVCWEdmTklCYTBCSXNHMGVjd0M2N21lckhnUnBaTHdvY3JXYW92dVR4ZXcvVjB0eEpRMkRXZWFlM1dBR2JkaGIyREI0K3dSdzd3NWc4UXB2ODhsaXlHdG9XSHpNaTRDOWZBRUhiQmk4a3dVS3UyeE5BZEJ4YUdCTGJKZFp1eDFMd0FHRUNZQUVtNnd5ZnBlbEpyRWdGblJEeEVTd2d5VXhJVXNWTXdqVnk1QVlPMGJHODlBdXUxLzVCRjM4S3FqQkhsVUFZWHN0ZU5DR3dUZVdOdXd0azRKTWtybHpHTml6QTFobTY5ZzFOaXgrekRPQlcwYUJlUlpaR3FCaDhNNGVtZldOQUREVCt6cU1qUXlFU2RRRkhmRGJaRUNDTFJnZEhlQ1RlOENCYUtKWTFyRG5CUkNJQXVHVzRUWUFaZUZHOFp1TWtHaVExSUV3R0NKdEhaQm15MW9iQnN2Vk1uREQzaklBZXJ0aTNMRUJPTWpHY09wYTNXZkQ0aWM5dDZvdmVEdExmdzdRTUhqbkg2d1BBeWJXNnlhRzQrOEQ0SElRZnZ0RElWdExlanBCRnNWdlVJN05JQkh3M0RValJ6TDNyRFZ0c1lQT2tBU2N1WDNjb05EeW5UMlZZSkNrbitQanF2VUQ4aFZiUzhOZ2pwaEd4Y0FOZThzQUdOb1ZZLzgyNEJDQnRJYUd4UmU4cExLWmRwTWtUdlhpSjJ0b0dIelNOSERQU2NBeXEzZXI0cVB5R2FOYzdKQ1JYV0xUMlRqd0dtQ09lUWFzaHE2K3FTcFptcDh2b2pRcGhlRjU4bmNkWlZqTG5qV1BIcjRWV0tUS3hySEdVcXE5N3FYdTNqcDB3UHkrZUVDL0RZTlpzWkFPNklFYjlwWTlsTkN1R1BjTlY4MzBabWtNOWRtdytPS2ZiZGNYdkpNUGRZME5nMC83R25EWEtjRE1jY0JTN013ZEt6OEtDQUtRSWdZME1XR0N0cjRUT0hBYXNNd09rVHFmNnVueXVMeWtmZDI1NG5rYjdxc3cvaVZnN2poZ21TWDMxVnBkOXlSSGVMeCt6UmhqRUdSYkI2d0RZVDhOZHlteXViekR6Q0NHZnBNSldmU1JZZnI5SFAvYU1nQm03WW94TlFITWJRSG0rSUQ2YUZoOHlTOTN0QXZHUWI3ZGEyZ1lmUG9YZ2J0UEFxYVBBK2EzQUV1YmdHVTFSTTZCMDYwZmdrUm9DemorVGNEKzA0Q0ZFNEJsZFpkUmM0L1l4bHhnakpNZXdTaXdOMXpXZnNPbmdkbGpxM0VtWTA4dm01aS83ajV5SU1xcHZ1cEt5R29OZzlsbmdZb3NsOXdZLzBkWmRyTXpZbDhOZThzQVdOT3UyTUEzencvRjJDb05peTk5WGJ2ZnRyY0xyaXo2UGhzR24zVTljTTl4TU9ET2JRWVdDTUFOd1BKNDlVbGl1VzZTYXFxQm4vZ0dZUDhwd1B5SndOSXh3REs3NmFoRGVONnVYWUN1WXlBQmtFemE0TGJwWTVXRVdkU0x4akYyNi9kUUIwU0o2cjRCeUFONk5ReG1rV2Nxcm5RMDB4MURFREpGalI4Q2NOV0d2V1ZQcDZaZE1RNk9WT0NiM3dBc2NQSjZOQ3krN1BlcmtQNVEzdEJZMVByVDl0RXcrSndiZ1B1MkFsTmJnVmtDY0NPd3RBRlljZ0F1aXdXbE0vWHFEak1FYlA5dDRNQjJZTzU0WUpGTW8vNWdISWNBTFYxVFJaMTdGWE9oUHR2Z3R2a3FmOUg0a3ZIRGx5S0s0bDZWenZWU0JGMjJ1d2pPYjdwYncrQ2Zjd0JTa3llRkVIQVV4L3l3OUpUeUVibzI3QzE3T2wzYUZXTnVBbGdJbjlReE8ydFlmTmxiSzZNdmF4ZU1SWXF1dkw5clRjUGdKMzBUdUg4TGNIQXpNT3VnWDNRQUxvMjFXWEJaTEVId1JGMU9nSFMyZU9nYmdJUEhBN1BIQWV6TnU3UUZXRlo3Sm5YSjVybnF4SEV1bHZsend5Vk5OMyt3ZXJuNVlvdmw3U1hMR3d2bjRyaUxXTzRmZ01SSlhjUGQvK3BtT3ltRUxFaFJ6QnhKQW85Z1ZMNGt3Vm5ic0xjY2dIRXBXaTNlcG9jQ0FNZUJSVTVlVGNQaXkvNnF0bDB3cHZoQSsyZ1lmTzdOd09RbTRPQkdZR2FEcys1RXhZREdncVArY2NBa0lOYVZwQjhHVHY0ZDRPQnh3TncyWUdGcnhZQ21WMFl4TE5ZaGVDWGF1N0VoVjNnYTNMYjhnNCtSNDV1b0dMQURnSFdxaHNCWEE4SzFBWkFEeVJ2dXZ0a0JTQXJoK2k5RHNRaENPdGYwVVVnVy83YWlZVy9aMCtuUnJoaXpveFh3Rmh5QWk1eTRyR0h4VTY2cUFGaFQzckRTSVZkcEdIemVuY0RlamNEQkRjRHNCREJQMXVYMUNNSlJ3RmlRSUJ6eGllTDNLSVkxWVc1TVBPeE53TFJiOGdzMGFnaEFzczFHWjFPK1NGSHNkUlB0MGkvUExIdSsrZEZiL3g0bVhmaGNiV3hoZkN0WU1Gci91V3ZLeGZEYUFjZzdpcFBDdkZPVnB1bzNIckNqWVcvWkErclJydGk2VFM2TVZRK0w0TlBIMm54Njk4R25YRjBCc0thOElhYjRkRlpwR0h6K0pMQnZBcGllcUFBNEo4Q1BPUXVPQkJBT1YwQ1VZYklza1JrQWVjcnZBZE5iWGMvYURDeFNweVQ0Q0VJeVRnUmduZWlMSXAzblA2ZnMrYTRBNE44QjgvNDhDVUMrWkdKQTI5ZnB1TG14SlcrNWg1a05GZzJqaVdIU2kwcjBVdjRwQ29ac3h3OERVZm5oZDRWazBYR2RHdmFXUGFCVjJoVmpkamdBMEJscGtRL0s5Ym1uL0hPVnF0Q2x2S0VCcWxmRDRBdG1nUDNqRHNCeEI2REE3dGRiY3ZZekp2UUpraWkybjROT2VNcGJnSmt0YllQR0FDaUYzd0ZvRXgxWk1OZS80am5QTFh1K0t3RDR0LzVTTy9pTUJjWHVlc0h5bHlBQ01CUERnekdnN29wTThtRUhJR2R3cmZHQTFyQzM3QUgxMGE2NFlyNEFQdnZPU2R3RVBPVmJLeHUrSzJwZEtSVG1kSTNkcWtQUFZnYlNUQkdBWThBc0FUalduaUJkeDBReEp5bE9GQ2NyNkhCaXcxUC9DRGdVM0VnRUlNVzUyTThZa0xvbFFSZGRJTjFBeUtXaUJyZXRmOU1KUU42SHNhQ1B4ZTRydmdEZEhPY094RElBY21ERkRYdkxuazRmN1lxdDYzZ0VJQi9Zb2orNHA5eGFBYkJIZVVQTThxRjJhUmg4NFFRd05RWWNHZ2RteDRDNTBXcUNGbmdOc2dTdlErRHh1NE11aWF3aHdJQVhWazFPK2UvQTdDWmdUaFkxZGNubzFuSEwyb0RJeVpVTHBCc0FGVEJaOXBqVDBRUWduMlY2dWZSaWNTOFFSZ2JzNVpZcEVzRU5EZWpCZnBvTHJ3QU9qZ0l6Wk1CUlowQUhvVUMrU09BNTZ4SndObEV5VEZ3NUZ4QlBlV3ZsenBuYkFOQ2RRMWVTR1RSeWJNdXlkZ01nZ1ZCc0ttdFlvQzZNdDh6blp4c1pNTHpBeG9BT3ZzaCt5ZERxdFh4NEZJRGw4TC9vbVE3QTBRcUE4MlMvRVJkVEkyMm1OZmFUdUJJSXhSNEJoS2UreTYxcHVuUUMrTXl0SS9aei9jOUV1dnlCZWV0TEFmR1o1V09NWjlqMi9ncUFCQjFmTUxzSEFWQnFoZlRjeUg1ZDlNQnlFZHpzK0I1MFo3dm9HWlgrTnpOU3NkOGN3VWNHNUFTUktZYmRIUk5Zd2hoRElIUmdHbU8wZ0ZQK0hKaDE1ak9Yam55S2JsVlQ1Q2Jmb3EreUpPc3pGOFA4K1ZuTlBsSUNrTUF6ZHMvWUx4bFl6bnJKd0lwTzZlZ1RQTXFBNVpOREFCNmlDQ1lBeVlCY0JxVFJRMGU0NjMwU3haeVFKUUl2TUo4bVNlTHJZZStwL0d6R2ZuVHBFSUJ5NlVTL291dCtLMXdnK2Jyczg4ckhtRE9nQVZDTW5yRWZ4eE10ZTFNdDZqN3U5enpLZ0lYemN6RUJPSklCMEJuQ0pvcWdJZkRFaE01OFNXekpFUEdKZTloZlZINDJ1bi9NZnhsOWJnU2lCeVNJQlduQUpCREdFREFCOFFXRkE4d08zL2Erd0g0K3JnNFJMUFlMdWw4dENJOENzSm1KTVFBT3V3RkM5cU1JOWc5WjBDeGhaejY1SzB3ZkZCUHF1N1BFeVZkV0FPVEhWbFRjcHhoWEhaTHoxdzBaQTZFRExoa0Nza1JmMHN3NGRSWUMwUFEvdlZTUkFZUG83UUNkajdHcVZPU01lQlNBelV6TXhaY0RNd0xnY0tYL3pidjQ1U1FsSFhESWdhZ0pjK2JqWkJxQVdoVW9IL1krQjJEMEo3ckZhNkxZRFJtem9tc0FhT2VLcXhFdmJXYWNIUUIwOEprUkl0ZVNYaVNCTFlKT0xCK1g0eHJ6QXpZN3ZnZmQyUzRSQUtrRERnUHpORUFJeE1BU1NXRjM4V3Nna3VYTHlYVFJTUkNlL0RkdVNaTUJNd2U2T2JUZDhKQmoyNEFvdDA3dURPYlBQOVhzSXpVR0ZQczUrSkovTTZvVDRidXhIdjlYN0JlWThLZ09XRGcvWjU4R1RDOVhxNUZ4VFhPdzljM0NtNms1ZlBjamdiSGJnQWx2VkcydEgxVDNPYXZvcTZCbG5pWisxMm41dS8yc0RiT3Zhc3FvRmc4eDJMbmJjZDFHZGhTQWhYTis3cU1yQUM0c0E4c09SSjZ5SHdEMjh6K0Z0NGZkdjhVeXFVRHJEbUNFQmNwWjM5a0xTNmFxOWw0RDJyTGIvS1lzRlRQV2RmYnZoODZ2UXUyczFLL0sreklqVHNYSVZROWE1OUVnczRZNnNaZklBL0VjU3AvakVYdjhCV2NBaHhhQStTVmdTUUFrR0FNSUNjd1ZsTkxscVRjOUdidi9IQUE3TXJMNCtmMVZsWHdyVXE3U3ZDb3lHY3JyV3BHaHV1cjJmTkdZd004WVQ2N2hUM3MxTGFadnFuNU1MTTBiem1ITW1JRlNnZEZOai9tSUJjdDYzTmhGWndFekRzQkZncERQZWFuTmdBVGZDdEdzWDlUSUt3TnJnOXR1VmtobG5nN1RJL1lBclgxVmtYS3JFZTFsMlN5bk4xUkNzRkpzcW5RdjNVSU14aHdJUmpVNUFHTjlRVXRlVnozQlVBdmFodU5nakMzSHhMQU5EN25CcC9jZ09OWEY1d0N6OHhVREdnQ2pLUGJ2ZXZsemNLVUhIMmFnNmNuWXplcFlCQjlaaTJGeERKZGpvWEp2MVdERmlMSjZNS3FLWlV6b1FGVGZqMkhtd1RLY1RwVld2Y3hIS202a0tnb09SQUV2VmNsUEQ2TmR6TFhwTVQ4SVlOUGNMVjd5SkdCMkFWaFlyQUM0U05BNUF4S005cnlEUEU1ZnM2ZWVWS1dHWjJNM1MzTVFmRXlKVUtWOEwxWnBKWHBWSjlwTGlsbWxBeFdrVkpIS3dJaGpqRDlUdFZYVm0xSGRPeS9wSmlhTUZSV00rYm8wcldsNHlNMU43b1BoVEplY0M4d1JnQXR0QmpRV2RCQkdFU3dnU2lWMFBiOURSZ3UwVFkxOU4rTTFtUktoOG5pcUZ4M3JSRHNMcWpnbDl5YUdYVDgwdmNMMXduRTI1MlBBWkN6QUhRQ29pcW9XM3lZV0ZJdDY2NGZVcEthUkVyMU5QYWtINlhrdU9RK1lEd3k0Rk1Td2dVOEdTUlN6MFVKeDNWeC81dkZOYnJzL0VpTFJZK3Y0QUNJVHd3NmlKRW9kUUt3Qkl5QlJ2OXZ3aEt6VVc2ejY2VFVHRXdoRFMzZXpxdXNBeU54bkpuOHhhMUtSUFNGdHM5WWZGQi9RRFpjQW03OENuREJUNVU4ckNxamZjM3loOEduL2hHZC9Nc0tmMStRellKNDg5MUp5ZTEzaXkxY0FFOWNESis2RnBZckVraWR4RE4zT3RYUitGd0JHTWV6b01teEpMT3VtQXVENEo0cnhKcmZkSC9YQ29MR0ZWS2lVYncrTEFQUXFXV2FNTUxyZDYvK0p5Y1NJbTg1dzlsT3B0MWoxTXdBd0ZUaXFBV0VVeGVZSDVFTm4vakluVVZIZU1YUS9mL2pSZVB2Q2E0RGhUd0xIZkJjNGZyR3FxYU5KekxQdzZpWnhWK0hUcGxGR3ZaclhaVDQ1TjM5K0hXM1R1amxadjhENmZwOEhScThEdHM5WElPUjVZdGFrZ0JnZHJycnQ1UXNxOFNzZDBCaFE0SE13bVZpdEFXSEFZL0xiTERRTlFEYVRWSjhRNlc0cVZCNTFPT3FEWkRQVkIzVExPQmVwVzVqbXFhTGJlYzNqR2dCR01TeHZ2ZW1EWWtROUdvS0YxU2hVQ1NLQ3FCZVFydm1mVlpQQzFrZUJqWGNDbXc5MTF0VEo4cTVYZ09MYVFnQSt4L09kV0EyRUdaOThnYmpsZVRIZFFIUU4rMml3bHMzbkszL1poajNWZVFob3ZZemR4bUFyU3dRZ0RSQTNRaVNDSlVyVG5qZmw0S296UkNTQ0NlWW10OTBFb0pKYlZDay8xK0ZpQ3dGWnhMazRkUmZMRmlhNng4TGJZa0Q5djljWHRMRzYrTzRBWVFSZnJnUHlnVkljcXloVFhjV0ZPSkg4Zmgzcno3RUt3blVBcnE4bWNHd0syTUNDMWk3V1k3WmVuaDU2ZmVIVC9qRTN5bGlFNFRabmNkNjM2Z1BGQ0tXYXZHaGNSeDJKK2N2czlNbFN3MFR5M2NDbStjN24wRzBNRXhkVzRCTUliVFhFOVVDeW52eUNDWCtPdm00Z2JCeUEveGlzVmdKUHBYcnpMajRFb1JKakpJWnJXSEFyUzlpcHJLK0tjZWZnaXlCMFhWS0dqT21DbVc5eGhSVk1VU3lSRm5OZUZHRWRJMnErL0hGWGNsa3A5V3NBYmdURzl3R2owOENJNjRXeFJrL09URGNVQXZCSFhTTFF4Y1ZDRE1RU1dienYrMWU3V1ZieitrNXcydEp0c2JjQ1lWNldKWTdobUFzREE3cjFTejNPZ09nb00rS1RPSmJjalNJNXlHSWFORTF1dXdsQUFVL01GK3RGNS8wc0lnaFZMZFZkTTJTMGJTekh4Mk1pK0ZUeFhmOFg5MjVOQzRCeWNLOFF3Zm1nVlgxTGxjRml5a0VNY0wyQm5kSko3YVFmaWpLZnhMR0R3QWhCeU03YUM1VTRxd1B6Tnd1Zk5uTnVPSDRWWmFDUGxQbzJBYWhxRnFvUFZGYzE0Z2EybStXRUVMMGNBejlrZFByT21NdThyMW8vclRzWHo3Zjlvc3dGcytqTzZMQXFrdkMzR2dnNUZnNm13VzAzQ1VJNlgxMmg4bHlmY3ozUUhxcjNESWw2NERicWFRS2M5bUk4N1FYQUNENnZwSnFZMEVWeHoyQ0V5Q0k1ZU1TR1gyZTdWdEk1SjR5VFJ5WmhzY3J2dDFuUXVpdk9BYU5MbFlFU3djeVNnaVZicjM3QmZkMC91MzF5RWdnMkZWYWlQQ2VWT2d1cUFmR292MGlSMFI5SkFCSjBibndrOW5NeHcrZk9oNTVFYmdSaHpvenJCVUExcG9sTjlDTHdvazVIRUVVUUJqRk1RQjdEK2o2NTZQVytJcko4Ty9iQkNvNHNHRmRHZWpxaXlZQ3gzbUtlOS9KdFRpQnZtSTVPRmlUaXNnOUx0SkZGN2daR0RyVWJIS3M3OStoeXU1aFNhVXZoMWZvRnIzci82dlpKQ2lYZ0NEd1ZWRko3TVZtUkxzckdsdHVGQ2M2OHlGZEFDTURBZmx3UjRRTTNIUG9LZ0lFeHQ0Z3o0MlN1YVFiOGhCT0Uyb1ptbHUrS0ZsS1IzUVNzc01KeERQV2JianBmTG9KcnhHOENZVDhNS0daU1ZUQ3hZRlRJYjg0bmtDeENJUExEaWJ5MzBnWEZnaGFGNGMyUmVSNDY2VXUyZnZvRnIzci9mS0FFRnh2cHFNY2Q5eW9uSXJrdUs1TExWN01WQ00rL3VESkN5SUMySjhhMHoxaXdxeUVTZ01sMTVTYTMzUUtnbXRQRUJucDExbXd1WGdPNzBVZDRESFd6ZmdEWUMzekJFT2s3SGxBNlhLeUhRemI4SGdHb0NTUUxxc3hvckl5MUJ4aWU3V3gwckZhZit3cjlYdjMyQys1Ni83SGJKNVZIdFJZVCtHSnJzZWhIY3lhNTdQeUtBUWs2K3ZCa0JaUHBqUEVFeGx3VTU5YXdnM0MyNFc2S0JzQzZ0cUhSK01pZHlWRzNpM3JkQW5Bc0gyVDA5M1hUK3pMcjE5N01UQTgwaDNTZnNaUDJVcXBDclBRNDZvRjMxN1ZycGVpS1hUSjlNaE1Ma2dHZENhY0tHL211cFY5dzEvdm53eUdnQ0RDS1d6SmUzbHFzeXpMV1pXZTYva2Mvb0t6Z0tINGpDN29vbGhkQzRqaXV6TTBXUG8rY1BRMkFzWDFvYkZDVE81SnpuNTY2UHdiUmVpd25mVFdqSTRLdkRvaDFqdWgrYVQrV0tTWUQzaThBcWwyckprK1ZzVlFseTVra2RkdjJGdkhUNjFpY3FPN0ZyNzEvSWtMTlhPaTBGUWpWMDA0Nm9CeTZ3WjkyMlE5NUlDcURFYUw0WFd3M0NPY2Y5TXc3M0RGQjlBcUU2d1pBQVM4WHV6R1FJREtmK29Wa3F4dDAwdHRBYytZVDBQSjlxUkZTQjh4b3llNVh1MVpWZUNTZ0NMYllMVk5zd29uY0h4b2VMd0N6QkdqQk5raS80QlgzejlsWGdVQ3lJSUdtaG92YTgzY1JnTzVUZTl5TGdQM01mbXNCUzh4czgvVTY3ZVBRT3F5OXVtQlVydURjaHFvOHNIU2QzUE1mVDVpZm8rYWNrOGVGSEk2UUVjblQ1R3ZkT25WZFhvZitwdEorQlZQV2NlaWFSSEE4VXMvbmtBQ284bXpxbHFtV3JiRkRwcFQ1QTVVSVptN0NQQTJWZ20zUWZzRWQ5MDlrS0lxQjFxSkFLQ0JHOFpzdFp6M3hIT0FBaXdtcERJZG5nMW1hWlFBa1p6c0haNTM3WWZRcndOeXhvUStIYWtyblMwaDFtVUExQzk2VGRKVG1PUnloQzNvZXFkd1JPaStHRGhrRkk2YllOcmNOREVEZUFrWHdRaXpQUnBtbklzM09kcVpQU2FSRlVjYmNoSGxnaWU2YWdxMmtYN0RkLytkOGxVSlZYdVV6azhFUm1TKzJ2ZmQ0dXZOMlZPVjVyU3diMHkzSmhnSWg5d0plTjNZTVFDSWdSNzhRK25ERVZZQllaVXJVcGJYRm5NN0NPU2RmN040SVB2dERuVDJCWS9oOENoaDEwTVhRZVlHUys3R0dqYVFpQUJwdU5JRmlFQ256ZFdKTUlVSGNhekxwdEM3WWl2c0Y4LzdGZ0xGTXFwaVFMNVR1TmJLZkEvREM0NnJxcUFiQXdJS1dLK3RpbVJVQkVpTkdzT1FzeVFtK0dwamQ0bjA0NmhiVDg0S1B1WWpPbUhIeXA5MmdjZ0RTMk9vSXVWSWVoL3h5VWthVnd5RVdkTHJld0hFM3VCVURjS0l3bnE0MEhwRFhMK24zQ3piYUtkZ3VlbDVWbkZKbDJhd2FnaExRQlR6dGVaMGNqTHEyQTJuME02RVBoMnBDNTdXZzQxcG9MelpzQVpOc28wSHc2ZVZSL0o4YkY5WWpXR21WQ3BHS3dRTEJSQ2NyYmlTeE5MZ1ZBeENGOFhTbDhZREhIRlBXN3hlRkJSd3YvckdxT0tVQmtPRHpxZ2RXUFlBTTUzdlRBU01RdTRCeDlKKzY5T0hJRitONzFGMU8xZ1VCK0FzQmZGcUtDKzRXaTRCV1grQ1lnT1RBVTM2d2RNVk5WS2thM01vQldCaFB4eWl1a28zeGtTWDlmdkdNa3FzRGx6ekhDMU42U1E0RG9JTk9lN0tlbFdXVGhlemlPYmVLQ2RBUkFwRDFBZFZuUkgwNDhnS1VBbUFFWWk2T2g0REpWNFZvR0RXcWpxNFhMYk81bzFqQm9pbUVQaFBKbXd1OUZ2blRMZ2RnWVR3ZDJ3eVhiTXlSS2VuM2kyZVhYQjI0NUZsVllVcFZ4VXBHaUx0bUdCbHJURWhWVXdWOGRFa1ZLQXEzTUhKMXV6UmJSeCtPT2dEV0ZYNk1zWEpVLzM2bEpvRW9BMkFLdnc4K3V3VEVESUJiU3RkT3M4ZGREc0RDZURvbTdaZHN6QklzNmZjTDlyb3IyQzc1VVM5SXhKSnNFc0hkR0ZCaWw0eVl1VXdrbm9mSmdGNFhjRVVmanJ6K1g3ZktvNEVKSi8vUGtNT1JPNkZyVmpRTWVMNWtKaFpNTVh6THdOWkN0MW56REZnWVQ4Y1F3cEx0NGhET04waS9YN3lzNU9yQUpWZTBTL0lTZ0ZZN2o5WnZuUTdJMytseXFwWWFMOThDV3AvTituRGtaZGhpNmJXOEFuMWtQM2ZSVExLVldsd0Y2UlpDSDJMNHpERFIwazFJcWVUTmIyT1FTWU5iT1FNV3h0TXhlcXRrWTZJK255OVZFejZidGZiN3hjK1hYQjI0OUFvWHY4NSt0SUJWZ0pKNm40bGY2b1YrbWZqZERKTk1IMHdBVkZYOTBHTWsxZjVUeGxTM0ZnZ2g5MkR5TjBJT1J5NTY2NUtJZkNrdHNsK0szVnNHdHBWT1dPTWl1RENlcmxTbmpRMnJCK24zQytwSUJkdWx6OHdxb25yTlBMS2d3S2FDNUIzczUzcWhYVnE2b0ROZzZzT2hxdnFoRXIzVjJWTkxCam1uU1NOZHJPTEoxemtBdTZWUFJqRmNGejRmWERKOGk0NWhHOTRHdDNJR2pPRllBOFRUbFFaL3FHSDFvUDErOFp0bFQxTUF0SEs4bVFnMjV6T1pVU0NMSWxpV2Nidzh3Zlc1TG4wNHNzcW5IWDA0ZXVpQ2s2LzNkZTY2TVBwdUFRVlpBRUZrdzJNS0Z3NmExd0VMNCtsU0J2bUFPTWhEOHZrT2tGWDc3ZmVMTncxNFlUL3NzbWM0QTZvT2RIQkVrd1hsZ2pIMms0TmFsNndCNGZJdVg5THpaakFtb3JOZUhNbzVUYzBPZXdId0RUVWg5SFh4ZkdKc1lrQWJBQUFnQUVsRVFWUy91dkNwb0FjZXc2ekJCcmR5QmxRd3dvRHhkTFpXWExERmtIeUY4eEdFL2ZiN3hSOFhYQnlBQVZDMW9CMThIUVlJVCs4dUdmUDc1U0NVczFvNjRoZTh2NGo2Y0lRK0lxa1BoeHJCQ0hqZGpCSDZBYmxRa0FlWTFvbmR1a1NpRUxtc1VQcGpieXA3WHV2RGdBWHhkTlpWdldDTElmbUtnNkJiaHJqdXA5OHYzbFZ3Y1FMdzhncUE1djl6QzlqRXJ1dGx0ZzhnTXhEV1dNQmFNVmttQU5XRnlFVjZSMHVIMkkxSXpXN3lwYmtRT1RQNWYyY2g5S3NGa3dwMGtRbERBT214ekhwc2NHdUdBUXZpNlZENFJnbUFnL2I3eFpWbFQ1TUFUTlh3cVFjNktHd2YyVTJ1R1YydXpnM0Q0dWE3ZkRuUHdaY0tnSWRxOUdhSUJQWmIwWWREN2hneUlGV01YaUgwZVE1dlhTNUhjTWtjKys5bHoydDlHTEFnbnM3S3h4WnNDa2dkdE44dldEK3ZZRE1BVXBjamE3bE9SOWVMVmNJUDR0Y3VvYi8zQU9IQ2RXMDJWVFg2MkFwQjRNdjF2MjRnblB5OUhpSDAzZkozNjZLWUhZVEhzZ0JCZzFzNUF4YkcwK0hMWmFPcDY1aStsbjYvWU01RXdkWUJ3R2oxY21Va0U3KzhUSExOZEFIaHdyVU9YdGNyTy9wd2hGNGNjdDJvTjY4Qk1EQ2Ztc0pNL242UEVQb1lQcDhiSDNrQ2tidGpqaTJ0SkpBOTYyWUFXQkJQWjBXQkNyYllzRm9PZjlwREFpRU5rMTc5Zmt1dmY5blRYZXdLY0JTanNuN2xkb25XYmdRcHgrMjZvdGFMSXdBbGZpMlFRU0pZM1lqeTVpOWRtc0ZNL29FRE1NL1o3VWYwUmlZVUE3SitUb05iT1FDM2UwV0JCbTlxTGFkNkhJQ0cxWksxWEI1UG94bnVPT0ljeFNYZS9PZjh4SFYvUCtGcHdONDdnS1VwWUhtdVN2ZTBwS1pnQ0tTcTV3cW5pV0UxV1p6L3hvdUJtNzRLVE13QkkxN2xWQlh3dFdTcys4L3ZMNDVGZjN2aHBjQW52d29zOGQ0OERaWDNNMmh4OVhJQW51MElJTzBjaHUzNUFPZ0xMMHl1Ry9qT213YmcwMjhHL21OejFZV2RFVGJtNEk1QnJGbG92K0V0RDJ3SW83bCtBdGc4RDJ4WTdpdzNWNWRpRXFPNTRtbmo2WGRNQVljVSs2Z29uN0EzTlNPMnFGamx5WllEa0FYNnVENUlhbTQ0WWFVZlZORE54YUpjTElQWGNHR3BmaTZQblpkVkQxd1BzcFFCWC93bDRPYU53TjZKcWcreHdyeHNsY1ZGdVlKYmxlaGtjWVlaR1BTM0wyMEJ4dWVCY1M4bndnNUg1a1preDZUUVNiWEZaY0NRS2FkeDVDejVtUHVyQUZ4clJhYTE3cEFSMlBGQytFbFNIS1EvMFFqUWNnQ3lHeU05djNTbnNEQlJKZ0w2bXNXQ2Y2SWZXZVVKYWM4VUZscFk4NTAwRGNDZnZnYjQzaGl3Wnd5WVZoZDJEL1ZTcktHQW1JRG5Ca2lhZkVjTjljcHJIZ0tNemdOalMxVjdyUmpSbGNleXJxaWY2S0FrTWdYSU0rNnRBbkRsK3pTTDM2TzkrVThwOWpHSFFvMjg1LzJYQS9BblhlTm5LQW9yRFhIL0FJTHdiU3ZMRXo2UWwyK2NBZi8zWGNDZHc4RGtLSEJ3cE9wRmJFMndhZHpJZHloM2pqTlFpcllXRXdZcSsvekp3TWg4cGYreEtOU3dNNkRaTW16TlJSYk0ySysySWk2VGxGckFXZmQ1VjNpL0Y3SWdUMkxCRjVMYklka3F4TFBXdnR6bEFHUTNScFUzWTdBaWl4TXhMT1VCMnQ3cEtROE0wcUNUbnA4SGtvakpnTnFhTUVKZXNRdjRBUjNJdzhEQjRRcUFzKzZTV1JpcWdKZ1kwSFZEQWRCQTRCYTR4TjduZGxTRkFBakFZWDRJUE81ZEJETUFkUzJpK0p4N1hUZjFlRWRURGZnQVFuUjM0cC93UWtSbWpOQW9CeURUL3VnRnBoWEFtakFFbjhxYVBRQWdaQ3MwbFNja0NObVZpZ0ViRk1zUEJCRTNEY0JYN2dMdWF3SDdob0FEN0VNOERNdzQ4QWhBVHJqdFF3aVhvcWtURXdXZDdMT25lWE5DYno2VGlxL1RJbmIyTThaeklGclRRYkdpeTkyb0d6N3BYbC83anZkQUpuYjI0NzBJYkIzVDc3U2FpK2h5QVA1dm9UcVc2c0t3RkFjL1RBZGM1KzNkdmNzVHJ2UFZZU0s0U1FiOHhWMys2SWFBcVNIZzBGRFZoM2lPSUZUSUZ4dGl0OW9yTDVaL0xEMVE0cytCOE9uSFZ1WHdoaGRkNURvTEdzZ0NDSjA0cTY2WC9KdS92U2FlQXhEUHZiZHRtZHRLRFY5MGdWRVBJbC94eVNrdmlPaG1BRWpybHpTa3dqNDBTbFFaWVozOUkrOEpCTXg4bVpyeWhPc0t3cVlCK0twZFZTREZ2aFl3UFZSOUJEN3V5WDRTd1JTNTluTkkrYlJjay9EekowNXYxMk0wblk4ZkFrOGlXTDVCQjVxQVNQR1JDaThFVmp6djNtcXBrQzlBQ3Jyd2hLdWtCNjdHaHBxUlJvd1FNcUNpWWJqOG9Pb0hlVVdwZFlJQkFVajhjOFdqcmp5aE5JSjF1bnpqRFBqcVhkVWpKQUFQOFRNRXpMWXE5dU9ISUNRQUxlL0V3V2UrUWdkZEFxQ3p6RDgrdmdJZ2cwcXArNW5ZamFEekNnam1uQ1lvbmUwa2xxUDRKU2d2dksrNkxvRlBvRk1sa1BHaCswclBXdGE0UkhUTkpKUXo0TThFQUdvTlRQVlU4b3BTNjRDQzl6b0FXVEZDaGNxN2xDZGNoNnMzTDRKLzJRRklFQktBMVA5bUhJQm1oUGgzQWkzNTRSeUFBbVdzUi9QUnM2dk9SOFo4Rk1QUzk3eXh0SWxZZ1ZCL0k3akMwcklLU2ZMWEYxRUVCK0JGRmpRM2pDTEE0OU9Xc1JUVEVQenZ6UUV3cnk3VnJaNUt3ekFRQVBzc1Q5ancxZGNIZ0NyT1JRQ1MvYmduKzFIc0NZUVN2ZWFIa3p2R3Yxc2NnVS82UjU1WTFZSXhodk9tMUVaZWtRV2w4d1ZEeEpnd2M4OFFpSmM2QUtYL21lSERhd1g5ejE2TS9FbTdiTzhRMDhHQlAvakVrQUVWak1Cb0FGV1hValJBM0t0TndPQlhXM0VrQVpockFMa3RwQzZsS3RUVjRPVTdSSEIrM2tIV2d2L3pybllabDJrQ2tGNHVGOE1HUUdjK01xRVlVQ0EwbjF0a3d4Ync0U2NIQUhyNzFRN1c0KytjOGN6d2NCQW1IVkIvYzdCY2VrOWIzRnV3YmREL2tqR1dnekpqUTN0aEdtVkEzamhmT3lVK1J4QjZGYW1PRnA4TnJoc1RnTHk4Q3B6bTVRbFZwdEFVKzZDaU5nWENhSVEwQmNEWVY4YjBQNHBpMzB2Zkl4RDUrdzcyQzlhbGllZ1c4TUh6cXJtaC9tZXVGaFlpMHBLYnM2RDlmc2gvbjFYRk1yWU1iUGdVQnlDWno2Sit1RWtuREE5QW9ybldGUmIwMVdaRXNBQ29IaE9xeUM3d2RldFQwUUFLMktxT2I1TUNVdlB5aExFMG9ReHpxYVlOWEw1eEJ2eVZYZTEydkJ5TEFEalhBdmd4QnZTUEdGR01JakNtSmJFVzhIZm50eHRRbXhUMGNteHA5VVBBZEtBWjF1cEE2RUI3cWdEbzZvQ1V4WFJ0UFZTcEF3SnBuVWh1eEFxV0NDWUsxTUJFeFpsalk1UzhTWXIrcHhBRkF1QmF5aE5HMjZqdzh1c0NRTFgwU0FBa3d3Y0FFbmd5UWl6YVhvemlJbGkrT2U3LzlrSnZOazFMbUJNZTlFQ08zWFJCN2FQZUYwRVlITlZQZFQ4Z2owMTZZQmNXdEJmQlZZSnV6N21GN1ZnR1kvcE84ZjVXZFExLzdVNjduSUtOUzdqMHdJYkRQRlpzeU5ISFk3b2QveGRsRUhqOENjQzNUZ0NXSGdHQVBTeGlTZHQ0MzEydS84U1BBbDgvRGxoNHBEZVpXMlBENEoxYzkrdXlEYUlEa2dFSlFLblRmRy9OOG5VQW11NUhVbk1XNUFSYlBmRXVJSHkvQUNqUks3Rkw1cE9SNFJheGdUSG9mS2w4ci9TMVpXQm5BR0RLZWZibjNBRklQUlBYQjdzRmlWUWltS1ZnR2RsNW9vTndMUTEvMVUrRFFHU1hROXI1RXZ5MXE5clpiUDFsR1FEWnNQcHpJOEFQSGdYZ29kN3FVeDExWXRCYkZ6QysvQytCTDdTQVd3aGdkb0xrT05TTHF5NW9Mb2dZZnQzWkkxRjdFQUMrcGhzQW5la29raFA0SEl6bWwvUHZ0aFFXbVBCOUxKN2p4a2NTcjE0aldqNC8wd0ZsZ0pENWVvRHc2ZmU0RHpBWVBIb2tXaEhKWjNURlNrbjRoN1lPU09Cd0V0aU1UdjFhWTB1a3RGWVRtSTIvNDNFTVFtQ3VBSm1VRTBnbVZEOEVGZFBwZG54aFZocXpEcjhGNE5NdFlNOUpmZzk4RVZUZU51OVEyT0ZaQlg3dnI5dnRnbS9sY2V6Y3paNjFaTk44REN2aWxZQ2RQWHFORFFwQWxmR1RLbTBNNkFBMFBUQXlvTVN4NjRjUmZQUUhYc25pT1RJK2ZFV0RGR3ArUWI5QmV5U1JCVjJrcGwwUXh4R0FsSERta0k1Nlg2eitFUDdVRFlTZFJnaC9Jb3V3SVozNmxIYWJCRTBHSjByMTBSZ2IveEEvdHQvai82YU1BZis3UjRDeHp1QlhXUkdVTHdCZklyWTZVTmZwdkxhZTduMEkrTE8vcmVvTE1xaVZNYlczOG9VaGtOa1FJelpPN3RJd2VHZVBjbVdsQUZUakFZSFBWR3dYeFdvTFlibEVEa0x1VFQ4TURQaFhMSjRqQUxwYUpCK2dnVTZ4ZmdKa25UN0lLWElRWGg0WTBGWkNvZyt3eGlVVHdTa1hVYlNNVjFyQi9BMzFPWFd1RnBQVWRhL21SSEtpMWU2VStoQTdacTdsK0ErVUFmRHRIZy9McnB0a1FwWjcyN2NSV09MOTU0MlBhM3JPdnVPcWFnVWx0Z3RtSk0wOGo0L1BJTGJJREt6Nnc1UEFIc2JyYVRuTUdkWldJd0l6eElmZUswcm41NzhKM0xBVnVIOENPRFJhaFYvRkZRLzFJdW1JdlhQMVF1ZE5meU5UOG9WcWNIdmlQY0JkNDhBMGcyUkR1b0RxSGRiMlNhbFpBZEc5ZG5mRGtBRTBnWG5INWlqV0NEYktDcTUvTVJpVjBRRDhIZ0hRNjNqRzBoZHNMR3hBM3g5QncxQXNsaTdoTzNCd0FwZ25nL0dqdnEwMUlIclhKN3EzQ3o3RSsrWXppRjJyczFaTForOEg5akpzU29FQ1dYajZpZ21SODdhTGdmYkdxNEd2YmdMdTJnanNId2RtQ0VJUFNJMWgrU2tDUmpwZlVDM2lOV2Nwb1JyY25yWWJ1R3NVT01CbzdRQkN4U1RHL2lneFZjQklWR1BXTTFoMUpZUVBueUtORXhHWk1ESUo5YjY2ZUVCR3hQRFkxWTVuditHQ2pmR0F4RCtERHBpYXdwaEFCV1pQandOek5MQUVJSDRYQ0gwTTcvNWM5M2JCZkk4WWsyY2dWQWR2ZFQxMGlmRGtCV0MvcjlsR0g1MU5oSXNuc1dIT2ZQbUVVS1Q5NFdlQUc4ZUFPOGFBZldQQXdWRUhJU05RbEtRVWdsSmpKRXhxQytINk5xOTNrT3BVZzlzemJ3THVIYTY2UXpGV2thRmllWHhpNmhnVkhPTUNZR1J1Sis1VjRqWUpJREtJOUtsc0F2RkRxOFFEcm5iOE5XVlBoOUV3ZEZrUTc5VGxTTUlzTjBNaTVzOU1vT0dubzRVNmYzWUF2ZWZMN1k3cnZkb0ZMeE9BTlNBOGY3eFNnV21kMGtDUWJtWjZtVExFbkowVXFXTGhVa3hsckJuNm4zd1d1R2tZdUd1a0NzdWZHcTJpb2puUkZwYWZzVTdNRHhFckp1WmhZQ3NKb3NIdFdUY0JlMW9lcStoeGlnSmdYQnJNbVRCUG5KS0xycitWRUQ1NGliSFl2Wm9zOHNPK0ROY3JIckRYOFlWVnlnbEFLdWQwTHRNakZQdE5NejZRTERZN1ZvbUxKZDY3MUFFSDRYdSszZzduV3EyOElTdlg1OC9oZ3VPQmc4dnRGUXZWL2hFenhmcU9ldnVUZnBqcmk4dkFXejhMM05ZQ2ZqQmM2WllIbUJjaXRuRmQwNnB4eWI4VzRnUGxnb25CcWZmVHRkVGc5cHlicWlWTkJzc3lVc2RVRDdlR085YW1uZjNzWHR4UWlwbDdXZy9zRDRBOEF3SEl5Wk1Za3k1MFRwL3hnTjJPTDh5MDUxcXcyaFh6d1JDRWRUMm5tY2sxUnhIRyt3NWplTzlORlFCcFI2bGRNSU1YbEZXZ1ZuZHFGMmRWRnNKenVPZ1J3TUVsQjZEY0k2cnpuZW1EMFJuYndRaVNSUzNnN1ordFZJbDdQQzlrYWhpWVptNklpenVMaWdsaVQvVm9Vb2crcDhQOWwzd0o3cUdFYW5CNzdrM1ZjenJvVVRvV0xDc0FCdWQ0eXBhTENVb3hmOWkvOXc5QURpSUNVTHJRUld1SUI2dzdudVpyd2Fad0xCR3dDbFNxU3l6M0FoSGJhUkdFRkdPbUM0NEQ3MlVWZ2pXMkMyWjRsSUY0QXJqb2RPRFFjcVVHcUF4ZmNwRzRtSlZ1VnFjTDV0YnMyei92ZVYwdFlLL25oVEFxZXNZTkhkTzVQQ0pab3MrV3V6eEhKSVZpdVhGeUp4dXBOTGc5NzZaSzJsaXpVS29kaWxHVWd6eUdob2tGOHl3NU1mK3FSa2pkamZ1RHR3a2ttN0RUa05hQmFRMm94MXEzZU1EOCtCNk8zSDZlbThLeDFDY3g5cHRXbDlpWUlVQUFXckkzSTNuSGdQZE90c081ZU91eFhYQmRqMFYxdk9ML3NvM0N4ZWY2MHRsU3BZd3ZlS2YwcEF1Nm9oZmRKOGs0Q1VxZ3ZyNWpWNlZHVEJLQUxlQ0FoK1ZiWkxUbmg1Z3U2RDQ0QTZIOGNWbGtOSzk1TzFXa0JyZm4zMVI1SFN5K0pDd1BwbEF4UmVnRS8yVCtBbG9HbmNObWJReW9nVVF4L0t3QjRnSGo4WVdOVHdSQU9XMEZJSUluZG9xTmtUQXh6L2JkMDlYREdMQmRNTTYvcExLaTV3aEFYNjBnQ0sydWp4ekVBcUdMMnBRMUppczVBSkVBRkh2VHVqWUFLalJmK1NFdWdtMWQyQ09RTFUvREF3UTQ0Y2FFdzhBdFp6U0lQZ0F2dUtrZHJXTU02TTd4Q01Cb2lCbjRZcENFMk5DZnhXQUE1TUV1d3ZDQ0VJQ3dsbmhBSFYrWU9SZkRzV0pHZ1BwTUt3ZzFiOVFwRm56SGJEMkJLMkpHdWw5czhLa1lXMTd2TEFMUVJUQ0JwelhacFM0Z3RDWFhNQWtkdXVBeThFN1BpalBXcHJYSjVDUjM4eWd3MWZKRG9oaDJCbFJBZ3EyT2VON3VUV2MxRDBBRk50bUw1NEVTQnNDYUpjTGtEYWp4ajVaWFJpQ0lHQTB3YUR3Z2p5OHNrNStIWStYOXBwVWJKU0NwNlRuRkNNWHdueTFXQUZROHJVQWMyd1VyUkw2bVhUQWVmV25GZm56M0ZwYmFnUUtMQXFBem9aakFLa2twWGtOTzVHQ0V2T01MRlhPbm5DNHhJS09qblFHTmRXU00rR3FIUUdkN0pTc3hVZitKelFMd2hUZFY0amUxblF2cjFNa1BHdGxmOXlQMkR5K2dBcVo2clF5dGZ2ZEhTRHhnTHdCRjhBbUFZakhXbHVFRGlLR01pcU9WdnRlalhUQk91UlNZSndESkFBUmdaQUdXTDlOaytJTTNTemdUeWRFNGVlYzFuWkhidERhTkFmMURwZC9TTXgyRU5ENmtEMG9YdEZoQlhtY1krT1k2QUZDaG5LbnpsN05mZE1SM3FDQWFlMkIrVlZNWVhBU3ZEczMvWC96SEpaY0I4NHZ1aXFBQkVvMFFQbmhud3FRTHlSVVJtWkJQeXRud0hkZTBNMXZOMmxSNnBpY29LVUxheEhESUVkSGtXMmlXZzQvN2I1emI3RFNRQVZkMC9ncmlWMkpZb2pmcHdSR0VZc0dCck9CbXgvT2dQNXNBS0FOa2NiRnpOV1RSblgvR1NHSW1NWUgvTFlsaytnR3ZkVCtiVytTV0grSWcxR3FMNVFlVHRSMkVZajVMVkhmancvWkR3TDh5SjZUQjdVVTNWVm9UalRZeFlESytJdnY3ZHpOQVpJeHBaU2lVOGpqS2dJV1RjeWtaa0Jhd0RCQm5RZE1yNVFlVEtJNWlXQ0IwOUFtRWI3K3Vjbk9RL2FUUFduNnd1enlTNHUrUjBPYjZDVUdxSnBJREE5N0FkcUlOYmdSZ0JKNjlDRzRKcDZxL2NralhxQi9SS2xhNFdwa08yT0RnSG95bmlnQTBKaUx3YU5pRXQ5NVlRS0o0RlJDKzdickt6Ukg5alpiTjZpSll1U0htOUk1aU9BT2hITkpmWmtoK2d4c0JLUGJMdTMrSmdhV0Rkb2poTU81a2tEV1NsTlRnNEI2TXB5SUFqZjNJZ2dKZ01ENE1DQVJqRk1VOVFDZ0F5a2hTS25VQ1lIQjlKQjB3eTVhVFJVeG11cDRoK1ExdUFtRHMraHBYZ0ZMbkI2VUxPTk9uNXhBQ05KcXhnaHNjM0lQeFZCR0FpUUc5YUxlaWxXVUpXMUZ2VlhFTjBUS3AxQzZBdDE5VE1TQ0JwejFkSHRUL0pIN045eWF4cDZRa0Y3M0tCeFlJcjEwbkFNcHJvQjQ0cVFHVGo2c2pVcnRPRlB0TGVGUUhMRVM5QWRERnJxMUU2TTEzTWF4VkNUTkFYTkZUaEl5bExjb3I0MHp4dGdEQVBLdVZ3RE1yT0t3K1NCVGJ0UjJNTkQ3c1p3QzdRdm00d3FIYTRUL3VJcmhiKzduMEVnYlFkVGlqb3lnK2FnV1hUOGxsRHNBRldyL0I4cVAxSzdiVDBwdnRWd0hoVzYrdDJDL204c3Z2Wmxhd2kyQ0tlMzduaEZ0YXBrRG5JTFJxQlFBK3YwNEFqTXluNzlFSWtYTy9Ebnp5Q0J3VndlWDR3eHM5QjRyUlpneVBWRnF5a2dEZCs1SlNwQlU1cjB2SHlIeitqc2MzdWIwS0FCc1pNQ3lRZ2VFeEt5RlBWSXozbG1jTTZPZlBBR0NBRFlQRTY3SmZzNmg3RzBvK3h2aTdveUs0Y0xaZk9ncHNYd0MyTHE5TXd1dVZFUm9uS240blNKcmNYblFLY003ZHdNTVhnWWNzVnhrU2ViSmd6T1dQcWRCMWFkMmYzZ3BzbndLMkxYV2VSOW0zZGFuVUlWMWxCU0NQQXJCd3RwKzdEVGh1QnRpNlVEV0RtV0EvRHZYazhMUnB0ZlB0TlVsaWhZWlRPUENpMDRHSDN3RnNud0dPVzZpQXM1bjNHZUpKK0tMb0UrOVZEQ2xROFI2dk9RSFllZ0RZd3VZM1M2SC9pSjhqYjExY2swcTlRaG9jOVFNV2dQQlpKd0ZicG9GTjg4REdSV0JpcVFJZ1d5SlkzbFBvemFHSjFLVEVQaDM2enBUa0pyY1hQUkU0NFM3ZytDbmcyRGxneXlLd2FjbGZGb0l3dkN3eDlabjNRMURtSVB4LzIvc1NhTXV1c3N6dmpmWHExWlJVRWxKa0tzQkVHUXlZaEpDQlNrVXFBVzF0c0JkcHV4RVZhQnpvd1hacWUxZzkwRzJMb3RqUWRtTWpLcXRCeFFFUmRBV1VBa1VsWk5CR2tRUk55SUFFTUFreHBGS3BxamZVRzN0OS8vbS9jLys3MzdualBxOXVWZXFjdGU2NmI3am5ubjMyL3M2Ly8vM3YvLysrVHowZG1EMEt6QzRETTZ2QUZwZC8wTDNHaDZ5VERnbnZMd0t6QVdER2lIL1RoY0MyT1dEckVyQjFwUmdRaXNJUWhBYStBRUQrSEVFWTZ1Tkx5clJuWkxTbDZ0U2JyZ0xPZUJRNDR5aXc4eml3ZmFWNFVHYmRlZ21BNVFNVExGbHFzZm43WGVjRFcrZUFtZVBBbHRYaVhua3VaU0JrUmNtNFVHWHRVMnVvM3hzQVpnejZ5NTRKek13RFd6a2dCT0FxTU1WQkNTQVVPYmg4UXVOL0NpVGdjV0F1eVdoTDFhbXZ2QmJZK1ZneGJXNDc3cGFhN2dJQnFDblVyYlVCaVF1aEFLRFVvdDEzSWJCbER0aXlCRXl2dE81VkR4dnZWZnhXL0prV05GckNlSzhOQUdzWTdCc3ZLUUM0aFFDa0pOYUt5MkxSSXNnNlNKM0lRU2Uxb25LS0MyQ3NPWU1lTiswRHRqME9iRHNHYkZzRVptV3A1Uzc0ZzJJcjJ1QTIyQlNjQUpHQStkSkZ3UFE4TUwwRVRBVUFrZ0RUUHE5emRLLytzTVdwUEYxOU54WXdBNGczUHRzSHhBRTRTUUM2RmRTZ21HV1JSSUpMWkpsbDhFR0tqSGlYMWp3YU4xMEh6RDRCYkQwR3pDNFdyc0tNVzJwTm9iWm9DdTZDTENEZkNUcXpnZzZzcit3RnBoYUFLUWZnWkhLdnBSU1lnN0hONVhDTDJBYkFad1ByWkdhajZpcHBYaGduMGtxbVUxd294bkhlZGc1QUFUdVdIaWcyRkUxdVZSd294b1grV2NiZzg5UzNBcUNLUE9OY0NpOG9QdFZQKzkrK0czaitvU0syeFJCRkRFbFV4YlRTKzNudmM0RnBEc2p4bGxYUW9KZzhGZ2RDUW9HSkpUVGljTGNRNnZQTDZ3Ymc5Y0RNNGNKdjI3b0F6RkE1a3k5L1VPU3ZtZzhvUDg2bjBkSUNCbjI1SndqQVJXRFNBVWdCSE42dmZkYnYxMEFiQVJoOFg5MXZETTJzcytOdkFFQ0tQVkxDc0hveVVnUnFybGJuUndCOTMzT0JjKzREWHJJQzBJRW1pTG5FNzVkaThIc3lBY2p6V1VWR1VpNnVJQ01wVnd3SlZNWGRlT2szWEF4YytIbmcrdlYyZXNBWXcrc1dvUDMxcjNlTGNMd1FCZVFVckVIaDRKbzJoNHZEbUpQdUF5TUxHQWVFbjd1cWJnQitJN0RsU1dCR0N3ZTMxR2I5YUwyMGtHRGIvRUdSeFk2V1R6OGYyd3RNOGw0cGdMMVNnTThlc0hDdnN1eWxNRTRubjljZlFMdGxkZzZUWjBrVUtvckFmaWoyM3ZBUENtcXAzZmNDbDYwWEZJTmlkMVBsWnJmNDEvZG5BcEI2d1NRanV0VWZJREpSOENHSVFPd1dFSDdEeXdwS3JXYzhDRnpxUkxIa1ZZckIyalMyRlFINXZrdUJ5Y1hDQWxJVVVBQWtDTTJpUkJBNitBUkNlN0RqWW1RZHVMWVRsZWlRL1hUVFM0RHBJKzZuTGhaVzJuelZDRUJhTUxkK3NvSUdxakQxYW1wZHVnaVlXQ3BlQktBOWJCSkM5QWN0QWs4TEVTMjZTcXNmdEluTFo0NGRRaWY0SWdkaHltNVdMclBEeXVZSC83SFRDTndEblBrbzhMWHJCY2NqUWFpb2U2QmlLYWQzK1FZL01HVEg2clMzT0J2Q25RRHVBSXlxaGlEa1E5UlgrMjl5RTNvbjhJd2p4UVBJOHprVGlBcEdVM29Wa0QvNGZHRGllQXVBZE13NU1GUWpFZ2cxRFlzVWt1K2EzdUkwVEdCZlY3UG90d0h3YU9FbWJIRUFUdnVESXV0bmk2VUFRb0ZSSUZSWWhmZS9kaEV3N3RiZTlPZjBTaTFnOEhrcndSY2V2RGFqejA3Z0lKN24wNXJZeVdJcGI0eWEvN3Z2OFBSZEZwai9MWERta1FMQW5BNGpDQ09sVEJSTi9yRk1BSktna2tWSHBHVWp5U1NCU0ZlZzcvYXpxazhFZ2JTRXE4VURSQUNMS0RYU3lhUTdCci8vRGNBNExTQ3R3bktoVEVrUWNtQUlRaHRNK1VhYWpsMHVTOU5hdElUWFd6cHpmY2ROQjREcFkrNm5CZ0RhQ3RhbllMTjZmQ2o0dTFheTBRSXF0TUwvRVlDNjF3U0E5dEFKZVA2ZVdzQW9EeXNGcGcxZUIwSElRUkNJSWtWZUNxUWYvMDVQM1dDQitVUEErQ1BBenZtQ2FGV0RLRXVZY2wxeU1OK1kyZGNrcUdUZUhQRXZ2V0RTTmhPQWZiZWZYMEE2clM4Q1V3OFg5MDY2YkZJZmRxTUhKSUQrK0RKZ0xBQ1F1bXljM2d5QUVZUlJLRkNMRDFldTVPRExGNlF2WGVkeDB3M0ExQnd3eGRBSkxUWGpkOHNlUW5Hclo5YlBGeEx5QTdXSUtPTjYzdFl0Q1FCTi9zdjlRUG02QmtMcDB2bDl0L202aWV0UjZmYnlCQTRnblh0T1J3UlJwTm5UdFBwVzZnV0xIODNsS3FjT0ZURW5EaUt0b0h3eThSTkZocmVmeWV6dGJuckJmYldmZ3R0c1Ara0l5TzMyRUxEMWNISHZJbnJsdldzNlRzbkI3cUFVbGcvc3VGdEFXa0U1NXpZUTBRcHFjQUxvTkNYVEV0N0EzS29hRHdHUWZxb0FPRVVCYTdmVWJLY3RsdHdDYWpWYnh2U2l5dm9hc00wQmFCS3d3ZEtiOWZON05mY3FCV0dpU1d5a1dYRVIwdW1lYWNVRW9uUWdDS1JmSWdERmp5YTV5cThXZnNmczhkWWdpdU14Z3BBZy92bk16dTZtRjB6NlpqNUFQZHZQUWVjMFRFb3NudlFvc0dPaGFMdUlZdm53RVlTaXRoRTUyRjFYRkFBMHA1eWlnRDRvdENxeWdGS25wSFVwTFlQME9jS1VSWXY2TWo0TU5SNDMzUWhNMGdMNlFvbmdhd09nKzZybDlDc3dLb1NrRUl4UHlUc3VBUGlnQ1lCbUFYVmZZY1ZmK24wU1JZdzZkUDFZd05nSHNnU2FqaUpQNDI5UnJwV09NNmN4RGlKQjZOSU5NNHc3TGJVR01RVXdCL005bVozZFN5K1lWRzBFb0JpREJTVDVkZForUGtDc0FpSWxRWkRhM0xWYXRKMFdYRzJQYkw5OEFCKzRvbUIzb1AvSGdUVWhtR2dCZlJxV2YyVFRyVVNqRXhEU1AvcVd6UURnZkFGQVd5elI4cmtGdERBS1g3NWpvNm5VZ3VaeFo4TkJ5SGJ2dnFCUTM2VDFzd2NzQmFCQUdHUmc0MElyK3J0OVdVRGhRNVpBVTdFczJlOUxMemdscUhSeE5rYmV1VytvUVJSbHM1amFNam5LMGE5ZWNOZjJSNExBd084MjlrUUIzTFR0RVlRUFV3elFBV2dXMEFHbzhBUUgwbGpwL1YxN3BtMEtSY0VpZkd1Tk9ub2NPMXJBQ1FiS1BYaHM4VHROd1ZyNXVoK242WmYzd0RndTI5ZzJGZE10T2M4QjZQZHBGajA4WkZycGx3K1pBNUZUdkFRUTAvQlQzNkZQRGtScUJUOUphZzd4WWxRSXRZMGY4OGo3OHNaekNjS1BabHJBUWZTQ0s5dXZCNGg1NzdTQ290VWlFSjhvcHE4SVFGbC9QVUJQRW9CTHhiUkU2MkxTcUc0ZEZCOHI1YkhjT3RpT1FTcVQ1VDdSS3pZRGdKeCtCVUNDVHhaUUN3aGFRYzlvS2NFbkVCS2tuajVGc0oxTEFQbzl4b1dXUFdEeSs2SUlvcWJlYU8wVkErekhCMHp4SVFES2tuMUdndFhpUnhNSUF4MFZuMERiK2xrdUZqTFJDdDVXRXdENzFRdnUySDVPZmVrRDVGYWNpUWF5L0dJYkZnQlhyaXdBeUdtSkFEUjFjazNEd1RFM1RRNEIwTGV0ekJKRXJUWUFyMkJCU0kzSFRTOHRMS0JaUG8vZldRRFpwMTk3WjNzY2pHYjVCRHAvTDMrbmpNd2VCNkI4M0dqOXdqM2F0T3NQV2luOVdnWENGbFZPLzNjdGY0aUQ4WGtCa0g1VVNsQVpsTlBaQVFxQVJyNXZ4dTF5am1IMGdpdmJYMFVRS0k2M28wV3VuL3hIdVI4RTRWblBLNUpRTGQ0Vk50dFRCdksydW9pS09VZi9mK0dqd01OQmgwTk1WNkowYzBOcGNSdjdtcll2M2toOC91SHhZcCtiVnB3THAzUjdzdHMyWXpvdVNxM0tHYStxNyt4N0NvNG5hekFlclJLc1ZsVjFRaXRGNTlkeXlGWmFZWTBITXU5bVdMM2d0dlpYTWJ5bUJJRk1aMW92MmgwQitMVExpc3hnVytFcTV1VTkyaVo3MnVkOXZ2Uis0SkZwNE5qa1JoMk9OaTBPQjEvVUJDa3ZFWVJoZnVOczRPbWhoaVBLbkZRbHg2YUFqTW5TWEpVQUFDQUFTVVJCVlBqbXoxdzQxbm53TzRjQ0lCdkJ3WmdUQU9VSFJxM2d5REV4RDR6UkdWWUVucG01THFtUWMwTTVlc0Z0N2FjRmwwU2xIaUJ4dVRrWXh4ZGFpaFVDNFFWWEZ1NUZDVUQ1UXRKbDg1c2pHQTB6aVF4cWV1L2ZlbStodzBGMmZMTFFHeEZsWU1Sdm83djFXbUlWdHB0MURGa1h2T1I3THdKMkhTa3lvWm1FeXBvVlZlOHA3YjZxRU1uaWRHRy9WbC9MMmFQT0l3dUExcEFJUUUzREFtRmE0ajlmN0NQYUZwQ0hLdWpyNXh6WmVzR2RIcUFxS3o1WCtGTFJBbDU4bGUranVpK2tUQkFMTWNnWjczQ0RCa3BOMi83K2JmY1dPaHdVeUNFQWpRVGNBVmhLZGprUGMyUmFqZXdLeXUvbjEvL3FKY0EydWhCTVJHWFFPY245VTZKSU9qWEhRcVNZT3NWb1FwMUhOZ0F2ejh5bnk4MEg1UFZ6OUg2UnFWZDg0OVd0WFEvekEwT3cyYXlHTEo0NzRMMEc3OXZ2YnVsd2tKaThCR0NnNFMwMVNLcW9mb052U0lDKzV6a2hGVXVwVjhyVVRwSk4wNktwYUJrRlFtNU0xSGxrQTNBeU01L3U5WmwzOHpyazZmMGlVNi80aG1zY2dLNUlTVXRDVG93eURxYjdVeHdzcUZKVzNmby92YnVJQkpFWjFZUmd5SHdRS05pMEtFbDFPS1RDWkpkeHRQRG4vL3Y4b29hRGFWZ3FGeWlURDJJS2ZjalpTNEZvKzdnK0hYT1B2ODRqRzRESXpLZkx6UWY4S1ZmSS9GTktyUTZoOTR0Znordk9BOWNHQUFicnB5bFkyU0RsVlRUdCt1Q25WMy9WM2E3RFFRQXlzSkF3b2JaSmdVWGk3OFFheWhkODEyV2VpT0FaekV5VWlBa0hNZXU1QkY1RndaUUFXTFB3a25rTFF5OUNyUE15OCtsSUhaRnp2TjNUK1liVis4WDdjNjRPSEhpeDc0VjZ6SXhCK1JKMHdRK1VVOTkydFlvRnkzZmNYY1REeFFrb1BzQ1VoRkljektWQ2VnU2c1QjhBL1BJTE45Wnd4QlN4dGlLaVVBT2k3SlcwZExUdXN0RjhBR2JtMC8xbzN2ampuU0dkaitsWWxHd2RSTzhYTitjMXdBQklvSGs2azYxeXVTQ0pJVHEzakRZOVZ4MEJxSysrdXdBZlg2SmtJL2hNRTBTQzFFR2d1aVEraXNxY1FSTHJGNi8wak8ydys2Rk1uWmh5WllzUTFXNTBxT0hnUFgxTlhuZHRPRHNmZ013SHpNaW4rMCtaTjBTOVlPbGxNeldmTHdLUVNTMzk2UDNpWTNrTk9MRFBNMXkwNjVINGdPVzNwNHVURGtCOHpXZGI3RmdiZERoRWdKa0NVRFJ2b2dUbWQvdlB2M0JWQVVCdXZ5bE56QUFZaTRoaXNWUW5FSG9JcVdibHJ4cW00TXg4dWpmbGpUK1lqc1dCWWdJT2Mwb0pQc3Exc2xDcEg3MWZLeWJKT0VvQXV1VlRSU0NuWWxtVTZQL1o0aVNKRWNiTHYrWXU5LzFFQWg3SktFWERLeHE0Q2hVaUt5bVJid2pnSGRjVVdUQVJnTFlYSFNyMkxPVStCVjdNVnd6eHdPZmtPV3liWUFHWkQ1aVJUMGVkanB4RDZWaGNPUTZqOTR0UDUxd2RPSEJkTWVYYTlPcVdSY21XWEExWExVSVVINnp5Q3dsQXMzeitZQmtmczF1K1ZJZWpKRUYzY2tyakk5VDB5L2FNQTIrL3RnQWcwOFZVUktUOHZiS01VZ0FNSUd6ekFjT2k1SGtuSFFBejgrbCtNVy84MjlLeGh0SDd0VHoraklNQUpQQ1lNVUxBV2Q2ZnZpK0VZOW91b1pCTS9LeC80TFVCZ0ZMZ05DNW8xNkZyRThKSlZKZ2tpRmhhUVFCdjMrZFZiTXJXVnNDOFV4RlJramphVnNXMkR0UmRPSi92QXlvaFZZSzdBK2JUdlRkajhIbHFUTWNhUnUvWHhIa3pqZ05rSU9XdURyOGpuWVlES0R1dGdwVWhyYTB1QWxBeUNDVUFLOEJYY2pCWGdMQ2svaDBEL2hjQnlEeEZBZEF6b0ZVcVVCWVJKVFVjTVdkUFA3T05MNmk1YkxRZUFMSlJRK2JUL1c3RzRBdUFPWHEvbHNHZGNSZ0FZK2dsTGtZY2xKVlRzYTZwdENYM3VRakFLSU5Rc3RGckFaS0l3V3hRSWhJSnVvdkIvTngrcjJMekZDd2xqOFkwZXZsL01ZazBraWVWdGN2cndHVW5IUUNWampWa1BsM21JdFFzSVB1RWx4OUc3OWRPekRnTWdHa0FXbE55QkpuOHhLcHJCUkMremdFbzRMV1JnY2RWY09DampsTnZteDg0RHJ6TkFhaGFGWldMeWdLV3hVTmliSWhUY1BEOUJNTExhNjVienJlQU1TR1ZvWHZKL0NnaDFXVWZPK1hUWlM1Q0RZRHM5R0gxZm5PcklEY0FrQUJUVERDQ0xZSzBDd2kvNTg2V2NLSlVpRXBDOENDQllEc2lpU3BscVVJVW1PamYrbzJ0SWlLVlVKYmdVNXVTV2w0RFd3WDQrUGNYbnJRQVRCTlMrOHlueTF5RW9wZGNheSs5MzB5NVloZ0FnKzluMk9vVWVJNVRkUWVyKzMyZmRobUdvT0JaYW5CbytnMXlFS1U0ZFlnRlN2cUIvL3ZaQklCdDlSc2hrVGJXOFpaWjJoVWd2REwzaVUzdXV4NExTQk0wWkQ3ZFBSblRIMDhWQUlmVisyWEFPdWNRQU11VmNLZkZTRC8rSUFBQnNFb0d3WUFvSFpJS0VFWXhSSUh3TFM4cFV1aGpGVnM2L1paaElWV3l4VktCQklSWG5iUUFUQk5TKzh5bkk0dEJ6a0VBQ3YrY2hsVVZJS0UvNWNSR3NXbWxLZkl6dWRjM0FQTFFTbGczRTJPQ3lWUmMxa3BVM0RnQm1Lb1FzV3RsQmNzd2pQdStuZlRZdEJMK0dRZGdPZjE2R0NaVzZwWGxCQ3FXU2dxSnlwb09BRmZYWERpZmJ3RkpMdmk1SEFqbG5Vc2lJZTZBak9wNGlRTlFIUmxUMlBsZ0pDVWJiYzJzK3YvaEZ3RmIvcTdnbTZIbFlwQmJtVFYyc3NjUXl5L3FGQmoydjAvY0Fkei9IR0Q3TkRBMUFVeU9PVSsxQ3dXT2V3TmpLajYvTzAzRjEvV3V1Z1c0L1hKZ2ZCb1ltd0RHZEg3SXhCNWtMUElCK0k4QWZOd1pnZ2E1Y2syZkpiRW04Vjl6TldQZnJhc2JnTXVQQWN1c2VKOEV4c2I5RmRCaEErN2dhUU5LQjZUZmNnQ1l1ZytZSlQrZzg5YW9CRE1tSU1TY1AxMnVUS2oxM3VEdjh6c0tpZy91SjF1UU9zbm9qbTNxQjVQNUFDUkJIM09oUHV6elJOOURWODhIcVFMRVdQSm52VHk1bm0vdC8xczRCY3VTcFJadEdBdTRmaSt3dEJWWUV5Y2NyWXduNmhGOC9Ga0pwOWJLeEFLVkZzbi9kOHVyZ2JIUEE5TlBPRU9XbDQrMmNmb0ZIaGZWckpUWlBLSFNqNWRhT3R1cDZKeUNwUHg4ckhXUlZRN1dPbHJZQ014OEFISXpseGtBTFBEOWMwVkIreC9BM0UvK0UyZlVZSFhkRjdLVEd3ZHZUZDBBSFA5cjRQZ1dZRzBLV0JkZnNCZHNNUGZQcktLc29MOVhBVkxBdk8yZkZ5bENFNGNLbGl5ckRWWk5jR1MxQ3FFWWhXRmlBWlYrWG50YVVSZFRMbXBDRWJwY2hUWUxxaTZOcmtNQ3pMenQ1WGM0SHd5Sm1ta0orWjczalFPaDROV2VEVVppSzFLMDhmMEVYdDdDTUhWYXdJazdnYVZwWUpVQTlMSTFBbzhiektYMWN5dG9GdEZmcGRDSVd6N3JnekhndGg4dTBvUEdEd0VUYzhDRU15U1V6RmFpa2d0bHBXMVRhOEpxTmJhN2xWbGpTUmdXK1E2WlAvNTdXUXZqNmZ5ZEJqWGZBaktiZ0V2TUx3V0N2aE5vaXBnTnBuUXNobFM0SUdGV3pJazZ5bFd3QXo5M0VUTHhHV0I1Q2xpZExBQm9JT1M3cG1HZkcrMzNZQUc1bU5EMEc4RjQ2Nzh2a2lQSmN6Tk9BQzRVeVFtMk44dzk0a2lyRmxmSUFsN2k0MDJkNmRiUFdXQXRyc2pPRml1Q3ZBSlpPUUUwcEhURnNja0hZRGVDdmhOZ2lwUU54b0F6OC84SVByNW5idkgyamQrNkFUaEpBRTRBcXdUZFpLRUJMRG9EZ1U0K1lWa1BISUJvUHdhcmVPdC9Ca0RleHNNRkFGbmJ6TkpZbTBJRG5Wd2J0NHV5dXIxa3dMN1RwK2laTS8wOFdUOVJjN0RIVW11WVRyL3grNm80b3Z2dTlmakJiZ1I5SnlBK29td3d4dlpJNVVMZzZaVzd5OUZQZjlRTndLbS9DZ0NjS0FCb3ZoOEJ5VnkvVUN0SnEyZitYMXlZSlBHVTI3bElaTGJ1RVdEc1dCSGVzWmVEejRpVVJMVVdhMVRFNDdMcUsxMmZabWQzT1hpZEZjdHFtOTJLYXRWczFqQUVzTnY2c2R5bWFhMmc4K3hVTDRJK1BuMmJlQ2diTEdXSEkvaDhHM29UcjQ1aUs4NlBPbGJCVTl5S0kvQWNmTFIrb3VRd0g5QmZtbWJMbFRIYm9PblovVDkrNXZhZjhGVWFBVGhYc0ZPUTQ1bVVjZ1pDV1RBeGUwVVErdXJZTU8xLzM3R3R4UW1vTENCdFJTcDMwTHJEcDJTRmR6WU1nay9SK1ZOd3Z3Ujltd1FEc2FzcEdTZkpnWURZTlRicDhwc0NRRkp4RUlCa1FqRHJ4dDhkWENVSVkrQ09INU1WRlBpOFNPbjJuL1FZTFo5R3AwY3hBTklQNUl2QWt6Vnp4aXZSeWRuS056QmE4ZmRkTTg0YjZBRnlBcmlNRjJwYWprOWtZSWVvQ2xYbUEzQVFncjVOUUVITUJxTVZGTU5hSU9heU5STC92aGxIM1Jad21oYlFRVWNBYXNyVlZHejRFdGpDdS8zZGZiL0lEM1BiVDd1S0FaL01oY0lDMHZxUlRvNFcwSUJJRUFtRXRGd0NZcWpXMDNiY21kd0JZZW9XZ2V0VWJyUjhzbnJsb2lSMmRycEFDZityRDREOUV2VFZqSUp1N0hCVis3ODFYNzUyQ3pqOWx3VVprVEVnY1BvTlBwNU52NG9CUmhDRzZkZCsxRGtNejFKSWhSMUJBSEo3endxTzNmSVJSTTV0bURLNUNvUUtzU2dPZUJZQktGWlVMVHFjQjlyNk5pNUtZbWQzV0tEVUEwQmxoTkxNOEViVDFRQlhCVTcyYUk1WmpVY1ZPeHo3V0xrUThkMzd2c2FydC91QTZSY1BzeE5TQXRBWEhEWU5DMUFFcGY5czAxa0t3dUJ3R1U3SGdWdC8xanREMWU2MGZnUWlnU2UvajViUXArS1lwR0IrSDYyalQ3UDgvWnlwQklDOERoY3g4ZVk5d0YwMTVhYmhtbm9BeUo1V1NyS2VOZ0tPOVNIeG5UL0xTYXNKQmltNWxSaldCRUlWZVJPSW5LTDFxdW55YlJhd0xnQVNkRXk3NHFqYU5OekpDZ3FFRVl6Qkd2SzAyOTdtQUZTSEVJQjZlYktEZ2M4SjFrc21WOHQyOWYxZW42TDV2NmN4SUs1aUs2WG5lLzVqQ1RpRmNUcVZuL3IvdFdEUFd3WG5FUFRWZ0lLVUhVN2xqQVNhd0tlZkl3RHBNZFJ4UkIrd0ZnRCtSUkVESkFCcHdTenoyYzBMZnhjelZqa1ZLd2FZZ3RCQmV6dTNTdlgwOGQzOVA1dU8zUUthaFhNUWNpb3VyWlJBR0taV2FyL1laMXhYUlBlOHdRcjJBVUs3VHZiT1ZUWkJYeDRNQkVDUm5Db25VQlNGRVhUNm1mL1RLKy9xbXpBRi8wVUJPUHFCWllGNTJIclRGQ3cyTEg1RzhVQ3pKRWtvNW5acW1SblBoL3VDWG1wblZwRFRzSVBQd0tBcE9hU0EyUUxETFNIZjk3aVB4MHRwSVNMZno3Ymw0aUZmc1VzbmorSFpXRWVPWURDRG5EbUN2WmtFZ2VkY0NqeEdzZUloQll0M3Z4MDQ5SHdNTFJoOGdBOWdoMk1vSDlBQnFLSnp4ZjBNY083WGxTQVU0SHpoWVlGcSs1RDdod0J1Lzk4T1FMbElCQ0tuVzM5U2xYTlkrbnFlaXEyZGtRZytnbkdQYjkvWnBUMGxxNk1WNUQ5NmdMQ3dnRG1Dd2JkbkN2Wm1DZ1kvZHh5NDd4eGc1U1d1VWppZ1lQSEZid0ErZnlHd2ZyMnJYck12UEIrdnAzTDNHSENnaTlKT0hRQ2tSVlBwcGVVQmlnWExGeW15ZWpZVEI0WXNnZkEyMG9mUkFsWUIwRmZBbHZRcVAwL1RzWDVQTE9CNUROdTQ3MWNtSXdpQmFSd3cvRjAxSittejJwcUNoeFVNWnZwSmxtQnYzaVRvY3NXNGR6ZXdmaGtHRml4KzJmZWJYREFlSk8vWUVJTEJCN3BVMWc4TFFGbzk4UUFTVkdZTlE2RFpmRUczZm5FcXJnTGhiZi9IVjE1YW5ia0ZOQ3ZvaFdTbDlYUFEyWFRNLzJzM0k0RHdQSVp3QkVEZmdpdEgwRWs2TjZ4K3UvaUQ3VDRnL1lkQkJZUHBXSEVhSGxxd053K0FRYTRZajU0SnJKTythUURCNHB0K29DQXlZdk9QRUlRRENnWWZlRi85VTNBYkFNWDdJdEFsVnRBc3BLWmR6NVNPbHZBMnBzdHhqRVMzd0orOTJOZ0FHSzJnd2k3OFFvVmZFaEJlUUFDcU5OUDFSZG9BMThrS2RnRGh4a1VJL3pLSVlEQ25xeXpCM2p3QUpuTEZPRUlXN1FFRWkxLzFZMjF5d1ZnbENBY1FERDUvRWZqN000Q1ZyWjVBS2xraHhlUVVheEJJNG52Rnp4ZjhJZkNWQzRIVjdjQzZaRVg1bmVuM1ZYMXZBR0xacTh5c3J2SFkrUUJ3YkdmSTJFNkpwTHZkWCtrc3RocFV2UXJtWC9zVkRHWlZVSlpnYjE3dkpITEZlR1FjbUNkVmI1K0N4ZC81eGpaNlF6ek1MT1FCQklPZlRWMlBzNEhGSFE3Q0xRVVFtVXJWMHJnS0pNc0Nqc3hHQXFUbi9oencwRVhBNHRuQXlnNWdiVFlCb3JLa1V5TG5rQjlZVmhUeHUra1QxM2ljY3d0d2RCZXdQQXVzK2IyYXI5eEpBYWZxZmdNUU80ZGgrSjkrQkhlNWdxWlpaellvazFKSlVjcGFSNmJwOTNQK1cvTjZwMEt1R0llbWdFV0tnUFFoV1B4ZFA3TkJMaGlIS1lIVXAyRHdwWjhyTE9EOHRtSlFWcGxPTHhBcW1iUktDNkVEWUM3L0NlQ1JQY0N4M2NEU3JzSVNyczA0Q1BtOUFyWms1NVV2S0FzcFlMcVBhUGRSNC9IMGc4RFJIY0R5VnIvWDZWYWJMSGsyUGhqcFBWWlk3ZDV4d0Y2Q3dTOXkvNExiYlZ5UXNFS0l1ZkdpS2UwcDJKdlhPeDNraW5GMEdqaE9RWStvTlJ0bGpqaTlUUVBmL2ZPVjlJWlk0R3E0RDhIZ3kvNFcrT28yWUc1YlVVeTA0dlVjTENxU0pWUldzekpiTmd4U21NYXUrcS9BbzJjQlI4OEVqdE9xYmdOV1dhVGtJRnozWWlXckY0bkFqdE4wbkJackpuVSsvOFBBM0N4d2ZNWUI2TFVyYTNvZ2xMMHRwczZ3bFZoYTVyTGlxZDlBZERmQjRKZTZVMHMvMEJYVERZaDgwU3IyRk96TkEyQVh1V0lzekFCTDFKYUtXcTFSK253R2VNMTdPc29GWTVYVFZ3L0I0Q3YrRGpnMEM4eHZMWXFKQ0VDemdzeG1abHE5VDhlMFhHVXlhVWl6YXZQdHhvRnIvenZ3MkJuQTBaM0E4ZTJGVlYzeDZjNHNxd09iY2tleWhpWEFvd1VTQURoRDFYaGNlRE13eDM3bHZVNFh4Vk4ybjNySklvY3lna3IvVmJzN2ZlK0VkQkxjZmFYWFEzSVBXSXJwQkI2WGxud3BSNzZqWUc5ZTcvU1FLemFyeE03cUpGajhtZzhVYXJNVjlJWjRndk5ERDhIZ0t4OEhEczhBOHpNRkFGblBZUVBEbDBDbzJnNGZwRFpMcUtDeFQwLzdmaEo0ZkNkd2JGdmhSaXdSZ0pydUNPd1VnQ3BlQ3ZValptRUZ4aGZrOVc5NjlrVy9COHh2S1FxblZnZytCNkNCME1zSTdQNzBBSGdtZDJuMU5RMHJ2N0Z2QUxJbFZZSzczTW5RQ0RMVGhTR1pvRHB1UDd1Q2V1WDVuOHpyb0I1eXhUaEduUTBDZ3lCTXhZNjNBcS81YUJIRzZFQnZpRGxPTFYwRWcxKzBBQnlaTGdibCtIUnhuWlhKb3FxdHRBNE9Eb3ZsSlpWdVNqVFFGdHErTndOUGJITUF6cmFtZFZwVnM2d0VvUHRkTmczN3dKZnZzWWlKUDlORnF2SFkrN3ZBd2pTd3hBZU54Vk84VDZhTlZSUlJsVDZoSHJKME92YXcwV0RKQ0tuZzdnODZBUHZOQjl3ZzJKdlhPMzNJRldPQmduOEVJZjJuUkxENHRiZTErQVU3eUFXYlplc2tHSHdWZGQybWdBVUNjTktuSmdMUXJaL1Y5L0pubjVKVVltbkFFM2hDbXYzK3Q4QVdRZlN6eVBLL1BPT2dKZ0Rkc2dxQTVuZkpBdkxkTFYrYnowa0s0UnFQWjN3UVdKeHlBUHFEVmhaUXlRcjdneWFYSTlheFdDRlZBR0x2UlVoVjQ2UGdMblVXQnMwSGJCUHN6ZXVkUHVXS3NUUlpBSkRUbzhsOHVpLzQyanVMNXZlUUM3WnBzRW93K09yWlFscVZWdUg0RkxBOFdWeURBT1RBbUhVUUNBV1FrT2xzUUF3RHQvOS9BRThTZ1BRcE5hMDcrQWhBQTZITFhiYjVYcjRJYUFNZnYvZUd2UDVOenlZQTdVR2pCV1RXamg0MHY5ZlN5c2NITHRheGhKV3hGVnNOTkFYSDFraHc5ODMrRFlQbUE1YUN2WGtkTklCY2NlbWZjZW9vQWZoQUFjQSs2QTJ4THVBR3VjeHJ6Z0tPTWV4RGZWOU93YlMyQkIvQkVvcUxTckJvWUdnSjNFOHFMY0lFc1AvbmdDUHVVeTdTMTNMM3diNlBVNTYvbS9YajRQczBUS0NYUUE2QVh1TmVaWTNITXo1UUFOQWVORDFrd2NLWGxqNndPWlErYjdSK1BpMFBEMERlRkFmazU5MENLZzhxbmNmb0Z6SVJWV1ZxZkZmQmhnbjI1dlhPQUhMRldDRGJ2UHN0QnNKWjRMVVB0K2pkZXNnRmcrcVZwdFdxMTFiZzJndGdmdUxpUkFBZ1FlZytvRW1zT3Vqc1hiNVNzQW9DSU4vM3Z4MDRPbE5NNll2MHRkeDFNS3ZLNy9URmpWbWVDRDRIUVFRaGYxNTllVjcvcG1jL2t3Q2NLQUJvZVl2UjBvZXB0N1NFb1pRMFRyMWxQdVBRRmxBdE8wbnlBY1docHp3L0ZTakZ6R2pMeCtSR3Z4em9TZUMxaHdzQTlrbHZhRk41RkF5KzltSmduaGFRMHFxYWdnbEFEbzRjOUFoQ0RwSlBsNVpvbW1RODczOEhjR3c2QUpCVzFWZWNadjBjZVB3T1kwL3dsMWxBRC9XVUN4MG1NbERMcjhiam1iK0R3cDN4NG5rRFliRDB0aElPNWFOdGZtRGkveEdFZVJhd3hoczdWYi9xMmh1QUJRSndBbGh5eTJjQzB4b2dnakFBVUNXV0Fra3NPaUlZOTc4VG1PT3FlcXF3cUF4M1dHaEhLMDZuN1REd09jQVYvaWlwUEFLandnclptMm84bmtVQTBnS21BSFRycCtvOU1UckVZdnE0NG85cFpJT3RnbXU4bWFmQ1Y3MllBS1QvUndBeTVPUE91VmxBQWs5T3VsZTZ4UVJUV1VLbFd0a1UvSXZBSEFIdGk1b0l3REs4NDFaUEZ0Q21kcjBVOFBhQzloVnVsdGQ0Q0lDOFAyWnR0L201L3FDMTFUSlhsSkRHR3BmR0FtWU9EZ0ZvQ3hBQ2tMcHVXaDNLQ2dxRThnTlZaSzRLdHhnakpBQi8yWDFLcmFvMXJmTjdDV1pmM0xTQlQ0dUFFSXlXQlZwaXBMN0dnd0EwQVcyNUdiR0VOQlRSeDNybTFNMnczOW1tckZWd2pUZDFLbitWQVpBTEVFNUx0SUR5TVdVQnZiTE5MR0hnZDVIL1YwN0JEcDdyM3VVK0phZGduM3B0eGVrQTVNQnJpMC9XcDR3ekJqRGJDbmtNV01xVnBFOEdKd0xRcXZmYzBwcWJrVmo1YU5rN2diQ3hnSm5vMzBjQWpudG93dFhOYVoxc3V2U0tOaHNZVGNWS213OUY1eEdFKzk0ZGZFb1ArSlloRC84T0M4ZUlQVXNVSG9rVlZLQjc4WHN6YnpBRjRQdmQvL1BDS1ZHSXBPQXI3OG1uNERaT204WUMxamNvK3c2RUZURERQSnFlQ0VCWkJhNUdmZlZiaG1ROER0Wlc1VFlPdlBoWGlwMEdUdXUyMmxUTUxTdythQVZsOVFoRVdqdXJJL2FRaUxKa1RNTHNYOVIzci95bVo3M2ZwMSszN09VOWh1blhTa2RsN1QzUXJoS0N0bENNNTlrMmk1Q01NU0lBR2RxeEVJd3JtcHR6VHNDRXV0NXlpbEtvSkxBY3hDcTNmZTh0TENEQkZ3Tyt0S2p5dXhTQ01kWUVYb2VEckhjSHZ1MHRUd0x6bXdIQTROL0doNnpOQ3FxZU9TeEMybGI4dFFTaU13YnVxWElxQWNqRmgySmpCS0dKeVNoUUc2eWdWYmZKZWdVTFdCWWNNUjNydmI2b0NSYVF3RlBnbDFNNXJSNy9KdEJaT0laV3gvMCtzNFFlWTV6LzEvWDJ0Rm5BeFBwRkVMYVZrZExOOE1XR1ZyNHBDQnNmTUhOOGJtVEtmQ2paME5jcDQ1Ni94NTh6THpmdzZRZjNBQmQ4cFVnRVltcWs1Ykd5ZWswNklRbDFia1hTY25sTi91OEwyNEdkeDFxVnE5MUtRdnJwZ3dhQUF3OXArd25YUHcxWWp5V01HdERvMkFTT0ZHTVU3U0lFVXpkWUQzNHZNUG1Yd0xiSGdka0ZZQXRsR2lpbTZEcHhKdHZxOUx0bFZyL2FXS0VCOHBVWEFPT1BBRlB6d0JUWjlyMDR2ZFE5VHM0cEFaM2NkK3lIeGdmTUFPSCt2Y0E2OS85VXhpam16L0FlcllwZGFyMWxOU01ZelYrdldZLzM0SThEWTU4R3BoOEJwbzhBMDR2QUZFRklrbklIb2hHVlI2MlFoRlJTWWpRRTZxRnJpMnozaWFQQWhITk5seEt3QXJJMFExSUF4d2ZSZWFjYkM1Z0JQcDY2LzVJQ2dMS0N0cW5zcktLbHJGWlVGUEtPcjdvc01UdGRzeHpxUVJaOTNRMU1QQVJNUGxsb2hVeFJxa0VLNmdTaE9QMFMrZFkyaGxSdjk5eStvdlJpN0lpVG5UdkxxbWc2eERQWXBxQVVnUmdzb1I3TXhnSm1nSEQvYzRFMUZYdTdGUlJidkVnZDdldlhXbGJQcHA5RWdVamlKcHdlNnp3T01sdnBBV0NNVnVzSllQSVlNT2xTRFpScG9HaU54S3piZElRbFhPTk1XSmJHdHc0c3ZkZ3ozRWw0N256VFJ2UHJyS3B0QUpUNlpyemZpbnR2QUpneDR2c3ZkUXZJWEs1VllGM3NVWnhtSlV2Z0ExRk92d0Y4c3BLeUJ0TTF5NkVlcEk0THFWTWVkYkVhVHAwRUlLZFBLaDVGcVlZcVN4Z28yamdGcjEzajZYWEhuT2lTWk9lQlZTdnlDOHFDMnIwNUZWdlZ3OWNBTUFPQTE3OEFXUE1wMkxKYWFla2lDUFhFeHdIdzY2MG4xb0IvbmlHUWF6d09ra1NlcGJKLzcySTF4NENKK2NKNmxZSTFyaWNjclZpY1V1VlNtSVc4MnBrd25ISFZPS2JGc09velFHa0Zrd2V3bkJFUzM3QUJZTWFBWDM5WkFVQ0NiODJuSWxvKzQwcDJnTm52c29LdW54SDF4R3dBL0xPemRRT1FKUEl1SHpWMkdCZzdDb3c3QUkwbDMzWGZqT3N2Nm9Wb2RlczZJU2JCc0FaTVgra0p4VTU2S1k3cGttRlZoT2NpdXZUelN0MDV2MCtyeXVULzlnRHJaTmU0d1BNc0k3VkpQM0djUDdnVU9PZHZnTDFyUllKMFpJNUlWM2hWNC93ckdZUFBVMy9BaVJoWXVzeTJLN21VOTk5UCt6OTBPYkQ3THVCWkswWGRrZXE5TlNYMitvNEhMd2ZXbG9wRkNDMGZnY2lCTXRBRkM4Q0dyWVhWb1ZqblUyRzdyVFhyemg0a2ZSekxZMWt5R3dCb2VpR2NQaVhiNWVBemRYV25helBDU1NjYjRqM3hmbWF2OEN4MnA1MGxBTVcwVlhJTml0Q29nbDJyOUgyZGNjdFd3UXhRc242WlRCYk1OdGNnZEtJYmlaajUxVmNCazM4Q1hQeG9RY2ZDVWc4cGpjWWdaU2N3L21vbUFDblh5cjRsZUJoczVRYUJUSHBmN1g4ZE1QWUpZTzhYZ0F2OWU4UUpsQVpacThENHhTdUFOWUtQSlFuMEFSMkFIS3kxTUFDS2U5bmZGSTZJRXFkdUVXb0hJSjl3bHNWS0xla29NQ2E5RUFlZ1NUWVFlTTRUWGNvMlNFTWtBSEViQlpvajRiYll0ZHlDVnJGcUdYZ1RTeGdYWVRaZUhMaTlBTWpFUVJDVlVYUC9uNEtVYWFUOHZWVGkrUnRnN0dQQXVZY0FXbE1DZ1VWa1FmSjJRMTJ5QnZQWE13SEltaERXd2Y4MWltc1RpTFNFdkhaa3IralkvcDlDUVJENHA4RE9Cd3RlSXRhaTA1cW4zMUZGZGZMbEZ4WVdnQ0RVSWtSa2ovVHhiQ0VpLzg5amZQWjNYMlZxWVNKUWJtVU5RWTNIUVQ3aGJ2MnNMb2VyVndLUUhORUVvQ3NtOFI0TWhQUmpYVUd6VkVJS0lvWTd5YUVZdVk0ZGdHYjVSWHJ1b1NndFNDTExhcmtJQ1E5ZjZRTnlrR2pGZGpzSUJhSTRrR2x0OFcrUmc1ZzBISjhxQXA0N25paEF6RnB1V3RQSU1CWkpsQVNJTHZSNmZRMERDVmJKQ2tKT0pDcW5rNHBHcGI5OXRaOE1vcHlpS0RYN1dXRGl3WUtYaUVRT2VoQ3JnS2grZUpRK0VRSG8xTGJ5L3pSbHlmOFRJYmY5WFM1ZnRJYjhJOTJZdWdINGF5MnBMdXNvcmw3ZEFvb25XdE13UVNUZE9GdVFTTFRHSHlJQzhreFNJUXVBNGh3VTJXVUFvTzQvZ3JCY0Ric2ZXRWxTemcrSkNvWURvRUdNMWl4U2tIemdGL3dHN3k4c0lhM0o3SlBBR1d1RkpTUUlhVTAxaUpIVWlZUDRlMzNCclBPSG1HL0pNYU9mVFpWWVJod0dhdjg3dldLUEo5L3JTSDRJT0dPNXNJVHFnL2dneFhzNFRPYUJBRUNiZW9Pc2dmbCtEclFTaEZxY0VJaHl5dDBNYk11c0VreDc2aUFaWEtNOEJ2WGlaQUdsRitLYUliYWFkWXBlbTRhRGdwSlpRejZZSkFCVjVWY0hBSlowdjRGeFg2S0c1VXBZczBLbnFqaFJ1YWdFVmdQZ2xZQWw5Y2lIZjhtZFVySmgwUXg5dmtEQnpCeXdmYmtZUUlHd2FoQS9rZ2xBVHNIc0R6S0EwQkFUaVB5WjRORUR3SWVvYS91RllLS1hMMmYyNG5Rb0lnZDlSM3lRQ01URnF3SUFmZEJXSTcreUI1WkxFQ1lMRVRkODVZSmwrMllBVU5vc0xJZWwveFlsdTRKc2w2YmhOaEQ2aXQ0V0pDdkEyWmM0R3hvNzNSY2dKZU9xRm1HUjZyY0NoTFlBQ3lHb2ptRVlkajU5S25aK3RJUVJoSDlJdldBMmhpUkVqRGVSSTlDbHk3Zk1GM0V0V1JGYXdoUUlmNUlKd0U1NndkVElZZHQ3dHA5eXMxSzhKbm9Kdm9kOVduNjgyUE5rUDRoVXkxbmRXZ3N0QXRCRE1MWU41LzZQQWM1REdOb0Y0U3JaZk4rNCtJaFQ4anF3ZzJDcDhUaElKNXZmU1dCWEFWQ3JXTjlTTXhESytza2FPdmhvQWM4bWU2NTRwbVVCM2Ywd3l0K0U4RnlSQUdtUGxPRW9pU0QycWd2bUFLb09tNTJmQXVpVERIU3lJUnh4K2xJMFF4eEFEdWJmRjV2ZmZNbVNhanJXbFA3bm1aM2RTeSs0ci9aekFVRUhuUThSNzBIc1hsSytQZ0pzVzY4RzRYWUdaajBFWTJFWUFUQ0FUNnRBaG1FMERYY0M0ZmFhcGN3TWdBSWZMYjBrdXpUOVFtdzV1d0FBSUFCSlJFRlVTaStFZmVBTGtTcnBCb3ZiclFEbmttOHdBbzgvRTNpK0NDc1o5OE5DcEFwOGNVZWtaeUJhdkk0RVQvVG5hQWsvUlFDeUFYeTZ1TlNQQTBpK3dNZUI2ZVBBNUhGZ1pxMndwTkdLM0ZVREFIbXYzZlNDZTdhZlg4Q0I0VU5FRU9vbFZpLzNvYmFzdE53SjljTzVCT0JLRVFNc0FjaWZIV3pSQWlnV1dBbENuNUsyYlFZQU9lMUtNalRJUjJrUlVoS1ZTN0lyTGlhMHYrM3h3SE1aTUNiWU5QMEtmRzc5ekFxSzVEeE92eUV1V3U2VkQ1S1NIeTJZQUVRQWZwYVJkbDVVa3VVY3RJcEJuQ0lJbDRwc0QwM0Z0SUlQMUFEQWxCdUpNNDdFcXFVWDNMWDlrU0JRY3V1eWZ0Szc4eFVrSHlRK1JMcUhaM0Z2MUtjZ0xqNWtBUTFzMFFvNklBMW5IaE5MUXpBOFp4dkJYdU54OERjUzVVWXBObm9ZeHNDblVJcXZabzBGM3dQVE1hN0h2NTNIT0pWYlMvbCs1YnVtWDdkKzVXTEU0NGh4SVJKQjJOTUNxajlpeHd1RTkwc3ZXQ2FJQTZiQXA5NTlFS2VXQ2hBeUEwUFRPVjJ1bkdNUXZlQ083YmZxSGJjUzRySlI3RXdxbnc1QVdoTHVJbWcydUZRQVhBVnM4UkdtbnRXNCtnMmhCM1A3OUwvRUo5ekd2cXJ4T1BpYmlWaWhBT2dyV1FPZi9FQmZCY3NQTkJCcVc5SHY2enpHcUZ6bW9YejNCOUFlUGdYaXE2YmdpdjRZT0I5UUhTOEFmcGtBRk1NanJXQWNRQTBpTzlYSmlReUFub3MydlY3RVNIT09RZldDTzdaZjdGNDBtWkZRU2NSS0FZQmFTVTZ2QVZjVGdON3hYSGlVRnBEVE1LMmRGaDU2OTEyQlRpRGN2cGtBVElYekNMNGczV1hUWjRqcEdmam9GL29paEwrZngrMHlXVUFCTHdJd3RZS0tJYWJnQ3pIUXZpMmdnQktuME1jRVFEYUtUNWNHa0lPbzZTdXlZekVmalFCMEVNNW5aZ0FQb3hlOG9mM3NnU3FDUU0zamtkRkx2cFJ2UjEzKzdVVlJ1aFVGU2F2Tk82b3R3cDg4WlozK3Q0TTZITHRjaDZPVDlBRy9xOWNtdGYvL2dWMUpEWWNuUTJ6WTYvWWFrZlNyVStQZzFNNDVOcVB0M0lFdG9NN1dGSG9reXJXS2tvb2dsQ01XTFlqaVVYTXRLM2c4VXpkMVdMM2dEZTN2UlJDb1VFWUN3R3RZRnh4cWdBMkUvakkyMEY1aGhtUW9kOThCSE5ubHhPVGlnMWFHaURhbk8yMXlWNER5Z1d1QjhZZUI2Zm5DOVdFdGlLVlZLZUUwWkdpWFdjemVKb1dNSWlnNWE5VjVEQTFBTm9LRGVEeWxaOU5TWHh5QXNpS2F3clFxbUN2MkhWZjVlOGFSb3hmYzFuN3hzK2toSXRBVXZvanZ5V3J5eFZjV0paa3NWU3lab1FSQTNkY0FvSHpheDRHajJ3dHU2RlZLTTdnTWd0aTAyamJWNDc2b1VKSnMxai9BYkExbVEzUG04ZVRSc29aRHRSK3haS0NpRUttTVhUSWVYSFBHZGhZQXJYOEZ3RzRER01FbkFISUs0eXZUNThuV0MyYjczY2V4YVpnV1dhRUtnVTFnak5iUFA3UHZPWUdzVVNCa3YzaEJ0bVJXTnp4alRrOVJXa3R2eHA2UE9qMHZBUmpZOXNXa0ZlbDhSV3hlZ2pJRjRSandBT25aV01QQlRHanF2SG1zenhKT0JVRDN4eXpuTDJicVJPdm9QM04zcTg0akc0QzdNL1BwY3ZNQmVmMGN2VjlrNmhYdisyWW5vNVFmR0FyUmJhQ0MwbVd2Mll0RjNlY2VyTkRoa05aSUlzWFFSdjVkbFR0R0FESlN6MmdFRTFFSlFNLy8wMjZIZElFWkxDOEI2QTB0azBnMUphOER1ekpkcGhTODJRQkVaajVkYmo3Z3haTjVlci9JWkkrNjdwc2NnRTdRYURPVU15QzBXYjgrZ1hqdVI0RjVKNllzYVhuRmhCb0FHRVZ2VWhiNjBqSVNnQ1Fub2gvT0xCZ3ZJckw4djdEZEZrRVlNNWR0Tmc5N3R2ejV6SnF6ZGZJQm1KbFBsNXNQK0RKUDV4dFc3eGZmbnplaDdIK1orMytScGt5V1QxWXh1VVJKWVZ0eDZUMGZDVG9jb3VRVjg1VmtIUklHZWdFdUV2L1lLcGtBL0pjZVZtTDhrdjZ0NS85cHU2MnRmaVBXY0ZRVkVhMERaOVdjTEpFUHdNeDh1dmZualQ5SWdaeWo5NHQvbGRlQS9TOXRNYUdhOVNOZG1zSXhidlZzY1ZKMUdTY29NdDRVUHdoQXNtTVowYVh6UUJzdmRHUkJqUXowRlVwRUpSQUpRT3E0S0FuQmR6K3NmaVBKM2JPWW44ZnN5a3lWV01maU4zQk96Y2tTK1FETXpLZTdPVy84OGFxUXpzZkU1a0gxZnZHamVRMHdBRG9kbVZHd09laU1zVXFIckdPblM0VUZ5OVAvd0FFb2prRW5JK0lxT0lKUU5MZ3BDWGhjbUxBdEQvRCtrZ1FFMjM1TDkzdGorWUJxZ1RYOUJpQ2VXL05lZFQ0QW1RK1lrVS8zc2J6eEJ5bVF1WmhtOGcxVCtRYlYrd1dGZGpLTy9UZTJtRUZObENiNmdQRjcwOFZKMVRYSGdLZDkxR25acERmaTFrL2dNMnZxVTNEVW5DdUJtTlFlM1A5dnc2cGUyMjlLT3ZCMEsxaytaUytybnJmTTJBbEEzSk1adGFoL0VaS1pUM2RyeHVEejFPL3l4QXd1OUpnSnhyM2xRZlIrOGFhOEJ1eS93ZFdRWkFWbCtaekNyRzNxOWMvWXJrbUh5M0lSWXJ5QUFxQWtFQklsb3BKeE5OVWJFUitmQS9IKy8rQUFkUDlQbVM5ZGF6aWNKeWJtN21sQjhuUjJkSTFIdmdWa09sWkdQdDJuTTI5R0NhbWNHWmpBd2xRK3Z2clYrOFgvekdzQUFVaUxWUHAvd2QremFUTUZXdysva0FBMEdRUW5wQ3c1bURzQU1JcmNSQjVtQy8rTUFmZlR3Z2Z3S1kyS2ZtQ1o2WklrVVNocnhYeEJYNHlZYVY4SHptY24xM2pVQThDTWZEcVdZZVFjU2toVk9sOFU2dXhIN3hla3JzZzQ5aDhvaUNFTmdDNVRVRzV2S3h4VDhmMmFSdE90Y0FLUTFzOHNvUHVPVlVJd3BjaE5sRUVJT3lOU0lycnZ2M2h3bmNrV0laUFpzbmJjRHl6VHB2ZzNsVThtcFpRcW96eWZLNzRhajN3QUtoMUxncnNENXRNeGl6L25rR0Qxc0hxL1lORk94a0VBY3VXN29xbVhsaXN1UU9UN1ZWMmp3aS9rVGdqMVJrb1poQmplOFo4M1NDQUVFSlpXMEMzZ2ZmOHRBREN0NFZBU2FXSUJLMEhJOXE4QkY1eVVBTXpJcDh0Tng1Smc5YkI2di9qZERQU1JuczBCV0laZVVpdElvOUloSG1oWFR2ekNQUWRkY2NuWjc2VTFWL0l2QzRTQkNGeWcyNkRGTmc3YysrTWhoYjZxaUNpa1Q3V1ZVbXI2bFluMm5SS3lyZFo1MUdNQmxaSWMwN0dVQmRNam55NlhDaVVtcEE2ajk0dk1aYmdCTUZvNTUycHUyN1BYQXFYVHlBVVFjaXRPUWpBbTl4WDBOOXBJd0lQbVNDbUg1UXVQcUVSMEw0a0RZZ3A5ek9VTDZmWXhrYlpjRmNleUFyZUFGM0dsVitOUkR3QXo4dWtzblQzamlJTFZTbXBXTmxoTXplK2s5NHZNWmZnR0FQSmVIRGpwQ3JnTTAxVGRyeTlPenZtWUF6QXFMVldJd0VTaHd6YlJ3d1NFbitNcVA2YlFLNXRabFd5aGpDQ0NzQzE5WHY3Z09uQlJiZ3A3Y3UvNUFPeVZqcVZNbUE3NWRKWjluSEYweW9oV05saE14S25TKzBYbU10d0FtRnE0aW1uWWJyRXFOSlBjKzlrZmQ2MlJLaDBPbjhxVjloWFo5YXNrRVBnQWZJNTZ6aW9jVWdWYnpHVDI4bEV0Uk1vS3RnN2xCSHR6bmZaTkErQ1ErWFFXTThrNHVnbFdLL05MWUt6Uys4VTlHUmVYRDBnL1R5dmg0TmUxN1liNFpicjZnNnk3L2FOV2NvUHBqS1JUc0pJYWdzNUlKd2tFQXY2ZW4wNVM2R1VCZlJXc1VFeFp5VlpWUUNRd3JnTjdXZmRkNDFHUEJjeklwOE9EZVhmVFNiQmE2WVl4bFk4L3AzcS91ZGMzQytqVGJ0dnF0Mm9hZG5CMm00b05nTW4wVzBwK2hZV0hXYndnOXlVLzBLYjlFSXkrNXkyaGlDaXQ0VWdLeVRlQWtOOFZhbGs0TGUvbGRsT05SejRBV1dCUk02ZmRJUGZIc3R3L0crU0U1ck1uVlEva0E1QWtMSFMwYWs3VjdyZVhmaGdBQ2FCcUR0RDNlL25tYzVrOWtBL0E4MEpSZXErVTM4ekdWcDNPYkpvL0J2QU9EM2R0d2lXYXI5ekVIc2dISUdsRnVicVN4NytKamEzNmFuTExjRHZ2Z3dBK05EcERmSUx2K3FsenVYd0FYdVNqcmtLZW1sTzJlM1UxdVdVWW5MOGR3Qi81ZTJhcGNhOUxOdit2c1FmeUFVaGVYNFZndUIrbXpJc2FHOW50cXhoRjRYYmUzUUQrbjcvdUhMQVc5d1ExdGJsTVJRL1VBMENhSEM3cGxYRWgrcTRUME9XY2ZobGVZVFNIQkswRUgvbWkrZmNSdUtRbjRJNmZXcGVvQjRBZXZDejNIT09tOXliM0Y1bUJsWkJOY2xZQ2oxYVJmeWZyYmdQQ1RSNkF6Syt2RDRDeWdsWDdqcG1ON0hZNjZkMUUwY3RkSXJFRUU0d0VJTWxhbStQazdZRjZBTWo3RXdBVmJVODJ2VGVyQ3doQVhvcEpOOXpWSStBWXJPZVVMTFpnRXJZMng4blpBL2tBSkdXcjBuYVVXZEZweTJjVCtvQ1dqcGRqTEZ4RTVVellJQkJwRVVYNW5Mbmx2QWt0Yjc2U1BWQWZBT1VIcGlBTW05NmJzVnRDQU1hS0FMSUNNeXhEcTZjWGZ5Y0ErYi9tT0xsNm9GNEFpcUJSSUV6QnA3L1gyQWYwK2ZpMVhJaW9NSWxBSStBSVBJR1BtZVJPV1YzajFadXZ5dTJCK2dIb0ZmWmlEUzJsQzBMaVk1MldVQURrUW9UVE1IMUJGU1lSZEhvUmZLU3U1djlxcml6TUhZUFQrdng2QVJoU3VEY0F6em1EbzVaR0hUMVBBS1lNd1F4TUUyamlTby9nRXdCcnJxK3U0MVpPeSsrb0Q0QmFDY3NYVFBpU0kzZXk4czRLR29HOFF3Q01GTSswZ2dRaExSMEJGMTlTWHVEL2F5YWt6N3VSMC9Uc01jeGczU2pmcVdOQTBoc3JnYS9vamFxLzhXUGNDK1lJazRLZTRDTVN1QjJYVmh0MU9qOHpJZlhsVThCdFU4RGhtWVJYV2RmcmRGMWZncjMrUzhBdDQ4Q0QwNERWalhRU0RPNzBQVFVuYUo1dU9Dd3NJSUZIU1NGeTFwS1BXQ0RzWnhDcHc4VVZnS1NQeExYTTkzN096eHhBbGp6Y1BBYmNzd1U0UWg0VjNVTjhtS29lS20vYnU3OElmS0pRYThWRDQ4Q3lsSFFpTDNPMy9xZzVSZjMwQktBQ010SlhqWEtRY2ZCU0s4RGZxYzNLVkN3dU4yVkZHUm5tL3lLWnRxNFJlNWlmeVFRZ00yQStCZUIzR0hhWkJvNU1BSXVlMGw3S3QzY0M0eGh3KzVlTDdUdUNrSmsxakJ0eWVyYlVmWUc1RXhqWi9wcXJ4RTVmQU9yT3E1U21vd1ZJclJwMUl5VDJSNitmZzBiZ1ZZRzRDc3laZTJVc2FpT0dLWHI0U2ZwOWs4Q3hDWUFGU0t5dlhlWTFvMUJ4UXV4OTF5TXRmc0hQdXRnbm55VXVVdmhjMFpzZ1VYaWIrblZrcTYrWkthQUJJSHNnVlpudXdEOXNWbzY2cnJSNEltZGhMR1NROHpQTC9KZ0JReGVVMW91V2tPOVBUZ0R6YmdtWHhyek1rYXRsM2tlaXZmRzV4NHI0SVJjejVCZmtPNXZFWjBrZ3BJZkJaOHlLamxMMTdzeXkwdE1OY09uOWRsNEZ5NmRMRmFiajFNcHZvdzlJZnkrSTRObG85WHQrWnFVOVZkSnBxWmg0UUREeXhVeVlPWUp3SERnK0RoZ0kvV1VWWmw3YVNFdDkzK0dPOUlhMml1WktPZkE3bGhwOUpwdkFWeTYxdzJtT3dPNWhtQ2dNSEMxSDlPMjRndTZVRDlqUCtabWJ0TFJhU3NlaTlTTDRYRFBiQUVoL2tHUS9wU1VjYzBsYkFwRldiNjdsUVVocFZuTEJzb0txcVpjbEZNbVV0cnhQY3d4bDNYN3ZPQ0F0WUxTQ2N1Z0ZRbXFoZHNzSDdIVStSem5qaU9sWVhBOHdxa09ma0l0VEFvbStvS3lnY2E0RVM4alkrTjN6N2ZTRzRoZlV0cDNpaFVIcnVWU3NGeTFpUnZOUCsxTjdBNUJkSkFDbVZwQWdaUGhHT3lDaWdFamxQTHVkbjdrdkZ0T3h1QjRnNk9qRDhVV0xSa0NaRlJ3ckxDRVhKUVFocDJLKzM3bFFlQkNSWDFBN0tQUXRvMXByRkVtU1luMm1COUVBc08ra1lmazhLUWhaRjh5alZ6NWdwL016dHlPVWppVzliQ1VoRUJoS1JDQ2dTaXM0NXVRL1BoWC94ZkZXTWdPbld1Mmd4QjBURi9vMGtFWi9rQ0RNMVRzKzNSSFlud1ZVTDZYaERGckFzd2ZJQjZ3NlAxTXJUdWxZMHN1bTFWSUNnbEt3Q0VBQ3F2UUZDVUszZ0hjc0ZRQ00vSUxheXFQMWs5SnNoVnFybmNNYWxPWVl2Z2NHQXlDdkl3dW9kOFlCSlFtWnBtR0pleVJ3a0d3NG44akpPSlFOdzNpZExGaE1STkIwU2dBU1RKeUtveS80aWVYQ2VGZkpCVWVWMlNvQWNsRnlSMGJibTFPSFRVaU4wL0RUQXdEN3pRZU01MmRxajhWc0dFa1ZFMmpLZXRHN0FFaFEwZnJKQXY2UkMwdHJDMXNrbCtJV2xOaW5HTGJTYVpnN01jMHhmQThNYmdGMUxRVjF6MDhBMkc4K29NN1BWRjlNczJHVUUwZ1F5cCtMd3UyeWFnTGdSOVphWXBrU3lwUTZhNlEyRENxenBrdmlldFhJRmRvWmZ1aWVHbWNPRDBEZVAwSEViQmhOd1lQbUEvTDh6SlFzQVRBS25ndUVxUytYVHFrRTRZZldXd0NVRlpUa3NZQVl3WmZJQmVOOVR3MGNqT3d1OGdESVpxc29TU3ZoRWVRRGlpR1lGb3lXaVNEUnlwV2dpNjlVUDVzYzVmSWNxdVNDTmVYcWUyWDlaQUhmTTdLaGUycGNPQitBVDQxK2FPNWlSRDNRQUhCRUhkOWN0dWlCQm9BTkVrYmFBdzBBUjlyOXpjVWJBRFlZR0drUE5BQWNhZmMzRjI4QTJHQmdwRDNRQUhDazNkOWN2QUZnZzRHUjlrQUR3SkYyZjNQeEJvQU5Ca2JhQXcwQVI5cjl6Y1ViQURZWUdHa1BOQUFjYWZjM0YyOEEyR0JncEQzUUFIQ2szZDljZk94cVlKMmF1OVJkUHRkcC9raG9FT2xnbERZVDM5VjFQelFGWExzTVhBbGd0OVBDeEpLUGJ1ZnlmOC9LSElQZkJQQVpBQmY3OVhjNVhRMFpRMVE3MzYwTmJ4b0hybHNEdnM1WlJzZ28wdW5lMDZieTZYMW1adnRQOTlQTkFwNEY0THNCWEE1Z2p3OEVHVGVxYUdGNFFoelFGODBDWDdjQXZHSWRlRFlBZmhkWjJzVEtVY1ZycEU3bmQzMU41Z2o4ZTJkSW8yb3NrN05acE1kSzBaMTl0ditiSjRGOUs4RDFBQ2o4eWZOU2lrSGVnKzVaOTY5bTU3WS84L1pQK2RQTEtaaFAvcmNBK0FZQUY3ZzFvUlVoRU1VekZNdDZlU0pmWDc4YjJEa1BmTTBpOEdJQVgrdVdsQU1wcHJlVVVFcm44cDJnelRsKzJmbGcvc0RiVGt2SU9paytDUDIwLy9tendBWHp3RGNDdU5UUEplRlhwRXBNNlFFaklIbS96VEY4RDdUNWdBVFlOUUNlNjlhQWxvUlRHdWxmQkVTQlNZTnl4UjVnL0JodzdoS3dad2w0dms5TG5NNUptc0J6VXlER0FYM0I4RzIzTXovZzlCdVVhLzBJaXV0Zk1rajd6d0ttbmdBdVhTdk9wVXZBV1lCdEY0QlRuc3BJai9POHpQYWY3cWR2V0lUdzZlWkEwSkxRRWhLRUdneFpoVWovZHozTnpTS3diUjQ0ZXhuWXZWS2N5K21NNUttMEpoeEluVXRyR2ttekNQaWNnM1c1TE1Ha1FpWlpUbTl4UzlaMys0bTJvOEM1YzRYMTVwVEtXMkxiK2ZDeDdXTHRqWXh6cWlxbDI5SWN3L2RBNVNxWWY2UlRUaWxnK2xZQ0lYbUlDS1E0SUs5d3hmU0pZOEFaSzhDdUZXRG5hbkV1YTlaVEFNc2FDb2czRHQ5Mk8vTXZuUkdCdEd3a3FLUm1NRWtxQ2FhKzJrKzBMUURUaDRyUDg4VUhqNzRrRjFXYUFUbzlRSFE3bW1QNEh1Z1lodEVLajRQQjZaUStGUzBoUWFocGxkUHlhMWtYVE9xTlk4RHNjZ0crSGF2QXR0VUN2QnhJbml0cmtnTDRsY08zM2M3c3BCZE0za0F1U25xMm54OWdRZkFoNEp5Vnd2cnh3ZWwyejNwNGFNbHpINkRNMnovbFQrOGFCK1EvT1Q0RUVxY2tXUVNCa0dENkVRS1FuRENMd0JTbllnY2YzMmZYaW9HVUZhd0M0ZXN5dTdDWFhuRFA5dE9Dc3lENEtMQjFybWd2WDd6ZmJ1MldHL0p0bWUwLzNVL3ZLeEJOQU1vaTBLY2prQVRDTjNIT0VyM1VBakRyd09QNzFyWGl4WUVrZUtNRmxTWDhvY3dSNktVWFRKN0FhTkUydEY4V2ZBNFllN0t3MW13dlgveVpuK2VLbnZjcmZ6QzZJSy9PYlAvcGZucGZBR1FueVNvSVNCcVVYeUFBU1MxQUswSmZhZ1dZY1JET3JBRjY2VHhaUVU3akJPRWJNMGVnSDcxZ2NnWFNGWkFWNTROUXRqOVljTklwYk9OQ3loOFlnaThDVm9zcEFwRHVCNjNnOTJXMi8zUS92VzhBc3FNNGdMSUtCQklIOGJjSndNQ05NWDY4QlRxQmI4czZzR1d0c0lBNmp3RGs2NjJaSTlDdlhqQTVBNk5WYTJ0L0lBaWNuQy9hR1YrOFQ3NElRUG0vQW1HdUJjKzgvVlArOUlFQXlMc2xBS01WL0xnQXlJVUluZm5qd1BRcU1PT2dJL0RzdFE1TXI3VUFxTUY4VjJZWERxb1hYTmwrRVFRNk45djI5YUtkZXNVcFdKWmJBUHlQbWUwLzNVOGZHSURzc0RpZC9wVUFTQ3ZDYVhnSm1GZ3VBRWZnRVhUMjdnRGt1d2FVZy9uYm1TTXdqRjd3aHZiTGhTREw1VHd3dmRScW85b3FIekFDa0NCOFUyYjdUL2ZUaHdJZ08wMVQxSU1Db0FaeEdSaGJLb0FYUVVjUVRqa0krYTRCNWU1RnpqR3NYdkNHOWdkcXJMR0ZZcnBWRy9VdUh6Qk93Mi9MYVh4emJoNDNES2VvSndsQUhxTG5kU3M0dWRvQ29JQkhRRTQ1RVBrM0R1aXRtWU9Rb3hkY3RwOCtyRndJV3NHRllpRkZvTEdOY2hjRVFDNmUrT0pDNUoyWjdUL2RUeC9hQXBZZEozN0F5SksvREl3dkZ4WXZXcjBJd0VuL0gxT3BjbzVzdmVEVWhTQUFGNEhKcFFKa1dpeHA2azJuNElZZk1HZjBhbURIZXYySTgrbDQvVWJ2Tnc4RW96dzcyd0plUE9KOHVuZDdFa0tqOXp0S0dBMS83V3dBVG80NG40NXBXSTNlNy9BQUdQV1oyUUJrWUhDVStYVE1mR0dRbVlJeGpkN3ZxT0UwK1BYekFUamlmRHJLdFRaNnY0TVAvTWx5Umo0QVI1eFBGK1ZhcVpMSkYxVXpLZFBWNlAyZUxERHIzSTU4QUk0NG4wN1pNQVJiby9kNzhnTXViV0UrQUVlY1Q4ZTlZT24yVWhldTBmczl0VUNZRDhBUjU5TXBHNmJSK3oyMWdLZlcxZ05BejRnZVJUNWRURVpvOUg1UFBSRG1BekJtUk04Qkp6cWZMaVlqU0tLcjBmczlkWUJZRHdCSG1FOVh0UmZNc0l6MDRhUVoxK2o5bnB5Z3JBK0FrcXM4d2ZsMEJDQ1RXUnE5MzVNVFlMMWFWUThBbzF6bEFuQWk4K2tFUUdaVE5YcS92WWI3NVB0L2ZRQWNVVDVkQkdDajkzdnlBYXhYaStvRG9GTHlUM0ErM1JjYXZkOWVZM3hTL3o4ZmdDUVgvTFBSM1NPemtvbjU1amcxZXlBZmdEOE00TmNBUEQ2YURtQnRCMWU0Tk1ETmNlcjFRRDRBYndid3h3RGU0VXZSRTl3SFpHMWdOU1hETGx3TE5jZXAxUVA1QVB4enp3ajlJSUFQblhoVDVPUmM1RVlDQTlITmNXcjFRRDRBbVJINkZRQk1UU1paSDk4Wm1ENUJoNWcxRm9waU5uczF4Nm5UQS9rQXZBZkFFd0R1ZG5JK0V2UXhQZmtFellmYUNYUlNCbHVRTUI3WUhLZEdEK1FEc0JOQkgvOStBa0FvYnFUQURHSzdJbncxeDhuZkEva0E3RVhRdDhrZ3JHQUdNZkJ4WjVDdjVqaTVleUFmZ0wwSStyNjh1UjBRbVVGb0JRVTh2Zk52elhIeTlrQTlBT1JvTXc3Q2RHUUNqb1VaRHdMNGt2Lys4T1oxZ0poQklqR0RnTWgzdlRhdkJjMDM1L1JBUGdEN0plZ2pPRGZoaU13Z29xZUp3TlBQVGFCNkV6cS9ocStzQjRBY1hlWEVQK1poR1ZvOXZSaW1JUUQ1djVvUEFaQ3VwZ0RJOXdnOC9xei8xWHo1NXVzeWV5QWZnTU1ROUdVMk9wNGVBY2hwT0lKUVFFei9WdVBsbTYvSzdJSDZBTWpnR3pkbDZRdHlYNWpXanBRRmV2RjNscTN4ZjZ5aHJPbElBVWdRQ29qUjhnbUUrbDlObDIrK0pyTUg2Z0VnUjVVQTVLWXNjK0FabUNiUUNEaStJdmdFUU1vYjFYQkVBSElhamdCTUxWKzBrQ2R3czZhR3UzenFma1Y5QUdUd2pmdGczSlJWVlJBdEhRRVhYL3diQWNvWFA1ZDVDSUQ4R29KS3ZxREFsb0tPb0l6L3k3eDhjM3BtRDR6aGFxd2pSekNZeVFnNWdyMlpnc0ZUTHdlV3I4WFFnc1hqYndMV3JuTnRNbEtnTm9MQm1aQWE3UFRDQXVZSUJsTXZsV1Fzd3dyMlVsVXc0NWpkRFN4OEhiRCtDdGQrSFZDd2VQS2JnSlY5YUFTRE04WWc1OVRXRkR5c1lQQnRtWUs5MUliTk9IYVBBL003Z1VYS1hBNGhXRHo3OWNBOCtXMGF3ZUNNVVJqKzFIWWZjQmpCWU81NE1NWTN0R0R2OEkzbm1XU0hPellPTEowTExQR1hBUVdMejNvQjhNUVVzRWExNmtZd09HOHdoamg3NHlKa1VNRmdic05sQ2ZZTzBlcHdpc3NWWTM0YnNIdzJzRUlSa0FFRWkvZGNVMFNQNXFoRjFnZ0c1dzNHRUdkWHI0TDUxMzRGZzRrQWp1RFFncjFEdERxY1VtWkVUd0FyWndBcnU0QlZxc3YwS1ZoOC9vM0Y0djBRWFpCR01EaHZNSVk0dTNNWWh2OTVaaCtDdTF4QmN4dU9VL0hmZURJcTVjdjdGdXdkb3RYaGxDQlhqT1haQW55ck80QlY2aW4wSVZoOHdTdEx1V0NzVUF5dkVRek9HNUFCeis0ZUIrUi9ld251L2tPUC8zRy9sNGtKVEVSbGxqUXRJb3QyZTUzL0l3TzJPUGw0Rkx0Y25DcUFwOWNhaFQ1NkNCWmYrTHBTTGhoejFONXFCSVB6Qm1UQXMvc0xSSGNUREtiaU5IZEJHR3ltT0MvM2hnbEV2Z2pBbm9LOUE3WTQrWGdpVjR6VldZREFzL2V0eGF1YllQRkZQMVFrTHRDSVA4bmVhQVNEOHdaa3dMUDdBeUMvdEpOZzhML3hMTkJ1K1lCZEJYc0hiSEVGQUlOY01WYW1nZFdaQW9ScmZQZFhtOEtpdExkbWdZdmVXQXErMnk3aU1xZnVSakE0YjFBR09MdC9BUEpMcXdTRDMreTVUMXlJMEFvU2JBeE1NekdWMW84L015MnJvMkR2QUsydCtHZ2lWNHpqNCszQUl3RFh0d0JyVkpldUVDemUrOWFXNER1dDRQeGtJaFlzZGV0R01EaHZvRHFjUFJnQStTV3A0TzR2ZVE1VXYvbUFHd1I3OCs2clFxNFlxOVBBT2kyZkE0L3ZCa0t1ZEtWVTdWWnc3N3VLdldGdVpidGNNTmI1djBZd09HOWcrang3Y0FEeWk2UGc3Z2NjZ0l4bGNBNVRLaGFEMDF5WUtCbVZGcEJaTWZ4L20yQnZueTN0OExHcW9xVGxpWmJWSStnTWdId25NQW5DSUZpODk3Y0xBQVo2UXl6Rnp6U0N3WGtEMU9QczRRRElMNVhnTG1rNUpIay9TRDVnS2RpYmQzOFZjc1ZZR211QlRhQXpFSExIZ3lDY2Fva0I3LzFJa1VFVDVJS3h3RjVwQklQekJxYlBzNGNISUMvQWFlcXZQTDlwbUh4QUUrenRzNlZkTENEL2xjZ1ZZM1V5V0QwQmoxWndxZ0NnZ1hBN3NQZldBb0FKdmFFdFpCckI0THl4NmVmc1BBRHlDdG1DdmYwMHMvTm5Pc2dWWTNtOEJUUlpQWnVHQlVBQ2RBclkrNWxXRHFHbVliSXJMSEV4MGdnRzV3MU9IMmZuQTdDUGl6UWZhWHFnVXc4MEFHeXdNZEllYUFBNDB1NXZMdDRBc01IQVNIdWdBZUJJdTcrNWVBUEFCZ01qN1lFR2dDUHQvdWJpRFFBYkRJeTBCeG9BanJUN200czNBR3d3TU5JZWFBQTQwdTV2THQ0QXNNSEFTSHVnQWVCSXU3KzVlQVBBQmdNajdZRUdnQ1B0L3ViaURRQWJESXkwQjhaWU5NYmtYK1pla3B1SWlPUXJQYXIreHM4ODlISmc2alpnNWpBd3ZWWjhCK2xsOVBsTzUvRmMvbytFQ2puSGZpOHpZZmt2TTV1bG1wNHFKWFZxeDVkZUQ0emZBa3cvQ0d4ZEFaZ29IZnVoMTMxUWthSTVodThCczREczhCMEFXTG5JUkdDQnNGZm44N0pmZkRNd2RqT3c1UjVnOGdpd1phMzRqblFRVXdEbzk5d0JmSjRUTTdDT2lOZGxhajJyQS9qZVYvdmZEZUFUQVA0VUdIOEkyTHJjNmdjK1NIcVk0b01aNzRWU0tNMHhmQStVVXpCL29CVVVDS01sNnpTUS9Qc1hxWkQ1S1FDL0Ewdy9ERXdjQWNZWGdZblZ3cHB3QUR1QmtlZm5DaW05MEZtQldYd25LODdVZW41M0JJOHNidXdxYXo5cDVVZ25RaEJTK1pOMXpFOEFrMHV0dmlDd3E4REk4L254NWhpK0J6YjRnSnpLWkUxU0VGWlpnUzkvMnBXUi9nVEFKNEhKUThERU1XQjhBUmhmQnNhV0N3RHF1d1FLdnZOZ0hYdk9jWVZiUEZKUGt3K2REeEMvVzFZNHRXRHB3L1JsZ280bG8xVDQvS3hUaWhETnBKd2ozL1VpTUxYZW1wcmpmZkM3ZVdwekROOERsWXNRRGlLdFZ4ekVxb0hreVg5SFJpelcrbklnYVFudkFpYWVCQ2JtQzBzNHRnU011MnJNZVBBUjlYMjUyalhrbGFURlUxMDhLME1IYXYvbnZKNlp4VlZrOU9JN0dSMklab0dRTmMvSGdiSGdJd3FJTElWdWp1RjdvT01xV0Zhd0NvUnhrZkVJQjVDV2drUkVCQ05mOXdNVGM4QTRRY2lCV3lvR3oxNnJ3TmdhTUw1ZVdLcGN0WVpMM04rVFdMWDBndnR1UDBISGsybjE2SkR5eFhtVmhmVTBxeXdiSmJyNUdTdVhLeEEvc1Y1WTlVWVdkbmp3eVMzcUtLZ2FyV0E2OVdnNmZqUU9JSzBIYWRuSWpQVkZCK0FpTUU0QXVpVWtDRm5FU3lDU2ttQXVVN0NqbTE1d1grMlgyaWZCUm45QThtS2NXMlVGalVMVlFjZ1ZEbDgwdTQwU1loNzYzRmZ2cXVoTEN4aXRvQllVc29KZmpYS3R0QnlNcTlDS2NIbjRzUHVDYmdYTkp3eVdrRUNjejVRMzc2VVgzTE5uY1p5UUFBQURFa2xFUVZUOWZGZ0lKczZsQkJ3dG4zVHQ2RnBJejRSV251UXhQaDJYSUd6bTRDd1E5aFdJRmdCVEswZ1FIaUlBSmRkS3EwRUxRaCtLTDFxVVI0TXZTRXNvRU5JS3JnQUxITmlNb3grOTRLN3RsOXFubk1pbzhNU2Y2U053R3BZVmpDRGsvSnU3aXNxNDk2ZkNxWDBCa0RlcWxXd0t3aWMxZ0FRU3B6R1JFbkZnUkV6MDFlQUxMdnZxMktmaTQ1bTZjZjNxQlhkc2Z4UmJKTWhvOGRpbXFPaEVLOGNYUVJyOVFWcHZQb0ROTVhRUDlBM0FDRUxGeFBoK2pBQ2tQMGZMSUtGQ0NSUnFLdVBVZHFqbEM5bzA3Slp3S1ZOSGVCQzk0RFFjWk8wWEFBa21nb3RBazlRWXJSOWYvQnZCeVlmTVNBVERWTXp3VFhNTTNRTURBVkFnVkhDWjcvTWFRSzRRWlVIaU5DYkJRbHFVdzc0WUNiN2djbVlrZWxDOVlGbHd2VnY3UlJBb3JUdUJrRUNVOWFzQ0lEOS94OUI5MzV6WXp5S2txcGZpTkh4Y0EwZ0xRZ3ZCQWFQVmtDcW0zaDJBdEM1bS9SeUVxencvNHhoR0wzaEQrK01tc2xncUNiZ1VmTEtBY1JybVRsQnpETjBEQTF0QVhVbFdjRG0xSU9JSUpBamxUL0ZkMDVsYkZRRndqZHRnR2Nld2VzRnQ3UmMvR3g4aVdqVUNqR0NUMVl2V1QxTXdnVXFyZjNORzQ1dFRiY3UwYXhpbVd4OXhFTmNFUUhHYmNZQUV3dFNYU3FZMGduQ2RnZXVNSTBjdnVHeC9GVUdnRmh3RVlyUjgwUWNrV04rWDBmam0xRHdBV3Y4UmdKRmlsSlpCem56MHBRZytBWkFBbFZXaDFHdkdrYTBYekIwY0NRaTMwYVNHVmE5QUY2MmZMT0I3TWhyZm5Kb1B3UEVSNTlQeCtvM2U3Nm1MNUt3cDJHNTd4UGwwa3hjM2VyK25MdnlLdExtaGZVQzc4UkhuMDgxT05ucS9wemNBUjV4UFI5bVJSdS8zMUlWZ3ZnVWNjVDRkTmFvYnZkL1RHWUFqenFlanVtcWo5M3M2QTNERStYUlVnMlZTQ2pkYUdyM2ZVdytJK1ZQd2lQUHBxSmpPOEoxTnc0M2U3eW1Id0hvQUtNRmQ3UUVyQWVFRTVOTkpNYjNSK3ozbHNHY056Z2ZnaVBQcG9tSjZvL2Q3Nm9Hd1BnQ09LSjh1S3FZM2VyK25Ld0JIbUUrbm9xUkc3L2ZVQTE5OVUvQUk4K2tFd0VidjkzUUhvRWhaVG5BK25ZcVNHcjNmQm9BdGFpcUJVSW1kbTVoUEp3QTJlcituS3dCSG5FK1gxZ1V6U2JuUit6MTF3UGovQWVDcFBERDN0N3J2QUFBQUFFbEZUa1N1UW1DQ1wiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NtYWEuZnJhZ1xudmFyIHNtYWFfZGVmYXVsdCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgd2VpZ2h0TWFwO3ZhcnlpbmcgdmVjMiB2T2Zmc2V0MDt2YXJ5aW5nIHZlYzIgdk9mZnNldDE7dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjMiBjLGlub3V0IHZlYzIgdmFyaWFibGUsY29uc3QgaW4gdmVjMiB2YWx1ZSl7aWYoYy54KXt2YXJpYWJsZS54PXZhbHVlLng7fWlmKGMueSl7dmFyaWFibGUueT12YWx1ZS55O319dm9pZCBtb3ZlYyhjb25zdCBpbiBidmVjNCBjLGlub3V0IHZlYzQgdmFyaWFibGUsY29uc3QgaW4gdmVjNCB2YWx1ZSl7bW92ZWMoYy54eSx2YXJpYWJsZS54eSx2YWx1ZS54eSk7bW92ZWMoYy56dyx2YXJpYWJsZS56dyx2YWx1ZS56dyk7fXZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXt2ZWM0IGE7YS54PXRleHR1cmUyRCh3ZWlnaHRNYXAsdk9mZnNldDApLmE7YS55PXRleHR1cmUyRCh3ZWlnaHRNYXAsdk9mZnNldDEpLmc7YS53ej10ZXh0dXJlMkQod2VpZ2h0TWFwLHV2KS5yYjt2ZWM0IGNvbG9yPWlucHV0Q29sb3I7aWYoZG90KGEsdmVjNCgxLjApKT49MWUtNSl7Ym9vbCBoPW1heChhLngsYS56KT5tYXgoYS55LGEudyk7dmVjNCBibGVuZGluZ09mZnNldD12ZWM0KDAuMCxhLnksMC4wLGEudyk7dmVjMiBibGVuZGluZ1dlaWdodD1hLnl3O21vdmVjKGJ2ZWM0KGgpLGJsZW5kaW5nT2Zmc2V0LHZlYzQoYS54LDAuMCxhLnosMC4wKSk7bW92ZWMoYnZlYzIoaCksYmxlbmRpbmdXZWlnaHQsYS54eik7YmxlbmRpbmdXZWlnaHQvPWRvdChibGVuZGluZ1dlaWdodCx2ZWMyKDEuMCkpO3ZlYzQgYmxlbmRpbmdDb29yZD1ibGVuZGluZ09mZnNldCp2ZWM0KHRleGVsU2l6ZSwtdGV4ZWxTaXplKSt1di54eXh5O2NvbG9yPWJsZW5kaW5nV2VpZ2h0LngqdGV4dHVyZTJEKGlucHV0QnVmZmVyLGJsZW5kaW5nQ29vcmQueHkpO2NvbG9yKz1ibGVuZGluZ1dlaWdodC55KnRleHR1cmUyRChpbnB1dEJ1ZmZlcixibGVuZGluZ0Nvb3JkLnp3KTt9b3V0cHV0Q29sb3I9Y29sb3I7fVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NtYWEudmVydFxudmFyIHNtYWFfZGVmYXVsdDIgPSBcInZhcnlpbmcgdmVjMiB2T2Zmc2V0MDt2YXJ5aW5nIHZlYzIgdk9mZnNldDE7dm9pZCBtYWluU3VwcG9ydChjb25zdCBpbiB2ZWMyIHV2KXt2T2Zmc2V0MD11dit0ZXhlbFNpemUqdmVjMigxLjAsMC4wKTt2T2Zmc2V0MT11dit0ZXhlbFNpemUqdmVjMigwLjAsMS4wKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1NNQUFFZmZlY3QuanNcbnZhciBTTUFBRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb249QmxlbmRGdW5jdGlvbi5TUkNdIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge1NNQUFQcmVzZXR9IFtvcHRpb25zLnByZXNldD1TTUFBUHJlc2V0Lk1FRElVTV0gLSBUaGUgcXVhbGl0eSBwcmVzZXQuXG4gICAqIEBwYXJhbSB7RWRnZURldGVjdGlvbk1vZGV9IFtvcHRpb25zLmVkZ2VEZXRlY3Rpb25Nb2RlPUVkZ2VEZXRlY3Rpb25Nb2RlLkNPTE9SXSAtIFRoZSBlZGdlIGRldGVjdGlvbiBtb2RlLlxuICAgKiBAcGFyYW0ge1ByZWRpY2F0aW9uTW9kZX0gW29wdGlvbnMucHJlZGljYXRpb25Nb2RlPVByZWRpY2F0aW9uTW9kZS5ESVNBQkxFRF0gLSBUaGUgcHJlZGljYXRpb24gbW9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgcHJlc2V0ID0gU01BQVByZXNldC5NRURJVU0sXG4gICAgZWRnZURldGVjdGlvbk1vZGUgPSBFZGdlRGV0ZWN0aW9uTW9kZS5DT0xPUixcbiAgICBwcmVkaWNhdGlvbk1vZGUgPSBQcmVkaWNhdGlvbk1vZGUuRElTQUJMRURcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJTTUFBRWZmZWN0XCIsIHNtYWFfZGVmYXVsdCwge1xuICAgICAgdmVydGV4U2hhZGVyOiBzbWFhX2RlZmF1bHQyLFxuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5DT05WT0xVVElPTiB8IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIndlaWdodE1hcFwiLCBuZXcgVW5pZm9ybTQ1KG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICBsZXQgc2VhcmNoSW1hZ2UsIGFyZWFJbWFnZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlYXJjaEltYWdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgYXJlYUltYWdlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHByZXNldCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICBlZGdlRGV0ZWN0aW9uTW9kZSA9IGFyZ3VtZW50c1szXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIwKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMudGV4dHVyZS5uYW1lID0gXCJTTUFBLkVkZ2VzXCI7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzID0gdGhpcy5yZW5kZXJUYXJnZXRFZGdlcy5jbG9uZSgpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlLm5hbWUgPSBcIlNNQUEuV2VpZ2h0c1wiO1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwid2VpZ2h0TWFwXCIpLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLnRleHR1cmU7XG4gICAgdGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdGhpcy5jbGVhclBhc3Mub3ZlcnJpZGVDbGVhckNvbG9yID0gbmV3IENvbG9yOCgwKTtcbiAgICB0aGlzLmNsZWFyUGFzcy5vdmVycmlkZUNsZWFyQWxwaGEgPSAxO1xuICAgIHRoaXMuZWRnZURldGVjdGlvblBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgRWRnZURldGVjdGlvbk1hdGVyaWFsKCkpO1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25Nb2RlID0gZWRnZURldGVjdGlvbk1vZGU7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWwucHJlZGljYXRpb25Nb2RlID0gcHJlZGljYXRpb25Nb2RlO1xuICAgIHRoaXMud2VpZ2h0c1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgU01BQVdlaWdodHNNYXRlcmlhbCgpKTtcbiAgICBjb25zdCBsb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcjIoKTtcbiAgICBsb2FkaW5nTWFuYWdlci5vbkxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hUZXh0dXJlID0gbmV3IFRleHR1cmUzKHNlYXJjaEltYWdlKTtcbiAgICAgIHNlYXJjaFRleHR1cmUubmFtZSA9IFwiU01BQS5TZWFyY2hcIjtcbiAgICAgIHNlYXJjaFRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjg7XG4gICAgICBzZWFyY2hUZXh0dXJlLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI4O1xuICAgICAgc2VhcmNoVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHNlYXJjaFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgc2VhcmNoVGV4dHVyZS5mbGlwWSA9IHRydWU7XG4gICAgICB0aGlzLndlaWdodHNNYXRlcmlhbC5zZWFyY2hUZXh0dXJlID0gc2VhcmNoVGV4dHVyZTtcbiAgICAgIGNvbnN0IGFyZWFUZXh0dXJlID0gbmV3IFRleHR1cmUzKGFyZWFJbWFnZSk7XG4gICAgICBhcmVhVGV4dHVyZS5uYW1lID0gXCJTTUFBLkFyZWFcIjtcbiAgICAgIGFyZWFUZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjU7XG4gICAgICBhcmVhVGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI1O1xuICAgICAgYXJlYVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICBhcmVhVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBhcmVhVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGhpcy53ZWlnaHRzTWF0ZXJpYWwuYXJlYVRleHR1cmUgPSBhcmVhVGV4dHVyZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwibG9hZFwiIH0pO1xuICAgIH07XG4gICAgbG9hZGluZ01hbmFnZXIuaXRlbVN0YXJ0KFwic2VhcmNoXCIpO1xuICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1TdGFydChcImFyZWFcIik7XG4gICAgaWYgKHNlYXJjaEltYWdlICE9PSB2b2lkIDAgJiYgYXJlYUltYWdlICE9PSB2b2lkIDApIHtcbiAgICAgIGxvYWRpbmdNYW5hZ2VyLml0ZW1FbmQoXCJzZWFyY2hcIik7XG4gICAgICBsb2FkaW5nTWFuYWdlci5pdGVtRW5kKFwiYXJlYVwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBJbWFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc2VhcmNoSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcInNlYXJjaFwiKSk7XG4gICAgICBhcmVhSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gbG9hZGluZ01hbmFnZXIuaXRlbUVuZChcImFyZWFcIikpO1xuICAgICAgc2VhcmNoSW1hZ2Uuc3JjID0gc2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gICAgICBhcmVhSW1hZ2Uuc3JjID0gYXJlYUltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICAgIH1cbiAgICB0aGlzLmFwcGx5UHJlc2V0KHByZXNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlcyB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICovXG4gIGdldCBlZGdlc1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0RWRnZXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRnZXMgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VzVGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldEVkZ2VzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlc1RleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIHdlaWdodHMgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgd2VpZ2h0c1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIHdlaWdodHMgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodHNUZXh0dXJlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0V2VpZ2h0c1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0c1RleHR1cmU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge0VkZ2VEZXRlY3Rpb25NYXRlcmlhbH1cbiAgICovXG4gIGdldCBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvblBhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZWRnZSBkZXRlY3Rpb24gbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtFZGdlRGV0ZWN0aW9uTWF0ZXJpYWx9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgaW5zdGVhZC5cbiAgICovXG4gIGdldCBjb2xvckVkZ2VzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGdlIGRldGVjdGlvbiBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtFZGdlRGV0ZWN0aW9uTWF0ZXJpYWx9IFRoZSBtYXRlcmlhbC5cbiAgICovXG4gIGdldEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBlZGdlIHdlaWdodHMgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtTTUFBV2VpZ2h0c01hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IHdlaWdodHNNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHRzUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkZ2Ugd2VpZ2h0cyBtYXRlcmlhbC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHdlaWdodHNNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtTTUFBV2VpZ2h0c01hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRXZWlnaHRzTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMud2VpZ2h0c01hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlZGdlIGRldGVjdGlvbiBzZW5zaXRpdml0eS5cbiAgICpcbiAgICogU2VlIHtAbGluayBFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwjc2V0RWRnZURldGVjdGlvblRocmVzaG9sZH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIGVkZ2UgZGV0ZWN0aW9uIHNlbnNpdGl2aXR5LiBSYW5nZTogWzAuMDUsIDAuNV0uXG4gICAqL1xuICBzZXRFZGdlRGV0ZWN0aW9uVGhyZXNob2xkKHRocmVzaG9sZCkge1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gYW1vdW50IG9mIGhvcml6b250YWwvdmVydGljYWwgc2VhcmNoIHN0ZXBzLlxuICAgKlxuICAgKiBTZWUge0BsaW5rIFNNQUFXZWlnaHRzTWF0ZXJpYWwjc2V0T3J0aG9nb25hbFNlYXJjaFN0ZXBzfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugd2VpZ2h0c01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwcyAtIFRoZSBzZWFyY2ggc3RlcHMuIFJhbmdlOiBbMCwgMTEyXS5cbiAgICovXG4gIHNldE9ydGhvZ29uYWxTZWFyY2hTdGVwcyhzdGVwcykge1xuICAgIHRoaXMud2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IHN0ZXBzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBxdWFsaXR5IHByZXNldC5cbiAgICpcbiAgICogQHBhcmFtIHtTTUFBUHJlc2V0fSBwcmVzZXQgLSBUaGUgcHJlc2V0LlxuICAgKi9cbiAgYXBwbHlQcmVzZXQocHJlc2V0KSB7XG4gICAgY29uc3QgZWRnZURldGVjdGlvbk1hdGVyaWFsID0gdGhpcy5lZGdlRGV0ZWN0aW9uTWF0ZXJpYWw7XG4gICAgY29uc3Qgd2VpZ2h0c01hdGVyaWFsID0gdGhpcy53ZWlnaHRzTWF0ZXJpYWw7XG4gICAgc3dpdGNoIChwcmVzZXQpIHtcbiAgICAgIGNhc2UgU01BQVByZXNldC5MT1c6XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4xNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDQ7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5kaWFnb25hbERldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTTUFBUHJlc2V0Lk1FRElVTTpcbiAgICAgICAgZWRnZURldGVjdGlvbk1hdGVyaWFsLmVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5vcnRob2dvbmFsU2VhcmNoU3RlcHMgPSA4O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU01BQVByZXNldC5ISUdIOlxuICAgICAgICBlZGdlRGV0ZWN0aW9uTWF0ZXJpYWwuZWRnZURldGVjdGlvblRocmVzaG9sZCA9IDAuMTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDE2O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxTZWFyY2hTdGVwcyA9IDg7XG4gICAgICAgIHdlaWdodHNNYXRlcmlhbC5jb3JuZXJSb3VuZGluZyA9IDI1O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxEZXRlY3Rpb24gPSB0cnVlO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNQUFQcmVzZXQuVUxUUkE6XG4gICAgICAgIGVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5lZGdlRGV0ZWN0aW9uVGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLm9ydGhvZ29uYWxTZWFyY2hTdGVwcyA9IDMyO1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuZGlhZ29uYWxTZWFyY2hTdGVwcyA9IDE2O1xuICAgICAgICB3ZWlnaHRzTWF0ZXJpYWwuY29ybmVyUm91bmRpbmcgPSAyNTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmRpYWdvbmFsRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgd2VpZ2h0c01hdGVyaWFsLmNvcm5lckRldGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVwdGggdGV4dHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBBIGRlcHRoIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RGVwdGhQYWNraW5nU3RyYXRlZ2llc30gW2RlcHRoUGFja2luZz1CYXNpY0RlcHRoUGFja2luZ10gLSBUaGUgZGVwdGggcGFja2luZy5cbiAgICovXG4gIHNldERlcHRoVGV4dHVyZShkZXB0aFRleHR1cmUsIGRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nMTcpIHtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLmVkZ2VEZXRlY3Rpb25NYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIHRoaXMuY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcyk7XG4gICAgdGhpcy5lZGdlRGV0ZWN0aW9uUGFzcy5yZW5kZXIocmVuZGVyZXIsIGlucHV0QnVmZmVyLCB0aGlzLnJlbmRlclRhcmdldEVkZ2VzKTtcbiAgICB0aGlzLndlaWdodHNQYXNzLnJlbmRlcihyZW5kZXJlciwgdGhpcy5yZW5kZXJUYXJnZXRFZGdlcywgdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZWRnZURldGVjdGlvbk1hdGVyaWFsLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy53ZWlnaHRzTWF0ZXJpYWwuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEVkZ2VzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgaW50ZXJuYWwgcmVuZGVyIHRhcmdldHMgYW5kIHRleHR1cmVzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB7IHNlYXJjaFRleHR1cmUsIGFyZWFUZXh0dXJlIH0gPSB0aGlzLndlaWdodHNNYXRlcmlhbDtcbiAgICBpZiAoc2VhcmNoVGV4dHVyZSAhPT0gbnVsbCAmJiBhcmVhVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgc2VhcmNoVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICBhcmVhVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIFNNQUEgc2VhcmNoIGltYWdlLCBlbmNvZGVkIGFzIGEgYmFzZTY0IGRhdGEgVVJMLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIGdldCBzZWFyY2hJbWFnZURhdGFVUkwoKSB7XG4gICAgcmV0dXJuIHNlYXJjaEltYWdlRGF0YVVSTF9kZWZhdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgU01BQSBhcmVhIGltYWdlLCBlbmNvZGVkIGFzIGEgYmFzZTY0IGRhdGEgVVJMLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIGdldCBhcmVhSW1hZ2VEYXRhVVJMKCkge1xuICAgIHJldHVybiBhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1NTQU9FZmZlY3QuanNcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIGFzIEJhc2ljRGVwdGhQYWNraW5nMTgsIENvbG9yIGFzIENvbG9yOSwgUmVwZWF0V3JhcHBpbmcgYXMgUmVwZWF0V3JhcHBpbmczLCBSR0JBRm9ybWF0IGFzIFJHQkFGb3JtYXQ0LCBVbmlmb3JtIGFzIFVuaWZvcm00NiwgV2ViR0xSZW5kZXJUYXJnZXQgYXMgV2ViR0xSZW5kZXJUYXJnZXQyMSB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3NzYW8uZnJhZ1xudmFyIHNzYW9fZGVmYXVsdDMgPSBcInVuaWZvcm0gbG93cCBzYW1wbGVyMkQgYW9CdWZmZXI7dW5pZm9ybSBmbG9hdCBsdW1pbmFuY2VJbmZsdWVuY2U7dW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XFxuI2lmIFRIUkVFX1JFVklTSU9OIDwgMTQzXFxuI2RlZmluZSBsdW1pbmFuY2UodikgbGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZSh2KVxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKERFUFRIX0FXQVJFX1VQU0FNUExJTkcpICYmIGRlZmluZWQoTk9STUFMX0RFUFRIKVxcbiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIG5vcm1hbERlcHRoQnVmZmVyO1xcbiNlbHNlXFxudW5pZm9ybSBtZWRpdW1wIHNhbXBsZXIyRCBub3JtYWxEZXB0aEJ1ZmZlcjtcXG4jZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgQ09MT1JJWkVcXG51bmlmb3JtIHZlYzMgY29sb3I7XFxuI2VuZGlmXFxudm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsY29uc3QgaW4gZmxvYXQgZGVwdGgsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IGFvTGluZWFyPXRleHR1cmUyRChhb0J1ZmZlcix1dikucjtcXG4jaWYgZGVmaW5lZChERVBUSF9BV0FSRV9VUFNBTVBMSU5HKSAmJiBkZWZpbmVkKE5PUk1BTF9ERVBUSCkgJiYgX19WRVJTSU9OX18gPT0gMzAwXFxudmVjNCBub3JtYWxEZXB0aFs0XTtub3JtYWxEZXB0aFswXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDAsMCkpO25vcm1hbERlcHRoWzFdPXRleHR1cmVPZmZzZXQobm9ybWFsRGVwdGhCdWZmZXIsdXYsaXZlYzIoMCwxKSk7bm9ybWFsRGVwdGhbMl09dGV4dHVyZU9mZnNldChub3JtYWxEZXB0aEJ1ZmZlcix1dixpdmVjMigxLDApKTtub3JtYWxEZXB0aFszXT10ZXh0dXJlT2Zmc2V0KG5vcm1hbERlcHRoQnVmZmVyLHV2LGl2ZWMyKDEsMSkpO2Zsb2F0IGRvdDAxPWRvdChub3JtYWxEZXB0aFswXS5yZ2Isbm9ybWFsRGVwdGhbMV0ucmdiKTtmbG9hdCBkb3QwMj1kb3Qobm9ybWFsRGVwdGhbMF0ucmdiLG5vcm1hbERlcHRoWzJdLnJnYik7ZmxvYXQgZG90MDM9ZG90KG5vcm1hbERlcHRoWzBdLnJnYixub3JtYWxEZXB0aFszXS5yZ2IpO2Zsb2F0IG1pbkRvdD1taW4oZG90MDEsbWluKGRvdDAyLGRvdDAzKSk7ZmxvYXQgcz1zdGVwKFRIUkVTSE9MRCxtaW5Eb3QpO2Zsb2F0IHNtYWxsZXN0RGlzdGFuY2U9MS4wO2ludCBpbmRleDtmb3IoaW50IGk9MDtpPDQ7KytpKXtmbG9hdCBkaXN0YW5jZT1hYnMoZGVwdGgtbm9ybWFsRGVwdGhbaV0uYSk7aWYoZGlzdGFuY2U8c21hbGxlc3REaXN0YW5jZSl7c21hbGxlc3REaXN0YW5jZT1kaXN0YW5jZTtpbmRleD1pO319aXZlYzIgb2Zmc2V0c1s0XTtvZmZzZXRzWzBdPWl2ZWMyKDAsMCk7b2Zmc2V0c1sxXT1pdmVjMigwLDEpO29mZnNldHNbMl09aXZlYzIoMSwwKTtvZmZzZXRzWzNdPWl2ZWMyKDEsMSk7aXZlYzIgY29vcmQ9aXZlYzIodXYqdmVjMih0ZXh0dXJlU2l6ZShhb0J1ZmZlciwwKSkpK29mZnNldHNbaW5kZXhdO2Zsb2F0IGFvTmVhcmVzdD10ZXhlbEZldGNoKGFvQnVmZmVyLGNvb3JkLDApLnI7ZmxvYXQgYW89bWl4KGFvTmVhcmVzdCxhb0xpbmVhcixzKTtcXG4jZWxzZVxcbmZsb2F0IGFvPWFvTGluZWFyO1xcbiNlbmRpZlxcbmZsb2F0IGw9bHVtaW5hbmNlKGlucHV0Q29sb3IucmdiKTthbz1taXgoYW8sMC4wLGwqbHVtaW5hbmNlSW5mbHVlbmNlKTthbz1jbGFtcChhbyppbnRlbnNpdHksMC4wLDEuMCk7XFxuI2lmZGVmIENPTE9SSVpFXFxub3V0cHV0Q29sb3I9dmVjNCgxLjAtYW8qKDEuMC1jb2xvciksaW5wdXRDb2xvci5hKTtcXG4jZWxzZVxcbm91dHB1dENvbG9yPXZlYzQodmVjMygxLjAtYW8pLGlucHV0Q29sb3IuYSk7XFxuI2VuZGlmXFxufVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9TU0FPRWZmZWN0LmpzXG52YXIgTk9JU0VfVEVYVFVSRV9TSVpFID0gNjQ7XG52YXIgU1NBT0VmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgU1NBTyBlZmZlY3QuXG4gICAqXG4gICAqIEB0b2RvIE1vdmUgbm9ybWFsQnVmZmVyIHRvIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBbY2FtZXJhXSAtIFRoZSBtYWluIGNhbWVyYS5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbbm9ybWFsQnVmZmVyXSAtIEEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHRoZSBzY2VuZSBub3JtYWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLk1VTFRJUExZXSAtIFRoZSBibGVuZCBmdW5jdGlvbiBvZiB0aGlzIGVmZmVjdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXN0YW5jZVNjYWxpbmc9dHJ1ZV0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcHRoQXdhcmVVcHNhbXBsaW5nPXRydWVdIC0gRW5hYmxlcyBvciBkaXNhYmxlcyBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nLiBIYXMgbm8gZWZmZWN0IGlmIFdlYkdMIDIgaXMgbm90IHN1cHBvcnRlZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSBbb3B0aW9ucy5ub3JtYWxEZXB0aEJ1ZmZlcj1udWxsXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzPTldIC0gVGhlIGFtb3VudCBvZiBzYW1wbGVzIHBlciBwaXhlbC4gU2hvdWxkIG5vdCBiZSBhIG11bHRpcGxlIG9mIHRoZSByaW5nIGNvdW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmluZ3M9N10gLSBUaGUgYW1vdW50IG9mIHNwaXJhbCB0dXJucyBpbiB0aGUgb2NjbHVzaW9uIHNhbXBsaW5nIHBhdHRlcm4uIFNob3VsZCBiZSBhIHByaW1lIG51bWJlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkRGlzdGFuY2VUaHJlc2hvbGRdIC0gVGhlIHdvcmxkIGRpc3RhbmNlIHRocmVzaG9sZCBhdCB3aGljaCB0aGUgb2NjbHVzaW9uIGVmZmVjdCBzdGFydHMgdG8gZmFkZSBvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53b3JsZERpc3RhbmNlRmFsbG9mZl0gLSBUaGUgd29ybGQgZGlzdGFuY2UgZmFsbG9mZi4gSW5mbHVlbmNlcyB0aGUgc21vb3RobmVzcyBvZiB0aGUgb2NjbHVzaW9uIGN1dG9mZi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndvcmxkUHJveGltaXR5VGhyZXNob2xkXSAtIFRoZSB3b3JsZCBwcm94aW1pdHkgdGhyZXNob2xkIGF0IHdoaWNoIHRoZSBvY2NsdXNpb24gc3RhcnRzIHRvIGZhZGUgb3V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud29ybGRQcm94aW1pdHlGYWxsb2ZmXSAtIFRoZSB3b3JsZCBwcm94aW1pdHkgZmFsbG9mZi4gSW5mbHVlbmNlcyB0aGUgc21vb3RobmVzcyBvZiB0aGUgcHJveGltaXR5IGN1dG9mZi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlVGhyZXNob2xkPTAuOTddIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlRmFsbG9mZj0wLjAzXSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYW5nZVRocmVzaG9sZD0wLjAwMDVdIC0gRGVwcmVjYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhbmdlRmFsbG9mZj0wLjAwMV0gLSBEZXByZWNhdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUmFkaXVzU2NhbGU9MC4xXSAtIFRoZSBtaW5pbXVtIHJhZGl1cyBzY2FsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmx1bWluYW5jZUluZmx1ZW5jZT0wLjddIC0gRGV0ZXJtaW5lcyBob3cgbXVjaCB0aGUgbHVtaW5hbmNlIG9mIHRoZSBzY2VuZSBpbmZsdWVuY2VzIHRoZSBhbWJpZW50IG9jY2x1c2lvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0wLjE4MjVdIC0gVGhlIG9jY2x1c2lvbiBzYW1wbGluZyByYWRpdXMsIGV4cHJlc3NlZCBhcyBhIHNjYWxlIHJlbGF0aXZlIHRvIHRoZSByZXNvbHV0aW9uLiBSYW5nZSBbMWUtNiwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgYW1iaWVudCBvY2NsdXNpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iaWFzPTAuMDI1XSAtIEFuIG9jY2x1c2lvbiBiaWFzLiBFbGltaW5hdGVzIGFydGlmYWN0cyBjYXVzZWQgYnkgZGVwdGggZGlzY29udGludWl0aWVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFkZT0wLjAxXSAtIEluZmx1ZW5jZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIHNoYWRvd3MuIEEgbG93ZXIgdmFsdWUgcmVzdWx0cyBpbiBoaWdoZXIgY29udHJhc3QuXG4gICAqIEBwYXJhbSB7Q29sb3J9IFtvcHRpb25zLmNvbG9yPW51bGxdIC0gVGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0xLjBdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblggaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBEZXByZWNhdGVkLiBVc2UgcmVzb2x1dGlvblkgaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbWVyYSwgbm9ybWFsQnVmZmVyLCB7XG4gICAgYmxlbmRGdW5jdGlvbiA9IEJsZW5kRnVuY3Rpb24uTVVMVElQTFksXG4gICAgc2FtcGxlcyA9IDksXG4gICAgcmluZ3MgPSA3LFxuICAgIG5vcm1hbERlcHRoQnVmZmVyID0gbnVsbCxcbiAgICBkZXB0aEF3YXJlVXBzYW1wbGluZyA9IHRydWUsXG4gICAgd29ybGREaXN0YW5jZVRocmVzaG9sZCxcbiAgICB3b3JsZERpc3RhbmNlRmFsbG9mZixcbiAgICB3b3JsZFByb3hpbWl0eVRocmVzaG9sZCxcbiAgICB3b3JsZFByb3hpbWl0eUZhbGxvZmYsXG4gICAgZGlzdGFuY2VUaHJlc2hvbGQgPSAwLjk3LFxuICAgIGRpc3RhbmNlRmFsbG9mZiA9IDAuMDMsXG4gICAgcmFuZ2VUaHJlc2hvbGQgPSA1ZS00LFxuICAgIHJhbmdlRmFsbG9mZiA9IDFlLTMsXG4gICAgbWluUmFkaXVzU2NhbGUgPSAwLjEsXG4gICAgbHVtaW5hbmNlSW5mbHVlbmNlID0gMC43LFxuICAgIHJhZGl1cyA9IDAuMTgyNSxcbiAgICBpbnRlbnNpdHkgPSAxLFxuICAgIGJpYXMgPSAwLjAyNSxcbiAgICBmYWRlID0gMC4wMSxcbiAgICBjb2xvcjogY29sb3IyID0gbnVsbCxcbiAgICByZXNvbHV0aW9uU2NhbGUgPSAxLFxuICAgIHdpZHRoID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgaGVpZ2h0ID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblggPSB3aWR0aCxcbiAgICByZXNvbHV0aW9uWSA9IGhlaWdodFxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlNTQU9FZmZlY3RcIiwgc3Nhb19kZWZhdWx0Mywge1xuICAgICAgYmxlbmRGdW5jdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IEVmZmVjdEF0dHJpYnV0ZS5ERVBUSCxcbiAgICAgIGRlZmluZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiVEhSRVNIT0xEXCIsIFwiMC45OTdcIl1cbiAgICAgIF0pLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wiYW9CdWZmZXJcIiwgbmV3IFVuaWZvcm00NihudWxsKV0sXG4gICAgICAgIFtcIm5vcm1hbERlcHRoQnVmZmVyXCIsIG5ldyBVbmlmb3JtNDYobm9ybWFsRGVwdGhCdWZmZXIpXSxcbiAgICAgICAgW1wibHVtaW5hbmNlSW5mbHVlbmNlXCIsIG5ldyBVbmlmb3JtNDYobHVtaW5hbmNlSW5mbHVlbmNlKV0sXG4gICAgICAgIFtcImNvbG9yXCIsIG5ldyBVbmlmb3JtNDYobnVsbCldLFxuICAgICAgICBbXCJpbnRlbnNpdHlcIiwgbmV3IFVuaWZvcm00NihpbnRlbnNpdHkpXSxcbiAgICAgICAgW1wic2NhbGVcIiwgbmV3IFVuaWZvcm00NigwKV1cbiAgICAgICAgLy8gVW51c2VkLlxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIxKDEsIDEsIHsgZGVwdGhCdWZmZXI6IGZhbHNlIH0pO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiQU8uVGFyZ2V0XCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhb0J1ZmZlclwiKS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbiA9IG5ldyBSZXNvbHV0aW9uKHRoaXMsIHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSwgcmVzb2x1dGlvblNjYWxlKTtcbiAgICByZXNvbHV0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHRoaXMuc2V0U2l6ZShyZXNvbHV0aW9uLmJhc2VXaWR0aCwgcmVzb2x1dGlvbi5iYXNlSGVpZ2h0KSk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MgPSBuZXcgRGVwdGhEb3duc2FtcGxpbmdQYXNzKHsgbm9ybWFsQnVmZmVyLCByZXNvbHV0aW9uU2NhbGUgfSk7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZW5hYmxlZCA9IG5vcm1hbERlcHRoQnVmZmVyID09PSBudWxsO1xuICAgIHRoaXMuc3Nhb1Bhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgU1NBT01hdGVyaWFsKGNhbWVyYSkpO1xuICAgIGNvbnN0IG5vaXNlVGV4dHVyZSA9IG5ldyBOb2lzZVRleHR1cmUoTk9JU0VfVEVYVFVSRV9TSVpFLCBOT0lTRV9URVhUVVJFX1NJWkUsIFJHQkFGb3JtYXQ0KTtcbiAgICBub2lzZVRleHR1cmUud3JhcFMgPSBub2lzZVRleHR1cmUud3JhcFQgPSBSZXBlYXRXcmFwcGluZzM7XG4gICAgY29uc3Qgc3Nhb01hdGVyaWFsID0gdGhpcy5zc2FvTWF0ZXJpYWw7XG4gICAgc3Nhb01hdGVyaWFsLm5vcm1hbEJ1ZmZlciA9IG5vcm1hbEJ1ZmZlcjtcbiAgICBzc2FvTWF0ZXJpYWwubm9pc2VUZXh0dXJlID0gbm9pc2VUZXh0dXJlO1xuICAgIHNzYW9NYXRlcmlhbC5taW5SYWRpdXNTY2FsZSA9IG1pblJhZGl1c1NjYWxlO1xuICAgIHNzYW9NYXRlcmlhbC5zYW1wbGVzID0gc2FtcGxlcztcbiAgICBzc2FvTWF0ZXJpYWwucmFkaXVzID0gcmFkaXVzO1xuICAgIHNzYW9NYXRlcmlhbC5yaW5ncyA9IHJpbmdzO1xuICAgIHNzYW9NYXRlcmlhbC5mYWRlID0gZmFkZTtcbiAgICBzc2FvTWF0ZXJpYWwuYmlhcyA9IGJpYXM7XG4gICAgc3Nhb01hdGVyaWFsLmRpc3RhbmNlVGhyZXNob2xkID0gZGlzdGFuY2VUaHJlc2hvbGQ7XG4gICAgc3Nhb01hdGVyaWFsLmRpc3RhbmNlRmFsbG9mZiA9IGRpc3RhbmNlRmFsbG9mZjtcbiAgICBzc2FvTWF0ZXJpYWwucHJveGltaXR5VGhyZXNob2xkID0gcmFuZ2VUaHJlc2hvbGQ7XG4gICAgc3Nhb01hdGVyaWFsLnByb3hpbWl0eUZhbGxvZmYgPSByYW5nZUZhbGxvZmY7XG4gICAgaWYgKHdvcmxkRGlzdGFuY2VUaHJlc2hvbGQgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkRGlzdGFuY2VUaHJlc2hvbGQgPSB3b3JsZERpc3RhbmNlVGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAod29ybGREaXN0YW5jZUZhbGxvZmYgIT09IHZvaWQgMCkge1xuICAgICAgc3Nhb01hdGVyaWFsLndvcmxkRGlzdGFuY2VGYWxsb2ZmID0gd29ybGREaXN0YW5jZUZhbGxvZmY7XG4gICAgfVxuICAgIGlmICh3b3JsZFByb3hpbWl0eVRocmVzaG9sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBzc2FvTWF0ZXJpYWwud29ybGRQcm94aW1pdHlUaHJlc2hvbGQgPSB3b3JsZFByb3hpbWl0eVRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKHdvcmxkUHJveGltaXR5RmFsbG9mZiAhPT0gdm9pZCAwKSB7XG4gICAgICBzc2FvTWF0ZXJpYWwud29ybGRQcm94aW1pdHlGYWxsb2ZmID0gd29ybGRQcm94aW1pdHlGYWxsb2ZmO1xuICAgIH1cbiAgICBpZiAobm9ybWFsRGVwdGhCdWZmZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3Nhb01hdGVyaWFsLm5vcm1hbERlcHRoQnVmZmVyID0gbm9ybWFsRGVwdGhCdWZmZXI7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiTk9STUFMX0RFUFRIXCIsIFwiMVwiKTtcbiAgICB9XG4gICAgdGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZyA9IGRlcHRoQXdhcmVVcHNhbXBsaW5nO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjI7XG4gIH1cbiAgc2V0IG1haW5DYW1lcmEodmFsdWUpIHtcbiAgICB0aGlzLmNhbWVyYSA9IHZhbHVlO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vcm1hbCBidWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgKi9cbiAgZ2V0IG5vcm1hbEJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zc2FvTWF0ZXJpYWwubm9ybWFsQnVmZmVyO1xuICB9XG4gIHNldCBub3JtYWxCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5ub3JtYWxCdWZmZXIgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5mdWxsc2NyZWVuTWF0ZXJpYWwubm9ybWFsQnVmZmVyID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gc2V0dGluZ3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSByZXNvbHV0aW9uIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1Jlc29sdXRpb259IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgU1NBTyBtYXRlcmlhbC5cbiAgICpcbiAgICogQHR5cGUge1NTQU9NYXRlcmlhbH1cbiAgICovXG4gIGdldCBzc2FvTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb1Bhc3MuZnVsbHNjcmVlbk1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBTU0FPIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1NTQU9NYXRlcmlhbH0gVGhlIG1hdGVyaWFsLlxuICAgKi9cbiAgZ2V0U1NBT01hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBvY2NsdXNpb24gc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkIFVzZSBzc2FvTWF0ZXJpYWwuc2FtcGxlcyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsLnNhbXBsZXM7XG4gIH1cbiAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5zYW1wbGVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygc3BpcmFsIHR1cm5zIGluIHRoZSBvY2NsdXNpb24gc2FtcGxpbmcgcGF0dGVybi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbC5yaW5ncyBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHJpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnNzYW9NYXRlcmlhbC5yaW5ncztcbiAgfVxuICBzZXQgcmluZ3ModmFsdWUpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5yaW5ncyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgb2NjbHVzaW9uIHNhbXBsaW5nIHJhZGl1cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbC5yYWRpdXMgaW5zdGVhZC5cbiAgICovXG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Nhb01hdGVyaWFsLnJhZGl1cztcbiAgfVxuICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucmFkaXVzID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVwdGhBd2FyZVVwc2FtcGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJERVBUSF9BV0FSRV9VUFNBTVBMSU5HXCIpO1xuICB9XG4gIHNldCBkZXB0aEF3YXJlVXBzYW1wbGluZyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlcHRoQXdhcmVVcHNhbXBsaW5nICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJERVBUSF9BV0FSRV9VUFNBTVBMSU5HXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJERVBUSF9BV0FSRV9VUFNBTVBMSU5HXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEF3YXJlVXBzYW1wbGluZyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlzRGVwdGhBd2FyZVVwc2FtcGxpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmRlcHRoQXdhcmVVcHNhbXBsaW5nO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGRlcHRoLWF3YXJlIHVwc2FtcGxpbmcuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkZXB0aEF3YXJlVXBzYW1wbGluZyBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gV2hldGhlciBkZXB0aC1hd2FyZSB1cHNhbXBsaW5nIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGVwdGhBd2FyZVVwc2FtcGxpbmdFbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5kZXB0aEF3YXJlVXBzYW1wbGluZyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXN0YW5jZS1iYXNlZCByYWRpdXMgc2NhbGluZyBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCBkaXN0YW5jZVNjYWxpbmcoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0IGRpc3RhbmNlU2NhbGluZyh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICovXG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJjb2xvclwiKS52YWx1ZTtcbiAgfVxuICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3QgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChkZWZpbmVzLmhhcyhcIkNPTE9SSVpFXCIpKSB7XG4gICAgICAgIHVuaWZvcm1zLmdldChcImNvbG9yXCIpLnZhbHVlLnNldCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVzLnNldChcIkNPTE9SSVpFXCIsIFwiMVwiKTtcbiAgICAgICAgdW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWUgPSBuZXcgQ29sb3I5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWZpbmVzLmhhcyhcIkNPTE9SSVpFXCIpKSB7XG4gICAgICBkZWZpbmVzLmRlbGV0ZShcIkNPTE9SSVpFXCIpO1xuICAgICAgdW5pZm9ybXMuZ2V0KFwiY29sb3JcIikudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGluZmx1ZW5jZSBmYWN0b3IuIFJhbmdlOiBbMC4wLCAxLjBdLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBsdW1pbmFuY2VJbmZsdWVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwibHVtaW5hbmNlSW5mbHVlbmNlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBsdW1pbmFuY2VJbmZsdWVuY2UodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImx1bWluYW5jZUluZmx1ZW5jZVwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW50ZW5zaXR5LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGludGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJpbnRlbnNpdHlcIikudmFsdWU7XG4gIH1cbiAgc2V0IGludGVuc2l0eSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiaW50ZW5zaXR5XCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbG9yIG9mIHRoZSBhbWJpZW50IG9jY2x1c2lvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGNvbG9yIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge0NvbG9yfSBUaGUgY29sb3IuXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIGFtYmllbnQgb2NjbHVzaW9uLiBTZXQgdG8gYG51bGxgIHRvIGRpc2FibGUgY29sb3JpemF0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgY29sb3IgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtDb2xvcn0gdmFsdWUgLSBUaGUgY29sb3IuXG4gICAqL1xuICBzZXRDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuY29sb3IgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgb2NjbHVzaW9uIGRpc3RhbmNlIGN1dG9mZi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHNzYW9NYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIC0gVGhlIGRpc3RhbmNlIHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldERpc3RhbmNlQ3V0b2ZmKHRocmVzaG9sZCwgZmFsbG9mZikge1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmRpc3RhbmNlVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmRpc3RhbmNlRmFsbG9mZiA9IGZhbGxvZmY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9jY2x1c2lvbiBwcm94aW1pdHkgY3V0b2ZmLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3Nhb01hdGVyaWFsIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGQgLSBUaGUgcHJveGltaXR5IHRocmVzaG9sZC4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhbGxvZmYgLSBUaGUgZmFsbG9mZi4gUmFuZ2UgWzAuMCwgMS4wXS5cbiAgICovXG4gIHNldFByb3hpbWl0eUN1dG9mZih0aHJlc2hvbGQsIGZhbGxvZmYpIHtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5wcm94aW1pdHlUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwucHJveGltaXR5RmFsbG9mZiA9IGZhbGxvZmY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlcHRoIHRleHR1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gQSBkZXB0aCB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0RlcHRoUGFja2luZ1N0cmF0ZWdpZXN9IFtkZXB0aFBhY2tpbmc9QmFzaWNEZXB0aFBhY2tpbmddIC0gVGhlIGRlcHRoIHBhY2tpbmcuXG4gICAqL1xuICBzZXREZXB0aFRleHR1cmUoZGVwdGhUZXh0dXJlLCBkZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZzE4KSB7XG4gICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3Muc2V0RGVwdGhUZXh0dXJlKGRlcHRoVGV4dHVyZSwgZGVwdGhQYWNraW5nKTtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kZXB0aEJ1ZmZlciA9IGRlcHRoVGV4dHVyZTtcbiAgICB0aGlzLnNzYW9NYXRlcmlhbC5kZXB0aFBhY2tpbmcgPSBkZXB0aFBhY2tpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuICAgIGlmICh0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmRlcHRoRG93bnNhbXBsaW5nUGFzcy5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICB0aGlzLnNzYW9QYXNzLnJlbmRlcihyZW5kZXJlciwgbnVsbCwgcmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB3ID0gcmVzb2x1dGlvbi53aWR0aCwgaCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgIHRoaXMuc3Nhb01hdGVyaWFsLmNvcHlDYW1lcmFTZXR0aW5ncyh0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5zc2FvTWF0ZXJpYWwuc2V0U2l6ZSh3LCBoKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHcsIGgpO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnJlc29sdXRpb24uc2NhbGUgPSByZXNvbHV0aW9uLnNjYWxlO1xuICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uIHRhc2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUJ1ZmZlclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbWFpbiBmcmFtZSBidWZmZXJzLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbm9ybWFsRGVwdGhCdWZmZXIgPSB0aGlzLnVuaWZvcm1zLmdldChcIm5vcm1hbERlcHRoQnVmZmVyXCIpLnZhbHVlO1xuICAgICAgaWYgKG5vcm1hbERlcHRoQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLmluaXRpYWxpemUocmVuZGVyZXIsIGFscGhhLCBmcmFtZUJ1ZmZlclR5cGUpO1xuICAgICAgICBub3JtYWxEZXB0aEJ1ZmZlciA9IHRoaXMuZGVwdGhEb3duc2FtcGxpbmdQYXNzLnRleHR1cmU7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwibm9ybWFsRGVwdGhCdWZmZXJcIikudmFsdWUgPSBub3JtYWxEZXB0aEJ1ZmZlcjtcbiAgICAgICAgdGhpcy5zc2FvTWF0ZXJpYWwubm9ybWFsRGVwdGhCdWZmZXIgPSBub3JtYWxEZXB0aEJ1ZmZlcjtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIk5PUk1BTF9ERVBUSFwiLCBcIjFcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZXB0aERvd25zYW1wbGluZ1Bhc3MuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVGV4dHVyZUVmZmVjdC5qc1xuaW1wb3J0IHsgVW5pZm9ybSBhcyBVbmlmb3JtNDcsIFVuc2lnbmVkQnl0ZVR5cGUgYXMgVW5zaWduZWRCeXRlVHlwZTE2IH0gZnJvbSBcInRocmVlXCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGV4dHVyZS5mcmFnXG52YXIgdGV4dHVyZV9kZWZhdWx0ID0gXCIjaWZkZWYgVEVYVFVSRV9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMyIHZVdjI7dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe1xcbiNpZmRlZiBVVl9UUkFOU0ZPUk1cXG52ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdlV2Mik7XFxuI2Vsc2VcXG52ZWM0IHRleGVsPXRleHR1cmUyRChtYXAsdXYpO1xcbiNlbmRpZlxcbm91dHB1dENvbG9yPVRFWEVMO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC90ZXh0dXJlLnZlcnRcbnZhciB0ZXh0dXJlX2RlZmF1bHQyID0gXCIjaWZkZWYgQVNQRUNUX0NPUlJFQ1RJT05cXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNlbHNlXFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7XFxuI2lmZGVmIEFTUEVDVF9DT1JSRUNUSU9OXFxudlV2Mj11dip2ZWMyKGFzcGVjdCwxLjApKnNjYWxlO1xcbiNlbHNlXFxudlV2Mj0odXZUcmFuc2Zvcm0qdmVjMyh1diwxLjApKS54eTtcXG4jZW5kaWZcXG59XCI7XG5cbi8vIHNyYy9lZmZlY3RzL1RleHR1cmVFZmZlY3QuanNcbnZhciBUZXh0dXJlRWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0ZXh0dXJlIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0JsZW5kRnVuY3Rpb259IFtvcHRpb25zLmJsZW5kRnVuY3Rpb25dIC0gVGhlIGJsZW5kIGZ1bmN0aW9uIG9mIHRoaXMgZWZmZWN0LlxuICAgKiBAcGFyYW0ge1RleHR1cmV9IFtvcHRpb25zLnRleHR1cmVdIC0gQSB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFzcGVjdENvcnJlY3Rpb249ZmFsc2VdIC0gRGVwcmVjYXRlZC4gQWRqdXN0IHRoZSB0ZXh0dXJlJ3Mgb2Zmc2V0LCByZXBlYXQgYW5kIGNlbnRlciBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBibGVuZEZ1bmN0aW9uLCB0ZXh0dXJlID0gbnVsbCwgYXNwZWN0Q29ycmVjdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiVGV4dHVyZUVmZmVjdFwiLCB0ZXh0dXJlX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICBkZWZpbmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIlRFWEVMXCIsIFwidGV4ZWxcIl1cbiAgICAgIF0pLFxuICAgICAgdW5pZm9ybXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1wibWFwXCIsIG5ldyBVbmlmb3JtNDcobnVsbCldLFxuICAgICAgICBbXCJzY2FsZVwiLCBuZXcgVW5pZm9ybTQ3KDEpXSxcbiAgICAgICAgW1widXZUcmFuc2Zvcm1cIiwgbmV3IFVuaWZvcm00NyhudWxsKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLmFzcGVjdENvcnJlY3Rpb24gPSBhc3BlY3RDb3JyZWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGV4dHVyZS5cbiAgICpcbiAgICogQHR5cGUge1RleHR1cmV9XG4gICAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG4gICAgY29uc3QgZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcbiAgICBpZiAocHJldlRleHR1cmUgIT09IHZhbHVlKSB7XG4gICAgICB1bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHVuaWZvcm1zLmdldChcInV2VHJhbnNmb3JtXCIpLnZhbHVlID0gdmFsdWUubWF0cml4O1xuICAgICAgZGVmaW5lcy5kZWxldGUoXCJURVhUVVJFX1BSRUNJU0lPTl9ISUdIXCIpO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh2YWx1ZS5tYXRyaXhBdXRvVXBkYXRlKSB7XG4gICAgICAgICAgZGVmaW5lcy5zZXQoXCJVVl9UUkFOU0ZPUk1cIiwgXCIxXCIpO1xuICAgICAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKHRleHR1cmVfZGVmYXVsdDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmluZXMuZGVsZXRlKFwiVVZfVFJBTlNGT1JNXCIpO1xuICAgICAgICAgIHRoaXMuc2V0VmVydGV4U2hhZGVyKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBVbnNpZ25lZEJ5dGVUeXBlMTYpIHtcbiAgICAgICAgICBkZWZpbmVzLnNldChcIlRFWFRVUkVfUFJFQ0lTSU9OX0hJR0hcIiwgXCIxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2VGV4dHVyZSA9PT0gbnVsbCB8fCBwcmV2VGV4dHVyZS50eXBlICE9PSB2YWx1ZS50eXBlIHx8IHByZXZUZXh0dXJlLmVuY29kaW5nICE9PSB2YWx1ZS5lbmNvZGluZykge1xuICAgICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGV4dHVyZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZS5cbiAgICovXG4gIGdldFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dHVyZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgc2V0VGV4dHVyZSh2YWx1ZSkge1xuICAgIHRoaXMudGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhc3BlY3QgY29ycmVjdGlvbiBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZCBBZGp1c3QgdGhlIHRleHR1cmUncyBvZmZzZXQsIHJlcGVhdCwgcm90YXRpb24gYW5kIGNlbnRlciBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFzcGVjdENvcnJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5lcy5oYXMoXCJBU1BFQ1RfQ09SUkVDVElPTlwiKTtcbiAgfVxuICBzZXQgYXNwZWN0Q29ycmVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmFzcGVjdENvcnJlY3Rpb24gIT09IHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcIkFTUEVDVF9DT1JSRUNUSU9OXCIsIFwiMVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5kZWxldGUoXCJBU1BFQ1RfQ09SUkVDVElPTlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRleHR1cmUgVVYgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHV2VHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgcmV0dXJuIHRleHR1cmUgIT09IG51bGwgJiYgdGV4dHVyZS5tYXRyaXhBdXRvVXBkYXRlO1xuICB9XG4gIHNldCB1dlRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3dpenpsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudHMgb2YgYSB0ZXhlbCBiZWZvcmUgaXQgaXMgd3JpdHRlbiB0byB0aGUgb3V0cHV0IGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gciAtIFRoZSBzd2l6emxlIGZvciB0aGUgYHJgIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtDb2xvckNoYW5uZWx9IFtnPXJdIC0gVGhlIHN3aXp6bGUgZm9yIHRoZSBgZ2AgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0NvbG9yQ2hhbm5lbH0gW2I9cl0gLSBUaGUgc3dpenpsZSBmb3IgdGhlIGBiYCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Q29sb3JDaGFubmVsfSBbYT1yXSAtIFRoZSBzd2l6emxlIGZvciB0aGUgYGFgIGNvbXBvbmVudC5cbiAgICovXG4gIHNldFRleHR1cmVTd2l6emxlUkdCQShyLCBnID0gciwgYiA9IHIsIGEgPSByKSB7XG4gICAgY29uc3QgcmdiYSA9IFwicmdiYVwiO1xuICAgIGxldCBzd2l6emxlID0gXCJcIjtcbiAgICBpZiAociAhPT0gQ29sb3JDaGFubmVsLlJFRCB8fCBnICE9PSBDb2xvckNoYW5uZWwuR1JFRU4gfHwgYiAhPT0gQ29sb3JDaGFubmVsLkJMVUUgfHwgYSAhPT0gQ29sb3JDaGFubmVsLkFMUEhBKSB7XG4gICAgICBzd2l6emxlID0gW1wiLlwiLCByZ2JhW3JdLCByZ2JhW2ddLCByZ2JhW2JdLCByZ2JhW2FdXS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmluZXMuc2V0KFwiVEVYRUxcIiwgXCJ0ZXhlbFwiICsgc3dpenpsZSk7XG4gICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IGlucHV0QnVmZmVyIC0gQSBmcmFtZSBidWZmZXIgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91cyBwYXNzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbHRhVGltZV0gLSBUaGUgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBvbmUgaW4gc2Vjb25kcy5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJlciwgaW5wdXRCdWZmZXIsIGRlbHRhVGltZSkge1xuICAgIGlmICh0aGlzLnRleHR1cmUubWF0cml4QXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy50ZXh0dXJlLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVGlsdFNoaWZ0RWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm00OCwgVmVjdG9yMiBhcyBWZWN0b3IyMjcsIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjIgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC90aWx0LXNoaWZ0LmZyYWdcbnZhciB0aWx0X3NoaWZ0X2RlZmF1bHQgPSBcIiNpZmRlZiBGUkFNRUJVRkZFUl9QUkVDSVNJT05fSElHSFxcbnVuaWZvcm0gbWVkaXVtcCBzYW1wbGVyMkQgbWFwO1xcbiNlbHNlXFxudW5pZm9ybSBsb3dwIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxudW5pZm9ybSB2ZWMyIG1hc2tQYXJhbXM7dmFyeWluZyB2ZWMyIHZVdjI7ZmxvYXQgbGluZWFyR3JhZGllbnRNYXNrKGNvbnN0IGluIGZsb2F0IHgpe3JldHVybiBzdGVwKG1hc2tQYXJhbXMueCx4KS1zdGVwKG1hc2tQYXJhbXMueSx4KTt9dm9pZCBtYWluSW1hZ2UoY29uc3QgaW4gdmVjNCBpbnB1dENvbG9yLGNvbnN0IGluIHZlYzIgdXYsb3V0IHZlYzQgb3V0cHV0Q29sb3Ipe2Zsb2F0IG1hc2s9bGluZWFyR3JhZGllbnRNYXNrKHZVdjIueSk7dmVjNCB0ZXhlbD10ZXh0dXJlMkQobWFwLHV2KTtvdXRwdXRDb2xvcj1taXgodGV4ZWwsaW5wdXRDb2xvcixtYXNrKTt9XCI7XG5cbi8vIHNyYy9lZmZlY3RzL2dsc2wvdGlsdC1zaGlmdC52ZXJ0XG52YXIgdGlsdF9zaGlmdF9kZWZhdWx0MiA9IFwidW5pZm9ybSB2ZWMyIHJvdGF0aW9uO3ZhcnlpbmcgdmVjMiB2VXYyO3ZvaWQgbWFpblN1cHBvcnQoY29uc3QgaW4gdmVjMiB1dil7dlV2Mj0odXYtMC41KSoyLjAqdmVjMihhc3BlY3QsMS4wKTt2VXYyPXZlYzIoZG90KHJvdGF0aW9uLHZVdjIpLGRvdChyb3RhdGlvbix2ZWMyKHZVdjIueSwtdlV2Mi54KSkpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvVGlsdFNoaWZ0RWZmZWN0LmpzXG52YXIgVGlsdFNoaWZ0RWZmZWN0ID0gY2xhc3MgZXh0ZW5kcyBFZmZlY3Qge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB0aWx0IHNoaWZ0IEVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXQ9MC4wXSAtIFRoZSByZWxhdGl2ZSBvZmZzZXQgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3RhdGlvbj0wLjBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBmb2N1cyBhcmVhIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb2N1c0FyZWE9MC40XSAtIFRoZSByZWxhdGl2ZSBzaXplIG9mIHRoZSBmb2N1cyBhcmVhLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmVhdGhlcj0wLjNdIC0gVGhlIHNvZnRuZXNzIG9mIHRoZSBmb2N1cyBhcmVhIGVkZ2VzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmlhcz0wLjA2XSAtIERlcHJlY2F0ZWQuXG4gICAqIEBwYXJhbSB7S2VybmVsU2l6ZX0gW29wdGlvbnMua2VybmVsU2l6ZT1LZXJuZWxTaXplLk1FRElVTV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uWD1SZXNvbHV0aW9uLkFVVE9fU0laRV0gLSBUaGUgaG9yaXpvbnRhbCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvblk9UmVzb2x1dGlvbi5BVVRPX1NJWkVdIC0gVGhlIHZlcnRpY2FsIHJlc29sdXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmxlbmRGdW5jdGlvbixcbiAgICBvZmZzZXQgPSAwLFxuICAgIHJvdGF0aW9uID0gMCxcbiAgICBmb2N1c0FyZWEgPSAwLjQsXG4gICAgZmVhdGhlciA9IDAuMyxcbiAgICBrZXJuZWxTaXplID0gS2VybmVsU2l6ZS5NRURJVU0sXG4gICAgcmVzb2x1dGlvblNjYWxlID0gMC41LFxuICAgIHJlc29sdXRpb25YID0gUmVzb2x1dGlvbi5BVVRPX1NJWkUsXG4gICAgcmVzb2x1dGlvblkgPSBSZXNvbHV0aW9uLkFVVE9fU0laRVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihcIlRpbHRTaGlmdEVmZmVjdFwiLCB0aWx0X3NoaWZ0X2RlZmF1bHQsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogdGlsdF9zaGlmdF9kZWZhdWx0MixcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJyb3RhdGlvblwiLCBuZXcgVW5pZm9ybTQ4KG5ldyBWZWN0b3IyMjcoKSldLFxuICAgICAgICBbXCJtYXNrUGFyYW1zXCIsIG5ldyBVbmlmb3JtNDgobmV3IFZlY3RvcjIyNygpKV0sXG4gICAgICAgIFtcIm1hcFwiLCBuZXcgVW5pZm9ybTQ4KG51bGwpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5fZm9jdXNBcmVhID0gZm9jdXNBcmVhO1xuICAgIHRoaXMuX2ZlYXRoZXIgPSBmZWF0aGVyO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0MjIoMSwgMSwgeyBkZXB0aEJ1ZmZlcjogZmFsc2UgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJUaWx0U2hpZnQuVGFyZ2V0XCI7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXBcIikudmFsdWUgPSB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIHRoaXMuYmx1clBhc3MgPSBuZXcgVGlsdFNoaWZ0Qmx1clBhc3Moe1xuICAgICAga2VybmVsU2l6ZSxcbiAgICAgIHJlc29sdXRpb25TY2FsZSxcbiAgICAgIHJlc29sdXRpb25YLFxuICAgICAgcmVzb2x1dGlvblksXG4gICAgICBvZmZzZXQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGZvY3VzQXJlYSxcbiAgICAgIGZlYXRoZXJcbiAgICB9KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uID0gbmV3IFJlc29sdXRpb24odGhpcywgcmVzb2x1dGlvblgsIHJlc29sdXRpb25ZLCByZXNvbHV0aW9uU2NhbGUpO1xuICAgIHJlc29sdXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4gdGhpcy5zZXRTaXplKHJlc29sdXRpb24uYmFzZVdpZHRoLCByZXNvbHV0aW9uLmJhc2VIZWlnaHQpKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWFzayBwYXJhbXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVQYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy51bmlmb3Jtcy5nZXQoXCJtYXNrUGFyYW1zXCIpLnZhbHVlO1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCh0aGlzLmZvY3VzQXJlYSAtIHRoaXMuZmVhdGhlciwgMCk7XG4gICAgcGFyYW1zLnNldCh0aGlzLm9mZnNldCAtIHgsIHRoaXMub2Zmc2V0ICsgeCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgZm9jdXMgYXJlYSBpbiByYWRpYW5zLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy51bmlmb3Jtcy5nZXQoXCJyb3RhdGlvblwiKS52YWx1ZS54KTtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcInJvdGF0aW9uXCIpLnZhbHVlLnNldChNYXRoLmNvcyh2YWx1ZSksIE1hdGguc2luKHZhbHVlKSk7XG4gICAgdGhpcy5ibHVyUGFzcy5ibHVyTWF0ZXJpYWwucm90YXRpb24gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgZm9jdXMgYXJlYS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5ibHVyUGFzcy5ibHVyTWF0ZXJpYWwub2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGZvY3VzIGFyZWEuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZm9jdXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c0FyZWE7XG4gIH1cbiAgc2V0IGZvY3VzQXJlYSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvY3VzQXJlYSA9IHZhbHVlO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLmZvY3VzQXJlYSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFyYW1zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzb2Z0bmVzcyBvZiB0aGUgZm9jdXMgYXJlYSBlZGdlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBmZWF0aGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9mZWF0aGVyO1xuICB9XG4gIHNldCBmZWF0aGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fZmVhdGhlciA9IHZhbHVlO1xuICAgIHRoaXMuYmx1clBhc3MuYmx1ck1hdGVyaWFsLmZlYXRoZXIgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICB9XG4gIC8qKlxuICAgKiBBIGJsZW5kIGJpYXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgYmlhcygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgYmlhcyh2YWx1ZSkge1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICB0aGlzLmJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIsIHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cbiAgICovXG4gIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgcmVzb2x1dGlvbi5zZXRCYXNlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTtcbiAgICB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb24uY29weShyZXNvbHV0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5ibHVyUGFzcy5pbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKTtcbiAgICBpZiAoZnJhbWVCdWZmZXJUeXBlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSA9IGZyYW1lQnVmZmVyVHlwZTtcbiAgICAgIGlmIChnZXRPdXRwdXRDb2xvclNwYWNlKHJlbmRlcmVyKSA9PT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgc2V0VGV4dHVyZUNvbG9yU3BhY2UodGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2VmZmVjdHMvVG9uZU1hcHBpbmdFZmZlY3QuanNcbmltcG9ydCB7IExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgVW5pZm9ybSBhcyBVbmlmb3JtNDksIFdlYkdMUmVuZGVyVGFyZ2V0IGFzIFdlYkdMUmVuZGVyVGFyZ2V0MjMgfSBmcm9tIFwidGhyZWVcIjtcblxuLy8gc3JjL2VmZmVjdHMvZ2xzbC90b25lLW1hcHBpbmcuZnJhZ1xudmFyIHRvbmVfbWFwcGluZ19kZWZhdWx0ID0gXCIjaW5jbHVkZSA8dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudD5cXG4jaWYgVEhSRUVfUkVWSVNJT04gPCAxNDNcXG4jZGVmaW5lIGx1bWluYW5jZSh2KSBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKHYpXFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCB3aGl0ZVBvaW50O1xcbiNpZiBUT05FX01BUFBJTkdfTU9ERSA9PSAxIHx8IFRPTkVfTUFQUElOR19NT0RFID09IDJcXG51bmlmb3JtIGZsb2F0IG1pZGRsZUdyZXk7XFxuI2lmIFRPTkVfTUFQUElOR19NT0RFID09IDJcXG51bmlmb3JtIGxvd3Agc2FtcGxlcjJEIGx1bWluYW5jZUJ1ZmZlcjtcXG4jZWxzZVxcbnVuaWZvcm0gZmxvYXQgYXZlcmFnZUx1bWluYW5jZTtcXG4jZW5kaWZcXG52ZWMzIFJlaW5oYXJkMlRvbmVNYXBwaW5nKHZlYzMgY29sb3Ipe2NvbG9yKj10b25lTWFwcGluZ0V4cG9zdXJlO2Zsb2F0IGw9bHVtaW5hbmNlKGNvbG9yKTtcXG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gMlxcbmZsb2F0IGx1bUF2Zz11bnBhY2tSR0JBVG9GbG9hdCh0ZXh0dXJlMkQobHVtaW5hbmNlQnVmZmVyLHZlYzIoMC41KSkpO1xcbiNlbHNlXFxuZmxvYXQgbHVtQXZnPWF2ZXJhZ2VMdW1pbmFuY2U7XFxuI2VuZGlmXFxuZmxvYXQgbHVtU2NhbGVkPShsKm1pZGRsZUdyZXkpL21heChsdW1BdmcsMWUtNik7ZmxvYXQgbHVtQ29tcHJlc3NlZD1sdW1TY2FsZWQqKDEuMCtsdW1TY2FsZWQvKHdoaXRlUG9pbnQqd2hpdGVQb2ludCkpO2x1bUNvbXByZXNzZWQvPSgxLjArbHVtU2NhbGVkKTtyZXR1cm4gY2xhbXAobHVtQ29tcHJlc3NlZCpjb2xvciwwLjAsMS4wKTt9XFxuI2VsaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gM1xcbiNkZWZpbmUgQSAwLjE1XFxuI2RlZmluZSBCIDAuNTBcXG4jZGVmaW5lIEMgMC4xMFxcbiNkZWZpbmUgRCAwLjIwXFxuI2RlZmluZSBFIDAuMDJcXG4jZGVmaW5lIEYgMC4zMFxcbnZlYzMgVW5jaGFydGVkMkhlbHBlcihjb25zdCBpbiB2ZWMzIHgpe3JldHVybigoeCooQSp4K0MqQikrRCpFKS8oeCooQSp4K0IpK0QqRikpLUUvRjt9dmVjMyBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcodmVjMyBjb2xvcil7Y29sb3IqPXRvbmVNYXBwaW5nRXhwb3N1cmU7cmV0dXJuIGNsYW1wKFVuY2hhcnRlZDJIZWxwZXIoY29sb3IpL1VuY2hhcnRlZDJIZWxwZXIodmVjMyh3aGl0ZVBvaW50KSksMC4wLDEuMCk7fVxcbiNlbmRpZlxcbnZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtcXG4jaWYgVE9ORV9NQVBQSU5HX01PREUgPT0gMSB8fCBUT05FX01BUFBJTkdfTU9ERSA9PSAyXFxub3V0cHV0Q29sb3I9dmVjNChSZWluaGFyZDJUb25lTWFwcGluZyhpbnB1dENvbG9yLnJnYiksaW5wdXRDb2xvci5hKTtcXG4jZWxpZiBUT05FX01BUFBJTkdfTU9ERSA9PSAzXFxub3V0cHV0Q29sb3I9dmVjNChVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcoaW5wdXRDb2xvci5yZ2IpLGlucHV0Q29sb3IuYSk7XFxuI2Vsc2VcXG5vdXRwdXRDb2xvcj12ZWM0KHRvbmVNYXBwaW5nKGlucHV0Q29sb3IucmdiKSxpbnB1dENvbG9yLmEpO1xcbiNlbmRpZlxcbn1cIjtcblxuLy8gc3JjL2VmZmVjdHMvVG9uZU1hcHBpbmdFZmZlY3QuanNcbnZhciBUb25lTWFwcGluZ0VmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgdG9uZSBtYXBwaW5nIGVmZmVjdC5cbiAgICpcbiAgICogVGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvbmx5IGFmZmVjdCB0aGUgUmVpbmhhcmQyIG9wZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbj1CbGVuZEZ1bmN0aW9uLlNSQ10gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWRhcHRpdmU9ZmFsc2VdIC0gRGVwcmVjYXRlZC4gVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUb25lTWFwcGluZ01vZGV9IFtvcHRpb25zLm1vZGU9VG9uZU1hcHBpbmdNb2RlLkFHWF0gLSBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTI1Nl0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbHVtaW5hbmNlIHRleHR1cmUuIE11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhMdW1pbmFuY2U9NC4wXSAtIERlcHJlY2F0ZWQuIFNhbWUgYXMgd2hpdGVQb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndoaXRlUG9pbnQ9NC4wXSAtIFRoZSB3aGl0ZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pZGRsZUdyZXk9MC42XSAtIFRoZSBtaWRkbGUgZ3JleSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5MdW1pbmFuY2U9MC4wMV0gLSBUaGUgbWluaW11bSBsdW1pbmFuY2UuIFByZXZlbnRzIHZlcnkgaGlnaCBleHBvc3VyZSBpbiBkYXJrIHNjZW5lcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF2ZXJhZ2VMdW1pbmFuY2U9MS4wXSAtIFRoZSBhdmVyYWdlIGx1bWluYW5jZS4gVXNlZCBmb3IgdGhlIG5vbi1hZGFwdGl2ZSBSZWluaGFyZCBvcGVyYXRvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFkYXB0YXRpb25SYXRlPTEuMF0gLSBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uID0gQmxlbmRGdW5jdGlvbi5TUkMsXG4gICAgYWRhcHRpdmUgPSBmYWxzZSxcbiAgICBtb2RlID0gYWRhcHRpdmUgPyBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyX0FEQVBUSVZFIDogVG9uZU1hcHBpbmdNb2RlLkFHWCxcbiAgICByZXNvbHV0aW9uID0gMjU2LFxuICAgIG1heEx1bWluYW5jZSA9IDQsXG4gICAgd2hpdGVQb2ludCA9IG1heEx1bWluYW5jZSxcbiAgICBtaWRkbGVHcmV5ID0gMC42LFxuICAgIG1pbkx1bWluYW5jZSA9IDAuMDEsXG4gICAgYXZlcmFnZUx1bWluYW5jZSA9IDEsXG4gICAgYWRhcHRhdGlvblJhdGUgPSAxXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwiVG9uZU1hcHBpbmdFZmZlY3RcIiwgdG9uZV9tYXBwaW5nX2RlZmF1bHQsIHtcbiAgICAgIGJsZW5kRnVuY3Rpb24sXG4gICAgICB1bmlmb3JtczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJsdW1pbmFuY2VCdWZmZXJcIiwgbmV3IFVuaWZvcm00OShudWxsKV0sXG4gICAgICAgIFtcIm1heEx1bWluYW5jZVwiLCBuZXcgVW5pZm9ybTQ5KG1heEx1bWluYW5jZSldLFxuICAgICAgICAvLyBVbnVzZWRcbiAgICAgICAgW1wid2hpdGVQb2ludFwiLCBuZXcgVW5pZm9ybTQ5KHdoaXRlUG9pbnQpXSxcbiAgICAgICAgW1wibWlkZGxlR3JleVwiLCBuZXcgVW5pZm9ybTQ5KG1pZGRsZUdyZXkpXSxcbiAgICAgICAgW1wiYXZlcmFnZUx1bWluYW5jZVwiLCBuZXcgVW5pZm9ybTQ5KGF2ZXJhZ2VMdW1pbmFuY2UpXVxuICAgICAgXSlcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZSA9IG5ldyBXZWJHTFJlbmRlclRhcmdldDIzKDEsIDEsIHtcbiAgICAgIG1pbkZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxuICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXRMdW1pbmFuY2UudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0THVtaW5hbmNlLnRleHR1cmUubmFtZSA9IFwiTHVtaW5hbmNlXCI7XG4gICAgdGhpcy5sdW1pbmFuY2VQYXNzID0gbmV3IEx1bWluYW5jZVBhc3Moe1xuICAgICAgcmVuZGVyVGFyZ2V0OiB0aGlzLnJlbmRlclRhcmdldEx1bWluYW5jZVxuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzID0gbmV3IEFkYXB0aXZlTHVtaW5hbmNlUGFzcyh0aGlzLmx1bWluYW5jZVBhc3MudGV4dHVyZSwge1xuICAgICAgbWluTHVtaW5hbmNlLFxuICAgICAgYWRhcHRhdGlvblJhdGVcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcImx1bWluYW5jZUJ1ZmZlclwiKS52YWx1ZSA9IHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLnRleHR1cmU7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqXG4gICAqIEB0eXBlIHtUb25lTWFwcGluZ01vZGV9XG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZGVmaW5lcy5nZXQoXCJUT05FX01BUFBJTkdfTU9ERVwiKSk7XG4gIH1cbiAgc2V0IG1vZGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5tb2RlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLmNsZWFyKCk7XG4gICAgICB0aGlzLmRlZmluZXMuc2V0KFwiVE9ORV9NQVBQSU5HX01PREVcIiwgdmFsdWUudG9GaXhlZCgwKSk7XG4gICAgICB2YWx1ZSA9IHZhbGlkYXRlVG9uZU1hcHBpbmdNb2RlKHZhbHVlKTtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQ6XG4gICAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIlJlaW5oYXJkVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5PUFRJTUlaRURfQ0lORU9OOlxuICAgICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyh0ZXhlbClcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVG9uZU1hcHBpbmdNb2RlLkFDRVNfRklMTUlDOlxuICAgICAgICAgIHRoaXMuZGVmaW5lcy5zZXQoXCJ0b25lTWFwcGluZyh0ZXhlbClcIiwgXCJBQ0VTRmlsbWljVG9uZU1hcHBpbmcodGV4ZWwpXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRvbmVNYXBwaW5nTW9kZS5BR1g6XG4gICAgICAgICAgdGhpcy5kZWZpbmVzLnNldChcInRvbmVNYXBwaW5nKHRleGVsKVwiLCBcIkFnWFRvbmVNYXBwaW5nKHRleGVsKVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmRlZmluZXMuc2V0KFwidG9uZU1hcHBpbmcodGV4ZWwpXCIsIFwidGV4ZWxcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlUGFzcy5lbmFibGVkID0gdmFsdWUgPT09IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkU7XG4gICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9uZSBtYXBwaW5nIG1vZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1RvbmVNYXBwaW5nTW9kZX0gVGhlIHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKi9cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0b25lIG1hcHBpbmcgbW9kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG1vZGUgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtUb25lTWFwcGluZ01vZGV9IHZhbHVlIC0gVGhlIHRvbmUgbWFwcGluZyBtb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgd2hpdGUgcG9pbnQuIERlZmF1bHQgaXMgYDQuMGAuXG4gICAqXG4gICAqIE9ubHkgYXBwbGllcyB0byBSZWluaGFyZDIgKE1vZGlmaWVkICYgQWRhcHRpdmUpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdoaXRlUG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2V0KFwid2hpdGVQb2ludFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgd2hpdGVQb2ludCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwid2hpdGVQb2ludFwiKS52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWlkZGxlIGdyZXkgZmFjdG9yLiBEZWZhdWx0IGlzIGAwLjZgLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gUmVpbmhhcmQyIChNb2RpZmllZCAmIEFkYXB0aXZlKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBtaWRkbGVHcmV5KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm1pZGRsZUdyZXlcIikudmFsdWU7XG4gIH1cbiAgc2V0IG1pZGRsZUdyZXkodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmdldChcIm1pZGRsZUdyZXlcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGF2ZXJhZ2UgbHVtaW5hbmNlLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpZXMgdG8gUmVpbmhhcmQyIChNb2RpZmllZCkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYXZlcmFnZUx1bWluYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5nZXQoXCJhdmVyYWdlTHVtaW5hbmNlXCIpLnZhbHVlO1xuICB9XG4gIHNldCBhdmVyYWdlTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJhdmVyYWdlTHVtaW5hbmNlXCIpLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhZGFwdGl2ZSBsdW1pbmFuY2UgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEB0eXBlIHtBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsfVxuICAgKi9cbiAgZ2V0IGFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VQYXNzLmZ1bGxzY3JlZW5NYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWRhcHRpdmUgbHVtaW5hbmNlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsfSBUaGUgbWF0ZXJpYWwuXG4gICAqL1xuICBnZXRBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmx1bWluYW5jZVBhc3MucmVzb2x1dGlvbi53aWR0aDtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IGV4cG9uZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nMih2YWx1ZSkpKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHRoaXMubHVtaW5hbmNlUGFzcy5yZXNvbHV0aW9uLnNldFByZWZlcnJlZFNpemUoc2l6ZSwgc2l6ZSk7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLm1pcExldmVsMXgxID0gZXhwb25lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdXRpb24gb2YgdGhlIGx1bWluYW5jZSB0ZXh0dXJlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVzb2x1dGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBsdW1pbmFuY2UgdGV4dHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHJlc29sdXRpb24gaW5zdGVhZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHJlc29sdXRpb24uXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcGFzcyB1c2VzIGFkYXB0aXZlIGx1bWluYW5jZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSBtb2RlIGluc3RlYWQuXG4gICAqL1xuICBnZXQgYWRhcHRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gVG9uZU1hcHBpbmdNb2RlLlJFSU5IQVJEMl9BREFQVElWRTtcbiAgfVxuICBzZXQgYWRhcHRpdmUodmFsdWUpIHtcbiAgICB0aGlzLm1vZGUgPSB2YWx1ZSA/IFRvbmVNYXBwaW5nTW9kZS5SRUlOSEFSRDJfQURBUFRJVkUgOiBUb25lTWFwcGluZ01vZGUuUkVJTkhBUkQyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbHVtaW5hbmNlIGFkYXB0YXRpb24gcmF0ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwuYWRhcHRhdGlvblJhdGUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhZGFwdGF0aW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLmFkYXB0YXRpb25SYXRlO1xuICB9XG4gIHNldCBhZGFwdGF0aW9uUmF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbC5hZGFwdGF0aW9uUmF0ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0IGRpc3RpbmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWQuXCIpO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHNldCBkaXN0aW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2Fybih0aGlzLm5hbWUsIFwiZGlzdGluY3Rpb24gd2FzIHJlbW92ZWQuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dEJ1ZmZlciAtIEEgZnJhbWUgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YVRpbWVdIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyZXIsIGlucHV0QnVmZmVyLCBkZWx0YVRpbWUpIHtcbiAgICBpZiAodGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuZW5hYmxlZCkge1xuICAgICAgdGhpcy5sdW1pbmFuY2VQYXNzLnJlbmRlcihyZW5kZXJlciwgaW5wdXRCdWZmZXIpO1xuICAgICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MucmVuZGVyKHJlbmRlcmVyLCBudWxsLCBudWxsLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24gdGFza3MuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lQnVmZmVyVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBtYWluIGZyYW1lIGJ1ZmZlcnMuXG4gICAqL1xuICBpbml0aWFsaXplKHJlbmRlcmVyLCBhbHBoYSwgZnJhbWVCdWZmZXJUeXBlKSB7XG4gICAgdGhpcy5hZGFwdGl2ZUx1bWluYW5jZVBhc3MuaW5pdGlhbGl6ZShyZW5kZXJlciwgYWxwaGEsIGZyYW1lQnVmZmVyVHlwZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lZmZlY3RzL1ZpZ25ldHRlRWZmZWN0LmpzXG5pbXBvcnQgeyBVbmlmb3JtIGFzIFVuaWZvcm01MCB9IGZyb20gXCJ0aHJlZVwiO1xuXG4vLyBzcmMvZWZmZWN0cy9nbHNsL3ZpZ25ldHRlLmZyYWdcbnZhciB2aWduZXR0ZV9kZWZhdWx0ID0gXCJ1bmlmb3JtIGZsb2F0IG9mZnNldDt1bmlmb3JtIGZsb2F0IGRhcmtuZXNzO3ZvaWQgbWFpbkltYWdlKGNvbnN0IGluIHZlYzQgaW5wdXRDb2xvcixjb25zdCBpbiB2ZWMyIHV2LG91dCB2ZWM0IG91dHB1dENvbG9yKXtjb25zdCB2ZWMyIGNlbnRlcj12ZWMyKDAuNSk7dmVjMyBjb2xvcj1pbnB1dENvbG9yLnJnYjtcXG4jaWYgVklHTkVUVEVfVEVDSE5JUVVFID09IDBcXG5mbG9hdCBkPWRpc3RhbmNlKHV2LGNlbnRlcik7Y29sb3IqPXNtb290aHN0ZXAoMC44LG9mZnNldCowLjc5OSxkKihkYXJrbmVzcytvZmZzZXQpKTtcXG4jZWxzZVxcbnZlYzIgY29vcmQ9KHV2LWNlbnRlcikqdmVjMihvZmZzZXQpO2NvbG9yPW1peChjb2xvcix2ZWMzKDEuMC1kYXJrbmVzcyksZG90KGNvb3JkLGNvb3JkKSk7XFxuI2VuZGlmXFxub3V0cHV0Q29sb3I9dmVjNChjb2xvcixpbnB1dENvbG9yLmEpO31cIjtcblxuLy8gc3JjL2VmZmVjdHMvVmlnbmV0dGVFZmZlY3QuanNcbnZhciBWaWduZXR0ZUVmZmVjdCA9IGNsYXNzIGV4dGVuZHMgRWZmZWN0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgVmlnbmV0dGUgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7QmxlbmRGdW5jdGlvbn0gW29wdGlvbnMuYmxlbmRGdW5jdGlvbl0gLSBUaGUgYmxlbmQgZnVuY3Rpb24gb2YgdGhpcyBlZmZlY3QuXG4gICAqIEBwYXJhbSB7VmlnbmV0dGVUZWNobmlxdWV9IFtvcHRpb25zLnRlY2huaXF1ZT1WaWduZXR0ZVRlY2huaXF1ZS5ERUZBVUxUXSAtIFRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZXNraWw9ZmFsc2VdIC0gRGVwcmVjYXRlZC4gVXNlIHRlY2huaXF1ZSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTAuNV0gLSBUaGUgVmlnbmV0dGUgb2Zmc2V0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGFya25lc3M9MC41XSAtIFRoZSBWaWduZXR0ZSBkYXJrbmVzcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBibGVuZEZ1bmN0aW9uLFxuICAgIHRlY2huaXF1ZSA9IFZpZ25ldHRlVGVjaG5pcXVlLkRFRkFVTFQsXG4gICAgZXNraWwgPSBmYWxzZSxcbiAgICBvZmZzZXQgPSAwLjUsXG4gICAgZGFya25lc3MgPSAwLjVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoXCJWaWduZXR0ZUVmZmVjdFwiLCB2aWduZXR0ZV9kZWZhdWx0LCB7XG4gICAgICBibGVuZEZ1bmN0aW9uLFxuICAgICAgZGVmaW5lczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJWSUdORVRURV9URUNITklRVUVcIiwgdGVjaG5pcXVlLnRvRml4ZWQoMCldXG4gICAgICBdKSxcbiAgICAgIHVuaWZvcm1zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFtcIm9mZnNldFwiLCBuZXcgVW5pZm9ybTUwKG9mZnNldCldLFxuICAgICAgICBbXCJkYXJrbmVzc1wiLCBuZXcgVW5pZm9ybTUwKGRhcmtuZXNzKV1cbiAgICAgIF0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBWaWduZXR0ZSB0ZWNobmlxdWUuXG4gICAqXG4gICAqIEB0eXBlIHtWaWduZXR0ZVRlY2huaXF1ZX1cbiAgICovXG4gIGdldCB0ZWNobmlxdWUoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLmRlZmluZXMuZ2V0KFwiVklHTkVUVEVfVEVDSE5JUVVFXCIpKTtcbiAgfVxuICBzZXQgdGVjaG5pcXVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGVjaG5pcXVlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kZWZpbmVzLnNldChcIlZJR05FVFRFX1RFQ0hOSVFVRVwiLCB2YWx1ZS50b0ZpeGVkKDApKTtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgRXNraWwncyBWaWduZXR0ZSB0ZWNobmlxdWUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXByZWNhdGVkIFVzZSB0ZWNobmlxdWUgaW5zdGVhZC5cbiAgICovXG4gIGdldCBlc2tpbCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNobmlxdWUgPT09IFZpZ25ldHRlVGVjaG5pcXVlLkVTS0lMO1xuICB9XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBFc2tpbCdzIFZpZ25ldHRlIHRlY2huaXF1ZSBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRlY2huaXF1ZSBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IGVza2lsKHZhbHVlKSB7XG4gICAgdGhpcy50ZWNobmlxdWUgPSB2YWx1ZSA/IFZpZ25ldHRlVGVjaG5pcXVlLkVTS0lMIDogVmlnbmV0dGVUZWNobmlxdWUuREVGQVVMVDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgdGVjaG5pcXVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge1ZpZ25ldHRlVGVjaG5pcXVlfSBUaGUgdGVjaG5pcXVlLlxuICAgKi9cbiAgZ2V0VGVjaG5pcXVlKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2huaXF1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgVmlnbmV0dGUgdGVjaG5pcXVlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVjaG5pcXVlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7VmlnbmV0dGVUZWNobmlxdWV9IHZhbHVlIC0gVGhlIHRlY2huaXF1ZS5cbiAgICovXG4gIHNldFRlY2huaXF1ZSh2YWx1ZSkge1xuICAgIHRoaXMudGVjaG5pcXVlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBWaWduZXR0ZSBvZmZzZXQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcIm9mZnNldFwiKS52YWx1ZTtcbiAgfVxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5nZXQoXCJvZmZzZXRcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugb2Zmc2V0IGluc3RlYWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9mZnNldC5cbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIFZpZ25ldHRlIG9mZnNldC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9mZnNldCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgb2Zmc2V0LlxuICAgKi9cbiAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIFZpZ25ldHRlIGRhcmtuZXNzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRhcmtuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdldChcImRhcmtuZXNzXCIpLnZhbHVlO1xuICB9XG4gIHNldCBkYXJrbmVzcyh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMuZ2V0KFwiZGFya25lc3NcIikudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVmlnbmV0dGUgZGFya25lc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBkYXJrbmVzcyBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkYXJrbmVzcy5cbiAgICovXG4gIGdldERhcmtuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmRhcmtuZXNzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBWaWduZXR0ZSBkYXJrbmVzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGRhcmtuZXNzIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBkYXJrbmVzcy5cbiAgICovXG4gIHNldERhcmtuZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5kYXJrbmVzcyA9IHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbG9hZGVycy9MVVQzZGxMb2FkZXIuanNcbmltcG9ydCB7IEZpbGVMb2FkZXIsIExvYWRlciwgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXIzIH0gZnJvbSBcInRocmVlXCI7XG52YXIgTFVUM2RsTG9hZGVyID0gY2xhc3MgZXh0ZW5kcyBMb2FkZXIge1xuICAvKipcbiAgICogTG9hZHMgYSBMVVQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSAzZGwtZmlsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGxvYWRlZCBsb29rdXAgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQSBwcm9ncmVzcyBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBYTUxIdHRwUmVxdWVzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9va3VwVGV4dHVyZT59IEEgcHJvbWlzZSB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0ZXh0dXJlLlxuICAgKi9cbiAgbG9hZCh1cmwsIG9uTG9hZCA9ICgpID0+IHtcbiAgfSwgb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgfSwgb25FcnJvciA9IG51bGwpIHtcbiAgICBjb25zdCBleHRlcm5hbE1hbmFnZXIgPSB0aGlzLm1hbmFnZXI7XG4gICAgY29uc3QgaW50ZXJuYWxNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyMygpO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKGludGVybmFsTWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwidGV4dFwiKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IgPSAodXJsMikgPT4ge1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVycm9yKHVybDIpO1xuICAgICAgICBpZiAob25FcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgIG9uRXJyb3IoYEZhaWxlZCB0byBsb2FkICR7dXJsMn1gKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGBGYWlsZWQgdG8gbG9hZCAke3VybDJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgICBsb2FkZXIubG9hZCh1cmwsIChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgaW50ZXJuYWxNYW5hZ2VyLm9uRXJyb3IodXJsKTtcbiAgICAgICAgfVxuICAgICAgfSwgb25Qcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IC0gVGhlIExVVCBkYXRhLlxuICAgKiBAcmV0dXJuIHtMb29rdXBUZXh0dXJlfSBUaGUgbG9va3VwIHRleHR1cmUuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBGYWlscyBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCByZWdFeHBHcmlkSW5mbyA9IC9eW1xcZCBdKyQvbTtcbiAgICBjb25zdCByZWdFeHBEYXRhUG9pbnRzID0gL14oW1xcZC5lKy1dKykgKyhbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICokL2dtO1xuICAgIGxldCByZXN1bHQgPSByZWdFeHBHcmlkSW5mby5leGVjKGlucHV0KTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGdyaWQgaW5mb3JtYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGdyaWRMaW5lcyA9IHJlc3VsdFswXS50cmltKCkuc3BsaXQoL1xccysvZykubWFwKChuKSA9PiBOdW1iZXIobikpO1xuICAgIGNvbnN0IGdyaWRTdGVwID0gZ3JpZExpbmVzWzFdIC0gZ3JpZExpbmVzWzBdO1xuICAgIGNvbnN0IHNpemUgPSBncmlkTGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IHNpemVTcSA9IHNpemUgKiogMjtcbiAgICBmb3IgKGxldCBpID0gMSwgbCA9IGdyaWRMaW5lcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGlmIChncmlkU3RlcCAhPT0gZ3JpZExpbmVzW2ldIC0gZ3JpZExpbmVzW2kgLSAxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbnNpc3RlbnQgZ3JpZCBzaXplXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICoqIDMgKiA0KTtcbiAgICBsZXQgbWF4VmFsdWUgPSAwO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBEYXRhUG9pbnRzLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgciA9IE51bWJlcihyZXN1bHRbMV0pO1xuICAgICAgY29uc3QgZyA9IE51bWJlcihyZXN1bHRbMl0pO1xuICAgICAgY29uc3QgYiA9IE51bWJlcihyZXN1bHRbM10pO1xuICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heChtYXhWYWx1ZSwgciwgZywgYik7XG4gICAgICBjb25zdCBiTGF5ZXIgPSBpbmRleCAlIHNpemU7XG4gICAgICBjb25zdCBnTGF5ZXIgPSBNYXRoLmZsb29yKGluZGV4IC8gc2l6ZSkgJSBzaXplO1xuICAgICAgY29uc3QgckxheWVyID0gTWF0aC5mbG9vcihpbmRleCAvIHNpemVTcSkgJSBzaXplO1xuICAgICAgY29uc3QgZDQgPSAoYkxheWVyICogc2l6ZVNxICsgZ0xheWVyICogc2l6ZSArIHJMYXllcikgKiA0O1xuICAgICAgZGF0YVtkNCArIDBdID0gcjtcbiAgICAgIGRhdGFbZDQgKyAxXSA9IGc7XG4gICAgICBkYXRhW2Q0ICsgMl0gPSBiO1xuICAgICAgZGF0YVtkNCArIDNdID0gMTtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGJpdHMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKG1heFZhbHVlKSk7XG4gICAgY29uc3QgbWF4Qml0VmFsdWUgPSBNYXRoLnBvdygyLCBiaXRzKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICBkYXRhW2kgKyAwXSAvPSBtYXhCaXRWYWx1ZTtcbiAgICAgIGRhdGFbaSArIDFdIC89IG1heEJpdFZhbHVlO1xuICAgICAgZGF0YVtpICsgMl0gLz0gbWF4Qml0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9va3VwVGV4dHVyZShkYXRhLCBzaXplKTtcbiAgfVxufTtcblxuLy8gc3JjL2xvYWRlcnMvTFVUQ3ViZUxvYWRlci5qc1xuaW1wb3J0IHsgRmlsZUxvYWRlciBhcyBGaWxlTG9hZGVyMiwgTG9hZGVyIGFzIExvYWRlcjIsIExvYWRpbmdNYW5hZ2VyIGFzIExvYWRpbmdNYW5hZ2VyNCwgVmVjdG9yMyBhcyBWZWN0b3IzNyB9IGZyb20gXCJ0aHJlZVwiO1xudmFyIExVVEN1YmVMb2FkZXIgPSBjbGFzcyBleHRlbmRzIExvYWRlcjIge1xuICAvKipcbiAgICogTG9hZHMgYSBMVVQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBDVUJFLWZpbGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxvYWRdIC0gQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBsb2FkZWQgbG9va3VwIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSAtIEEgcHJvZ3Jlc3MgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgWE1MSHR0cFJlcXVlc3QgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSAtIEFuIGVycm9yIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIFVSTCBvZiB0aGUgZmlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPExvb2t1cFRleHR1cmU+fSBBIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICovXG4gIGxvYWQodXJsLCBvbkxvYWQgPSAoKSA9PiB7XG4gIH0sIG9uUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gIH0sIG9uRXJyb3IgPSBudWxsKSB7XG4gICAgY29uc3QgZXh0ZXJuYWxNYW5hZ2VyID0gdGhpcy5tYW5hZ2VyO1xuICAgIGNvbnN0IGludGVybmFsTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcjQoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcjIoaW50ZXJuYWxNYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJ0ZXh0XCIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvciA9ICh1cmwyKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRXJyb3IodXJsMik7XG4gICAgICAgIGlmIChvbkVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt1cmwyfWApO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoYEZhaWxlZCB0byBsb2FkICR7dXJsMn1gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgKGRhdGEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlKGRhdGEpO1xuICAgICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBpbnRlcm5hbE1hbmFnZXIub25FcnJvcih1cmwpO1xuICAgICAgICB9XG4gICAgICB9LCBvblByb2dyZXNzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgLSBUaGUgTFVUIGRhdGEuXG4gICAqIEByZXR1cm4ge0xvb2t1cFRleHR1cmV9IFRoZSBsb29rdXAgdGV4dHVyZS5cbiAgICogQHRocm93cyB7RXJyb3J9IEZhaWxzIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAqL1xuICBwYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlZ0V4cFRpdGxlID0gL1RJVExFICtcIihbXlwiXSopXCIvO1xuICAgIGNvbnN0IHJlZ0V4cFNpemUgPSAvTFVUXzNEX1NJWkUgKyhcXGQrKS87XG4gICAgY29uc3QgcmVnRXhwRG9tYWluTWluID0gL0RPTUFJTl9NSU4gKyhbXFxkLl0rKSArKFtcXGQuXSspICsoW1xcZC5dKykvO1xuICAgIGNvbnN0IHJlZ0V4cERvbWFpbk1heCA9IC9ET01BSU5fTUFYICsoW1xcZC5dKykgKyhbXFxkLl0rKSArKFtcXGQuXSspLztcbiAgICBjb25zdCByZWdFeHBEYXRhUG9pbnRzID0gL14oW1xcZC5lKy1dKykgKyhbXFxkLmUrLV0rKSArKFtcXGQuZSstXSspICokL2dtO1xuICAgIGxldCByZXN1bHQgPSByZWdFeHBUaXRsZS5leGVjKGlucHV0KTtcbiAgICBjb25zdCB0aXRsZSA9IHJlc3VsdCAhPT0gbnVsbCA/IHJlc3VsdFsxXSA6IG51bGw7XG4gICAgcmVzdWx0ID0gcmVnRXhwU2l6ZS5leGVjKGlucHV0KTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIExVVF8zRF9TSVpFIGluZm9ybWF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqKiAzICogNCk7XG4gICAgY29uc3QgZG9tYWluTWluID0gbmV3IFZlY3RvcjM3KDAsIDAsIDApO1xuICAgIGNvbnN0IGRvbWFpbk1heCA9IG5ldyBWZWN0b3IzNygxLCAxLCAxKTtcbiAgICByZXN1bHQgPSByZWdFeHBEb21haW5NaW4uZXhlYyhpbnB1dCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgZG9tYWluTWluLnNldChOdW1iZXIocmVzdWx0WzFdKSwgTnVtYmVyKHJlc3VsdFsyXSksIE51bWJlcihyZXN1bHRbM10pKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVnRXhwRG9tYWluTWF4LmV4ZWMoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIGRvbWFpbk1heC5zZXQoTnVtYmVyKHJlc3VsdFsxXSksIE51bWJlcihyZXN1bHRbMl0pLCBOdW1iZXIocmVzdWx0WzNdKSk7XG4gICAgfVxuICAgIGlmIChkb21haW5NaW4ueCA+IGRvbWFpbk1heC54IHx8IGRvbWFpbk1pbi55ID4gZG9tYWluTWF4LnkgfHwgZG9tYWluTWluLnogPiBkb21haW5NYXgueikge1xuICAgICAgZG9tYWluTWluLnNldCgwLCAwLCAwKTtcbiAgICAgIGRvbWFpbk1heC5zZXQoMSwgMSwgMSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGRvbWFpblwiKTtcbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRGF0YVBvaW50cy5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGRhdGFbaSsrXSA9IE51bWJlcihyZXN1bHRbMV0pO1xuICAgICAgZGF0YVtpKytdID0gTnVtYmVyKHJlc3VsdFsyXSk7XG4gICAgICBkYXRhW2krK10gPSBOdW1iZXIocmVzdWx0WzNdKTtcbiAgICAgIGRhdGFbaSsrXSA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGx1dCA9IG5ldyBMb29rdXBUZXh0dXJlKGRhdGEsIHNpemUpO1xuICAgIGx1dC5kb21haW5NaW4uY29weShkb21haW5NaW4pO1xuICAgIGx1dC5kb21haW5NYXguY29weShkb21haW5NYXgpO1xuICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgbHV0Lm5hbWUgPSB0aXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGx1dDtcbiAgfVxufTtcblxuLy8gc3JjL2xvYWRlcnMvU01BQUltYWdlTG9hZGVyLmpzXG5pbXBvcnQgeyBMb2FkZXIgYXMgTG9hZGVyMywgTG9hZGluZ01hbmFnZXIgYXMgTG9hZGluZ01hbmFnZXI1IH0gZnJvbSBcInRocmVlXCI7XG52YXIgU01BQUltYWdlTG9hZGVyID0gY2xhc3MgZXh0ZW5kcyBMb2FkZXIzIHtcbiAgLyoqXG4gICAqIExvYWRzIHRoZSBTTUFBIGRhdGEgaW1hZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Mb2FkXSAtIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgc2VhcmNoIGltYWdlIGFuZCBhcmVhIGltYWdlIGFzIGEgcGFpci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQW4gZXJyb3IgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEltYWdlW10+fSBBIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBzZWFyY2ggaW1hZ2UgYW5kIGFyZWEgaW1hZ2UgYXMgYSBwYWlyLlxuICAgKi9cbiAgbG9hZChvbkxvYWQgPSAoKSA9PiB7XG4gIH0sIG9uRXJyb3IgPSBudWxsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIG9uTG9hZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIG9uRXJyb3IgPSBhcmd1bWVudHNbM107XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzIHx8IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb25Mb2FkID0gYXJndW1lbnRzWzFdO1xuICAgICAgb25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVybmFsTWFuYWdlciA9IHRoaXMubWFuYWdlcjtcbiAgICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXI1KCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBjb25zdCBhcmVhSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGludGVybmFsTWFuYWdlci5vbkVycm9yID0gKHVybCkgPT4ge1xuICAgICAgICBleHRlcm5hbE1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgIGlmIChvbkVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt1cmx9YCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpbnRlcm5hbE1hbmFnZXIub25Mb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbc2VhcmNoSW1hZ2UsIGFyZWFJbWFnZV07XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgc2VhcmNoSW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRXJyb3IoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgIH0pO1xuICAgICAgYXJlYUltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbUVycm9yKFwic21hYS1hcmVhXCIpO1xuICAgICAgfSk7XG4gICAgICBzZWFyY2hJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRW5kKFwic21hYS1zZWFyY2hcIik7XG4gICAgICAgIGludGVybmFsTWFuYWdlci5pdGVtRW5kKFwic21hYS1zZWFyY2hcIik7XG4gICAgICB9KTtcbiAgICAgIGFyZWFJbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIGV4dGVybmFsTWFuYWdlci5pdGVtRW5kKFwic21hYS1hcmVhXCIpO1xuICAgICAgICBpbnRlcm5hbE1hbmFnZXIuaXRlbUVuZChcInNtYWEtYXJlYVwiKTtcbiAgICAgIH0pO1xuICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtc2VhcmNoXCIpO1xuICAgICAgZXh0ZXJuYWxNYW5hZ2VyLml0ZW1TdGFydChcInNtYWEtYXJlYVwiKTtcbiAgICAgIGludGVybmFsTWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLXNlYXJjaFwiKTtcbiAgICAgIGludGVybmFsTWFuYWdlci5pdGVtU3RhcnQoXCJzbWFhLWFyZWFcIik7XG4gICAgICBzZWFyY2hJbWFnZS5zcmMgPSBzZWFyY2hJbWFnZURhdGFVUkxfZGVmYXVsdDtcbiAgICAgIGFyZWFJbWFnZS5zcmMgPSBhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQ7XG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBBZGFwdGl2ZUx1bWluYW5jZU1hdGVyaWFsLFxuICBBZGFwdGl2ZUx1bWluYW5jZVBhc3MsXG4gIEJsZW5kRnVuY3Rpb24sXG4gIEJsZW5kTW9kZSxcbiAgQmxvb21FZmZlY3QsXG4gIEthd2FzZUJsdXJQYXNzIGFzIEJsdXJQYXNzLFxuICBCb2tlaEVmZmVjdCxcbiAgQm9rZWhNYXRlcmlhbCxcbiAgQm94Qmx1ck1hdGVyaWFsLFxuICBCb3hCbHVyUGFzcyxcbiAgQnJpZ2h0bmVzc0NvbnRyYXN0RWZmZWN0LFxuICBDaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0LFxuICBDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsLFxuICBDbGVhck1hc2tQYXNzLFxuICBDbGVhclBhc3MsXG4gIENvbG9yQXZlcmFnZUVmZmVjdCxcbiAgQ29sb3JDaGFubmVsLFxuICBDb2xvckRlcHRoRWZmZWN0LFxuICBFZGdlRGV0ZWN0aW9uTWF0ZXJpYWwgYXMgQ29sb3JFZGdlc01hdGVyaWFsLFxuICBLYXdhc2VCbHVyTWF0ZXJpYWwgYXMgQ29udm9sdXRpb25NYXRlcmlhbCxcbiAgQ29weU1hdGVyaWFsLFxuICBDb3B5UGFzcyxcbiAgRGVwdGhDb21wYXJpc29uTWF0ZXJpYWwsXG4gIERlcHRoQ29weU1hdGVyaWFsLFxuICBEZXB0aENvcHlNb2RlLFxuICBEZXB0aENvcHlQYXNzLFxuICBEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsLFxuICBEZXB0aERvd25zYW1wbGluZ1Bhc3MsXG4gIERlcHRoRWZmZWN0LFxuICBEZXB0aE1hc2tNYXRlcmlhbCxcbiAgRGVwdGhPZkZpZWxkRWZmZWN0LFxuICBEZXB0aFBhc3MsXG4gIERlcHRoUGlja2luZ1Bhc3MsXG4gIERlcHRoQ29weVBhc3MgYXMgRGVwdGhTYXZlUGFzcyxcbiAgRGVwdGhUZXN0U3RyYXRlZ3ksXG4gIERpc3BsYXlQM0NvbG9yU3BhY2UsXG4gIERpc3Bvc2FibGUsXG4gIERvdFNjcmVlbkVmZmVjdCxcbiAgRG93bnNhbXBsaW5nTWF0ZXJpYWwsXG4gIEVkZ2VEZXRlY3Rpb25NYXRlcmlhbCxcbiAgRWRnZURldGVjdGlvbk1vZGUsXG4gIEVmZmVjdCxcbiAgRWZmZWN0QXR0cmlidXRlLFxuICBFZmZlY3RDb21wb3NlcixcbiAgRWZmZWN0TWF0ZXJpYWwsXG4gIEVmZmVjdFBhc3MsXG4gIEVmZmVjdFNoYWRlckRhdGEsXG4gIEVmZmVjdFNoYWRlclNlY3Rpb24sXG4gIEZYQUFFZmZlY3QsXG4gIEdhbW1hQ29ycmVjdGlvbkVmZmVjdCxcbiAgR2F1c3NLZXJuZWwsXG4gIEdhdXNzaWFuQmx1ck1hdGVyaWFsLFxuICBHYXVzc2lhbkJsdXJQYXNzLFxuICBHbGl0Y2hFZmZlY3QsXG4gIEdsaXRjaE1vZGUsXG4gIEdvZFJheXNFZmZlY3QsXG4gIEdvZFJheXNNYXRlcmlhbCxcbiAgR3JpZEVmZmVjdCxcbiAgSHVlU2F0dXJhdGlvbkVmZmVjdCxcbiAgSW1tdXRhYmxlVGltZXIsXG4gIEluaXRpYWxpemFibGUsXG4gIEthd2FzZUJsdXJNYXRlcmlhbCxcbiAgS2F3YXNlQmx1clBhc3MsXG4gIEtlcm5lbFNpemUsXG4gIExVVDFERWZmZWN0LFxuICBMVVQzREVmZmVjdCxcbiAgTFVUM2RsTG9hZGVyLFxuICBMVVRDdWJlTG9hZGVyLFxuICBMVVQzREVmZmVjdCBhcyBMVVRFZmZlY3QsXG4gIExVVE9wZXJhdGlvbixcbiAgTGFtYmRhUGFzcyxcbiAgTGVuc0Rpc3RvcnRpb25FZmZlY3QsXG4gIExpbmVhclNSR0JDb2xvclNwYWNlLFxuICBMb29rdXBUZXh0dXJlLFxuICBMb29rdXBUZXh0dXJlIGFzIExvb2t1cFRleHR1cmUzRCxcbiAgTHVtaW5hbmNlTWF0ZXJpYWwsXG4gIEx1bWluYW5jZVBhc3MsXG4gIE1hc2tGdW5jdGlvbixcbiAgTWFza01hdGVyaWFsLFxuICBNYXNrUGFzcyxcbiAgTWlwbWFwQmx1clBhc3MsXG4gIE5vQ29sb3JTcGFjZSxcbiAgTm9pc2VFZmZlY3QsXG4gIE5vaXNlVGV4dHVyZSxcbiAgTm9ybWFsUGFzcyxcbiAgT3V0bGluZU1hdGVyaWFsIGFzIE91dGxpbmVFZGdlc01hdGVyaWFsLFxuICBPdXRsaW5lRWZmZWN0LFxuICBPdXRsaW5lTWF0ZXJpYWwsXG4gIE92ZXJyaWRlTWF0ZXJpYWxNYW5hZ2VyLFxuICBQYXNzLFxuICBQaXhlbGF0aW9uRWZmZWN0LFxuICBQcmVkaWNhdGlvbk1vZGUsXG4gIFJhd0ltYWdlRGF0YSxcbiAgUmVhbGlzdGljQm9rZWhFZmZlY3QsXG4gIFJlbmRlclBhc3MsXG4gIFJlc2l6YWJsZSxcbiAgUmVzb2x1dGlvbiBhcyBSZXNpemVyLFxuICBSZXNvbHV0aW9uLFxuICBTTUFBQXJlYUltYWdlRGF0YSxcbiAgU01BQUVmZmVjdCxcbiAgU01BQUltYWdlR2VuZXJhdG9yLFxuICBTTUFBSW1hZ2VMb2FkZXIsXG4gIFNNQUFQcmVzZXQsXG4gIFNNQUFTZWFyY2hJbWFnZURhdGEsXG4gIFNNQUFXZWlnaHRzTWF0ZXJpYWwsXG4gIFNSR0JDb2xvclNwYWNlLFxuICBTU0FPRWZmZWN0LFxuICBTU0FPTWF0ZXJpYWwsXG4gIENvcHlQYXNzIGFzIFNhdmVQYXNzLFxuICBTY2FubGluZUVmZmVjdCxcbiAgRWZmZWN0U2hhZGVyU2VjdGlvbiBhcyBTZWN0aW9uLFxuICBTZWxlY3Rpb24sXG4gIFNlbGVjdGl2ZUJsb29tRWZmZWN0LFxuICBTZXBpYUVmZmVjdCxcbiAgU2hhZGVyUGFzcyxcbiAgU2hvY2tXYXZlRWZmZWN0LFxuICBUZXRyYWhlZHJhbFVwc2NhbGVyLFxuICBUZXh0dXJlRWZmZWN0LFxuICBUaWx0U2hpZnRCbHVyTWF0ZXJpYWwsXG4gIFRpbHRTaGlmdEJsdXJQYXNzLFxuICBUaWx0U2hpZnRFZmZlY3QsXG4gIFRpbWVyLFxuICBUb25lTWFwcGluZ0VmZmVjdCxcbiAgVG9uZU1hcHBpbmdNb2RlLFxuICBVcHNhbXBsaW5nTWF0ZXJpYWwsXG4gIFZpZ25ldHRlRWZmZWN0LFxuICBWaWduZXR0ZVRlY2huaXF1ZSxcbiAgV2ViR0xFeHRlbnNpb24sXG4gIHZlcnNpb25cbn07XG4iXSwibmFtZXMiOlsidmVyc2lvbiIsIkRpc3Bvc2FibGUiLCJkaXNwb3NlIiwiRGVwdGhTdGVuY2lsRm9ybWF0IiwiRGVwdGhUZXh0dXJlIiwiTGluZWFyRmlsdGVyIiwiTGluZWFyRmlsdGVyMiIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJVbnNpZ25lZEJ5dGVUeXBlMTEiLCJVbnNpZ25lZEludFR5cGUiLCJVbnNpZ25lZEludDI0OFR5cGUiLCJWZWN0b3IyIiwiVmVjdG9yMjE2IiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJXZWJHTFJlbmRlclRhcmdldDEzIiwiTmVhcmVzdEZpbHRlciIsIldlYkdMUmVuZGVyVGFyZ2V0MyIsIk5vQmxlbmRpbmciLCJTaGFkZXJNYXRlcmlhbCIsIlVuaWZvcm0iLCJhZGFwdGl2ZV9sdW1pbmFuY2VfZGVmYXVsdCIsImNvbW1vbl9kZWZhdWx0IiwiQWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImRlZmluZXMiLCJNSVBfTEVWRUxfMVgxIiwidW5pZm9ybXMiLCJsdW1pbmFuY2VCdWZmZXIwIiwibHVtaW5hbmNlQnVmZmVyMSIsIm1pbkx1bWluYW5jZSIsImRlbHRhVGltZSIsInRhdSIsImV4dGVuc2lvbnMiLCJzaGFkZXJUZXh0dXJlTE9EIiwiYmxlbmRpbmciLCJ0b25lTWFwcGVkIiwiZGVwdGhXcml0ZSIsImRlcHRoVGVzdCIsImZyYWdtZW50U2hhZGVyIiwidmVydGV4U2hhZGVyIiwidmFsdWUiLCJzZXRMdW1pbmFuY2VCdWZmZXIwIiwic2V0THVtaW5hbmNlQnVmZmVyMSIsIm1pcExldmVsMXgxIiwidG9GaXhlZCIsIm5lZWRzVXBkYXRlIiwic2V0TWlwTGV2ZWwxeDEiLCJzZXREZWx0YVRpbWUiLCJnZXRNaW5MdW1pbmFuY2UiLCJzZXRNaW5MdW1pbmFuY2UiLCJhZGFwdGF0aW9uUmF0ZSIsImdldEFkYXB0YXRpb25SYXRlIiwic2V0QWRhcHRhdGlvblJhdGUiLCJOb0JsZW5kaW5nMiIsIlNoYWRlck1hdGVyaWFsMiIsIlVuaWZvcm0yIiwiY29udm9sdXRpb25fYm9rZWhfZGVmYXVsdCIsIkJva2VoTWF0ZXJpYWwiLCJmaWxsIiwiZm9yZWdyb3VuZCIsIlBBU1MiLCJpbnB1dEJ1ZmZlciIsImNvY0J1ZmZlciIsInRleGVsU2l6ZSIsImtlcm5lbDY0Iiwia2VybmVsMTYiLCJzY2FsZSIsIkZPUkVHUk9VTkQiLCJnZW5lcmF0ZUtlcm5lbCIsInNldElucHV0QnVmZmVyIiwic2V0Q29DQnVmZmVyIiwiZ2V0U2NhbGUiLCJzZXRTY2FsZSIsIkdPTERFTl9BTkdMRSIsInBvaW50czY0IiwiRmxvYXQ2NEFycmF5IiwicG9pbnRzMTYiLCJpNjQiLCJpMTYiLCJpIiwic3FydDgwIiwiTWF0aCIsInNxcnQiLCJ0aGV0YSIsInIiLCJ1IiwiY29zIiwidjMiLCJzaW4iLCJzZXRUZXhlbFNpemUiLCJ4IiwieSIsInNldCIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsIk5vQmxlbmRpbmczIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJTaGFkZXJNYXRlcmlhbDMiLCJVbmlmb3JtMyIsIlZlY3RvcjIyIiwiTGluZWFyRW5jb2RpbmciLCJSRVZJU0lPTiIsInNSR0JFbmNvZGluZyIsIkJsZW5kRnVuY3Rpb24iLCJTS0lQIiwiU0VUIiwiQUREIiwiQUxQSEEiLCJBVkVSQUdFIiwiQ09MT1IiLCJDT0xPUl9CVVJOIiwiQ09MT1JfRE9ER0UiLCJEQVJLRU4iLCJESUZGRVJFTkNFIiwiRElWSURFIiwiRFNUIiwiRVhDTFVTSU9OIiwiSEFSRF9MSUdIVCIsIkhBUkRfTUlYIiwiSFVFIiwiSU5WRVJUIiwiSU5WRVJUX1JHQiIsIkxJR0hURU4iLCJMSU5FQVJfQlVSTiIsIkxJTkVBUl9ET0RHRSIsIkxJTkVBUl9MSUdIVCIsIkxVTUlOT1NJVFkiLCJNVUxUSVBMWSIsIk5FR0FUSU9OIiwiTk9STUFMIiwiT1ZFUkxBWSIsIlBJTl9MSUdIVCIsIlJFRkxFQ1QiLCJTQVRVUkFUSU9OIiwiU0NSRUVOIiwiU09GVF9MSUdIVCIsIlNSQyIsIlNVQlRSQUNUIiwiVklWSURfTElHSFQiLCJDb2xvckNoYW5uZWwiLCJSRUQiLCJHUkVFTiIsIkJMVUUiLCJOb0NvbG9yU3BhY2UiLCJTUkdCQ29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwiRGlzcGxheVAzQ29sb3JTcGFjZSIsIkRlcHRoQ29weU1vZGUiLCJGVUxMIiwiU0lOR0xFIiwiRGVwdGhUZXN0U3RyYXRlZ3kiLCJERUZBVUxUIiwiS0VFUF9NQVhfREVQVEgiLCJESVNDQVJEX01BWF9ERVBUSCIsIkVkZ2VEZXRlY3Rpb25Nb2RlIiwiREVQVEgiLCJMVU1BIiwiRWZmZWN0QXR0cmlidXRlIiwiTk9ORSIsIkNPTlZPTFVUSU9OIiwiRWZmZWN0U2hhZGVyU2VjdGlvbiIsIkZSQUdNRU5UX0hFQUQiLCJGUkFHTUVOVF9NQUlOX1VWIiwiRlJBR01FTlRfTUFJTl9JTUFHRSIsIlZFUlRFWF9IRUFEIiwiVkVSVEVYX01BSU5fU1VQUE9SVCIsIkdsaXRjaE1vZGUiLCJESVNBQkxFRCIsIlNQT1JBRElDIiwiQ09OU1RBTlRfTUlMRCIsIkNPTlNUQU5UX1dJTEQiLCJLZXJuZWxTaXplIiwiVkVSWV9TTUFMTCIsIlNNQUxMIiwiTUVESVVNIiwiTEFSR0UiLCJWRVJZX0xBUkdFIiwiSFVHRSIsIkxVVE9wZXJhdGlvbiIsIlNDQUxFX1VQIiwiTWFza0Z1bmN0aW9uIiwiRElTQ0FSRCIsIk1VTFRJUExZX1JHQl9TRVRfQUxQSEEiLCJNVUxUSVBMWV9SR0IiLCJQcmVkaWNhdGlvbk1vZGUiLCJDVVNUT00iLCJTTUFBUHJlc2V0IiwiTE9XIiwiSElHSCIsIlVMVFJBIiwiVG9uZU1hcHBpbmdNb2RlIiwiUkVJTkhBUkQiLCJSRUlOSEFSRDIiLCJSRUlOSEFSRDJfQURBUFRJVkUiLCJVTkNIQVJURUQyIiwiT1BUSU1JWkVEX0NJTkVPTiIsIkFDRVNfRklMTUlDIiwiQUdYIiwiVmlnbmV0dGVUZWNobmlxdWUiLCJFU0tJTCIsIldlYkdMRXh0ZW5zaW9uIiwiREVSSVZBVElWRVMiLCJGUkFHX0RFUFRIIiwiRFJBV19CVUZGRVJTIiwiU0hBREVSX1RFWFRVUkVfTE9EIiwicmV2aXNpb24iLCJOdW1iZXIiLCJyZXBsYWNlIiwidXNlQ29sb3JTcGFjZSIsImVuY29kaW5nVG9Db2xvclNwYWNlIiwiTWFwIiwiY29sb3JTcGFjZVRvRW5jb2RpbmciLCJnZXRPdXRwdXRDb2xvclNwYWNlIiwicmVuZGVyZXIiLCJvdXRwdXRDb2xvclNwYWNlIiwiZ2V0Iiwib3V0cHV0RW5jb2RpbmciLCJzZXRUZXh0dXJlQ29sb3JTcGFjZSIsInRleHR1cmUiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJjb3B5VGV4dHVyZUNvbG9yU3BhY2UiLCJzcmMiLCJkZXN0IiwidXBkYXRlRnJhZ21lbnRTaGFkZXIiLCJ2YWxpZGF0ZVRvbmVNYXBwaW5nTW9kZSIsIm1vZGUiLCJjb25zb2xlIiwid2FybiIsIm9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiIsImRlcHRoIiwibmVhciIsImZhciIsInZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCIsInZpZXdaIiwibWluIiwibWF4IiwiY29udm9sdXRpb25fYm94X2RlZmF1bHQiLCJjb252b2x1dGlvbl9ib3hfZGVmYXVsdDIiLCJCb3hCbHVyTWF0ZXJpYWwiLCJiaWxhdGVyYWwiLCJrZXJuZWxTaXplIiwiREVQVEhfUEFDS0lORyIsIkRJU1RBTkNFX1RIUkVTSE9MRCIsImRlcHRoQnVmZmVyIiwibm9ybWFsRGVwdGhCdWZmZXIiLCJjYW1lcmFOZWFyRmFyIiwibWF4VmFyeWluZ1ZlY3RvcnMiLCJNQVhfVkFSWUlOR19WRUNUT1JTIiwiS0VSTkVMX1NJWkUiLCJFcnJvciIsIktFUk5FTF9TSVpFX0hBTEYiLCJmbG9vciIsIktFUk5FTF9TSVpFX1NRIiwiS0VSTkVMX1NJWkVfU1FfSEFMRiIsIklOVl9LRVJORUxfU0laRV9TUSIsIk5PUk1BTF9ERVBUSCIsImRlcHRoUGFja2luZyIsIkJJTEFURVJBTCIsIndvcmxkRGlzdGFuY2VUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJjb3B5Q2FtZXJhU2V0dGluZ3MiLCJjYW1lcmEiLCJQRVJTUEVDVElWRV9DQU1FUkEiLCJCYXNpY0RlcHRoUGFja2luZyIsIk5vQmxlbmRpbmc0IiwiUGVyc3BlY3RpdmVDYW1lcmEyIiwiU2hhZGVyTWF0ZXJpYWw0IiwiVW5pZm9ybTQiLCJjaXJjbGVfb2ZfY29uZnVzaW9uX2RlZmF1bHQiLCJDaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsIiwiZm9jdXNEaXN0YW5jZSIsImZvY3VzUmFuZ2UiLCJjYW1lcmFOZWFyIiwiY2FtZXJhRmFyIiwiZm9jYWxMZW5ndGgiLCJzZXREZXB0aEJ1ZmZlciIsImJ1ZmZlciIsIndvcmxkRm9jdXNEaXN0YW5jZSIsImdldEZvY3VzRGlzdGFuY2UiLCJzZXRGb2N1c0Rpc3RhbmNlIiwid29ybGRGb2N1c1JhbmdlIiwiZ2V0Rm9jYWxMZW5ndGgiLCJzZXRGb2NhbExlbmd0aCIsImFkb3B0Q2FtZXJhU2V0dGluZ3MiLCJOb0JsZW5kaW5nNSIsIlNoYWRlck1hdGVyaWFsNSIsIlVuaWZvcm01IiwiVmVjdG9yNCIsImNvbnZvbHV0aW9uX2thd2FzZV9kZWZhdWx0IiwiY29udm9sdXRpb25fa2F3YXNlX2RlZmF1bHQyIiwia2VybmVsUHJlc2V0cyIsIkZsb2F0MzJBcnJheSIsIkthd2FzZUJsdXJNYXRlcmlhbCIsImtlcm5lbCIsImtlcm5lbFNlcXVlbmNlIiwiZ2V0S2VybmVsIiwic2V0S2VybmVsIiwiTm9CbGVuZGluZzYiLCJTaGFkZXJNYXRlcmlhbDYiLCJVbmlmb3JtNiIsImNvcHlfZGVmYXVsdCIsIkNvcHlNYXRlcmlhbCIsIm9wYWNpdHkiLCJnZXRPcGFjaXR5Iiwic2V0T3BhY2l0eSIsIk5vQmxlbmRpbmc3IiwiUGVyc3BlY3RpdmVDYW1lcmEzIiwiUkdCQURlcHRoUGFja2luZyIsIlNoYWRlck1hdGVyaWFsNyIsIlVuaWZvcm03IiwiZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0IiwiZGVwdGhfY29tcGFyaXNvbl9kZWZhdWx0MiIsIkRlcHRoQ29tcGFyaXNvbk1hdGVyaWFsIiwiZGVwdGhUZXh0dXJlIiwiQmFzaWNEZXB0aFBhY2tpbmcyIiwiTm9CbGVuZGluZzgiLCJTaGFkZXJNYXRlcmlhbDgiLCJVbmlmb3JtOCIsIlZlY3RvcjIzIiwiZGVwdGhfY29weV9kZWZhdWx0IiwiZGVwdGhfY29weV9kZWZhdWx0MiIsIkRlcHRoQ29weU1hdGVyaWFsIiwiSU5QVVRfREVQVEhfUEFDS0lORyIsIk9VVFBVVF9ERVBUSF9QQUNLSU5HIiwiREVQVEhfQ09QWV9NT0RFIiwidGV4ZWxQb3NpdGlvbiIsImRlcHRoQ29weU1vZGUiLCJpbnB1dERlcHRoUGFja2luZyIsIm91dHB1dERlcHRoUGFja2luZyIsImdldElucHV0RGVwdGhQYWNraW5nIiwic2V0SW5wdXREZXB0aFBhY2tpbmciLCJnZXRPdXRwdXREZXB0aFBhY2tpbmciLCJzZXRPdXRwdXREZXB0aFBhY2tpbmciLCJnZXRUZXhlbFBvc2l0aW9uIiwic2V0VGV4ZWxQb3NpdGlvbiIsImdldE1vZGUiLCJzZXRNb2RlIiwiQmFzaWNEZXB0aFBhY2tpbmczIiwiTm9CbGVuZGluZzkiLCJTaGFkZXJNYXRlcmlhbDkiLCJVbmlmb3JtOSIsIlZlY3RvcjI0IiwiZGVwdGhfZG93bnNhbXBsaW5nX2RlZmF1bHQiLCJkZXB0aF9kb3duc2FtcGxpbmdfZGVmYXVsdDIiLCJEZXB0aERvd25zYW1wbGluZ01hdGVyaWFsIiwibm9ybWFsQnVmZmVyIiwiRE9XTlNBTVBMRV9OT1JNQUxTIiwic2V0Tm9ybWFsQnVmZmVyIiwiQWx3YXlzRGVwdGgiLCJCYXNpY0RlcHRoUGFja2luZzQiLCJFcXVhbERlcHRoIiwiR3JlYXRlckRlcHRoIiwiR3JlYXRlckVxdWFsRGVwdGgiLCJMZXNzRGVwdGgiLCJMZXNzRXF1YWxEZXB0aCIsIk5ldmVyRGVwdGgiLCJOb0JsZW5kaW5nMTAiLCJOb3RFcXVhbERlcHRoIiwiUGVyc3BlY3RpdmVDYW1lcmE0IiwiU2hhZGVyTWF0ZXJpYWwxMCIsIlVuaWZvcm0xMCIsIlZlY3RvcjI1IiwiZGVwdGhfbWFza19kZWZhdWx0IiwiRGVwdGhNYXNrTWF0ZXJpYWwiLCJERVBUSF9FUFNJTE9OIiwiREVQVEhfUEFDS0lOR18wIiwiREVQVEhfUEFDS0lOR18xIiwiREVQVEhfVEVTVF9TVFJBVEVHWSIsImRlcHRoQnVmZmVyMCIsImRlcHRoQnVmZmVyMSIsImRlcHRoTW9kZSIsImRlcHRoUGFja2luZzAiLCJzZXREZXB0aEJ1ZmZlcjAiLCJkZXB0aFBhY2tpbmcxIiwic2V0RGVwdGhCdWZmZXIxIiwibWF4RGVwdGhTdHJhdGVneSIsImtlZXBGYXIiLCJnZXRNYXhEZXB0aFN0cmF0ZWd5Iiwic2V0TWF4RGVwdGhTdHJhdGVneSIsImVwc2lsb24iLCJnZXRFcHNpbG9uIiwic2V0RXBzaWxvbiIsIkRFUFRIX01PREUiLCJnZXREZXB0aE1vZGUiLCJzZXREZXB0aE1vZGUiLCJOb0JsZW5kaW5nMTEiLCJTaGFkZXJNYXRlcmlhbDExIiwiVW5pZm9ybTExIiwiVmVjdG9yMjYiLCJjb252b2x1dGlvbl9kb3duc2FtcGxpbmdfZGVmYXVsdCIsImNvbnZvbHV0aW9uX2Rvd25zYW1wbGluZ19kZWZhdWx0MiIsIkRvd25zYW1wbGluZ01hdGVyaWFsIiwiQmFzaWNEZXB0aFBhY2tpbmc1IiwiTm9CbGVuZGluZzEyIiwiUkVWSVNJT04yIiwiU2hhZGVyTWF0ZXJpYWwxMiIsIlVuaWZvcm0xMiIsIlZlY3RvcjI3IiwiZWRnZV9kZXRlY3Rpb25fZGVmYXVsdCIsImVkZ2VfZGV0ZWN0aW9uX2RlZmF1bHQyIiwiRWRnZURldGVjdGlvbk1hdGVyaWFsIiwiVEhSRUVfUkVWSVNJT04iLCJMT0NBTF9DT05UUkFTVF9BREFQVEFUSU9OX0ZBQ1RPUiIsIkVER0VfVEhSRVNIT0xEIiwiREVQVEhfVEhSRVNIT0xEIiwiUFJFRElDQVRJT05fTU9ERSIsIlBSRURJQ0FUSU9OX1RIUkVTSE9MRCIsIlBSRURJQ0FUSU9OX1NDQUxFIiwiUFJFRElDQVRJT05fU1RSRU5HVEgiLCJwcmVkaWNhdGlvbkJ1ZmZlciIsImVkZ2VEZXRlY3Rpb25Nb2RlIiwiRURHRV9ERVRFQ1RJT05fTU9ERSIsImdldEVkZ2VEZXRlY3Rpb25Nb2RlIiwic2V0RWRnZURldGVjdGlvbk1vZGUiLCJsb2NhbENvbnRyYXN0QWRhcHRhdGlvbkZhY3RvciIsImdldExvY2FsQ29udHJhc3RBZGFwdGF0aW9uRmFjdG9yIiwic2V0TG9jYWxDb250cmFzdEFkYXB0YXRpb25GYWN0b3IiLCJlZGdlRGV0ZWN0aW9uVGhyZXNob2xkIiwiZ2V0RWRnZURldGVjdGlvblRocmVzaG9sZCIsInNldEVkZ2VEZXRlY3Rpb25UaHJlc2hvbGQiLCJwcmVkaWNhdGlvbk1vZGUiLCJnZXRQcmVkaWNhdGlvbk1vZGUiLCJzZXRQcmVkaWNhdGlvbk1vZGUiLCJzZXRQcmVkaWNhdGlvbkJ1ZmZlciIsInByZWRpY2F0aW9uVGhyZXNob2xkIiwiZ2V0UHJlZGljYXRpb25UaHJlc2hvbGQiLCJzZXRQcmVkaWNhdGlvblRocmVzaG9sZCIsInByZWRpY2F0aW9uU2NhbGUiLCJnZXRQcmVkaWNhdGlvblNjYWxlIiwic2V0UHJlZGljYXRpb25TY2FsZSIsInByZWRpY2F0aW9uU3RyZW5ndGgiLCJnZXRQcmVkaWNhdGlvblN0cmVuZ3RoIiwic2V0UHJlZGljYXRpb25TdHJlbmd0aCIsIkJhc2ljRGVwdGhQYWNraW5nNiIsIk5vQmxlbmRpbmcxMyIsIlBlcnNwZWN0aXZlQ2FtZXJhNSIsIlJFVklTSU9OMyIsIlNoYWRlck1hdGVyaWFsMTMiLCJVbmlmb3JtMTMiLCJWZWN0b3IyOCIsImVmZmVjdF9kZWZhdWx0IiwiZWZmZWN0X2RlZmF1bHQyIiwiRWZmZWN0TWF0ZXJpYWwiLCJzaGFkZXJQYXJ0cyIsImRpdGhlcmluZyIsIkVOQ09ERV9PVVRQVVQiLCJyZXNvbHV0aW9uIiwiYXNwZWN0IiwidGltZSIsInNldFNoYWRlclBhcnRzIiwic2V0RGVmaW5lcyIsInNldFVuaWZvcm1zIiwic2V0U2hhZGVyRGF0YSIsImRhdGEiLCJzZXRFeHRlbnNpb25zIiwiZW50cnkiLCJlbnRyaWVzIiwiZXh0ZW5zaW9uIiwiZW5jb2RlT3V0cHV0IiwiaXNPdXRwdXRFbmNvZGluZ0VuYWJsZWQiLCJzZXRPdXRwdXRFbmNvZGluZ0VuYWJsZWQiLCJTZWN0aW9uIiwiTm9CbGVuZGluZzE0IiwiU2hhZGVyTWF0ZXJpYWwxNCIsIlVuaWZvcm0xNCIsIlZlY3RvcjI5IiwiY29udm9sdXRpb25fZ2F1c3NpYW5fZGVmYXVsdCIsImNvbnZvbHV0aW9uX2dhdXNzaWFuX2RlZmF1bHQyIiwiR2F1c3NpYW5CbHVyTWF0ZXJpYWwiLCJkaXJlY3Rpb24iLCJfa2VybmVsU2l6ZSIsIkdhdXNzS2VybmVsIiwic3RlcHMiLCJsaW5lYXJTdGVwcyIsImtlcm5lbERhdGEiLCJqIiwibGluZWFyT2Zmc2V0cyIsImxpbmVhcldlaWdodHMiLCJTVEVQUyIsIk5vQmxlbmRpbmcxNSIsIlNoYWRlck1hdGVyaWFsMTUiLCJVbmlmb3JtMTUiLCJjb252b2x1dGlvbl9nb2RfcmF5c19kZWZhdWx0IiwiR29kUmF5c01hdGVyaWFsIiwibGlnaHRQb3NpdGlvbiIsIlNBTVBMRVNfSU5UIiwiU0FNUExFU19GTE9BVCIsImRlbnNpdHkiLCJkZWNheSIsIndlaWdodCIsImV4cG9zdXJlIiwiY2xhbXBNYXgiLCJnZXRMaWdodFBvc2l0aW9uIiwic2V0TGlnaHRQb3NpdGlvbiIsImdldERlbnNpdHkiLCJzZXREZW5zaXR5IiwiZ2V0RGVjYXkiLCJzZXREZWNheSIsImdldFdlaWdodCIsInNldFdlaWdodCIsImdldEV4cG9zdXJlIiwic2V0RXhwb3N1cmUiLCJtYXhJbnRlbnNpdHkiLCJnZXRNYXhJbnRlbnNpdHkiLCJzZXRNYXhJbnRlbnNpdHkiLCJzYW1wbGVzIiwicyIsImdldFNhbXBsZXMiLCJzZXRTYW1wbGVzIiwiTm9CbGVuZGluZzE2IiwiUkVWSVNJT040IiwiU2hhZGVyTWF0ZXJpYWwxNiIsIlVuaWZvcm0xNiIsImx1bWluYW5jZV9kZWZhdWx0IiwiTHVtaW5hbmNlTWF0ZXJpYWwiLCJjb2xvck91dHB1dCIsImx1bWluYW5jZVJhbmdlIiwic21vb3RoaW5nIiwicmFuZ2UiLCJUSFJFU0hPTEQiLCJnZXRUaHJlc2hvbGQiLCJzZXRUaHJlc2hvbGQiLCJnZXRTbW9vdGhpbmdGYWN0b3IiLCJzZXRTbW9vdGhpbmdGYWN0b3IiLCJ1c2VUaHJlc2hvbGQiLCJpc0NvbG9yT3V0cHV0RW5hYmxlZCIsInNldENvbG9yT3V0cHV0RW5hYmxlZCIsInVzZVJhbmdlIiwiUkFOR0UiLCJnZXRMdW1pbmFuY2VSYW5nZSIsInNldEx1bWluYW5jZVJhbmdlIiwiTm9CbGVuZGluZzE3IiwiU2hhZGVyTWF0ZXJpYWwxNyIsIlVuaWZvcm0xNyIsIm1hc2tfZGVmYXVsdCIsIk1hc2tNYXRlcmlhbCIsIm1hc2tUZXh0dXJlIiwic3RyZW5ndGgiLCJjb2xvckNoYW5uZWwiLCJtYXNrRnVuY3Rpb24iLCJNQVNLX1BSRUNJU0lPTl9ISUdIIiwidHlwZSIsInNldE1hc2tUZXh0dXJlIiwiQ09MT1JfQ0hBTk5FTCIsInNldENvbG9yQ2hhbm5lbCIsIk1BU0tfRlVOQ1RJT04iLCJzZXRNYXNrRnVuY3Rpb24iLCJpbnZlcnRlZCIsIklOVkVSVEVEIiwiaXNJbnZlcnRlZCIsInNldEludmVydGVkIiwiZ2V0U3RyZW5ndGgiLCJzZXRTdHJlbmd0aCIsIk5vQmxlbmRpbmcxOCIsIlNoYWRlck1hdGVyaWFsMTgiLCJVbmlmb3JtMTgiLCJWZWN0b3IyMTAiLCJvdXRsaW5lX2RlZmF1bHQiLCJvdXRsaW5lX2RlZmF1bHQyIiwiT3V0bGluZU1hdGVyaWFsIiwiTm9CbGVuZGluZzE5IiwiU2hhZGVyTWF0ZXJpYWwxOSIsIlVuaWZvcm0xOSIsIlZlY3RvcjIxMSIsInNtYWFfd2VpZ2h0c19kZWZhdWx0Iiwic21hYV93ZWlnaHRzX2RlZmF1bHQyIiwiU01BQVdlaWdodHNNYXRlcmlhbCIsIk1BWF9TRUFSQ0hfU1RFUFNfSU5UIiwiTUFYX1NFQVJDSF9TVEVQU19GTE9BVCIsIk1BWF9TRUFSQ0hfU1RFUFNfRElBR19JTlQiLCJNQVhfU0VBUkNIX1NURVBTX0RJQUdfRkxPQVQiLCJDT1JORVJfUk9VTkRJTkciLCJDT1JORVJfUk9VTkRJTkdfTk9STSIsIkFSRUFURVhfTUFYX0RJU1RBTkNFIiwiQVJFQVRFWF9NQVhfRElTVEFOQ0VfRElBRyIsIkFSRUFURVhfUElYRUxfU0laRSIsIkFSRUFURVhfU1VCVEVYX1NJWkUiLCJTRUFSQ0hURVhfU0laRSIsIlNFQVJDSFRFWF9QQUNLRURfU0laRSIsInNlYXJjaFRleHR1cmUiLCJhcmVhVGV4dHVyZSIsInNldExvb2t1cFRleHR1cmVzIiwic2VhcmNoIiwiYXJlYTIiLCJvcnRob2dvbmFsU2VhcmNoU3RlcHMiLCJzZXRPcnRob2dvbmFsU2VhcmNoU3RlcHMiLCJkaWFnb25hbFNlYXJjaFN0ZXBzIiwic2V0RGlhZ29uYWxTZWFyY2hTdGVwcyIsImRpYWdvbmFsRGV0ZWN0aW9uIiwiRElTQUJMRV9ESUFHX0RFVEVDVElPTiIsImlzRGlhZ29uYWxEZXRlY3Rpb25FbmFibGVkIiwic2V0RGlhZ29uYWxEZXRlY3Rpb25FbmFibGVkIiwiY29ybmVyUm91bmRpbmciLCJzZXRDb3JuZXJSb3VuZGluZyIsImNvcm5lckRldGVjdGlvbiIsIkRJU0FCTEVfQ09STkVSX0RFVEVDVElPTiIsImlzQ29ybmVyUm91bmRpbmdFbmFibGVkIiwic2V0Q29ybmVyUm91bmRpbmdFbmFibGVkIiwiQmFzaWNEZXB0aFBhY2tpbmc3IiwiTWF0cml4NCIsIk5vQmxlbmRpbmcyMCIsIlBlcnNwZWN0aXZlQ2FtZXJhNiIsIlNoYWRlck1hdGVyaWFsMjAiLCJVbmlmb3JtMjAiLCJWZWN0b3IyMTIiLCJzc2FvX2RlZmF1bHQiLCJzc2FvX2RlZmF1bHQyIiwiU1NBT01hdGVyaWFsIiwiSU5WX1NBTVBMRVNfRkxPQVQiLCJTUElSQUxfVFVSTlMiLCJSQURJVVMiLCJSQURJVVNfU1EiLCJESVNUQU5DRV9TQ0FMSU5HIiwibm9pc2VUZXh0dXJlIiwiaW52ZXJzZVByb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwiZGlzdGFuY2VDdXRvZmYiLCJwcm94aW1pdHlDdXRvZmYiLCJub2lzZVNjYWxlIiwibWluUmFkaXVzU2NhbGUiLCJpbnRlbnNpdHkiLCJmYWRlIiwiYmlhcyIsInNldE5vcm1hbERlcHRoQnVmZmVyIiwic2V0Tm9pc2VUZXh0dXJlIiwicmluZ3MiLCJnZXRSaW5ncyIsInNldFJpbmdzIiwiTEVHQUNZX0lOVEVOU0lUWSIsImdldEludGVuc2l0eSIsInNldEludGVuc2l0eSIsImdldEZhZGUiLCJzZXRGYWRlIiwiZ2V0QmlhcyIsInNldEJpYXMiLCJnZXRNaW5SYWRpdXNTY2FsZSIsInNldE1pblJhZGl1c1NjYWxlIiwidXBkYXRlUmFkaXVzIiwicmFkaXVzIiwiZ2V0UmFkaXVzIiwic2V0UmFkaXVzIiwiZGlzdGFuY2VTY2FsaW5nIiwiaXNEaXN0YW5jZVNjYWxpbmdFbmFibGVkIiwic2V0RGlzdGFuY2VTY2FsaW5nRW5hYmxlZCIsImRpc3RhbmNlVGhyZXNob2xkIiwiZGlzdGFuY2VGYWxsb2ZmIiwid29ybGREaXN0YW5jZUZhbGxvZmYiLCJzZXREaXN0YW5jZUN1dG9mZiIsImZhbGxvZmYiLCJwcm94aW1pdHlUaHJlc2hvbGQiLCJwcm94aW1pdHlGYWxsb2ZmIiwid29ybGRQcm94aW1pdHlUaHJlc2hvbGQiLCJ3b3JsZFByb3hpbWl0eUZhbGxvZmYiLCJzZXRQcm94aW1pdHlDdXRvZmYiLCJjb3B5IiwiaW52ZXJ0IiwiaW1hZ2UiLCJVbmlmb3JtMjEiLCJWZWN0b3IyMTMiLCJWZWN0b3I0MiIsImNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdCIsImNvbnZvbHV0aW9uX3RpbHRfc2hpZnRfZGVmYXVsdDIiLCJUaWx0U2hpZnRCbHVyTWF0ZXJpYWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImZvY3VzQXJlYSIsImZlYXRoZXIiLCJtYXNrUGFyYW1zIiwiX29mZnNldCIsIl9mb2N1c0FyZWEiLCJfZmVhdGhlciIsInVwZGF0ZVBhcmFtcyIsInBhcmFtcyIsImEiLCJiIiwiYWNvcyIsIk5vQmxlbmRpbmcyMSIsIlNoYWRlck1hdGVyaWFsMjEiLCJVbmlmb3JtMjIiLCJWZWN0b3IyMTQiLCJjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQiLCJjb252b2x1dGlvbl91cHNhbXBsaW5nX2RlZmF1bHQyIiwiVXBzYW1wbGluZ01hdGVyaWFsIiwic3VwcG9ydEJ1ZmZlciIsIlVuc2lnbmVkQnl0ZVR5cGUyIiwiV2ViR0xSZW5kZXJUYXJnZXQyIiwiQmFzaWNEZXB0aFBhY2tpbmc4IiwiQnVmZmVyQXR0cmlidXRlIiwiQnVmZmVyR2VvbWV0cnkiLCJDYW1lcmEiLCJNYXRlcmlhbCIsIk1lc2giLCJTY2VuZSIsIlRleHR1cmUiLCJkdW1teUNhbWVyYSIsImdlb21ldHJ5IiwiZ2V0RnVsbHNjcmVlblRyaWFuZ2xlIiwidmVydGljZXMiLCJ1dnMiLCJzZXRBdHRyaWJ1dGUiLCJhZGRBdHRyaWJ1dGUiLCJQYXNzIiwiX1Bhc3MiLCJzY2VuZSIsInNjcmVlbiIsInJ0dCIsIm5lZWRzU3dhcCIsIm5lZWRzRGVwdGhUZXh0dXJlIiwiZW5hYmxlZCIsInJlbmRlclRvU2NyZWVuIiwibWF0ZXJpYWwiLCJmdWxsc2NyZWVuTWF0ZXJpYWwiLCJtYWluU2NlbmUiLCJtYWluQ2FtZXJhIiwic2V0UmVuZGVyZXIiLCJpc0VuYWJsZWQiLCJzZXRFbmFibGVkIiwiZnJ1c3R1bUN1bGxlZCIsImFkZCIsImdldEZ1bGxzY3JlZW5NYXRlcmlhbCIsInNldEZ1bGxzY3JlZW5NYXRlcmlhbCIsImdldERlcHRoVGV4dHVyZSIsInNldERlcHRoVGV4dHVyZSIsInJlbmRlciIsIm91dHB1dEJ1ZmZlciIsInN0ZW5jaWxUZXN0IiwiaW5pdGlhbGl6ZSIsImFscGhhIiwiZnJhbWVCdWZmZXJUeXBlIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsInByb3BlcnR5IiwiaXNEaXNwb3NhYmxlIiwiQ29weVBhc3MiLCJyZW5kZXJUYXJnZXQiLCJhdXRvUmVzaXplIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwic3RlbmNpbEJ1ZmZlciIsInJlc2l6ZSIsImdldFRleHR1cmUiLCJzZXRBdXRvUmVzaXplRW5hYmxlZCIsInNldFJlbmRlclRhcmdldCIsIkZSQU1FQlVGRkVSX1BSRUNJU0lPTl9ISUdIIiwiQWRhcHRpdmVMdW1pbmFuY2VQYXNzIiwibHVtaW5hbmNlQnVmZmVyIiwicmVuZGVyVGFyZ2V0UHJldmlvdXMiLCJyZW5kZXJUYXJnZXRBZGFwdGVkIiwiY2xvbmUiLCJjb3B5UGFzcyIsIkJhc2ljRGVwdGhQYWNraW5nOSIsIlVuc2lnbmVkQnl0ZVR5cGUzIiwiV2ViR0xSZW5kZXJUYXJnZXQ0IiwiQm94Qmx1clBhc3MiLCJpdGVyYXRpb25zIiwicmVzb2x1dGlvblNjYWxlIiwicmVzb2x1dGlvblgiLCJSZXNvbHV0aW9uIiwiQVVUT19TSVpFIiwicmVzb2x1dGlvblkiLCJyZW5kZXJUYXJnZXRBIiwicmVuZGVyVGFyZ2V0QiIsImJsdXJNYXRlcmlhbCIsImNvcHlNYXRlcmlhbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiYmFzZVdpZHRoIiwiYmFzZUhlaWdodCIsInByZXZpb3VzQnVmZmVyIiwibCIsInNldEJhc2VTaXplIiwidyIsImgiLCJjYXBhYmlsaXRpZXMiLCJtYXhWYXJ5aW5ncyIsIkNsZWFyTWFza1Bhc3MiLCJzdGVuY2lsIiwic3RhdGUiLCJidWZmZXJzIiwic2V0TG9ja2VkIiwic2V0VGVzdCIsIkNvbG9yIiwiY29sb3IiLCJDbGVhclBhc3MiLCJjb2xvcjIiLCJvdmVycmlkZUNsZWFyQ29sb3IiLCJvdmVycmlkZUNsZWFyQWxwaGEiLCJzZXRDbGVhckZsYWdzIiwiZ2V0T3ZlcnJpZGVDbGVhckNvbG9yIiwic2V0T3ZlcnJpZGVDbGVhckNvbG9yIiwiZ2V0T3ZlcnJpZGVDbGVhckFscGhhIiwic2V0T3ZlcnJpZGVDbGVhckFscGhhIiwiY2xlYXJBbHBoYSIsImdldENsZWFyQWxwaGEiLCJoYXNPdmVycmlkZUNsZWFyQ29sb3IiLCJoYXNPdmVycmlkZUNsZWFyQWxwaGEiLCJnZXRDbGVhckNvbG9yIiwic2V0Q2xlYXJDb2xvciIsInNldENsZWFyQWxwaGEiLCJjbGVhciIsIkNvbG9yMiIsIk1lc2hEZXB0aE1hdGVyaWFsIiwiTmVhcmVzdEZpbHRlcjIiLCJSR0JBRGVwdGhQYWNraW5nMiIsIldlYkdMUmVuZGVyVGFyZ2V0NSIsIlJlbmRlclBhc3MiLCJvdmVycmlkZU1hdGVyaWFsIiwiY2xlYXJQYXNzIiwib3ZlcnJpZGVNYXRlcmlhbE1hbmFnZXIiLCJPdmVycmlkZU1hdGVyaWFsTWFuYWdlciIsImlnbm9yZUJhY2tncm91bmQiLCJza2lwU2hhZG93TWFwVXBkYXRlIiwic2VsZWN0aW9uIiwibWFuYWdlciIsInNldE1hdGVyaWFsIiwiZ2V0T3ZlcnJpZGVNYXRlcmlhbCIsInNldE92ZXJyaWRlTWF0ZXJpYWwiLCJnZXRTZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJpc0JhY2tncm91bmREaXNhYmxlZCIsInNldEJhY2tncm91bmREaXNhYmxlZCIsImlzU2hhZG93TWFwRGlzYWJsZWQiLCJzZXRTaGFkb3dNYXBEaXNhYmxlZCIsImdldENsZWFyUGFzcyIsIm1hc2siLCJsYXllcnMiLCJiYWNrZ3JvdW5kIiwic2hhZG93TWFwQXV0b1VwZGF0ZSIsInNoYWRvd01hcCIsImF1dG9VcGRhdGUiLCJnZXRMYXllciIsIkRlcHRoUGFzcyIsInJlbmRlclBhc3MiLCJnZXRSZXNvbHV0aW9uIiwiZ2V0UmVzb2x1dGlvblNjYWxlIiwic2V0UmVzb2x1dGlvblNjYWxlIiwiQmFzaWNEZXB0aFBhY2tpbmcxMCIsIkZsb2F0VHlwZSIsIk5lYXJlc3RGaWx0ZXIzIiwiV2ViR0xSZW5kZXJUYXJnZXQ2IiwiRGVwdGhEb3duc2FtcGxpbmdQYXNzIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZ2wiLCJnZXRDb250ZXh0IiwicmVuZGVyYWJsZSIsImdldEV4dGVuc2lvbiIsIkZsb2F0VHlwZTMiLCJSR0JBRGVwdGhQYWNraW5nNCIsIkJhc2ljRGVwdGhQYWNraW5nMTEiLCJGbG9hdFR5cGUyIiwiTmVhcmVzdEZpbHRlcjQiLCJSR0JBRGVwdGhQYWNraW5nMyIsIlVuc2lnbmVkQnl0ZVR5cGU0IiwiV2ViR0xSZW5kZXJUYXJnZXQ3IiwiRGVwdGhDb3B5UGFzcyIsImdldERlcHRoUGFja2luZyIsInVucGFja0ZhY3RvcnMiLCJ1bnBhY2tSR0JBVG9EZXB0aCIsInBhY2tlZERlcHRoIiwiRGVwdGhQaWNraW5nUGFzcyIsInBpeGVsQnVmZmVyIiwiVWludDhBcnJheSIsImNhbGxiYWNrIiwicmVhZERlcHRoIiwibmRjIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYWNrZWQiLCJyb3VuZCIsInJlYWRSZW5kZXJUYXJnZXRQaXhlbHMiLCJCYXNpY0RlcHRoUGFja2luZzEyIiwiVW5zaWduZWRCeXRlVHlwZTUiLCJwcmVmaXhTdWJzdHJpbmdzIiwicHJlZml4Iiwic3Vic3RyaW5ncyIsInN0cmluZ3MiLCJzdWJzdHJpbmciLCJwcmVmaXhlZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJyZWdFeHAiLCJSZWdFeHAiLCJpbnRlZ3JhdGVFZmZlY3QiLCJlZmZlY3QiLCJnZXRGcmFnbWVudFNoYWRlciIsImdldFZlcnRleFNoYWRlciIsIm1haW5JbWFnZUV4aXN0cyIsInRlc3QiLCJtYWluVXZFeGlzdHMiLCJhdHRyaWJ1dGVzIiwiZ2V0QXR0cmlidXRlcyIsImZ1bmN0aW9uUmVnRXhwIiwiZnJhZ21lbnRIZWFkIiwiZnJhZ21lbnRNYWluVXYiLCJmcmFnbWVudE1haW5JbWFnZSIsInZlcnRleEhlYWQiLCJ2ZXJ0ZXhNYWluU3VwcG9ydCIsInZhcnlpbmdzIiwiU2V0IiwibmFtZXMiLCJ1dlRyYW5zZm9ybWF0aW9uIiwibmVlZHNVdiIsIm0yIiwibWF0Y2hBbGwiLCJuIiwic3BsaXQiLCJkIiwiZGVsZXRlIiwiZm9yRWFjaCIsInZhbCIsInNoYWRlcnMiLCJibGVuZE1vZGUiLCJibGVuZE1vZGVzIiwiYmxlbmRGdW5jdGlvbiIsImlucHV0Q29sb3JTcGFjZSIsImRlcHRoUGFyYW1SZWdFeHAiLCJibGVuZE9wYWNpdHkiLCJFZmZlY3RQYXNzIiwiZWZmZWN0cyIsImxpc3RlbmVyIiwiZXZlbnQiLCJoYW5kbGVFdmVudCIsInNldEVmZmVjdHMiLCJza2lwUmVuZGVyaW5nIiwibWluVGltZSIsIm1heFRpbWUiLCJQT1NJVElWRV9JTkZJTklUWSIsInRpbWVTY2FsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzb3J0IiwidXBkYXRlTWF0ZXJpYWwiLCJFZmZlY3RTaGFkZXJEYXRhIiwiaWQiLCJibGVuZFJlZ0V4cCIsInZhbHVlcyIsImdldFNoYWRlckNvZGUiLCJ0cmltIiwicmVjb21waWxlIiwidXBkYXRlIiwiVW5zaWduZWRCeXRlVHlwZTYiLCJXZWJHTFJlbmRlclRhcmdldDgiLCJHYXVzc2lhbkJsdXJQYXNzIiwiVW5zaWduZWRCeXRlVHlwZTciLCJXZWJHTFJlbmRlclRhcmdldDkiLCJLYXdhc2VCbHVyUGFzcyIsIl9ibHVyTWF0ZXJpYWwiLCJwcmVmZXJyZWRXaWR0aCIsInByZWZlcnJlZEhlaWdodCIsImdldEtlcm5lbFNpemUiLCJzZXRLZXJuZWxTaXplIiwibGVuZ3RoIiwiTGFtYmRhUGFzcyIsImYiLCJVbnNpZ25lZEJ5dGVUeXBlOCIsIldlYkdMUmVuZGVyVGFyZ2V0MTAiLCJMdW1pbmFuY2VQYXNzIiwiTWFza1Bhc3MiLCJpbnZlcnNlIiwiY29udGV4dCIsIndyaXRlVmFsdWUiLCJjbGVhclZhbHVlIiwic2V0TWFzayIsInNldE9wIiwiUkVQTEFDRSIsInNldEZ1bmMiLCJBTFdBWVMiLCJzZXRDbGVhciIsIkVRVUFMIiwiS0VFUCIsIlVuc2lnbmVkQnl0ZVR5cGU5IiwiVmVjdG9yMjE1IiwiV2ViR0xSZW5kZXJUYXJnZXQxMSIsIk1pcG1hcEJsdXJQYXNzIiwiZG93bnNhbXBsaW5nTWlwbWFwcyIsInVwc2FtcGxpbmdNaXBtYXBzIiwiZG93bnNhbXBsaW5nTWF0ZXJpYWwiLCJ1cHNhbXBsaW5nTWF0ZXJpYWwiLCJsZXZlbHMiLCJtaXBtYXAiLCJwdXNoIiwibWlwbWFwcyIsImNvbmNhdCIsIkNvbG9yMyIsIk1lc2hOb3JtYWxNYXRlcmlhbCIsIk5lYXJlc3RGaWx0ZXI1IiwiV2ViR0xSZW5kZXJUYXJnZXQxMiIsIk5vcm1hbFBhc3MiLCJVbnNpZ25lZEJ5dGVUeXBlMTAiLCJTaGFkZXJQYXNzIiwiaW5wdXQiLCJzZXRJbnB1dCIsIlRpbHRTaGlmdEJsdXJQYXNzIiwiTUlMTElTRUNPTkRTX1RPX1NFQ09ORFMiLCJTRUNPTkRTX1RPX01JTExJU0VDT05EUyIsIlRpbWVyIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJwcmV2aW91c1RpbWUiLCJjdXJyZW50VGltZSIsIl9kZWx0YSIsIl9lbGFwc2VkIiwiX2ZpeGVkRGVsdGEiLCJ0aW1lc2NhbGUiLCJ1c2VGaXhlZERlbHRhIiwiX2F1dG9SZXNldCIsImF1dG9SZXNldCIsImRvY3VtZW50IiwiaGlkZGVuIiwiZGVsdGEiLCJmaXhlZERlbHRhIiwiZWxhcHNlZCIsInRpbWVzdGFtcCIsInJlc2V0IiwiRWZmZWN0Q29tcG9zZXIiLCJtdWx0aXNhbXBsaW5nIiwiY3JlYXRlQnVmZmVyIiwicGFzc2VzIiwidGltZXIiLCJhdXRvUmVuZGVyVG9TY3JlZW4iLCJnZXRUaW1lciIsImdldFJlbmRlcmVyIiwic2l6ZSIsImdldFNpemUiLCJnZXRDb250ZXh0QXR0cmlidXRlcyIsImF1dG9DbGVhciIsInBhc3MiLCJyZXBsYWNlUmVuZGVyZXIiLCJ1cGRhdGVET00iLCJvbGRSZW5kZXJlciIsInBhcmVudCIsImRvbUVsZW1lbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZURlcHRoVGV4dHVyZSIsImZvcm1hdCIsImRlbGV0ZURlcHRoVGV4dHVyZSIsImdldERyYXdpbmdCdWZmZXJTaXplIiwib3B0aW9ucyIsImlnbm9yZURlcHRoRm9yTXVsdGlzYW1wbGVDb3B5Iiwic2V0TWFpblNjZW5lIiwic2V0TWFpbkNhbWVyYSIsImFkZFBhc3MiLCJpbmRleCIsImRyYXdpbmdCdWZmZXJTaXplIiwic3BsaWNlIiwicmVtb3ZlUGFzcyIsImluZGV4T2YiLCJleGlzdHMiLCJyZW1vdmVkIiwicmVkdWNlciIsImRlcHRoVGV4dHVyZVJlcXVpcmVkIiwicmVkdWNlIiwicmVtb3ZlQWxsUGFzc2VzIiwiTk9URVFVQUwiLCJ1cGRhdGVTdHlsZSIsImN1cnJlbnRTaXplIiwiZ2V0Q29lZmZpY2llbnRzIiwicmVzdWx0Iiwicm93MCIsInJvdzEiLCJlZGdlQmlhcyIsIndlaWdodHMiLCJvZmZzZXRzIiwiZ2VuZXJhdGUiLCJjb2VmZmljaWVudHMiLCJtaWQiLCJzdW0iLCJBcnJheSIsIm9mZnNldDAiLCJvZmZzZXQxIiwid2VpZ2h0MCIsIndlaWdodDEiLCJvIiwibGluZWFyV2VpZ2h0U3VtIiwiSW1tdXRhYmxlVGltZXIiLCJOYU4iLCJJbml0aWFsaXphYmxlIiwiQmFja1NpZGUiLCJEb3VibGVTaWRlIiwiRnJvbnRTaWRlIiwiU2hhZGVyTWF0ZXJpYWwyMiIsIndvcmthcm91bmRFbmFibGVkIiwib3JpZ2luYWxNYXRlcmlhbHMiLCJtYXRlcmlhbHMiLCJtYXRlcmlhbHNCYWNrU2lkZSIsIm1hdGVyaWFsc0RvdWJsZVNpZGUiLCJtYXRlcmlhbHNGbGF0U2hhZGVkIiwibWF0ZXJpYWxzRmxhdFNoYWRlZEJhY2tTaWRlIiwibWF0ZXJpYWxzRmxhdFNoYWRlZERvdWJsZVNpZGUiLCJtZXNoQ291bnQiLCJyZXBsYWNlTWF0ZXJpYWwiLCJub2RlIiwiaXNNZXNoIiwiZmxhdFNoYWRpbmciLCJzaWRlIiwiaXNTa2lubmVkTWVzaCIsImlzSW5zdGFuY2VkTWVzaCIsImNsb25lTWF0ZXJpYWwiLCJ0ZXh0dXJlVW5pZm9ybXMiLCJpc1JlbmRlclRhcmdldFRleHR1cmUiLCJkaXNwb3NlTWF0ZXJpYWxzIiwiYXNzaWduIiwic2tpbm5pbmciLCJtYXAiLCJjMiIsInNoYWRvd01hcEVuYWJsZWQiLCJ0cmF2ZXJzZSIsIlJlc2l6YWJsZSIsIkV2ZW50RGlzcGF0Y2hlciIsIlZlY3RvcjIxNyIsInJlc2l6YWJsZSIsImJhc2VTaXplIiwicHJlZmVycmVkU2l6ZSIsInRhcmdldCIsImVmZmVjdGl2ZVNpemUiLCJ1cGRhdGVFZmZlY3RpdmVTaXplIiwiYmFzZSIsInByZWZlcnJlZCIsImVmZmVjdGl2ZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0Iiwic2V0U2NhbGFyIiwiZGlzcGF0Y2hFdmVudCIsImdldEJhc2VXaWR0aCIsInNldEJhc2VXaWR0aCIsImdldEJhc2VIZWlnaHQiLCJzZXRCYXNlSGVpZ2h0IiwiZ2V0UHJlZmVycmVkV2lkdGgiLCJzZXRQcmVmZXJyZWRXaWR0aCIsImdldFByZWZlcnJlZEhlaWdodCIsInNldFByZWZlcnJlZEhlaWdodCIsInNldFByZWZlcnJlZFNpemUiLCJTZWxlY3Rpb24iLCJpdGVyYWJsZSIsImxheWVyIiwiZXhjbHVzaXZlIiwiY3VycmVudExheWVyIiwib2JqZWN0IiwiZGlzYWJsZSIsImVuYWJsZSIsInNldExheWVyIiwiaXNFeGNsdXNpdmUiLCJzZXRFeGNsdXNpdmUiLCJvYmplY3RzIiwiaGFzIiwidG9nZ2xlIiwic2V0VmlzaWJsZSIsInZpc2libGUiLCJFdmVudERpc3BhdGNoZXIyIiwiVW5pZm9ybTIzIiwiYWRkX2RlZmF1bHQiLCJhbHBoYV9kZWZhdWx0IiwiYXZlcmFnZV9kZWZhdWx0IiwiY29sb3JfZGVmYXVsdCIsImNvbG9yX2J1cm5fZGVmYXVsdCIsImNvbG9yX2RvZGdlX2RlZmF1bHQiLCJkYXJrZW5fZGVmYXVsdCIsImRpZmZlcmVuY2VfZGVmYXVsdCIsImRpdmlkZV9kZWZhdWx0IiwiZXhjbHVzaW9uX2RlZmF1bHQiLCJoYXJkX2xpZ2h0X2RlZmF1bHQiLCJoYXJkX21peF9kZWZhdWx0IiwiaHVlX2RlZmF1bHQiLCJpbnZlcnRfZGVmYXVsdCIsImludmVydF9yZ2JfZGVmYXVsdCIsImxpZ2h0ZW5fZGVmYXVsdCIsImxpbmVhcl9idXJuX2RlZmF1bHQiLCJsaW5lYXJfZG9kZ2VfZGVmYXVsdCIsImxpbmVhcl9saWdodF9kZWZhdWx0IiwibHVtaW5vc2l0eV9kZWZhdWx0IiwibXVsdGlwbHlfZGVmYXVsdCIsIm5lZ2F0aW9uX2RlZmF1bHQiLCJub3JtYWxfZGVmYXVsdCIsIm92ZXJsYXlfZGVmYXVsdCIsInBpbl9saWdodF9kZWZhdWx0IiwicmVmbGVjdF9kZWZhdWx0Iiwic2F0dXJhdGlvbl9kZWZhdWx0Iiwic2NyZWVuX2RlZmF1bHQiLCJzb2Z0X2xpZ2h0X2RlZmF1bHQiLCJzcmNfZGVmYXVsdCIsInN1YnRyYWN0X2RlZmF1bHQiLCJ2aXZpZF9saWdodF9kZWZhdWx0IiwiYmxlbmRGdW5jdGlvbnMiLCJCbGVuZE1vZGUiLCJfYmxlbmRGdW5jdGlvbiIsImdldEJsZW5kRnVuY3Rpb24iLCJzZXRCbGVuZEZ1bmN0aW9uIiwiVW5pZm9ybTI0IiwiV2ViR0xSZW5kZXJUYXJnZXQxNSIsIkJhc2ljRGVwdGhQYWNraW5nMTMiLCJFdmVudERpc3BhdGNoZXIzIiwiTWF0ZXJpYWwyIiwiVGV4dHVyZTIiLCJXZWJHTFJlbmRlclRhcmdldDE0IiwiRWZmZWN0Iiwic2V0Q2hhbmdlZCIsIl9pbnB1dENvbG9yU3BhY2UiLCJfb3V0cHV0Q29sb3JTcGFjZSIsImdldE5hbWUiLCJnZXREZWZpbmVzIiwiZ2V0VW5pZm9ybXMiLCJnZXRFeHRlbnNpb25zIiwiZ2V0QmxlbmRNb2RlIiwic2V0QXR0cmlidXRlcyIsInNldEZyYWdtZW50U2hhZGVyIiwic2V0VmVydGV4U2hhZGVyIiwiYmxvb21fZGVmYXVsdCIsIkJsb29tRWZmZWN0IiwibHVtaW5hbmNlVGhyZXNob2xkIiwibHVtaW5hbmNlU21vb3RoaW5nIiwibWlwbWFwQmx1ciIsImJsdXJQYXNzIiwibHVtaW5hbmNlUGFzcyIsImx1bWluYW5jZU1hdGVyaWFsIiwibWlwbWFwQmx1clBhc3MiLCJnZXRCbHVyUGFzcyIsImdldEx1bWluYW5jZVBhc3MiLCJnZXRMdW1pbmFuY2VNYXRlcmlhbCIsImRpc3RpbmN0aW9uIiwiVW5pZm9ybTI1IiwiYm9rZWhfZGVmYXVsdCIsIkJva2VoRWZmZWN0IiwiZm9jdXMiLCJkb2YiLCJhcGVydHVyZSIsIm1heEJsdXIiLCJVbmlmb3JtMjYiLCJicmlnaHRuZXNzX2NvbnRyYXN0X2RlZmF1bHQiLCJCcmlnaHRuZXNzQ29udHJhc3RFZmZlY3QiLCJicmlnaHRuZXNzIiwiY29udHJhc3QiLCJnZXRCcmlnaHRuZXNzIiwic2V0QnJpZ2h0bmVzcyIsImdldENvbnRyYXN0Iiwic2V0Q29udHJhc3QiLCJjb2xvcl9hdmVyYWdlX2RlZmF1bHQiLCJDb2xvckF2ZXJhZ2VFZmZlY3QiLCJVbmlmb3JtMjciLCJjb2xvcl9kZXB0aF9kZWZhdWx0IiwiQ29sb3JEZXB0aEVmZmVjdCIsImJpdHMiLCJiaXREZXB0aCIsInBvdyIsImdldEJpdERlcHRoIiwic2V0Qml0RGVwdGgiLCJVbmlmb3JtMjgiLCJWZWN0b3IyMTgiLCJjaHJvbWF0aWNfYWJlcnJhdGlvbl9kZWZhdWx0IiwiY2hyb21hdGljX2FiZXJyYXRpb25fZGVmYXVsdDIiLCJDaHJvbWF0aWNBYmVycmF0aW9uRWZmZWN0IiwicmFkaWFsTW9kdWxhdGlvbiIsIm1vZHVsYXRpb25PZmZzZXQiLCJnZXRPZmZzZXQiLCJzZXRPZmZzZXQiLCJkZXB0aF9kZWZhdWx0IiwiRGVwdGhFZmZlY3QiLCJCYXNpY0RlcHRoUGFja2luZzE0IiwiVW5pZm9ybTI5IiwiVW5zaWduZWRCeXRlVHlwZTEyIiwiV2ViR0xSZW5kZXJUYXJnZXQxNiIsImRlcHRoX29mX2ZpZWxkX2RlZmF1bHQiLCJEZXB0aE9mRmllbGRFZmZlY3QiLCJib2tlaFNjYWxlIiwicmVuZGVyVGFyZ2V0TWFza2VkIiwicmVuZGVyVGFyZ2V0TmVhciIsInJlbmRlclRhcmdldEZhciIsInJlbmRlclRhcmdldENvQyIsInJlbmRlclRhcmdldENvQ0JsdXJyZWQiLCJjb2NQYXNzIiwiY29jTWF0ZXJpYWwiLCJtYXNrUGFzcyIsIm1hc2tNYXRlcmlhbCIsImJva2VoTmVhckJhc2VQYXNzIiwiYm9rZWhOZWFyRmlsbFBhc3MiLCJib2tlaEZhckJhc2VQYXNzIiwiYm9rZWhGYXJGaWxsUGFzcyIsImNvY1RleHR1cmUiLCJjaXJjbGVPZkNvbmZ1c2lvbk1hdGVyaWFsIiwiZ2V0Q2lyY2xlT2ZDb25mdXNpb25NYXRlcmlhbCIsImdldEJva2VoU2NhbGUiLCJzZXRCb2tlaFNjYWxlIiwiZ2V0VGFyZ2V0Iiwic2V0VGFyZ2V0IiwiY2FsY3VsYXRlRm9jdXNEaXN0YW5jZSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciIsIkxPR19ERVBUSCIsIlVuaWZvcm0zMCIsIlZlY3RvcjIxOSIsImRvdF9zY3JlZW5fZGVmYXVsdCIsIkRvdFNjcmVlbkVmZmVjdCIsImFuZ2xlIiwiUEkiLCJnZXRBbmdsZSIsInNldEFuZ2xlIiwiZnhhYV9kZWZhdWx0IiwiZnhhYV9kZWZhdWx0MiIsIkZYQUFFZmZlY3QiLCJtaW5FZGdlVGhyZXNob2xkIiwibWF4RWRnZVRocmVzaG9sZCIsInN1YnBpeGVsUXVhbGl0eSIsIlVuaWZvcm0zMSIsImdhbW1hX2NvcnJlY3Rpb25fZGVmYXVsdCIsIkdhbW1hQ29ycmVjdGlvbkVmZmVjdCIsImdhbW1hIiwiTmVhcmVzdEZpbHRlcjYiLCJSZXBlYXRXcmFwcGluZyIsIlJHQkFGb3JtYXQiLCJSR0JBRm9ybWF0MyIsIlVuaWZvcm0zMiIsIlZlY3RvcjIyMCIsIkNvbG9yNCIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJEYXRhVGV4dHVyZSIsIkRhdGEzRFRleHR1cmUiLCJGbG9hdFR5cGU0IiwiTGluZWFyRmlsdGVyMyIsIlVuc2lnbmVkQnl0ZVR5cGUxMyIsIlZlY3RvcjMiLCJjcmVhdGVDYW52YXMiLCJjYW52YXMiLCJjcmVhdGVFbGVtZW50IiwiSW1hZ2UiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJSYXdJbWFnZURhdGEiLCJfUmF3SW1hZ2VEYXRhIiwidG9DYW52YXMiLCJmcm9tIiwiZ2V0SW1hZ2VEYXRhIiwid29ya2VyX2RlZmF1bHQiLCJjIiwiTG9va3VwVGV4dHVyZSIsIl9Mb29rdXBUZXh0dXJlIiwid3JhcFMiLCJ3cmFwVCIsIndyYXBSIiwidW5wYWNrQWxpZ25tZW50IiwiZG9tYWluTWluIiwiZG9tYWluTWF4IiwiaXNMb29rdXBUZXh0dXJlM0QiLCJzY2FsZVVwIiwidHJhbnNmZXJEYXRhIiwicHJvbWlzZSIsInJlamVjdCIsIndvcmtlclVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ3b3JrZXIiLCJXb3JrZXIiLCJlcnJvciIsImx1dCIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zZmVyTGlzdCIsInBvc3RNZXNzYWdlIiwib3BlcmF0aW9uIiwiYXBwbHlMVVQiLCJpbWcwIiwiaW1nMSIsInNpemUwIiwic2l6ZTEiLCJkYXRhMCIsImRhdGExIiwic2l6ZVNxIiwiaTQiLCJnIiwiaVJHQiIsImNvbnZlcnRUb1VpbnQ4IiwiZmxvYXREYXRhIiwidWludDhEYXRhIiwiY29udmVydFRvRmxvYXQiLCJjb252ZXJ0VG9SR0JBIiwiY29udmVydExpbmVhclRvU1JHQiIsImZyb21BcnJheSIsInRvQXJyYXkiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwidG9EYXRhVGV4dHVyZSIsInJhd0ltYWdlRGF0YSIsInoiLCJqNCIsImNyZWF0ZU5ldXRyYWwiLCJQIiwiQyIsIlQiLCJjYWxjdWxhdGVUZXRyYWhlZHJvblZvbHVtZSIsImJjWCIsImJjWSIsImJjWiIsImJhWCIsImJhWSIsImJhWiIsImNyb3NzWCIsImNyb3NzWSIsImNyb3NzWiIsInRyaWFuZ2xlQXJlYSIsIm5vcm1hbFgiLCJub3JtYWxZIiwibm9ybWFsWiIsImNvbnN0YW50IiwiZG90IiwiYWJzIiwic2FtcGxlIiwidGV0cmFoZWRyYWxTYW1wbGUiLCJweCIsInB5IiwicHoiLCJtaW5YIiwibWluWSIsIm1pbloiLCJtYXhYIiwiY2VpbCIsIm1heFkiLCJtYXhaIiwic3UiLCJzdiIsInN3IiwiUDAiLCJQMSIsIlAyIiwiUDMiLCJjb29yZHMiLCJ0bXAiLCJkaWZmWCIsImRpZmZZIiwiZGlmZloiLCJWMCIsIlYxIiwiVjIiLCJWMyIsIlRldHJhaGVkcmFsVXBzY2FsZXIiLCJleHBhbmQiLCJvcmlnaW5hbFNpemUiLCJjYnJ0IiwicmdiIiwiYXJyYXkiLCJtYXhWYWx1ZSIsImFyZWEiLCJPUlRIT0dPTkFMX1NJWkUiLCJESUFHT05BTF9TSVpFIiwiRElBR09OQUxfU0FNUExFUyIsIlNNT09USF9NQVhfRElTVEFOQ0UiLCJvcnRob2dvbmFsU3Vic2FtcGxpbmdPZmZzZXRzIiwiZGlhZ29uYWxTdWJzYW1wbGluZ09mZnNldHMiLCJvcnRob2dvbmFsRWRnZXMiLCJkaWFnb25hbEVkZ2VzIiwibGVycCIsInAiLCJzYXR1cmF0ZSIsInNtb290aEFyZWEiLCJhMSIsImEyIiwiYjFYIiwiYjFZIiwiYjJYIiwiYjJZIiwiZ2V0T3J0aEFyZWEiLCJwMVgiLCJwMVkiLCJwMlgiLCJwMlkiLCJkWCIsImRZIiwieDEiLCJ4MiIsInkxIiwieTIiLCJzaWduIiwidCIsInRJbnQiLCJ0cnVuYyIsImdldE9ydGhBcmVhRm9yUGF0dGVybiIsInBhdHRlcm4iLCJsZWZ0IiwicmlnaHQiLCJvMSIsIm8yIiwiaXNJbnNpZGVBcmVhIiwiYTFYIiwiYTFZIiwiYTJYIiwiYTJZIiwieG0iLCJ5bSIsImdldERpYWdBcmVhRm9yUGl4ZWwiLCJwWCIsInBZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJnZXREaWFnQXJlYSIsImUxIiwiZTIiLCJnZXREaWFnQXJlYUZvclBhdHRlcm4iLCJnZW5lcmF0ZVBhdHRlcm5zIiwicGF0dGVybnMiLCJvcnRob2dvbmFsIiwiYXNzZW1ibGUiLCJiYXNlWCIsImJhc2VZIiwiZWRnZXMyIiwiZHN0RGF0YSIsImRzdFdpZHRoIiwiZWRnZSIsInNyY0RhdGEiLCJzcmNXaWR0aCIsIlNNQUFBcmVhSW1hZ2VEYXRhIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvcnRoUGF0dGVyblNpemUiLCJkaWFnUGF0dGVyblNpemUiLCJvcnRob2dvbmFsUGF0dGVybnMiLCJkaWFnb25hbFBhdHRlcm5zIiwiTG9hZGluZ01hbmFnZXIiLCJ3b3JrZXJfZGVmYXVsdDIiLCJ1c2VDYWNoZSIsInNlYXJjaEltYWdlRGF0YSIsImFyZWFJbWFnZURhdGEiLCJ1cmxzIiwidG9EYXRhVVJMIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIlNNQUFJbWFnZUdlbmVyYXRvciIsImRpc2FibGVDYWNoZSIsInNldENhY2hlRW5hYmxlZCIsIndpbmRvdyIsImNhY2hlZFVSTHMiLCJnZXRJdGVtIiwidGhlbiIsInNlYXJjaEltYWdlIiwiYXJlYUltYWdlIiwib25Mb2FkIiwib25FcnJvciIsIml0ZW1FcnJvciIsIml0ZW1FbmQiLCJpdGVtU3RhcnQiLCJlZGdlcyIsImJpbGluZWFyIiwibGVycDIiLCJlMCIsImUzIiwiZGVsdGFMZWZ0IiwidG9wIiwiZGVsdGFSaWdodCIsIlNNQUFTZWFyY2hJbWFnZURhdGEiLCJoYWxmV2lkdGgiLCJjcm9wcGVkV2lkdGgiLCJjcm9wcGVkSGVpZ2h0IiwiY3JvcHBlZERhdGEiLCJEYXRhVGV4dHVyZTIiLCJMdW1pbmFuY2VGb3JtYXQiLCJSZWRGb3JtYXQiLCJSR0Zvcm1hdCIsIlJHQkFGb3JtYXQyIiwiVW5zaWduZWRCeXRlVHlwZTE0IiwiZ2V0Tm9pc2UiLCJjaGFubmVscyIsInJhbmRvbSIsIk5vaXNlVGV4dHVyZSIsImdsaXRjaF9kZWZhdWx0IiwidGV4dHVyZVRhZyIsInJhbmRvbUZsb2F0IiwibG93IiwiaGlnaCIsIkdsaXRjaEVmZmVjdCIsImNocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQiLCJkZWxheSIsImR1cmF0aW9uIiwiY29sdW1ucyIsInJhdGlvIiwicGVydHVyYmF0aW9uTWFwIiwiZHRTaXplIiwiZGlzdG9ydGlvbiIsImJyZWFrUG9pbnQiLCJzZWVkcyIsImFjdGl2ZSIsImlzQWN0aXZlIiwibWluRGVsYXkiLCJnZXRNaW5EZWxheSIsInNldE1pbkRlbGF5IiwibWF4RGVsYXkiLCJnZXRNYXhEZWxheSIsInNldE1heERlbGF5IiwibWluRHVyYXRpb24iLCJnZXRNaW5EdXJhdGlvbiIsInNldE1pbkR1cmF0aW9uIiwibWF4RHVyYXRpb24iLCJnZXRNYXhEdXJhdGlvbiIsInNldE1heER1cmF0aW9uIiwibWluU3RyZW5ndGgiLCJnZXRNaW5TdHJlbmd0aCIsInNldE1pblN0cmVuZ3RoIiwibWF4U3RyZW5ndGgiLCJnZXRNYXhTdHJlbmd0aCIsInNldE1heFN0cmVuZ3RoIiwiZ2V0R2xpdGNoUmF0aW8iLCJzZXRHbGl0Y2hSYXRpbyIsImdldEdsaXRjaENvbHVtbnMiLCJzZXRHbGl0Y2hDb2x1bW5zIiwiZ2V0Q2hyb21hdGljQWJlcnJhdGlvbk9mZnNldCIsInNldENocm9tYXRpY0FiZXJyYXRpb25PZmZzZXQiLCJjdXJyZW50TWFwIiwiZ2V0UGVydHVyYmF0aW9uTWFwIiwic2V0UGVydHVyYmF0aW9uTWFwIiwiZ2VuZXJhdGVQZXJ0dXJiYXRpb25NYXAiLCJ0cmlnZ2VyIiwibXVsdGlwbHlTY2FsYXIiLCJCYXNpY0RlcHRoUGFja2luZzE1IiwiQ29sb3I1IiwiRGVwdGhUZXh0dXJlMiIsIk1hdHJpeDQyIiwiU2NlbmUyIiwiVW5pZm9ybTMzIiwiVmVjdG9yMjIxIiwiVmVjdG9yMzIiLCJXZWJHTFJlbmRlclRhcmdldDE3IiwiZ29kX3JheXNfZGVmYXVsdCIsInYiLCJtIiwiR29kUmF5c0VmZmVjdCIsImxpZ2h0U291cmNlIiwiYmx1ciIsIl9saWdodFNvdXJjZSIsImxpZ2h0U2NlbmUiLCJzY3JlZW5Qb3NpdGlvbiIsInJlbmRlclRhcmdldExpZ2h0IiwicmVuZGVyUGFzc0xpZ2h0IiwiZGVwdGhNYXNrUGFzcyIsImRlcHRoTWFza01hdGVyaWFsIiwiZ29kUmF5c1Bhc3MiLCJnb2RSYXlzTWF0ZXJpYWwiLCJ0cmFuc3BhcmVudCIsImdldEdvZFJheXNNYXRlcmlhbCIsIm1hdHJpeEF1dG9VcGRhdGUiLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIm1hdHJpeCIsIm1hdHJpeFdvcmxkIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwicHJvamVjdCIsIlVuaWZvcm0zNCIsIlZlY3RvcjIyMiIsImdyaWRfZGVmYXVsdCIsIkdyaWRFZmZlY3QiLCJsaW5lV2lkdGgiLCJnZXRMaW5lV2lkdGgiLCJzZXRMaW5lV2lkdGgiLCJVbmlmb3JtMzUiLCJWZWN0b3IzMyIsImh1ZV9zYXR1cmF0aW9uX2RlZmF1bHQiLCJIdWVTYXR1cmF0aW9uRWZmZWN0IiwiaHVlIiwic2F0dXJhdGlvbiIsImdldFNhdHVyYXRpb24iLCJzZXRTYXR1cmF0aW9uIiwiZ2V0SHVlIiwic2V0SHVlIiwiVW5pZm9ybTM2IiwiVmVjdG9yMjIzIiwibGVuc19kaXN0b3J0aW9uX2RlZmF1bHQiLCJMZW5zRGlzdG9ydGlvbkVmZmVjdCIsInByaW5jaXBhbFBvaW50Iiwic2tldyIsIkZsb2F0VHlwZTUiLCJIYWxmRmxvYXRUeXBlIiwiVW5pZm9ybTM3IiwibHV0XzFkX2RlZmF1bHQiLCJMVVQxREVmZmVjdCIsIkRhdGEzRFRleHR1cmUyIiwiRmxvYXRUeXBlNiIsIkhhbGZGbG9hdFR5cGUyIiwiTGluZWFyRmlsdGVyNCIsIk5lYXJlc3RGaWx0ZXI3Iiwic1JHQkVuY29kaW5nMiIsIlVuaWZvcm0zOCIsIlZlY3RvcjM0IiwibHV0XzNkX2RlZmF1bHQiLCJMVVQzREVmZmVjdCIsInRldHJhaGVkcmFsSW50ZXJwb2xhdGlvbiIsImlucHV0RW5jb2RpbmciLCJnZXRJbnB1dEVuY29kaW5nIiwic2V0SW5wdXRFbmNvZGluZyIsImdldE91dHB1dEVuY29kaW5nIiwiZ2V0TFVUIiwic2V0TFVUIiwidXBkYXRlU2NhbGVPZmZzZXQiLCJkb21haW5TY2FsZSIsInN1YiIsImRpdmlkZSIsIm5lZ2F0ZSIsIm11bHRpcGx5IiwiYWRkU2NhbGFyIiwiY29uZmlndXJlVGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uIiwic291cmNlIiwic2V0VGV0cmFoZWRyYWxJbnRlcnBvbGF0aW9uRW5hYmxlZCIsIm5vaXNlX2RlZmF1bHQiLCJOb2lzZUVmZmVjdCIsInByZW11bHRpcGx5IiwiaXNQcmVtdWx0aXBsaWVkIiwic2V0UHJlbXVsdGlwbGllZCIsIkNvbG9yNiIsIlJlcGVhdFdyYXBwaW5nMiIsIlVuaWZvcm0zOSIsIlVuc2lnbmVkQnl0ZVR5cGUxNSIsIldlYkdMUmVuZGVyVGFyZ2V0MTgiLCJvdXRsaW5lX2RlZmF1bHQzIiwib3V0bGluZV9kZWZhdWx0NCIsIk91dGxpbmVFZmZlY3QiLCJwYXR0ZXJuVGV4dHVyZSIsInBhdHRlcm5TY2FsZSIsImVkZ2VTdHJlbmd0aCIsInB1bHNlU3BlZWQiLCJ2aXNpYmxlRWRnZUNvbG9yIiwiaGlkZGVuRWRnZUNvbG9yIiwieFJheSIsInJlbmRlclRhcmdldE1hc2siLCJyZW5kZXJUYXJnZXRPdXRsaW5lIiwiZGVwdGhQYXNzIiwib3V0bGluZVBhc3MiLCJvdXRsaW5lTWF0ZXJpYWwiLCJmb3JjZVVwZGF0ZSIsImdldFB1bHNlU3BlZWQiLCJzZXRQdWxzZVNwZWVkIiwic2VsZWN0aW9uTGF5ZXIiLCJpc1hSYXlFbmFibGVkIiwic2V0WFJheUVuYWJsZWQiLCJzZXRQYXR0ZXJuVGV4dHVyZSIsImNsZWFyU2VsZWN0aW9uIiwic2VsZWN0T2JqZWN0IiwiZGVzZWxlY3RPYmplY3QiLCJwdWxzZSIsIlVuaWZvcm00MCIsIlZlY3RvcjIyNCIsIlZlY3RvcjQzIiwicGl4ZWxhdGlvbl9kZWZhdWx0IiwiUGl4ZWxhdGlvbkVmZmVjdCIsImdyYW51bGFyaXR5IiwiX2dyYW51bGFyaXR5IiwiZ2V0R3JhbnVsYXJpdHkiLCJzZXRHcmFudWxhcml0eSIsIlVuaWZvcm00MSIsIlZlY3RvcjQ0IiwicmVhbGlzdGljX2Jva2VoX2RlZmF1bHQiLCJSZWFsaXN0aWNCb2tlaEVmZmVjdCIsImZTdG9wIiwibHVtaW5hbmNlR2FpbiIsImZyaW5nZSIsInNob3dGb2N1cyIsIm1hbnVhbERvRiIsInBlbnRhZ29uIiwicGFyc2VJbnQiLCJVbmlmb3JtNDIiLCJWZWN0b3IyMjUiLCJzY2FubGluZXNfZGVmYXVsdCIsIlNjYW5saW5lRWZmZWN0Iiwic2Nyb2xsU3BlZWQiLCJVbmlmb3JtNDMiLCJWZWN0b3IyMjYiLCJWZWN0b3IzNSIsInNob2NrX3dhdmVfZGVmYXVsdCIsInNob2NrX3dhdmVfZGVmYXVsdDIiLCJIQUxGX1BJIiwidjIiLCJhYiIsIlNob2NrV2F2ZUVmZmVjdCIsInNwZWVkIiwibWF4UmFkaXVzIiwid2F2ZVNpemUiLCJhbXBsaXR1ZGUiLCJlcGljZW50ZXIiLCJnZXRQb3NpdGlvbiIsInNldFBvc2l0aW9uIiwiZ2V0U3BlZWQiLCJzZXRTcGVlZCIsImV4cGxvZGUiLCJ1QWN0aXZlIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJhbmdsZVRvIiwiQmFzaWNEZXB0aFBhY2tpbmcxNiIsIkNvbG9yNyIsIk5vdEVxdWFsRGVwdGgyIiwiRXF1YWxEZXB0aDIiLCJSR0JBRGVwdGhQYWNraW5nNSIsIldlYkdMUmVuZGVyVGFyZ2V0MTkiLCJTZWxlY3RpdmVCbG9vbUVmZmVjdCIsIl9pbnZlcnRlZCIsIl9pZ25vcmVCYWNrZ3JvdW5kIiwiVW5pZm9ybTQ0IiwiVmVjdG9yMzYiLCJzZXBpYV9kZWZhdWx0IiwiU2VwaWFFZmZlY3QiLCJ3ZWlnaHRzUiIsIndlaWdodHNHIiwid2VpZ2h0c0IiLCJCYXNpY0RlcHRoUGFja2luZzE3IiwiQ29sb3I4IiwiTGluZWFyRmlsdGVyNSIsIkxvYWRpbmdNYW5hZ2VyMiIsIk5lYXJlc3RGaWx0ZXI4IiwiVGV4dHVyZTMiLCJVbmlmb3JtNDUiLCJXZWJHTFJlbmRlclRhcmdldDIwIiwic2VhcmNoSW1hZ2VEYXRhVVJMX2RlZmF1bHQiLCJhcmVhSW1hZ2VEYXRhVVJMX2RlZmF1bHQiLCJzbWFhX2RlZmF1bHQiLCJzbWFhX2RlZmF1bHQyIiwiU01BQUVmZmVjdCIsInByZXNldCIsImFyZ3VtZW50cyIsInJlbmRlclRhcmdldEVkZ2VzIiwicmVuZGVyVGFyZ2V0V2VpZ2h0cyIsImVkZ2VEZXRlY3Rpb25QYXNzIiwiZWRnZURldGVjdGlvbk1hdGVyaWFsIiwid2VpZ2h0c1Bhc3MiLCJsb2FkaW5nTWFuYWdlciIsImZsaXBZIiwid2VpZ2h0c01hdGVyaWFsIiwiYXBwbHlQcmVzZXQiLCJlZGdlc1RleHR1cmUiLCJnZXRFZGdlc1RleHR1cmUiLCJ3ZWlnaHRzVGV4dHVyZSIsImdldFdlaWdodHNUZXh0dXJlIiwiY29sb3JFZGdlc01hdGVyaWFsIiwiZ2V0RWRnZURldGVjdGlvbk1hdGVyaWFsIiwiZ2V0V2VpZ2h0c01hdGVyaWFsIiwic2VhcmNoSW1hZ2VEYXRhVVJMIiwiYXJlYUltYWdlRGF0YVVSTCIsIkJhc2ljRGVwdGhQYWNraW5nMTgiLCJDb2xvcjkiLCJSZXBlYXRXcmFwcGluZzMiLCJSR0JBRm9ybWF0NCIsIlVuaWZvcm00NiIsIldlYkdMUmVuZGVyVGFyZ2V0MjEiLCJzc2FvX2RlZmF1bHQzIiwiTk9JU0VfVEVYVFVSRV9TSVpFIiwiU1NBT0VmZmVjdCIsImRlcHRoQXdhcmVVcHNhbXBsaW5nIiwicmFuZ2VUaHJlc2hvbGQiLCJyYW5nZUZhbGxvZmYiLCJsdW1pbmFuY2VJbmZsdWVuY2UiLCJkZXB0aERvd25zYW1wbGluZ1Bhc3MiLCJzc2FvUGFzcyIsInNzYW9NYXRlcmlhbCIsImdldFNTQU9NYXRlcmlhbCIsImlzRGVwdGhBd2FyZVVwc2FtcGxpbmdFbmFibGVkIiwic2V0RGVwdGhBd2FyZVVwc2FtcGxpbmdFbmFibGVkIiwiZ2V0Q29sb3IiLCJzZXRDb2xvciIsIlVuaWZvcm00NyIsIlVuc2lnbmVkQnl0ZVR5cGUxNiIsInRleHR1cmVfZGVmYXVsdCIsInRleHR1cmVfZGVmYXVsdDIiLCJUZXh0dXJlRWZmZWN0IiwiYXNwZWN0Q29ycmVjdGlvbiIsInByZXZUZXh0dXJlIiwic2V0VGV4dHVyZSIsInV2VHJhbnNmb3JtIiwic2V0VGV4dHVyZVN3aXp6bGVSR0JBIiwicmdiYSIsInN3aXp6bGUiLCJqb2luIiwidXBkYXRlTWF0cml4IiwiVW5pZm9ybTQ4IiwiVmVjdG9yMjI3IiwiV2ViR0xSZW5kZXJUYXJnZXQyMiIsInRpbHRfc2hpZnRfZGVmYXVsdCIsInRpbHRfc2hpZnRfZGVmYXVsdDIiLCJUaWx0U2hpZnRFZmZlY3QiLCJMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIiLCJVbmlmb3JtNDkiLCJXZWJHTFJlbmRlclRhcmdldDIzIiwidG9uZV9tYXBwaW5nX2RlZmF1bHQiLCJUb25lTWFwcGluZ0VmZmVjdCIsImFkYXB0aXZlIiwibWF4THVtaW5hbmNlIiwid2hpdGVQb2ludCIsIm1pZGRsZUdyZXkiLCJhdmVyYWdlTHVtaW5hbmNlIiwicmVuZGVyVGFyZ2V0THVtaW5hbmNlIiwiYWRhcHRpdmVMdW1pbmFuY2VQYXNzIiwiYWRhcHRpdmVMdW1pbmFuY2VNYXRlcmlhbCIsImdldEFkYXB0aXZlTHVtaW5hbmNlTWF0ZXJpYWwiLCJleHBvbmVudCIsImxvZzIiLCJzZXRSZXNvbHV0aW9uIiwiVW5pZm9ybTUwIiwidmlnbmV0dGVfZGVmYXVsdCIsIlZpZ25ldHRlRWZmZWN0IiwidGVjaG5pcXVlIiwiZXNraWwiLCJkYXJrbmVzcyIsImdldFRlY2huaXF1ZSIsInNldFRlY2huaXF1ZSIsImdldERhcmtuZXNzIiwic2V0RGFya25lc3MiLCJGaWxlTG9hZGVyIiwiTG9hZGVyIiwiTG9hZGluZ01hbmFnZXIzIiwiTFVUM2RsTG9hZGVyIiwibG9hZCIsInVybCIsIm9uUHJvZ3Jlc3MiLCJleHRlcm5hbE1hbmFnZXIiLCJpbnRlcm5hbE1hbmFnZXIiLCJsb2FkZXIiLCJzZXRQYXRoIiwicGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInVybDIiLCJwYXJzZSIsInJlZ0V4cEdyaWRJbmZvIiwicmVnRXhwRGF0YVBvaW50cyIsImV4ZWMiLCJncmlkTGluZXMiLCJncmlkU3RlcCIsImJMYXllciIsImdMYXllciIsInJMYXllciIsImQ0IiwibWF4Qml0VmFsdWUiLCJGaWxlTG9hZGVyMiIsIkxvYWRlcjIiLCJMb2FkaW5nTWFuYWdlcjQiLCJWZWN0b3IzNyIsIkxVVEN1YmVMb2FkZXIiLCJyZWdFeHBUaXRsZSIsInJlZ0V4cFNpemUiLCJyZWdFeHBEb21haW5NaW4iLCJyZWdFeHBEb21haW5NYXgiLCJ0aXRsZSIsIkxvYWRlcjMiLCJMb2FkaW5nTWFuYWdlcjUiLCJTTUFBSW1hZ2VMb2FkZXIiLCJCbHVyUGFzcyIsIkNvbG9yRWRnZXNNYXRlcmlhbCIsIkNvbnZvbHV0aW9uTWF0ZXJpYWwiLCJEZXB0aFNhdmVQYXNzIiwiTFVURWZmZWN0IiwiTG9va3VwVGV4dHVyZTNEIiwiT3V0bGluZUVkZ2VzTWF0ZXJpYWwiLCJSZXNpemVyIiwiU2F2ZVBhc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/postprocessing/build/index.js\n");

/***/ })

};
;